<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/hais-notebook/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hais-notebook/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hais-notebook/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hais-notebook/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hais-notebook/css/main.css">


<link rel="stylesheet" href="/hais-notebook/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hyuain.github.io/hais-notebook').hostname,
    root: '/hais-notebook/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: 'W0QZQNNH7N',
      apiKey: '00189c8d102508ea71e94422b5f129fd',
      indexName: 'hais-notebook',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="主要是关于计算机网络基础的一些东西。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络基础">
<meta property="og:url" content="https://hyuain.github.io/hais-notebook/2020/03/03/CS-Network/index.html">
<meta property="og:site_name" content="Hais Notebook">
<meta property="og:description" content="主要是关于计算机网络基础的一些东西。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-StatusCode.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Session-Cookie.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/BASIC.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/DIGEST.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Proxy.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Getway.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Encryption.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/AsymEncryption.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-1.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-2.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-1.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-2.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebSocket.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SPDY.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Binary-Framing.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Header-Compression.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Multiplex.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-1.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-2.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebDAV.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-HTTP3.0.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-1.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Blocking.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-No-Blocking.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-Error-Correcting.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Web-Application.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Login-Process.webp">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Handshake.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Wavehand.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header-Options.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Timestamp-RTT.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TFO.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window-2.png">
<meta property="og:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Receive-Window.png">
<meta property="article:published_time" content="2020-03-03T21:37:30.000Z">
<meta property="article:modified_time" content="2020-03-22T03:49:31.935Z">
<meta property="article:author" content="Harvey Zhang">
<meta property="article:tag" content="入门">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-StatusCode.png">

<link rel="canonical" href="https://hyuain.github.io/hais-notebook/2020/03/03/CS-Network/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>计算机网络基础 | Hais Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/hais-notebook/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hais Notebook</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/hais-notebook/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/hais-notebook/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/hais-notebook/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hais-notebook/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hyuain.github.io/hais-notebook/2020/03/03/CS-Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hais-notebook/images/avatar.gif">
      <meta itemprop="name" content="Harvey Zhang">
      <meta itemprop="description" content="小海的笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hais Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-03 21:37:30" itemprop="dateCreated datePublished" datetime="2020-03-03T21:37:30+00:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 03:49:31" itemprop="dateModified" datetime="2020-03-22T03:49:31+00:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hais-notebook/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hais-notebook/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A6%82%E5%BF%B5/" itemprop="url" rel="index">
                    <span itemprop="name">概念</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>主要是关于计算机网络基础的一些东西。</p>
<a id="more"></a>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-基本介绍"><a href="#HTTP-基本介绍" class="headerlink" title="HTTP 基本介绍"></a>HTTP 基本介绍</h2><h3 id="HTTP-历史"><a href="#HTTP-历史" class="headerlink" title="HTTP 历史"></a>HTTP 历史</h3><ul>
<li>HTTP 0.9：1991，只有 GET、只能传HTML，没有 CSS、JS，每个HTTP请求都是短连接</li>
<li>HTTP 1.0：1996，有了 POST、HEAD……</li>
<li>HTTP 1.1：1997，目前为止最常用的版本</li>
<li>HTTP 2.0：2015，HTTP 1.1 的扩展，于2015年5月提出</li>
<li>HTTP 3.0：QUIC 协议（一种传输层协议，TCP的效率比较低，QUIC 为了减小 TCP 的延迟和带宽开销）</li>
</ul>
<h3 id="TCP-IP-与-HTTP"><a href="#TCP-IP-与-HTTP" class="headerlink" title="TCP/IP 与 HTTP"></a>TCP/IP 与 HTTP</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul>
<li>应用层：FTP、DNS、HTTP</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP</li>
<li>链路层：网络</li>
</ul>
<h4 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h4><ul>
<li>系统在 HOST 文件中找 IP 地址</li>
<li>系统向本地 DNS 服务器请求：114.114.114.114（国内移动、电信和联通通用的DNS），8.8.8.8（GOOGLE 公司提供的 DNS，该地址是全球通用）</li>
<li>本地 DNS 服务器一层层向上请求，直到根 DNS 服务器</li>
</ul>
<h2 id="HTTP-协议结构和通讯原理"><a href="#HTTP-协议结构和通讯原理" class="headerlink" title="HTTP 协议结构和通讯原理"></a>HTTP 协议结构和通讯原理</h2><h3 id="HTTP-协议特点"><a href="#HTTP-协议特点" class="headerlink" title="HTTP 协议特点"></a>HTTP 协议特点</h3><ul>
<li><strong>支持客户/服务器模式</strong></li>
<li><strong>简单快速</strong><ul>
<li>客户向服务器请求服务时，只需要传送请求方法和路径</li>
<li>GET、HEAD、POST</li>
<li>HTTP服务器程序规模小，因此通信速度块</li>
</ul>
</li>
<li><strong>灵活</strong><ul>
<li>允许传输任意类型的数据对象</li>
<li>正在传输的类型由 Content-Type 加以标记</li>
</ul>
</li>
<li><strong>无连接</strong><ul>
<li>无连接的含义是限制 <strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接——keep alive 功能使得连接（TCP）不断开，有规定的超时时间</li>
<li>采用这种方式可以节省传输时间</li>
</ul>
</li>
<li><strong>无状态</strong><ul>
<li>协议对事务的处理能力 <strong>没有记忆能力</strong>，每个请求都是 <strong>独立的</strong></li>
<li>如果后续处理需要前面的信息，则必须重传，导致每次连接的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
</li>
</ul>
<h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><blockquote>
<p>问题：我们在浏览器的 Web 地址应该叫 URL 还是 URI？</p>
<ul>
<li>URI：可以分为 URL 和 URN，或同时具备 locators 和 names 特性的一个东西</li>
<li>URN 像一个人的名字，URL 像一个人的地址；URN 确定了东西的身份，URL 提供了找到它的方式（提供了访问机制，比如说协议）</li>
</ul>
</blockquote>
<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【请求行】POST（请求方法） &#x2F;webTours&#x2F;login.pl（请求 URI） HTTP&#x2F;1.1（HTTP 协议及版本）</span><br><span class="line">【请求头】用键值对来传递参数，包括 Host、Accept、Content-Type 等</span><br><span class="line"></span><br><span class="line">【请求体】</span><br></pre></td></tr></table></figure>

<p>可以用 curl 构造请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X -POST <span class="comment"># 设置请求动词</span></span><br><span class="line">curl -H <span class="string">'Accept: text/html'</span> <span class="comment"># -H 也可以写成 --header</span></span><br><span class="line">curl -H <span class="string">'Content-Type: text/plain;charset=utf-8'</span> -d <span class="string">'请求体内容'</span> <span class="comment"># -d 也可以写成 --data</span></span><br></pre></td></tr></table></figure>

<p>可以用 Node.js 读取请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.method</span><br><span class="line">request.url <span class="comment">// 路径，带参数</span></span><br><span class="line">request.path <span class="comment">// 纯路径</span></span><br><span class="line">request.query <span class="comment">// 只有查询参数</span></span><br><span class="line">request.headers[<span class="string">'Accept'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【响应行】HTTP&#x2F;1.1（报文协议及版本） 200 Ok（状态码及状态描述）</span><br><span class="line">【响应头】</span><br><span class="line"></span><br><span class="line">【响应体】</span><br></pre></td></tr></table></figure>

<p>可以用 Node.js 设置响应：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.statusCode = <span class="number">200</span></span><br><span class="line">response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">response.write(<span class="string">'内容'</span>) <span class="comment">// 内容可以追加</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>注意 <code>path</code> 都是以 <code>/</code> 开头的</p>
          </div>

<h4 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h4><ul>
<li><strong>Accept</strong>：浏览器端可以接收的媒体类型<ul>
<li><strong>Accept: text/html</strong>，代表浏览器可以接收服务器回发的类型为 text/html 类型的数据，如果服务器无法返回此类型，应该返回一个 406 错误（Non Acceptable）</li>
<li><strong>Accept: <em>/</em></strong>，代表浏览器可以处理所有类型</li>
<li>可以设置优先级（权重值q，取0~1.000）</li>
</ul>
</li>
<li><strong>Accept-Encoding</strong>：浏览器申明自己接收的编码（压缩）方法（gzip、deflate）</li>
<li><strong>Accept-Language</strong>：浏览器申明自己接收的语言<ul>
<li><strong>Accept-Language</strong>: zh-cn,zh;q=0.7,en-us,en;q=0.3 </li>
</ul>
</li>
<li><strong>Connection</strong><ul>
<li><strong>Connection: keep-alive</strong>，TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>
<li><strong>Connection: close</strong>，一个 Request 完成后，TCP 连接关闭</li>
</ul>
</li>
<li><strong>Host</strong>：指定被请求资源的 Internet 主机和端口号，通常从 URL 中提取出来</li>
<li><strong>Referer</strong>：一般会带上此字段，告诉服务器是从哪个页面链接过来的</li>
<li><strong>User-Agent</strong>：告诉 HTTP 服务器，客户端使用的操作系统和浏览器名称和版本</li>
<li><strong>Content-Type</strong>：说明了报文体对象的媒体类型<br>  <strong>text/html</strong>：HTML<br>  <strong>text/plain</strong>：纯文本<br>  <strong>text/xml</strong>：XML<br>  <strong>image/gif</strong>：GIF图像<br>  <strong>image/jpeg</strong>：JPG图像<br>  <strong>image/png</strong>：PNG图像<br>  <strong>application/xhtml+xml</strong>：XHTML<br>  <strong>application/xml</strong>：XML<br>  <strong>application/atom+xml</strong>：Atom XML<br>  <strong>application/json</strong>：JSON<br>  <strong>application/pdf</strong>：PDF<br>  <strong>application/msword</strong>：WORD<br>  <strong>application/octet-stream</strong>：二进制数据流<br>  <strong>application/x-www-form-urlencoded</strong>：表单提交</li>
</ul>
<h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><ul>
<li><strong>GET</strong>：请求访问已被 URI 识别的资源<ul>
<li>提交的内容是 URL 的一部分，长度限制、安全性</li>
</ul>
</li>
<li><strong>POST</strong>：与 GET 功能类似，一般用来传输实体的主体，主要目的是提交数据，不是获取响应主体的内容</li>
<li><strong>PUT</strong>：与 POST 最大的不同是，PUT 是幂等（不管重复多少次操作，都是实现相同的结果）的，POST 是不幂等的，因此一般创建对象用 POST，更新对象用 PUT，但是 PUT 没有验证机制，有安全性问题，所以一般还是用 POST</li>
<li><strong>HEAD</strong>：类似于GET，只不过返回的响应中没有具体的内容，用于获取报头（测试超链接的有效性）</li>
<li><strong>DELETE</strong>：请求删除资源，与 PUT 相反，并且没有验证机制，因此现在一般不用</li>
<li><strong>OPTIONS</strong>：用来查询针对请求 URI 指定的资源支持的方法<ul>
<li>服务器返回一个<code>Allow: GET, HEAD, POST</code>等等</li>
</ul>
</li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断，但容易受到 XST 攻击，一般不用</li>
<li><strong>CONNECT</strong>：开启客户端与所请求资源之间的双向沟通的通道，可以用来创建隧道，一般用于 HTTP 代理</li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-StatusCode.png" alt="HTTP状态码"></p>
<ul>
<li><strong>200 Ok</strong>，请求已成功，并且所希望的响应头或数据体已经随此响应返回</li>
<li><strong>202 Accepted</strong>，已接收，但处理未完成</li>
<li><strong>206 Partial Content</strong>，部分内容，处理器成功处理了部分 GET 请求——断点续传</li>
<li><strong>301 Moved Permanently</strong>，永久移动，请求的资源已被永久移动到新的 URI，以后任何新的请求都应使用新的 URI 代替</li>
<li><strong>302 Found</strong>，临时移动，客户端应继续使用原有 URI</li>
<li><strong>400 Bad Request</strong>，客户端请求的语法错误，服务器无法理解</li>
<li><strong>401 Unauthorized</strong>，请求要求用户的身份验证</li>
<li><strong>403 Forbidden</strong>，服务器理解客户端的请求，但是拒绝执行此请求</li>
<li><strong>404 Not Found</strong>，服务器无法根据请求找到资源（网页）</li>
<li><strong>500 Internal Server Error</strong>，服务器内部错误，无法完成请求</li>
<li><strong>502 Bad Gateway</strong>，充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
</ul>
<h3 id="HTTP-状态管理：Cookie-和-Session"><a href="#HTTP-状态管理：Cookie-和-Session" class="headerlink" title="HTTP 状态管理：Cookie 和 Session"></a>HTTP 状态管理：Cookie 和 Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>W3C 推行的一种机制，客户端请求服务器，如果服务器需要记录该用户的状态，就向客户端浏览器颁发一个Cookie，<br>客户端浏览器会把Cookie保存起来，浏览器再请求的时候，就会把请求的网址连同Cookie一同提交给服务器</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>另一种记录客户状态的机制，服务器把客户端信息以某种形式记录在服务器上<br>客户端可以以 Cookie、URL 重写或隐藏表单的形式保存 Session ID</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Session-Cookie.png" alt="Session与Cookie"></p>
<h4 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h4><ul>
<li>有效期不同<ul>
<li>Cookie 的有效时间久，或者可以设置到永远</li>
<li>Session 的有效期<ul>
<li>超时自动失效，通常不长</li>
<li>程序调用 HttpSession.invalidate() 主动失效（退出、注销等操作）</li>
<li>服务器进程被终止</li>
</ul>
</li>
<li>存放位置不同，Cookie 在客户端，Session 在服务器端</li>
<li>安全性（隐私策略）不同，用户可以更改 Cookie</li>
<li>对服务器压力不同</li>
</ul>
</li>
</ul>
<h2 id="HTTP-协议的特性"><a href="#HTTP-协议的特性" class="headerlink" title="HTTP 协议的特性"></a>HTTP 协议的特性</h2><h3 id="HTTP-协议中的编码和解码"><a href="#HTTP-协议中的编码和解码" class="headerlink" title="HTTP 协议中的编码和解码"></a>HTTP 协议中的编码和解码</h3><blockquote>
<p>码 = 字符集+编码</p>
</blockquote>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><ul>
<li>字库表：里面存储了所有的字符</li>
<li>字符集：字符对应的二进制地址的集合</li>
<li>编码方式：一套编码规范可以有多种不同的编码方式（比如 UTF-8，对应的编码规范是 Unicode），一种算法来节约空间</li>
</ul>
<p>常见的编码规范：</p>
<ul>
<li>ASCII 码：7 位码，128 个字符，1 个字节</li>
<li>GBK：汉字内码扩展规范，2 个字节</li>
<li>ISO-8859-1：加了希腊语等，把其他所有的当做 ISO-8859-1 来解都没问题，没有中文，8 位码，1 个字节</li>
<li>Unicode：包含全世界所有的字符，最多 4 个字节</li>
</ul>
<h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>乱码的由来：解码过程、编码过程都可能导致乱码</p>
<h4 id="URL-的编码与解码"><a href="#URL-的编码与解码" class="headerlink" title="URL 的编码与解码"></a>URL 的编码与解码</h4><p>URL 是采用 ASCII 字符集进行编码的</p>
<p><code>%</code> 编码规范：</p>
<ul>
<li>对 URL 中属于 ASCII 字符集的非保留字不做编码</li>
<li>对 URL 中的保留字需要取其 ASCII 内码，然后加上%的前缀对该字符进行编码</li>
<li>对 URL 中非 ASCII 字符需要取其 Unicode 内码，然后加上 <code>%</code> 的前缀对该字符进行编码</li>
</ul>
<blockquote>
<p>Fiddler</p>
</blockquote>
<h3 id="HTTP-协议的基本认证"><a href="#HTTP-协议的基本认证" class="headerlink" title="HTTP 协议的基本认证"></a>HTTP 协议的基本认证</h3><h4 id="常见的认证方式"><a href="#常见的认证方式" class="headerlink" title="常见的认证方式"></a>常见的认证方式</h4><h4 id="BASIC"><a href="#BASIC" class="headerlink" title="BASIC"></a>BASIC</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/BASIC.png" alt="BASIC"></p>
<p>不便捷灵活，且不安全（Base64实际上就是明文传输）</p>
<h4 id="DIGEST"><a href="#DIGEST" class="headerlink" title="DIGEST"></a>DIGEST</h4><p>同样采用质询 / 响应方式，但不会明文传输密码</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/DIGEST.png" alt="DIGEST"></p>
<p>默认使用md5加密：<br>客户端发送响应摘要 = MD5(HA1:nonce:HA2)<br>其中，HA1 = MD5(username:realm:password), HA2 = MD5(method:digestURI)<br>虽然以前认为是不可逆的加密，但是仍然存在字典攻击、用户被冒充等风险</p>
<h4 id="SSL-客户端"><a href="#SSL-客户端" class="headerlink" title="SSL 客户端"></a>SSL 客户端</h4><p>凭借客户端证书认证</p>
<h4 id="FormBase"><a href="#FormBase" class="headerlink" title="FormBase"></a>FormBase</h4><p>不是在 HTTP 协议中定义的，是使用 Web 应用各自实现的基于表单的认证，通过 Cookie 和 Session 来保持用户登录状态</p>
<h3 id="HTTP-中的长连接和短链接"><a href="#HTTP-中的长连接和短链接" class="headerlink" title="HTTP 中的长连接和短链接"></a>HTTP 中的长连接和短链接</h3><p>HTTP 中的长连接和短链接本质上是 TCP 的长连接和短链接</p>
<ul>
<li>HTTP/1.0 中，默认是短链接，每遇到一个外部资源就建立一个对话</li>
<li>HTTP/1.1 起，默认是长连接</li>
</ul>
<h3 id="中介代理与中介网关"><a href="#中介代理与中介网关" class="headerlink" title="中介代理与中介网关"></a>中介代理与中介网关</h3><h4 id="中介代理"><a href="#中介代理" class="headerlink" title="中介代理"></a>中介代理</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Proxy.png" alt="中介代理"></p>
<p>代理的作用：抓包、匿名访问、过滤器</p>
<h4 id="中介网关"><a href="#中介网关" class="headerlink" title="中介网关"></a>中介网关</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Getway.png" alt="中介网关"></p>
<p>扮演协议转换器的角色：</p>
<ul>
<li>(HTTP/) 服务器端网关，通过 HTTP 协议与客户端对话，通过其他协议与服务器通信</li>
<li>(/HTTP) 客户端网关，通过其他协议与客户端对话，通过 HTTP 协议与服务器通信</li>
</ul>
<p>常见网关类型：</p>
<ul>
<li>HTTP/*：服务器端 Web 网关</li>
<li>HTTP/HTTPS：服务器端安全网关</li>
<li>HTTPS/HTTP：客户端安全加速网关（SSL 卸载）</li>
<li>资源网关</li>
</ul>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>缓存的内容：CSS、JS、图片等更新频率不大的静态资源文件</p>
<h4 id="HTTP-缓存头部字段"><a href="#HTTP-缓存头部字段" class="headerlink" title="HTTP 缓存头部字段"></a>HTTP 缓存头部字段</h4><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>请求/响应头，缓存控制字段</p>
</blockquote>
<ul>
<li>no-store：所有内容都不缓存</li>
<li>no-cache：缓存，但浏览器会请求服务器判断资源是否更新</li>
<li>max-age=x：请求缓存后 x 秒不再发起请求</li>
<li>s-maxage=x：类似，但只对 CDN 缓存有效</li>
<li>public：客户端和代理服务器（CDN）都可以缓存</li>
<li>private：只有客户端可以缓存</li>
</ul>
<h5 id="其他头部字段"><a href="#其他头部字段" class="headerlink" title="其他头部字段"></a>其他头部字段</h5><p>响应头，服务器返回：</p>
<ul>
<li><strong>Expires</strong>：代表资源过期时间，是 HTTP/1.0 的属性，比 HTTP/1.1 的 <strong>Cache-Control:max-age=x</strong> 优先级低</li>
<li><strong>Last-Modified</strong>：资源最新修改时间</li>
<li><strong>Etag</strong>：缓存资源标识</li>
</ul>
<p>请求头，服务器提供：</p>
<ul>
<li><strong>if-Modified-Since</strong>：资源最新修改时间，与 <strong>Last-Modified</strong> 是一对，他们会进行对比</li>
<li><strong>if-None-Match</strong>：缓存资源标识，与 <strong>Etag</strong> 是一对（其实就是上次服务器给的 Etag），他们会进行对比</li>
</ul>
<h4 id="HTTP-缓存工作方式"><a href="#HTTP-缓存工作方式" class="headerlink" title="HTTP 缓存工作方式"></a>HTTP 缓存工作方式</h4><h5 id="场景一：让服务器与浏览器约定一个文件过期时间-Expires"><a href="#场景一：让服务器与浏览器约定一个文件过期时间-Expires" class="headerlink" title="场景一：让服务器与浏览器约定一个文件过期时间 Expires"></a>场景一：让服务器与浏览器约定一个文件过期时间 Expires</h5><p>服务器给浏览器一个 Expires，后续请求浏览器会对比当前 <strong>本地时间</strong> 是否已经大于 Expires，超过过期时间再请求。</p>
<p>问题：即使超过过期时间之后，文件可能仍然没有变化</p>
<h5 id="场景二：约定-Expires-的基础上，再通过文件的最新修改时间进行对比-Last-Modified-与-if-Modified-Since"><a href="#场景二：约定-Expires-的基础上，再通过文件的最新修改时间进行对比-Last-Modified-与-if-Modified-Since" class="headerlink" title="场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since"></a>场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since</h5><p>服务器给浏览器 Expires 和 Last-Modified，后续若超过 Expires 后，浏览器请求时会带上 if-Modified-Since，服务器进行对比，如果文件未修改，就返回 304 Not Modified，让浏览器使用缓存</p>
<p>问题：浏览器可以随意修改本地时间，而且 Last-Modified 只能精确到秒</p>
<h5 id="场景三：在上面的基础上加上-Etag-If-None-Match，再使用-max-age"><a href="#场景三：在上面的基础上加上-Etag-If-None-Match，再使用-max-age" class="headerlink" title="场景三：在上面的基础上加上 Etag/If-None-Match，再使用 max-age"></a>场景三：在上面的基础上加上 Etag/If-None-Match，再使用 max-age</h5><p>max-age 使用的是 <strong>相对时间</strong>，因此浏览器不能通过修改本地时间的方式来影响缓存，优先级高于 Expires；<br>Etag 优先级也高于 Last-Modified，因为文件只要修改过，Etag 就会发生变化</p>
<p>至此其实 Last-Modified 和 Expires 其实已经没什么用了，但很多时候还是会加上</p>
<p>问题：max-age 或者 Expires 未过期的情况下，若改动文件，应该怎样让浏览器知道？</p>
<h5 id="缓存改进方案"><a href="#缓存改进方案" class="headerlink" title="缓存改进方案"></a>缓存改进方案</h5><h6 id="md5-hash-缓存"><a href="#md5-hash-缓存" class="headerlink" title="md5/hash 缓存"></a>md5/hash 缓存</h6><p>不缓存 html，为静态文件添加 MD5 或者 hash 标识，比如将静态资源的文件名改为 <code>f-hash1.js</code>，若文件修改了，文件名也会改变为 <code>f-hash2.js</code></p>
<h6 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h6><blockquote>
<p>CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p>
</blockquote>
<p>CDN 的作用：</p>
<ol>
<li>减少源站压力</li>
<li>解决跨区域访问问题</li>
</ol>
<p>CDN缓存的工作方式：</p>
<ol>
<li>第一次请求，CDN 和 浏览器同时缓存</li>
<li>浏览器缓存过期后，找 CDN 进行对比，CDN 看自己的过期没有，若自己没过期，就给发给浏览器</li>
</ol>
<h4 id="浏览器操作对-HTTP-缓存的影响"><a href="#浏览器操作对-HTTP-缓存的影响" class="headerlink" title="浏览器操作对 HTTP 缓存的影响"></a>浏览器操作对 HTTP 缓存的影响</h4><table>
<thead>
<tr>
<th>用户操作</th>
<th>Expires/Cache-Control</th>
<th>Last-Modified/Etag</th>
</tr>
</thead>
<tbody><tr>
<td>地址栏回车</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>页面链接跳转</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>新开窗口</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>前进、后退</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>F5 刷新</td>
<td><em>无效</em></td>
<td>有效</td>
</tr>
<tr>
<td>Ctrl+F5 刷新</td>
<td><em>无效</em></td>
<td><em>无效</em></td>
</tr>
</tbody></table>
<h3 id="HTTP-内容协商机制"><a href="#HTTP-内容协商机制" class="headerlink" title="HTTP 内容协商机制"></a>HTTP 内容协商机制</h3><blockquote>
<p>指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以相应资源的语言、字符集、编码方式等作为判断的基准</p>
</blockquote>
<h4 id="内容协商的方式"><a href="#内容协商的方式" class="headerlink" title="内容协商的方式"></a>内容协商的方式</h4><ul>
<li><strong>客户端驱动</strong>：客户端发起请求，服务器发送可选项列表，客户端做出选择后再发送第二次请求</li>
<li><strong>服务器驱动</strong>：服务器检查客户端的请求头部集并决定提供哪个版本的页面<ul>
<li>客户端发送：Accept、Accept-Language、Accept-Charset、Accept-Encoding<ul>
<li><code>Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0</code></li>
</ul>
</li>
<li>服务器返回：Content-Type、Content-Language、Content-Type、Content-Encoding</li>
</ul>
</li>
<li><strong>透明协商</strong>：某个中间设备（通常是缓存代理）代表客户端进行协商</li>
</ul>
<h3 id="HTTP-断点续传和多线程下载"><a href="#HTTP-断点续传和多线程下载" class="headerlink" title="HTTP 断点续传和多线程下载"></a>HTTP 断点续传和多线程下载</h3><p>主要是通过请求头中的 <strong>Range</strong> 和响应头中的 <strong>Content-Range</strong> 实现的，并且若使用断点续传模式返回的状态码都是 206 Partial Content</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>用于请求头中，指定第一个字节的位置和最后一个字节的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Range:(unit&#x3D;first byte pos)-[last byte pos]</span><br><span class="line">Range:bytes&#x3D;0-499</span><br><span class="line">Range:bytes&#x3D;-500</span><br><span class="line">Range:bytes&#x3D;500-</span><br><span class="line">Range:bytes&#x3D;500-600,601-999</span><br></pre></td></tr></table></figure>

<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p>用于响应头中，返回当前接受的范围和文件总大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range:bytes(unit first byte pos)-[last byte pos]&#x2F;[entity length]</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Encryption.png" alt="对称加密"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/AsymEncryption.png" alt="非对称加密"></p>
<p>对称加密效率高，但在密钥分发时存在安全隐患，容易被截获；非对称加密安全性高，但性能低下；因此我们可以先用非对称加密传输对称加密的密钥，之后再用对称加密来传输数据</p>
<h4 id="数字签名与数字证书"><a href="#数字签名与数字证书" class="headerlink" title="数字签名与数字证书"></a>数字签名与数字证书</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-1.png" alt="数字签名"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-2.png" alt="数字签名"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-1.png" alt="数字证书"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-2.png" alt="数字证书"></p>
<h3 id="HTTPS-协议概述"><a href="#HTTPS-协议概述" class="headerlink" title="HTTPS 协议概述"></a>HTTPS 协议概述</h3><blockquote>
<p>HTTPS 可以认为是 HTTP + TLS，TLS 是传输层加密协议，他的前身是 SSL 协议</p>
</blockquote>
<p>可以认为 TLS 建立在传输层和应用层之间（会话层），目前常用的版本有 TLS/1.0、1.1、1.2、1.3 和 SSL/3.0，但是 SSL/3.0 可能会存在 ‎POODLE 攻击，TSL/1.0 也存在一些漏洞</p>
<p>HTTPS 功能：<br>    - <strong>内容加密</strong>（非对称加密协商密钥 + 对称加密传输数据）<br>    - <strong>数据完整性</strong>（数字签名）<br>    - <strong>身份认证</strong>（数字证书）</p>
<h3 id="HTTPS-使用成本"><a href="#HTTPS-使用成本" class="headerlink" title="HTTPS 使用成本"></a>HTTPS 使用成本</h3><ul>
<li>证书费用以及更新维护</li>
<li>降低用户的访问速度</li>
<li>消耗 CPU 资源</li>
</ul>
<p>HTTPS 对性能的影响：</p>
<ul>
<li>协议交互所增加的网络往返时延（Round-Trip Time）<ul>
<li>有可能用户访问 HTTP，服务器需要返回 302 使其跳转到 HTTPS</li>
<li>TLS 完全握手阶段 1 和 2，以及与 CA 服务器进行连接与验证</li>
</ul>
</li>
<li>加解密相关的计算耗时<ul>
<li>浏览器计算耗时</li>
<li>服务端计算耗时</li>
</ul>
</li>
</ul>
<div class="note warning">
            <p>HTTPS 并不能解决所有的劫持问题</p>
          </div>

<h2 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h2><h3 id="HTTP-协议的瓶颈"><a href="#HTTP-协议的瓶颈" class="headerlink" title="HTTP 协议的瓶颈"></a>HTTP 协议的瓶颈</h3><ul>
<li>单路连接、请求低效，一条连接上只可发送 <strong>一个</strong> 请求，并且严格先入先出（非关键资源阻塞问题）</li>
<li>请求只能 <strong>从客户端开始</strong>，客户端不可以接受除了响应以外的指令，没办法让服务器一更新，客户端就立即更新</li>
<li>头部冗余，请求/响应头部 <strong>不经压缩</strong> 就发送</li>
<li>每次相互发送 <strong>相同的头部</strong> 造成浪费</li>
<li>不强制使用加密</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote>
<p>是为了解决 HTTP 长连接问题而做出的改良协议，与 HTTP 协议有交集</p>
</blockquote>
<p>HTTP 的生命周期是由 Request/Response 确定的，一个 Request 与 一个 Response 对应，且 Response 是被动的。</p>
<p>WebSocket 是持久化协议，</p>
<p>一个典型的 WebSocket 握手：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;   浏览器随机生成的 Base64</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat  用来区分同一个 URL 下不同的服务所需要的协议 </span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>

<p>传统的轮询方式：</p>
<ul>
<li>AJAX 轮询：浏览器每隔几秒发一次请求，询问服务器有没有新消息</li>
<li>长轮询（Long Poll）：采取阻塞的方式，客户端发起连接，如果没有消息，服务器就一直不返回，直到有消息再返回</li>
</ul>
<blockquote>
<p>传统方式问题：太占用资源了，AJAX 轮询需要很高的处理速度，长轮询则需要能容纳很高的并发数</p>
</blockquote>
<p>WebSocket：</p>
<ul>
<li>一次连接，长期有效，服务器有消息的时候再推送（回调）</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebSocket.png" alt="WebSocket"></p>
<p>WebSocket 的主要特点：</p>
<ul>
<li>真正的 <strong>全双工方式</strong>，允许服务器向客户端主动推送数据</li>
<li>减少 <strong>通信量</strong></li>
</ul>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><blockquote>
<p>是谷歌开发的基于 TCP 的应用层协议，为了降低网络延迟，优化用户体验，也是对 HTTP 协议的增强</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SPDY.png" alt="SPDY"></p>
<p>SPDY 的改进：</p>
<ul>
<li>多路复用、请求优化，允许多个请求共用一个 TCP 连接，并且可以设置优先级（避免非关键资源阻塞）</li>
<li>支持服务器推送技术，主要是资源类的推送（比如若浏览器请求了 <code>style.css</code>，服务器就主动再预推送一个 <code>style.js</code>），跟 WebSocket 不同</li>
<li>压缩了 HTTP 头</li>
<li>强制使用 SSL 传输协议</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><blockquote>
<p>可以理解为 SPDY 的升级版</p>
</blockquote>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><blockquote>
<p>HTTP/2.0 性能增强的核心</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Binary-Framing.png" alt="二进制分帧"></p>
<p>在二进制分帧层上，会将原来传输的信息分成更小的帧，并且采用二进制编码；HTTP/2.0 的通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，每个数据流都以消息的形式发送，这些消息由一个或多个帧组成，帧可以乱序发送，最后会根据每个帧上面的流标识符重新组装</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Header-Compression.png" alt="首部压缩"></p>
<p>使用 <strong>首部表</strong> 来跟踪和存储键值对，相同的数据不再通过每次响应和请求发送，通讯期间几乎不会改变 <strong>通用的键值对</strong>，每次只会发送新增或改变的部分头部，首部表在整个连接中有效，会不断更新</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Multiplex.png" alt="多路复用"></p>
<p>所有通信都在一个 TCP 连接上完成，将 HTTP 协议通信的基本单位缩小为帧，让多个数据流共用一个连接，提高利用率</p>
<p>单链接多资源的优势：</p>
<ul>
<li>可以 <strong>减少服务器连接压力</strong>，内存占用少了，连接吞吐量大了</li>
<li>由于 TCP 连接减少而使 <strong>网络拥塞状况</strong> 得以改观</li>
<li>慢启动时间减少，<strong>拥塞</strong> 和 <strong>丢包</strong> 恢复速度更快</li>
</ul>
<h4 id="并行双向字节流"><a href="#并行双向字节流" class="headerlink" title="并行双向字节流"></a>并行双向字节流</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-1.png" alt="并行双向字节流"></p>
<ul>
<li>并行交错地发送请求，请求之间互不影响</li>
<li>并行交错地发送响应，相应之间互不影响</li>
<li>只使用一个连接即可并行发送多个请求和响应</li>
<li>消除不必要的延迟，减少页面加载的时间</li>
</ul>
<h4 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h4><p>高优先级的流都应该优先发送，但也不是绝对的，不同优先级混合发送也是必须的（为了避免首部阻塞等情况）</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-2.png" alt="服务器推送"></p>
<p>服务器可以向客户端额外推送资源</p>
<h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><blockquote>
<p>基于万维网的分布式创作和版本控制，用于管理 Web 服务器的文件</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebDAV.png" alt="WebDAV"></p>
<h3 id="QUIC-和-HTTP-3-0"><a href="#QUIC-和-HTTP-3-0" class="headerlink" title="QUIC 和 HTTP/3.0"></a>QUIC 和 HTTP/3.0</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-HTTP3.0.png" alt="QUIC和HTTP/3.0"></p>
<p>HTTP/2.0 的问题：</p>
<ul>
<li>队头阻塞，如果出现丢包，整个 TCP 连接都需要停下来重传，因为 HTTP/1.1 是建立多个 TCP 连接，所以不会全部都需要停下来</li>
<li>建立连接的握手延迟大，TCP 需要握手，对于短连接场景影响大</li>
</ul>
<p>QUIC 的特性：</p>
<ul>
<li><strong>0 RTT</strong><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-1.png" alt="QUIC建立连接的过程"></li>
<li><strong>没有队头阻塞的多路复用</strong><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Blocking.png" alt="TCP队头阻塞"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-No-Blocking.png" alt="QUIC没有队头阻塞"></li>
<li><strong>前向纠错</strong>，会多发一些冗余的包（校验包），虽然产生了多的包，但是减少了重传带来的损失<br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-Error-Correcting.png" alt="前向纠错"></li>
</ul>
<h1 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a>Web 安全</h1><h2 id="Web-安全概述"><a href="#Web-安全概述" class="headerlink" title="Web 安全概述"></a>Web 安全概述</h2><h3 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h3><ul>
<li>由动态脚本、编译过的代码等组合而成</li>
<li>通常架设在 Web 服务器上，用户在 Web 浏览器上发送请求</li>
<li>这些请求使用 HTTP 协议，由 Web 应用和企业后台数据库及其他动态内容通信</li>
</ul>
<h3 id="Web-应用三层架构"><a href="#Web-应用三层架构" class="headerlink" title="Web 应用三层架构"></a>Web 应用三层架构</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Web-Application.png" alt="Web 应用三层架构"></p>
<h3 id="WASC-的定义"><a href="#WASC-的定义" class="headerlink" title="WASC 的定义"></a>WASC 的定义</h3><blockquote>
<p>WASC（Web Application Security Consortium）是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，负责为 WWW 指定广为接受的应用安全标准</p>
</blockquote>
<p>WASC 将应用安全威胁分为六大类：</p>
<ol>
<li>Authentication（验证）</li>
<li>Authorization（授权）</li>
<li>Client-Side Attacks（客户侧攻击）</li>
<li>Command Execution（命令执行）</li>
<li>Information Disclosure（信息暴露）</li>
<li>Logical Attacks（逻辑性攻击）</li>
</ol>
<h3 id="OWASP-的定义"><a href="#OWASP-的定义" class="headerlink" title="OWASP 的定义"></a>OWASP 的定义</h3><blockquote>
<p>OWASP（Open Web Application Security Project）致力于发现和解决不安全 Web 应用的根本原因</p>
</blockquote>
<ol>
<li>Injection（注入）</li>
<li>Broken Authentication（失效的身份认证）</li>
<li>Sensitive Data Exposure（敏感信息泄露）</li>
<li>XXE, XML External Entities（XML 外部实体）</li>
<li>Broken Access Control（失效的访问控制）</li>
<li>Security Misconfiguration（安全配置错误）</li>
<li>XSS, Cross-Site Scripting（跨站脚本）</li>
<li>Insecure Deserialization（不安全的反序列化）</li>
<li>Using Components with Known Vulnerabilities（使用含有已知漏洞的组件）</li>
<li>Insufficient Logging &amp; Monitoring（不足的日志记录和监控）</li>
</ol>
<h2 id="验证机制安全"><a href="#验证机制安全" class="headerlink" title="验证机制安全"></a>验证机制安全</h2><h3 id="什么是验证机制"><a href="#什么是验证机制" class="headerlink" title="什么是验证机制"></a>什么是验证机制</h3><ul>
<li>验证机制是 Web 应用中最简单的一种安全机制。一般来说，应用程序 <strong>必须用户提交的用户名和密码，判断是否允许登录</strong></li>
<li>验证机制是应用程序防御恶意攻击的 <strong>核心机制</strong>，处于安全防御的最前沿，如果缺乏安全有效的验证机制，其他核心安全机制（会话管理和访问控制）都无法实施</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Login-Process.webp" alt="典型的用户登陆流程"></p>
<p>有这样几种常用的验证技术：</p>
<ul>
<li>基于 HTML 表单的验证</li>
<li>多元机制</li>
<li>客户端 SSL 证书</li>
</ul>
<h3 id="验证机制存在的安全隐患"><a href="#验证机制存在的安全隐患" class="headerlink" title="验证机制存在的安全隐患"></a>验证机制存在的安全隐患</h3><h4 id="弱密码"><a href="#弱密码" class="headerlink" title="弱密码"></a>弱密码</h4><p>许多 Web 应用程序没有或很少对用户密码强度进行控制：</p>
<ul>
<li>非常短或空白密码</li>
<li>以常用字典词汇为密码</li>
<li>密码与用户名完全相同</li>
<li>长时间使用默认密码</li>
</ul>
<h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>登陆功能的公开性会诱使攻击者视图猜测用户名和密码，有诸如 Burp Suite 等工具提供了一些常用的字典</p>
<p>为了防止暴力破解，可以使用验证码，而验证码也需要注意几个问题：</p>
<ul>
<li>验证码是否真实有效</li>
<li>验证码的复杂度</li>
<li>应对当前诸如 OCR、打码等技术</li>
</ul>
<p>也可以设置 Cookie 和会话检测，增加失败计数器，当然 Cookie 在客户端可以随意修改</p>
<p>此外现在常用双因子认证（你知道的 + 你拥有的）</p>
<h4 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h4><p>包括问题的答案、邮箱、手机验证码用明文或简单的 MD5 加密等</p>
<h4 id="多阶登录机制"><a href="#多阶登录机制" class="headerlink" title="多阶登录机制"></a>多阶登录机制</h4><p>多次验证检查可能会提高登录机制的安全性，但在这个过程中可能也存在更多的执行缺陷：</p>
<ul>
<li>可能会认为到达第三阶段的用户已经通过了第一二阶段</li>
<li>可能认为每个阶段用户的身份不会变化</li>
<li>有些问题的细节或答案没有保存在服务器上，而是放在隐藏的 HTML 字段中</li>
</ul>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="什么是会话管理"><a href="#什么是会话管理" class="headerlink" title="什么是会话管理"></a>什么是会话管理</h3><ul>
<li>会话管理在用户通过请求提交他们的证书后，<strong>持续</strong> 向应用程序保证用户身份的真实性</li>
<li>由于会话管理机制发挥关键作用，且比较难以发现其漏洞，因此成为针对应用程序的恶意攻击的主要目标，攻击者若能破坏应用程序的会话管理，就能轻易避开验证机制</li>
</ul>
<h3 id="会话管理的安全隐患"><a href="#会话管理的安全隐患" class="headerlink" title="会话管理的安全隐患"></a>会话管理的安全隐患</h3><h4 id="会话令牌生成漏洞"><a href="#会话令牌生成漏洞" class="headerlink" title="会话令牌生成漏洞"></a>会话令牌生成漏洞</h4><p>通过简单的用户名、电子邮件经过简单的编码、加密生成的，不安全</p>
<h5 id="令牌可预测"><a href="#令牌可预测" class="headerlink" title="令牌可预测"></a>令牌可预测</h5><p>令牌有一定的模式和规则、时间依赖</p>
<h5 id="随机数强度不足"><a href="#随机数强度不足" class="headerlink" title="随机数强度不足"></a>随机数强度不足</h5><p>计算机中的数据极少完全随机，一般通过软件使用各种技巧生成伪随机数</p>
<h4 id="会话传输漏洞"><a href="#会话传输漏洞" class="headerlink" title="会话传输漏洞"></a>会话传输漏洞</h4><p>尽可能缩短一个会话的寿命可以降低攻击者截获、猜测或滥用有效会话的风险</p>
<h5 id="会话终止攻击"><a href="#会话终止攻击" class="headerlink" title="会话终止攻击"></a>会话终止攻击</h5><p>有一些应用程序没有有效的会话终止功能，他的有效期非常长</p>
<p>有些时候，退出功能并不能帮助服务器终止会话，比如只是简单地删除客户端的 Cookie，我们需要让服务端的会话失效</p>
<h5 id="会话劫持攻击"><a href="#会话劫持攻击" class="headerlink" title="会话劫持攻击"></a>会话劫持攻击</h5><p>攻击者通过网络嗅探、XSS 攻击等方式截获令牌</p>
<h3 id="会话管理漏洞的防御"><a href="#会话管理漏洞的防御" class="headerlink" title="会话管理漏洞的防御"></a>会话管理漏洞的防御</h3><ul>
<li><strong>令牌传输过程</strong>：令牌只能通过 HTTPS 传送，让浏览器不能通过 HTTP 传送令牌</li>
<li><strong>增加软硬会话过期</strong><ul>
<li>软会话过期：一定时间没有交互之后，Session 失效</li>
<li>应会话过期：经过一定时间之后，不管用户做什么，会话都会过期</li>
</ul>
</li>
<li><strong>提供完善的注销功能</strong></li>
</ul>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>Web 程序经常会建立用户提交数据的 SQL 语句，但如果建立 SQL 语句的方法不安全，则容易造成 SQL 注入漏洞</p>
<h3 id="SQL-注入危害"><a href="#SQL-注入危害" class="headerlink" title="SQL 注入危害"></a>SQL 注入危害</h3><ul>
<li><strong>探知数据库的具体结构</strong>，为进一步攻击做准备</li>
<li><strong>泄露数据</strong>，尤其是机密信息、账户信息等</li>
<li><strong>获得更高权限</strong>，来修改数据甚至是内部结构</li>
</ul>
<h3 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h3><ul>
<li><strong>参数化查询</strong>：最根本性的防御<ul>
<li>指定查询结构，用户输入预留占位符</li>
<li>指定占位符的内容</li>
</ul>
</li>
</ul>
<h2 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h2><p>攻击者通常通过注入 HTML 或 JS 脚本发动攻击，攻击成功后，攻击者可以得到私密网页内容和 Cookie 等</p>
<h3 id="XSS-攻击危害"><a href="#XSS-攻击危害" class="headerlink" title="XSS 攻击危害"></a>XSS 攻击危害</h3><ul>
<li><strong>盗号</strong></li>
<li><strong>控制数据</strong>，读取、篡改、添加、删除敏感数据</li>
<li><strong>非法转账</strong></li>
<li><strong>网站挂马</strong></li>
<li><strong>控制肉鸡</strong></li>
</ul>
<h3 id="XSS-攻击分类"><a href="#XSS-攻击分类" class="headerlink" title="XSS 攻击分类"></a>XSS 攻击分类</h3><h4 id="反射式-XSS-攻击"><a href="#反射式-XSS-攻击" class="headerlink" title="反射式 XSS 攻击"></a>反射式 XSS 攻击</h4><p>又称非永久性 XSS，是目前最流行的 XSS 攻击</p>
<p>出现在服务器直接使用客户端提交的数据，比如 URL 数据、HTML 表单等，并且没有对数据进行无害化处理，这些数据中藏着一些可执行脚本，最常见的方式就是恶意连接，其中包含了 XSS 攻击脚本</p>
<h4 id="存储式-XSS-攻击"><a href="#存储式-XSS-攻击" class="headerlink" title="存储式 XSS 攻击"></a>存储式 XSS 攻击</h4><p>又称永久性 XSS，危害更大</p>
<p>攻击者将脚本上传到 Web 服务器上，使得所有访问该页面的用户都面临信息泄露的可能</p>
<p>多发生在个人信息字段、文档或上传的文件及其他数据的名称、提交给应用程序管理员的反馈或问题、向其他用户传送的信息、在用户之间共享的上传文件内容</p>
<h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击仅仅通过 JavaScript 执行，常发生在应用程序每次返回相同的静态 HTML，而客户端 JavaScript 动态生成信息，并不会跟服务端交互获取的时候</p>
<h3 id="XSS-攻击载荷"><a href="#XSS-攻击载荷" class="headerlink" title="XSS 攻击载荷"></a>XSS 攻击载荷</h3><ul>
<li><strong>会话令牌</strong>：XSS 攻击最普遍的方式，截取受害者的会话令牌，劫持他的会话</li>
<li><strong>虚拟置换</strong>：向 Web 应用程序页面注入恶意数据（修改页面），没有修改保存在服务器上保存的内容，而是通过程序处理来显示置换</li>
<li><strong>注入木马</strong>：比如突然弹出一个对话框（木马登录表单），诱导你输入用户密码</li>
</ul>
<h3 id="XSS-防御措施"><a href="#XSS-防御措施" class="headerlink" title="XSS 防御措施"></a>XSS 防御措施</h3><ul>
<li><strong>输入验证</strong><ul>
<li>数据不是太长</li>
<li>数据仅包含合法字符</li>
<li>数据与正则表达式匹配</li>
<li>对不同的数据类型（比如账号、邮箱等）设置不同的规则</li>
</ul>
</li>
<li><strong>输出编码</strong><ul>
<li>对数据进行 HTML 编码，使用 HTML 实体代替字面量字符，净化可能的恶意字符</li>
</ul>
</li>
</ul>
<h2 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h2><p>典型的流程如下：</p>
<ol>
<li>受害者登录 <code>a.com</code>，并且保留了登录凭证（Cookie）</li>
<li>攻击者诱使受害者访问 <code>hack.com</code></li>
<li><code>hack.com</code> 向 <code>a.com</code> 发送请求：<code>a.com/act=xx</code> 浏览器默认会携带上 <code>a.com</code> 的 <code>Cookie</code></li>
<li><code>a.com</code> 收到请求后，确认是受害者的凭证，误认为是受害者自己发送的请求</li>
<li><code>a.com</code> 以受害者的名义执行了 <code>act=x</code></li>
</ol>
<h3 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h3><h4 id="GET-类型的-CSRF"><a href="#GET-类型的-CSRF" class="headerlink" title="GET 类型的 CSRF"></a>GET 类型的 CSRF</h4><p>这个类型非常简单，一般只需要一个 HTTP 请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bank.example/withraw?amount=10000&amp;for=hacker"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在受害者访问有这个 img 的页面之后，浏览器会自动向 <code>http://bank.example/withraw?amount=10000&amp;for=hacker</code> 发送请求</p>
<h4 id="POST-类型的-CSRF"><a href="#POST-类型的-CSRF" class="headerlink" title="POST 类型的 CSRF"></a>POST 类型的 CSRF</h4><p>这类攻击通常是使用一个自动提交的表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://bank.example/withdraw"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"xiaoming"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"for"</span> <span class="attr">value</span>=<span class="string">"hacker"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="链接类型的-CSRF"><a href="#链接类型的-CSRF" class="headerlink" title="链接类型的 CSRF"></a>链接类型的 CSRF</h4><p>需要用户点击链接才会触发：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://bank.example/withraw?amount=10000&amp;for=hacker"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSRF-的特点"><a href="#CSRF-的特点" class="headerlink" title="CSRF 的特点"></a>CSRF 的特点</h3><ul>
<li>攻击一般发起在 <strong>第三方网站</strong>，而不是被攻击的网站（通常是 <strong>跨域</strong> 的），因此被攻击的网站无法防止攻击的发生</li>
<li>攻击者利用受害者的登陆凭证，而不是直接盗取数据</li>
<li>攻击者仅仅是 <strong>利用</strong> 受害者的登录凭证，而 <strong>不能获取</strong> 到这个凭证</li>
<li>跨站请求可以用各种方式：图片、超链接、CORS、Form 表单等，部分请求可以直接嵌入第三方论坛、文章中，难以进行追踪</li>
<li>通常是跨域的，但有时候也可以在 <strong>本域</strong> 进行，比如在论坛和评论区可以发图和连接，这种攻击更加危险</li>
</ul>
<h3 id="CSRF-防御措施"><a href="#CSRF-防御措施" class="headerlink" title="CSRF 防御措施"></a>CSRF 防御措施</h3><p>针对 CSRF 通常是跨域请求，并且攻击者只是冒用、而无法真正获得 Cookie 的特点，可以采取以下策略：</p>
<ul>
<li><strong>阻止不明外域的访问</strong><ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
</li>
<li><strong>提交时要求附加本域才能获得的信息</strong><ul>
<li>CSRF Token</li>
<li>双重 Cookie 验证</li>
</ul>
</li>
</ul>
<h4 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h4><p>可以通过 <strong>Origin Header</strong> 和 <strong>Referer Header</strong> 来判断请求是否来自外域</p>
<p>对于 Origin 有两个问题：</p>
<ul>
<li>IE 11 不会在 CORS 请求上添加 Origin 标头</li>
<li>302 重定向之后，Origin 不再包含在重定向之后的请求中</li>
</ul>
<p>对于 Referer 也有问题：</p>
<ul>
<li>每个浏览器对于 Referer 的实现可能有差别，不能保证浏览器自身没有安全漏洞</li>
<li>攻击请求可能隐藏 Referer</li>
</ul>
<p>当 Origin 和 Referer 都不存在的时候，建议直接阻止访问</p>
<p>，同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这有时候也有问题，比如搜索引擎来的请求也会被当做疑似 CSRF 攻击，并且安全性并不是很高</p>
<h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h4><ol>
<li><strong>将 CSRF Token 输出到页面中</strong>，用户打开页面时，需要给用户生成一个 Token，可以将这个 Token 保存在 Session 中，同时给页面上所有的 a 标签 和 form 标签后面加入这个 Token</li>
<li><strong>页面提交的请求携带这个 Token</strong></li>
<li><strong>服务器验证 Token 是否正确</strong></li>
</ol>
<h4 id="分布式校验"><a href="#分布式校验" class="headerlink" title="分布式校验"></a>分布式校验</h4><p>使用一种计算出来的结果而不是随机生成的字符串作为 Token，这样在校验的时候就无需读取存储的 Token，只需要再计算一次即可</p>
<h4 id="双重-Cookie-验证"><a href="#双重-Cookie-验证" class="headerlink" title="双重 Cookie 验证"></a>双重 Cookie 验证</h4><p>因为攻击者实际上无法知道 Cookie 里面的内容，所以只需要让 AJAX 和表单请求中携带一个 Cookie 中的值，后端接口验证 Cookie 中的字段与请求参数中的字段是否相同，这样可以减小后端服务器 Session 存储的压力</p>
<p>但是也有一些问题：</p>
<ol>
<li>如果用户访问 <code>www.a.com</code>，后端域名为 <code>api.a.com</code>，那么在 <code>www.a.com</code> 下就拿不到 <code>api.a.com</code> 的 Cookie</li>
<li>于是这个认证必须种在 <code>a.com</code> 下</li>
<li>于是任意子域名都可以修改 <code>a.com</code> 下的 Cookie</li>
<li>如果某个子域名存在漏洞被 XSS 攻击，那么攻击者就可以修改 <code>a.com</code> 下的 Cookie</li>
<li>攻击者就可以使用自己配置的 Cookie，对用户在 <code>www.a.com</code> 下发起 CSRF 攻击</li>
</ol>
<h4 id="Samesite-Cookie"><a href="#Samesite-Cookie" class="headerlink" title="Samesite Cookie"></a>Samesite Cookie</h4><p>Google 起草了一份草案来改进 HTTP 协议，就是为 <code>Set-Cookie</code> 响应头增加 <code>Samesite</code> 属性，表明这个 Cookie 是个 <strong>同站 Cookie</strong></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><blockquote>
<p>TCP 面向连接、可靠、面向字节流；UDP 面向无连接</p>
</blockquote>
<ol>
<li><strong>面向连接</strong>。TCP 需要三次握手建立连接，UDP 则不需要</li>
<li><strong>可靠</strong>。TCP <strong>有状态</strong>，会记录哪些数据发送了，哪些数据对方接受了，哪些数据丢失了，不允许差错；TCP <strong>可控制</strong>，会根据丢包的情况或者状态，调整自己的行为，比如控制速度或者重发</li>
<li><strong>面向字节流</strong>。UDP 的数据传输是面向数据报的，TCP 为了维护状态，将 IP 包变成了字节流。</li>
</ol>
<p>所谓 <strong>面向数据报</strong> 是指，应用层交给 UDP 多长的 <strong>报文</strong>，UDP 就照样发送，一次发送一个报文；而面向字节流是指，TCP 虽然一次接收应用层来的一个数据块（大小不等），但 TCP 把应用程序看成一连串无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就会把它划分得短一些再发送；如果应用程序一次只发送一个字节，TCP 也可以等待积累足够多的字节后再构成报文段发送出去。</p>
<h2 id="TCP-的三次握手与四次挥手"><a href="#TCP-的三次握手与四次挥手" class="headerlink" title="TCP 的三次握手与四次挥手"></a>TCP 的三次握手与四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>三次握手是需要确认双方的 <strong>发送能力</strong> 和 <strong>接收能力</strong></p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Handshake.png" alt="TCP三次握手"></p>
<h4 id="三次握手的过程中可以携带数据吗？"><a href="#三次握手的过程中可以携带数据吗？" class="headerlink" title="三次握手的过程中可以携带数据吗？"></a>三次握手的过程中可以携带数据吗？</h4><p>前两次不能，第三次可以，此时客户端已经处于 ESTABLISHED 状态，确认了服务器发送、接受信息的能力正常</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Wavehand.png" alt="TCP四次挥手"></p>
<p>服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN。因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN。这就造成了四次挥手。</p>
<h3 id="半连接队列与-SYN-Flood"><a href="#半连接队列与-SYN-Flood" class="headerlink" title="半连接队列与 SYN Flood"></a>半连接队列与 SYN Flood</h3><p>三次握手之前，在服务器状态从 CLOSED 变为 LISTEN 的时候，还在内部创建了两个队列：<strong>半连接队列</strong> 和 <strong>全连接队列</strong></p>
<h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>又称 <strong>SYN 队列</strong>，当客户端发送 SYN 到服务端，服务端收到后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 <strong>半连接队列</strong></p>
<h4 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h4><p>又称 <strong>ACCEPTED 队列</strong>，当客户端返回 ACK，服务端接收后，三次握手完成，连接等待被某个具体的应用取走，在被取走之前，会被推入 <strong>全连接队列</strong></p>
<h4 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h4><p>属于典型的 Dos/DDos 攻击，用客户端在短时间内伪造大量不存在的 IP 地址，疯狂发送 SYN，使得服务器：</p>
<ol>
<li>处理大量 SYN 包并返回 ACK，使得 <strong>半连接队列爆满</strong></li>
<li>由于是不存在的 IP，服务端长时间 <strong>收不到客户端的 ACK</strong>，就会疯狂重发数据，直到耗尽服务器资源</li>
</ol>
<h5 id="如何应对-SYN-Flood-攻击？"><a href="#如何应对-SYN-Flood-攻击？" class="headerlink" title="如何应对 SYN Flood 攻击？"></a>如何应对 SYN Flood 攻击？</h5><ol>
<li><strong>增加半连接队列容量</strong></li>
<li><strong>减少 SYN + ACK 的重试次数</strong></li>
<li><strong>利用 SYN Cookie 技术</strong>，在服务端接收到 SYN 后不立即分配链接资源，而是根据 SYN 计算出一个 Cookie，连通第二次握手一同发给客户端，客户端回复 ACK 的时候带上 Cookie，服务端验证合法后才分配链接资源</li>
</ol>
<h2 id="TCP-报文"><a href="#TCP-报文" class="headerlink" title="TCP 报文"></a>TCP 报文</h2><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header.png" alt="TCP报文头"></p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>即 Sequence Number，指的是本报文段的第一个字节的序列号，长度为 4 个字节，可以：</p>
<ol>
<li>在 SYN 报文中交换彼此的初始序列号</li>
<li>保证数据包按照正确的顺序组装</li>
</ol>
<h5 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h5><p>即 Initial Sequence Number，在三次握手的过程中，双方会通过 SYN 报文来交换彼此的 ISN，ISN 会动态增长，每 4ms 就加 1，溢出则回到 0。动态增长的 ISN 增加了猜测 ISN 的难度</p>
<h4 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h4><p>即 ACK（Acknowledgement Number），用来告知对方下一个期望接收的序列号，小于 ACK 的所有字节已经全部接收到</p>
<h4 id="标记位"><a href="#标记位" class="headerlink" title="标记位"></a>标记位</h4><p>占用一个字节，常见的标记位有 SYN、ACK、FIN、RST、PSH。</p>
<ul>
<li>SYN：Synchronize，表示同步，用来开始请求</li>
<li>ACK：Acknowledge，表示确认</li>
<li>FIN：Finish，表示发送方准备断开连接</li>
<li>RST：Reset，用来强制断开连接</li>
<li>PSH：Push，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存</li>
</ul>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>占用两个字节，但实际上不够用，因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因此可以将窗口值扩大为原来的 2 ^ n 倍</p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃、等待重传</p>
<h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header-Options.png" alt="可选项"></p>
<p>常用的可选项有：</p>
<ul>
<li>Timestamp：TCP 时间戳</li>
<li>MSS：TCP 允许的从对方接收的最大报文段</li>
<li>SACK：选择确认选项</li>
<li>Window Scale：窗口缩放</li>
</ul>
<h5 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h5><p>Timestamp 一共占 10 个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind(1 Byte) + length(1 Byte) + info(8 Bytes)</span><br></pre></td></tr></table></figure>

<p>其中 <code>kind=8</code> <code>length=10</code>，<code>info</code> 由 <code>timestamp</code> 和 <code>timestamp echo</code> 两部分构成，各占四个字节</p>
<p>TCP 的时间戳主要解决两个问题：</p>
<ul>
<li>计算往返时延（RTT, Round-Trip Time）</li>
<li>防止序列号回绕</li>
</ul>
<h6 id="计算-RTT"><a href="#计算-RTT" class="headerlink" title="计算 RTT"></a>计算 RTT</h6><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Timestamp-RTT.png" alt="计算RTT"></p>
<h6 id="防止序列号回绕"><a href="#防止序列号回绕" class="headerlink" title="防止序列号回绕"></a>防止序列号回绕</h6><p>因为序列号的长度是有限的，若超出容纳的范围，就会回到 0，时间戳使得两个序列号相同的报文也能得以区分</p>
<h2 id="TFO"><a href="#TFO" class="headerlink" title="TFO"></a>TFO</h2><blockquote>
<p>TCP Fast Open，优化后的 TCP 三次握手流程，也是基于 SYN Cookie 技术</p>
</blockquote>
<h3 id="TFO-流程"><a href="#TFO-流程" class="headerlink" title="TFO 流程"></a>TFO 流程</h3><p>首轮的三次握手：</p>
<ol>
<li>客户端发送 <strong>SYN</strong> 给服务端</li>
<li>服务端计算得到一个 <strong>SYN Cookie</strong>，将这个 Cookie 放到 TCP 报文的 Fast Open 选项中，再继续三次握手</li>
<li>客户端把 <strong>Cookie</strong> 缓存下来，继续三次握手</li>
</ol>
<p>后续的三次握手：</p>
<ol>
<li>客户端将之前缓存的 <strong>Cookie、SYN 和 HTTP 请求</strong> 发送给服务端</li>
<li>服务端验证 Cookie 的合法性，如果合法就正常返回 <strong>SYN + ACK</strong>，同时可以给客户端发 <strong>HTTP 响应</strong></li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TFO.png" alt="TFO"></p>
<h2 id="TCP-超时重传"><a href="#TCP-超时重传" class="headerlink" title="TCP 超时重传"></a>TCP 超时重传</h2><blockquote>
<p>在间隔一段时间没有等到这个数据包回复时，将会重传这个数据包</p>
</blockquote>
<h3 id="超时重传时间的计算"><a href="#超时重传时间的计算" class="headerlink" title="超时重传时间的计算"></a>超时重传时间的计算</h3><p>重传的间隔被称为超时重传时间（RTO, Retransmission TimeOut），他的计算跟 RTT 密切相关，有两种主要的方法：经典方法和标准方法</p>
<h4 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h4><blockquote>
<p>平滑往返时间（SRTT, Smoothed Round-Trip Time）是根据 RTT 和之前的 SRTT 计算出来的一个值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRTT &#x3D; (α * SRTT) + ((1 - α) * RTT)</span><br><span class="line">初始的 SRTT 为 0</span><br></pre></td></tr></table></figure>

<p>α 即为 <strong>平滑因子</strong>，建议值是 0.8，范围是 0.8 ~ 0.9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO &#x3D; min(ubound, max(lbound, β * SRTT))</span><br></pre></td></tr></table></figure>

<p>其中，β 是 <strong>加权因子</strong>，一般为 1.3 ~ 2.0，<strong>lbound 是 下界</strong>，<strong>ubound 是上界</strong></p>
<p>在 RTT 变化较大的地方不太适用，因为 RTT 对 RTO 影响太小</p>
<h4 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h4><p>又称 Jacobson / Karels 算法</p>
<ol>
<li><strong>计算 SRTT</strong>：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT &#x3D; (α * SRTT) + ((1 - α) * RTT)</span><br></pre></td></tr></table></figure>

<p>α 的建议值是 <strong>0.125</strong></p>
<ol start="2">
<li>**计算中间变量 RTTVAR（Round-Trip Time Variation）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR &#x3D; (1 - β) * RTTVAR + β * (|RTT - SRTT|)</span><br></pre></td></tr></table></figure>

<p>β 的建议值是 <em>0.25*</em></p>
<ol start="3">
<li>计算 RTO</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO &#x3D; µ * SRTT + ∂ * RTTVAR</span><br></pre></td></tr></table></figure>

<p>µ 建议值取 1, ∂ 建议值取 4</p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>TCP 会把需要发送的数据放到 <strong>发送缓存区</strong>，需要接收的数据放到 <strong>接收缓存区</strong></p>
<p>流量控制则是通过 <strong>控制接收缓存区的大小</strong>，来控制发送端的发送，如果接收方的接收缓存区满了，就不能再发送了</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 滑动窗口分为 <strong>发送窗口</strong> 和 <strong>接收窗口</strong></p>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window.png" alt="TCP发送窗口"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window-2.png" alt="TCP发送窗口"></p>
<p>SND 即为 send，WND 即为 window，UNA 即为 unacknowledged，NXT 即为 next</p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Receive-Window.png" alt="TCP接收窗口"></p>
<p>REV 即为 receive</p>
<p>简单来说，接受端如果处理能力不够用了，想让发送端少发点，就会将自己的接收窗口大小（相当于缓冲队列，也就是还可以装的部分）在 ACK 报文首部加上，发给发送端，发送端收到之后调解自己发送窗口的大小</p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>流量控制主要是考虑到 <strong>发送端</strong> 和 <strong>接受端</strong> 的情况，而没有考虑到整个网络环境的影响，拥塞控制则是考虑整体网络环境的好坏</p>
<p>对于拥塞控制，TCP 每条连接都需要维护两个核心状态：</p>
<ul>
<li>拥塞窗口（CWND, Congestion Window）</li>
<li>慢启动阈值（SSThresh, Slow Start Threshold）</li>
</ul>
<p>涉及这几个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传和快速恢复</li>
</ul>
<h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>指的是目前自己还能传输的数据量大小，与上面的接收窗口不同，是 <strong>发送端</strong> 的限制</p>
<p>发送窗口最终的大小取 <strong>接收窗口</strong> 和 <strong>拥塞窗口</strong> 中的小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送窗口大小 &#x3D; min(RWND, CWND)</span><br></pre></td></tr></table></figure>

<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>由于刚接入网络传输数据的时候，并不知道网络的状态，所以不能操之过急，拥塞控制会采用保守的算法来慢慢适应网络</p>
<ul>
<li>首先，三次握手，双方宣告自己 <strong>接收窗口（RWND）</strong> 的大小</li>
<li>双方初始化自己 <strong>拥塞窗口（CWND）</strong> 的大小</li>
<li>在开始传输的一段时间，发送端每收到 1 个 ACK，拥塞窗口大小 <strong>+ 1</strong>，也就是说，每经过 1 个 RTT，CWND 翻倍，直到 CWND 达到 <strong>慢启动阈值</strong></li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当 CWND 达到慢启动阈值时，CWND 每次只能 <strong>+ 1 / CWND</strong>，也就是说，1 个 RTT 之后，CWND 只能增加 1</p>
<h3 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h3><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>解决的是 <strong>是否需要重传</strong> 的问题</p>
<p>当接受端发现丢包后，后续 ACK 一律回复为最后一个好包，因此当发送端发现接收到重复的 ACK，意识到丢包，就马上重传，而不是等一个 RTO</p>
<p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传</p>
<h4 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h4><p>解决的是 <strong>如何重传的问题</strong></p>
<p>接受端会回复一个 ACK 报文，在首部可选项中有 <strong>SACK</strong> 属性，通过 <strong>left edge</strong> 和 <strong>right edge</strong> 告知发送端已经接收到了哪些区间的数据包，进行 <strong>选择性重传（SACK, Selective Acknowledgement）</strong>，比如上面的例子，不会再传第 6、7 个包</p>
<h4 id="快速回复"><a href="#快速回复" class="headerlink" title="快速回复"></a>快速回复</h4><p>当发送端知道丢包之后，觉得网络可能有点拥塞，即会进入 <strong>快速恢复</strong> 阶段，发送端会做出如下改变：</p>
<ul>
<li>拥塞阈值降为 CWND 的一半</li>
<li>CWND 的大小变为拥塞阈值</li>
<li>CWND 线性增加</li>
</ul>
<h2 id="Nagle-算法与延迟确认"><a href="#Nagle-算法与延迟确认" class="headerlink" title="Nagle 算法与延迟确认"></a>Nagle 算法与延迟确认</h2><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><blockquote>
<p>为了避免频繁发送小包而诞生</p>
</blockquote>
<ul>
<li>第一次发送数据的时候不用等待，即使是再小的包也马上发送</li>
<li>后面发送的包需要满足下面条件之一：<ul>
<li>数据包大小达到最大子段大小（MSS, Max Segment Size）</li>
<li>之前所有包的 ACK 都已经接受到</li>
</ul>
</li>
</ul>
<h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><blockquote>
<p>为了避免频繁回复小包而诞生</p>
</blockquote>
<p>TCP 要求延迟的时延必须小于 500ms，一般的操作系统都不会超过 200ms</p>
<p>一些场景收到之后会马上回复：</p>
<ul>
<li>收到了大于一个 frame 的报文，且需要调整窗口大小</li>
<li>TCP 处于 quickack 模式（通过 <code>tcp_in_quickack_mode</code> 设置）</li>
<li>发现了乱序包</li>
</ul>
<h2 id="TCP-的-keep-alive"><a href="#TCP-的-keep-alive" class="headerlink" title="TCP 的 keep-alive"></a>TCP 的 keep-alive</h2><p>由于 TCP 不是一个轮询的协议，他无法获知对端连接失效的情况（比如对端网络故障或宕机），<strong>keep-alive</strong> 则是用于探测对端的连接是否失效，但是因为探测的时间比较长，所以一般不怎么用</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/hais-notebook/tags/%E5%85%A5%E9%97%A8/" rel="tag"># 入门</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/hais-notebook/2020/02/28/CS-Algorithm-QA-sort/" rel="prev" title="算法小问题：排序">
      <i class="fa fa-chevron-left"></i> 算法小问题：排序
    </a></div>
      <div class="post-nav-item">
    <a href="/hais-notebook/2020/03/05/JS-Canvas/" rel="next" title="JavaScript：Canvas">
      JavaScript：Canvas <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP"><span class="nav-number">1.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-基本介绍"><span class="nav-number">1.1.</span> <span class="nav-text">HTTP 基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-历史"><span class="nav-number">1.1.1.</span> <span class="nav-text">HTTP 历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-与-HTTP"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP&#x2F;IP 与 HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分层"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS-解析"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">DNS 解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-协议结构和通讯原理"><span class="nav-number">1.2.</span> <span class="nav-text">HTTP 协议结构和通讯原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-协议特点"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTP 协议特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI-和-URL"><span class="nav-number">1.2.2.</span> <span class="nav-text">URI 和 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-报文结构"><span class="nav-number">1.2.3.</span> <span class="nav-text">HTTP 报文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求报文"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">请求报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应报文"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">响应报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#报文头"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">报文头</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-请求方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">HTTP 请求方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-状态码"><span class="nav-number">1.2.5.</span> <span class="nav-text">HTTP 状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-状态管理：Cookie-和-Session"><span class="nav-number">1.2.6.</span> <span class="nav-text">HTTP 状态管理：Cookie 和 Session</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie-和-Session"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">Cookie 和 Session</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-协议的特性"><span class="nav-number">1.3.</span> <span class="nav-text">HTTP 协议的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-协议中的编码和解码"><span class="nav-number">1.3.1.</span> <span class="nav-text">HTTP 协议中的编码和解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码规范"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">编码规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乱码"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">乱码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL-的编码与解码"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">URL 的编码与解码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-协议的基本认证"><span class="nav-number">1.3.2.</span> <span class="nav-text">HTTP 协议的基本认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的认证方式"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">常见的认证方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BASIC"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">BASIC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DIGEST"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">DIGEST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSL-客户端"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">SSL 客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormBase"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">FormBase</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-中的长连接和短链接"><span class="nav-number">1.3.3.</span> <span class="nav-text">HTTP 中的长连接和短链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中介代理与中介网关"><span class="nav-number">1.3.4.</span> <span class="nav-text">中介代理与中介网关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中介代理"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">中介代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中介网关"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">中介网关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-缓存"><span class="nav-number">1.3.5.</span> <span class="nav-text">HTTP 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-缓存头部字段"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">HTTP 缓存头部字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache-Control"><span class="nav-number">1.3.5.1.1.</span> <span class="nav-text">Cache-Control</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他头部字段"><span class="nav-number">1.3.5.1.2.</span> <span class="nav-text">其他头部字段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-缓存工作方式"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">HTTP 缓存工作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#场景一：让服务器与浏览器约定一个文件过期时间-Expires"><span class="nav-number">1.3.5.2.1.</span> <span class="nav-text">场景一：让服务器与浏览器约定一个文件过期时间 Expires</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#场景二：约定-Expires-的基础上，再通过文件的最新修改时间进行对比-Last-Modified-与-if-Modified-Since"><span class="nav-number">1.3.5.2.2.</span> <span class="nav-text">场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#场景三：在上面的基础上加上-Etag-If-None-Match，再使用-max-age"><span class="nav-number">1.3.5.2.3.</span> <span class="nav-text">场景三：在上面的基础上加上 Etag&#x2F;If-None-Match，再使用 max-age</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存改进方案"><span class="nav-number">1.3.5.2.4.</span> <span class="nav-text">缓存改进方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#md5-hash-缓存"><span class="nav-number">1.3.5.2.4.1.</span> <span class="nav-text">md5&#x2F;hash 缓存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CDN-缓存"><span class="nav-number">1.3.5.2.4.2.</span> <span class="nav-text">CDN 缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器操作对-HTTP-缓存的影响"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">浏览器操作对 HTTP 缓存的影响</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-内容协商机制"><span class="nav-number">1.3.6.</span> <span class="nav-text">HTTP 内容协商机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内容协商的方式"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">内容协商的方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-断点续传和多线程下载"><span class="nav-number">1.3.7.</span> <span class="nav-text">HTTP 断点续传和多线程下载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Range"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">Range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Content-Range"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">Content-Range</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">1.4.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数字证书"><span class="nav-number">1.4.1.</span> <span class="nav-text">数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对称加密与非对称加密"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">对称加密与非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字签名与数字证书"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">数字签名与数字证书</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-协议概述"><span class="nav-number">1.4.2.</span> <span class="nav-text">HTTPS 协议概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-使用成本"><span class="nav-number">1.4.3.</span> <span class="nav-text">HTTPS 使用成本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-HTTP-的功能追加协议"><span class="nav-number">1.5.</span> <span class="nav-text">基于 HTTP 的功能追加协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-协议的瓶颈"><span class="nav-number">1.5.1.</span> <span class="nav-text">HTTP 协议的瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">1.5.2.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPDY"><span class="nav-number">1.5.3.</span> <span class="nav-text">SPDY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-2-0"><span class="nav-number">1.5.4.</span> <span class="nav-text">HTTP&#x2F;2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制分帧"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">二进制分帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#首部压缩"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">首部压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行双向字节流"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">并行双向字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求优先级"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">请求优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器推送"><span class="nav-number">1.5.4.6.</span> <span class="nav-text">服务器推送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebDAV"><span class="nav-number">1.5.5.</span> <span class="nav-text">WebDAV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QUIC-和-HTTP-3-0"><span class="nav-number">1.5.6.</span> <span class="nav-text">QUIC 和 HTTP&#x2F;3.0</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web-安全"><span class="nav-number">2.</span> <span class="nav-text">Web 安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-安全概述"><span class="nav-number">2.1.</span> <span class="nav-text">Web 安全概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-应用"><span class="nav-number">2.1.1.</span> <span class="nav-text">Web 应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-应用三层架构"><span class="nav-number">2.1.2.</span> <span class="nav-text">Web 应用三层架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WASC-的定义"><span class="nav-number">2.1.3.</span> <span class="nav-text">WASC 的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OWASP-的定义"><span class="nav-number">2.1.4.</span> <span class="nav-text">OWASP 的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证机制安全"><span class="nav-number">2.2.</span> <span class="nav-text">验证机制安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是验证机制"><span class="nav-number">2.2.1.</span> <span class="nav-text">什么是验证机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证机制存在的安全隐患"><span class="nav-number">2.2.2.</span> <span class="nav-text">验证机制存在的安全隐患</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#弱密码"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">弱密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暴力破解"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">暴力破解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忘记密码"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">忘记密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多阶登录机制"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">多阶登录机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会话管理"><span class="nav-number">2.3.</span> <span class="nav-text">会话管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是会话管理"><span class="nav-number">2.3.1.</span> <span class="nav-text">什么是会话管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话管理的安全隐患"><span class="nav-number">2.3.2.</span> <span class="nav-text">会话管理的安全隐患</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#会话令牌生成漏洞"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">会话令牌生成漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#令牌可预测"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">令牌可预测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#随机数强度不足"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">随机数强度不足</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#会话传输漏洞"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">会话传输漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#会话终止攻击"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">会话终止攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#会话劫持攻击"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">会话劫持攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话管理漏洞的防御"><span class="nav-number">2.3.3.</span> <span class="nav-text">会话管理漏洞的防御</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-注入攻击"><span class="nav-number">2.4.</span> <span class="nav-text">SQL 注入攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-注入危害"><span class="nav-number">2.4.1.</span> <span class="nav-text">SQL 注入危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-注入防御"><span class="nav-number">2.4.2.</span> <span class="nav-text">SQL 注入防御</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSS-跨站脚本攻击"><span class="nav-number">2.5.</span> <span class="nav-text">XSS 跨站脚本攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-攻击危害"><span class="nav-number">2.5.1.</span> <span class="nav-text">XSS 攻击危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-攻击分类"><span class="nav-number">2.5.2.</span> <span class="nav-text">XSS 攻击分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反射式-XSS-攻击"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">反射式 XSS 攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储式-XSS-攻击"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">存储式 XSS 攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-DOM-的-XSS-攻击"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">基于 DOM 的 XSS 攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-攻击载荷"><span class="nav-number">2.5.3.</span> <span class="nav-text">XSS 攻击载荷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-防御措施"><span class="nav-number">2.5.4.</span> <span class="nav-text">XSS 防御措施</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSRF-跨站请求伪造"><span class="nav-number">2.6.</span> <span class="nav-text">CSRF 跨站请求伪造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几种常见的攻击类型"><span class="nav-number">2.6.1.</span> <span class="nav-text">几种常见的攻击类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GET-类型的-CSRF"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">GET 类型的 CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POST-类型的-CSRF"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">POST 类型的 CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接类型的-CSRF"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">链接类型的 CSRF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF-的特点"><span class="nav-number">2.6.2.</span> <span class="nav-text">CSRF 的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF-防御措施"><span class="nav-number">2.6.3.</span> <span class="nav-text">CSRF 防御措施</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同源检测"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">同源检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF-Token"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">CSRF Token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式校验"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">分布式校验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双重-Cookie-验证"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">双重 Cookie 验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Samesite-Cookie"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">Samesite Cookie</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP"><span class="nav-number">3.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-与-UDP"><span class="nav-number">3.1.</span> <span class="nav-text">TCP 与 UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-的三次握手与四次挥手"><span class="nav-number">3.2.</span> <span class="nav-text">TCP 的三次握手与四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手"><span class="nav-number">3.2.1.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手的过程中可以携带数据吗？"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">三次握手的过程中可以携带数据吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四次挥手"><span class="nav-number">3.2.2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#半连接队列与-SYN-Flood"><span class="nav-number">3.2.3.</span> <span class="nav-text">半连接队列与 SYN Flood</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#半连接队列"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">半连接队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全连接队列"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">全连接队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN-Flood-攻击"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">SYN Flood 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何应对-SYN-Flood-攻击？"><span class="nav-number">3.2.3.3.1.</span> <span class="nav-text">如何应对 SYN Flood 攻击？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-报文"><span class="nav-number">3.3.</span> <span class="nav-text">TCP 报文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-报文头"><span class="nav-number">3.3.1.</span> <span class="nav-text">TCP 报文头</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#序列号"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">序列号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始序列号"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">初始序列号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确认号"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">确认号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记位"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">标记位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#窗口大小"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">窗口大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#校验和"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">校验和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选项"><span class="nav-number">3.3.1.6.</span> <span class="nav-text">可选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Timestamp"><span class="nav-number">3.3.1.6.1.</span> <span class="nav-text">Timestamp</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#计算-RTT"><span class="nav-number">3.3.1.6.1.1.</span> <span class="nav-text">计算 RTT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#防止序列号回绕"><span class="nav-number">3.3.1.6.1.2.</span> <span class="nav-text">防止序列号回绕</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TFO"><span class="nav-number">3.4.</span> <span class="nav-text">TFO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TFO-流程"><span class="nav-number">3.4.1.</span> <span class="nav-text">TFO 流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-超时重传"><span class="nav-number">3.5.</span> <span class="nav-text">TCP 超时重传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#超时重传时间的计算"><span class="nav-number">3.5.1.</span> <span class="nav-text">超时重传时间的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#经典方法"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">经典方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准方法"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">标准方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-流量控制"><span class="nav-number">3.5.2.</span> <span class="nav-text">TCP 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送窗口"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">发送窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收窗口"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">接收窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-拥塞控制"><span class="nav-number">3.5.3.</span> <span class="nav-text">TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞窗口"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">拥塞窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慢启动"><span class="nav-number">3.5.4.</span> <span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞避免"><span class="nav-number">3.5.5.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速重传与快速恢复"><span class="nav-number">3.5.6.</span> <span class="nav-text">快速重传与快速恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快速重传"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择性重传"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">选择性重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速回复"><span class="nav-number">3.5.6.3.</span> <span class="nav-text">快速回复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nagle-算法与延迟确认"><span class="nav-number">3.6.</span> <span class="nav-text">Nagle 算法与延迟确认</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nagle-算法"><span class="nav-number">3.6.1.</span> <span class="nav-text">Nagle 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟确认"><span class="nav-number">3.6.2.</span> <span class="nav-text">延迟确认</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-的-keep-alive"><span class="nav-number">3.7.</span> <span class="nav-text">TCP 的 keep-alive</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Harvey Zhang</p>
  <div class="site-description" itemprop="description">小海的笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hais-notebook/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hais-notebook/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/hais-notebook/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Harvey Zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/hais-notebook/lib/anime.min.js"></script>
  <script src="/hais-notebook/lib/velocity/velocity.min.js"></script>
  <script src="/hais-notebook/lib/velocity/velocity.ui.min.js"></script>

<script src="/hais-notebook/js/utils.js"></script>

<script src="/hais-notebook/js/motion.js"></script>


<script src="/hais-notebook/js/schemes/pisces.js"></script>


<script src="/hais-notebook/js/next-boot.js"></script>




  




  
<script src="/hais-notebook/js/local-search.js"></script>













  

  

</body>
</html>
