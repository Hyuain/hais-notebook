<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL 基本语法</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-SQL/</url>
    <content><![CDATA[<p>涉及 SQL 的基本语法。</p>
<a id="more"></a>

<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载 MySQL</a><br><a href="https://dev.mysql.com/downloads/workbench" target="_blank" rel="noopener">下载 MySQL WorkBench</a></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- use [schemas name]</span></span><br><span class="line">usz lzblog;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert into [table name] ([colunm name]) values ([colunm value])</span></span><br><span class="line"><span class="comment">-- password 是关键字，所以要用 `` 引起来</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (username, <span class="string">`password`</span>, nickname) <span class="keyword">values</span> (<span class="string">'zs'</span>, <span class="string">'123'</span>, <span class="string">'zhangsan'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username =<span class="string">'zs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般采用软删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> state=<span class="string">'0'</span> <span class="keyword">where</span> username=<span class="string">'lz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> state &lt;&gt; <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> nickname=<span class="string">'lz2'</span> <span class="keyword">where</span> username=<span class="string">'lz'</span>;</span><br><span class="line"><span class="comment">-- update [table name] set [colunm name]=[value] where [condition]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,username <span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'lz'</span> <span class="keyword">and</span> <span class="string">`password`</span>=<span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'lz'</span> <span class="keyword">or</span> <span class="string">`password`</span>=<span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%z%'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%z%'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>自学</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title>简单算法：字符串</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-CS-Algorithm-String/</url>
    <content><![CDATA[<p>一些字符串中涉及到的算法的题解。</p>
<a id="more"></a>

<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot; </span><br><span class="line"></span><br><span class="line">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> array = str.split(<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">const</span> result = array.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更优雅的写法</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .split(<span class="string">' '</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .split(<span class="regexp">/\s/g</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 match API</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .match(<span class="regexp">/[\w']+/g</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a>计数二进制子串</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</span><br><span class="line"></span><br><span class="line">重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">示例 1 :</span><br><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">s.length 在1到50,000之间。</span><br><span class="line">s 只包含“0”或“1”字符。</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/count-binary-substrings" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 建立数据结构，堆栈、保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="comment">// 给定任意子输入都返回第一个符合条件的字符串</span></span><br><span class="line">  <span class="keyword">const</span> match = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> j = str.match(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).toString().repeat(j.length)</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 for 循环控制程序运行流程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sub = match(str.slice(i))</span><br><span class="line">    <span class="keyword">if</span>(sub)&#123;</span><br><span class="line">      result.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小问题：数组去重</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-CS-Algorithm-QA/</url>
    <content><![CDATA[<p>总结：恰当地利用对象和 Map key 的唯一性可以实现对 <code>&#39;1&#39;</code> 和 <code>1</code> 的区分、对象的去重，以及 <code>undefined</code> <code>null</code> <code>NaN</code> 的良好识别。</p>
<a id="more"></a>

<p>使用数组 <code>[ 1, 1, &#39;1&#39;, &#39;1&#39;, 0, 0, { a: 1 }, { a: 1 }, x, y, z, undefined, undefined, null, null, NaN, NaN ]</code> 输出进行实验，其中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> y = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> z = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">let</span> isRepeat</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    isRepeat = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArray.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>[i] === newArray[j])&#123;</span><br><span class="line">        isRepeat = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepeat) &#123;</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>不能区分：对象，<code>NaN</code></p>
<h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><code>indexOf</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="keyword">this</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (newArray.indexOf(current) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      newArray.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>不能区分：对象，<code>NaN</code></p>
<h1 id="相邻元素去重（先排序）"><a href="#相邻元素去重（先排序）" class="headerlink" title="相邻元素去重（先排序）"></a>相邻元素去重（先排序）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">this</span>.sort()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>[i] !== <span class="keyword">this</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code>，<code>undefined</code>（会丢失）</p>
<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newArray = <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<p>不能区分：对象，<code>NaN</code>（会丢失）</p>
<h1 id="reduce（先排序）"><a href="#reduce（先排序）" class="headerlink" title="reduce（先排序）"></a><code>reduce</code>（先排序）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">result, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.length === <span class="number">0</span> || result[result.length - <span class="number">1</span>] !== current) &#123;</span><br><span class="line">      result.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>

<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code></p>
<h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a><code>includes</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象</p>
<h1 id="对象键值对"><a href="#对象键值对" class="headerlink" title="对象键值对"></a>对象键值对</h1><p>利用对象中 key 的不可重复性去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>不能区分：对象（存进去的时候所有对象都变成了 <code>[object Object]</code>）、’1’ 和 1</p>
<h2 id="改进版本-1"><a href="#改进版本-1" class="headerlink" title="改进版本 1"></a>改进版本 1</h2><p>可以区分 <code>&#39;1&#39;</code> 和 <code>1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="keyword">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进版本-2"><a href="#改进版本-2" class="headerlink" title="改进版本 2"></a>改进版本 2</h2><p>可以区分对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i])]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i])] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>利用 Map 的 key 唯一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.get(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">      map.set(<span class="keyword">this</span>[i], <span class="literal">true</span>)</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> (!map.has(item) &amp;&amp; map.set(item, <span class="literal">true</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>不能去重：对象，可以像上面的对象键值对方法一样处理</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类似于数组，但成员的值都是唯一的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化为</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="keyword">this</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以简化为</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<p>不能去重：对象</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>问题：原生 JavaScript</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-Others-QA-JS/</url>
    <content><![CDATA[<p>关于原生 JavaScript 的一些问题与答案。</p>
<a id="more"></a>

<h1 id="对象和数组的深拷贝"><a href="#对象和数组的深拷贝" class="headerlink" title="对象和数组的深拷贝"></a>对象和数组的深拷贝</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">100</span>,</span><br><span class="line">  b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><blockquote>
<p>只克隆第一层</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj.hasOwnProperty(key)) <span class="keyword">continue</span> <span class="comment">// 这里也可以用 break，因为到这一步基本就已经到原型的属性了，可以直接跳出循环</span></span><br><span class="line">  obj2[key] = obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 ES 6 的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj &#125;</span><br></pre></td></tr></table></figure>

<h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><blockquote>
<p>每一层都克隆</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)) <span class="comment">// 函数、日期、正则，在 stringify 的时候都会出现问题，平时在项目中用够了</span></span><br></pre></td></tr></table></figure>

<p>也可以用 <code>lodash</code> 之类的库，当然也可以手写一个简易版的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 是 function，创建一个新实例，返回</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不是 object，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是正则，创建一个新实例，返回</span></span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是日期，创建一个新实例，返回</span></span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="keyword">new</span> obj.constructor <span class="comment">// 这样克隆出来的 newObj 跟 obj 所属的类是一样的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = deepClone(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于堆栈内存和闭包"><a href="#关于堆栈内存和闭包" class="headerlink" title="关于堆栈内存和闭包"></a>关于堆栈内存和闭包</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="string">'0'</span>,</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">a[b]= <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Zhang'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="built_in">Symbol</span>(<span class="string">'1'</span>),</span><br><span class="line">    c = <span class="built_in">Symbol</span>(<span class="string">'1'</span>)</span><br><span class="line">a[b] = <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Harvey'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = &#123; <span class="attr">n</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">    c = &#123; <span class="attr">m</span>: <span class="string">'2'</span> &#125;</span><br><span class="line">a[b] = <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Zhang'</span></span><br><span class="line"><span class="comment">// 所有的引用类型存的时候都会被转换成字符串，而 object 转换成字符串的结果都是 '[object Object]'</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>堆：存储引用类型值的空间；<br>栈：存储基本类型值和执行代码的环境；浏览器加载页面就会形成栈内存，当执行函数的时候，都会形成一个新的执行上下文（Execution Context Stack），压入栈中执行</p>
          </div>

<p>闭包的作用 1：保存——保存私有变量，不被销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i *= <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">2</span>) <span class="comment">// =&gt; var test = AAAFFF111</span></span><br><span class="line">test(<span class="number">5</span>) <span class="comment">// =&gt; '4'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：地址 AAAFFF111</span><br><span class="line">│ 作为函数，存储代码（字符串）</span><br><span class="line">│ 作为对象，存储键值对（prototype、length、name ...）</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 1，不销毁，因为 i 被占着</span><br><span class="line">│ i &#x3D; 2</span><br><span class="line">│ return AAAFFF111</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">    ↑</span><br><span class="line">    | 上级作用域</span><br><span class="line">    |</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 2，执行完之后销毁</span><br><span class="line">│ alert(i *&#x3D; 2)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<p>闭包的作用 2：保护——修改自己的私有变量，不会影响外面的东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>,</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123; <span class="comment">// 全局 A = AAAFFF000</span></span><br><span class="line">  A = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    alert(a + b++)</span><br><span class="line">  &#125;</span><br><span class="line">  alert(a++)</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>) <span class="comment">// =&gt; '1', a = 2</span></span><br><span class="line">A(<span class="number">2</span>) <span class="comment">// =&gt; '4', b = 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ Global Object</span><br><span class="line">| a &#x3D; 0</span><br><span class="line">| b &#x3D; 0</span><br><span class="line">| A &#x3D; AAAFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">│ &#96;A &#x3D; function(b) &#123; alert(a + b++) &#125;; alert(a++)&#96;</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ &#96;alert(a + b++)&#96;</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(1) ECStack，因为 BBBFFF000 被全局 A 占用了，所以不销毁</span><br><span class="line">│ a &#x3D; 1</span><br><span class="line">| A &#x3D; BBBFFF000</span><br><span class="line">| alert(a++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(2) ECStack，没有被占用的，所以销毁</span><br><span class="line">│ b &#x3D; 2</span><br><span class="line">| alert(a + b++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName() <span class="comment">// 2</span></span><br><span class="line">getName() <span class="comment">// 4</span></span><br><span class="line">Foo().getName() <span class="comment">// Foo() 作为普通函数执行，改变了全局的 getName() 为 1，返回 this（为 window）</span></span><br><span class="line">getName() <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName() <span class="comment">// 前面是无参数 new（优先级18），后面是成员访问（优先级19），先执行成员访问，获取 Foo.getName()，为 2，再 new（相当于普通函数执行）</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName() <span class="comment">// 前面是有参数 new（优先级19），后面是成员访问（优先级19），先 new（创建实例），getName 是原型上的 getName，3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName() <span class="comment">// 先 new（创建实例 xxx），变为 new xxx.getName()，再算成员访问（原型上的方法），为 3，再 new</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">| 代码字符串</span><br><span class="line">| getName: fun -&gt; 2</span><br><span class="line">| prototype: BBBFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ constructor: Foo</span><br><span class="line">| getName: func -&gt; 3</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 变量提升阶段</span><br><span class="line">| Foo &#x3D; AAAFFF000，声明并定义</span><br><span class="line">│ getName &#x3D; func -&gt; 5，var 声明，之后在 function 赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 代码执行阶段</span><br><span class="line">| getName &#x3D; func -&gt; 4，在 var 处赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">await</span> async2() <span class="comment">// -&gt; 执行 async2 并等待返回结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>) <span class="comment">// 6 -&gt; 有的浏览器会先执行 then 的，而不是按入栈出栈的先后顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)  <span class="comment">// 1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>) <span class="comment">// 4</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>) <span class="comment">// 7</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>浏览器是多线程的，但 JS 是单线程的</p>
          </div>

<p>宏任务：定时器、事件绑定、AJAX<br>微任务：promise 和 async await</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQ：HTML 与 CSS</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-Others-QA-HtmlCss/</url>
    <content><![CDATA[<p>关于 HTML 和 CSS 的一些问题与答案。</p>
<a id="more"></a>

<h1 id="水平垂直居中的方案"><a href="#水平垂直居中的方案" class="headerlink" title="水平垂直居中的方案"></a>水平垂直居中的方案</h1><h2 id="定位：三种"><a href="#定位：三种" class="headerlink" title="定位：三种"></a>定位：三种</h2><ol>
<li><code>absolute</code> + <code>margin</code>：需要知道自己的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>absolute</code> + <code>margin</code>：不需要知道自己的宽高，但是得有宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>sbsolute</code> + <code>translate</code>： 不需要知道自己的宽高，不需要有具体的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a><code>flex</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-id">#box</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HTML = <span class="built_in">document</span>.documentElement,</span><br><span class="line">      winW = HTML.clientWidth,</span><br><span class="line">      winH = HTML.clientHeight,</span><br><span class="line">      boxW = box.offsetWidth, <span class="comment">// 带边框的宽，也可以用 getBoundingClientReact</span></span><br><span class="line">      boxH = box.offsetHeight <span class="comment">// 带边框的高</span></span><br><span class="line">box.style.position = <span class="string">'absolute'</span></span><br><span class="line">box.style.left = (winW - boxW) / <span class="number">2</span> + <span class="string">'px'</span></span><br><span class="line">box.style.top = (winH - boxH) / <span class="number">2</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure>

<h2 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a><code>table-cell</code></h2><p>要求父级有固定宽高，相当于给文本居中</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="左右固定、中间自适应布局"><a href="#左右固定、中间自适应布局" class="headerlink" title="左右固定、中间自适应布局"></a>左右固定、中间自适应布局</h1><h2 id="float-负-margin"><a href="#float-负-margin" class="headerlink" title="float + 负 margin"></a><code>float</code> + 负 <code>margin</code></h2><p>圣杯布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双飞翼布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>, <span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a><code>calc</code></h2><p>兼容到 IE 9，渲染会比较慢</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: calc(<span class="number">100%</span> - <span class="number">400px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a><code>flex</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移动端响应式方案"><a href="#移动端响应式方案" class="headerlink" title="移动端响应式方案"></a>移动端响应式方案</h1><h2 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h2><h2 id="PC-固定布局，移动端-rem"><a href="#PC-固定布局，移动端-rem" class="headerlink" title="PC 固定布局，移动端 rem"></a>PC 固定布局，移动端 rem</h2><h2 id="flex-2"><a href="#flex-2" class="headerlink" title="flex"></a>flex</h2><h2 id="vh-vw"><a href="#vh-vw" class="headerlink" title="vh/vw"></a>vh/vw</h2>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-React-Redux/</url>
    <content><![CDATA[<p>主要记录了 Redux 的相关东西。</p>
<p>可以看看 <a href="https://codesandbox.io/s/jovial-gates-wbs8e" target="_blank" rel="noopener">这个例子</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React Event</title>
    <url>/hais-notebook/2020/02/04/2020-02-04-React-Event/</url>
    <content><![CDATA[<p>主要记录了 React 事件的相关东西。</p>
<a id="more"></a>

<h1 id="类组件的事件"><a href="#类组件的事件" class="headerlink" title="类组件的事件"></a>类组件的事件</h1><p>可以这样写事件</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 这样写的 addN 是挂在原型上的  </span></span><br><span class="line">  addN() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.addN()&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*   这样最安全最好懂，箭头函数的 <span class="keyword">this</span> 不会变   *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能在 JSX 里面这样写：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&#123;/</span>*   这里面 addN 的 <span class="keyword">this</span> 会变成 <span class="built_in">window</span>   *<span class="regexp">/&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为在点击的时候 React 实际上运行的是 <code>button.onClick.call(null,event)</code>，<code>this</code> 被 React 改了，当然我们可以通过 <code>bind</code> 来绑定 <code>this</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.addN.bind(<span class="keyword">this</span>)&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以给箭头函数取个名字再来调用：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; ... &#125;  </span><br><span class="line">  addN() &#123; ... &#125;</span><br><span class="line">  _addN() &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.addN()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>._addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们可以将 <code>addN</code> 写在 <code>constructor</code> 里面：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这样 addN 就是挂在每个实例对象上了  </span></span><br><span class="line">    <span class="keyword">this</span>.addN = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这种写法本质与上面的一样，只是 ES 6 的语法糖：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addN = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Tools-axios/</url>
    <content><![CDATA[<p>文档翻译<br>用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端。</p>
<a id="more"></a>

<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li>从浏览器发起 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li>
<li>从 node.js 发起 <a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>JSON 数据的自动转换</li>
<li>从客户端防范 XSRF 攻击</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>

<p>使用 bower：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure>

<p>使用 yarn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add axios</span><br></pre></td></tr></table></figure>

<p>使用 cdn：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="注意：这是在-CommonJS-中的使用方法"><a href="#注意：这是在-CommonJS-中的使用方法" class="headerlink" title="注意：这是在 CommonJS 中的使用方法"></a>注意：这是在 CommonJS 中的使用方法</h2><p>为了在使用 <code>require()</code> 进行导入的 CommonJS 中获得 TypeScript 输入时的智能补充和类型提示，需要使用这样的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>).default;</span><br><span class="line"><span class="comment">// 这样 axios.&lt;method&gt; 就可以提供自动补充和参数类型了</span></span><br></pre></td></tr></table></figure>

<p>执行一个 <code>GET</code> 请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已知 ID 的情况下请求 user</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理成功的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理失败的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 永远执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以这样写：</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理成功的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理失败的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 永远执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要使用 async/await？那就在你外面的函数/方法上加上 `async` 关键字</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> aixos.get(<span class="string">'/user?ID=12345'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong><code>async/await</code> 是 ECMAScript 2017 的一部分，并且不支持 Internet Explorer 和一些更久的浏览器，所以使用的时候要注意。</p>
</blockquote>
<p>执行一个 <code>POST</code> 请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>执行多个并发请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permission'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermission()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct,perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求都完成了</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<h1 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h1><p>可以通过给 <code>axios</code> 传递相关的 config 来执行请求。</p>
<p>axios(config)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 GET 方法请求一个图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType: <span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>axios(url[, config])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求（默认方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h2><p>为了方便，所有支持的请求方法都提供了别名。</p>
<p>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config])<br>axios.options(url[, config])<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])</p>
<blockquote>
<p>注意<br>当使用别名时，不需要再在 config 中指定 <code>url</code> <code>method</code> 和 <code>data</code> 属性</p>
</blockquote>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>有一些帮助函数来处理并发请求。</p>
<p>axios.all(iterable)<br>axios.spread(callback)</p>
<h2 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h2><p>你可以使用自定义的 config 来创建一个 axios 实例。</p>
<p>axios.create([config])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下面列举了可用的实例方法，指定的 config 会与实例的 config 合并。</p>
<p>axios#request(config)<br>axios#get(url[, config])<br>axios#delete(url[, config])<br>axios#head(url[, config])<br>axios#options(url[, config])<br>axios#post(url[, data[, config]])<br>axios#put(url[, data[, config]])<br>axios#patch(url[, data[, config]])<br>axios#getUri([config])</p>
<h1 id="请求的-config"><a href="#请求的-config" class="headerlink" title="请求的 config"></a>请求的 config</h1><p>在众多的 config 选项中，只有 <code>url</code> 是必须的。如果没有指定 <code>method</code>，则默认为 <code>GET</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url` 是被用于请求的服务器的 URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是发起请求时用的方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `baseURL` 将在 `url` 不是绝对路径的时候放在 `url` 的前面</span></span><br><span class="line">  <span class="comment">// 给 axios 实例设置一个 `baseURL` 就可以很方便地给实例的方法传递相对路径</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在请求发送给服务器之前变换数据</span></span><br><span class="line">  <span class="comment">// 这只适用于 'PUT' 'POST' 'PATCH' 和 'DELETE' 方法</span></span><br><span class="line">  <span class="comment">// 数组中最后的函数必须返回一个字符串</span></span><br><span class="line">  <span class="comment">// 或者 Buffer、ArrayBuffer、FormData 或 Stream 的实例</span></span><br><span class="line">  <span class="comment">// 你可以修改 headers 对象</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些什么来修改数据</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 允许对响应数据在传递给 then/catch 之前进行变换</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些什么来修改数据</span></span><br><span class="line">    <span class="keyword">return</span> data    </span><br><span class="line">  &#125;],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `headers` 是自定义的请求头</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `params` 是请求时的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须要是一个纯粹的对象或者 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个可选的函数，用来控制序列化的 `params`</span></span><br><span class="line">  <span class="comment">// （比如 https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/）</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是被当做请求体发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于 'PUT' 'POST' 和 'PATCH' 方法</span></span><br><span class="line">  <span class="comment">// 当没有设置 `transformRequest` 时，必须是以下几种类型之一：</span></span><br><span class="line">  <span class="comment">// - 字符串、纯粹的对象、ArrayBuffer、ArrayBufferView、URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 只有浏览器可用：FormData、文件、Blob</span></span><br><span class="line">  <span class="comment">// - 只有 Node 可用： Stream、Buffer</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送请求数据的另一种写法</span></span><br><span class="line">  <span class="comment">// post 方法</span></span><br><span class="line">  <span class="comment">// 只有 value 被发送，key 不会</span></span><br><span class="line">  data: <span class="string">'Country=Brasil&amp;City=Belo Horizonte'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定了请求超时的毫秒数</span></span><br><span class="line">  <span class="comment">// 如果请求超过了 `timeout`，则请求将会被放弃</span></span><br><span class="line">  timeout: <span class="number">1000</span>, <span class="comment">// 默认为 `0` （没有时限）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `withCredentials` 指定了访问跨站点的 Access-Control 请求</span></span><br><span class="line">  <span class="comment">// 是否使用证书</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `adapter` 允许自定义让测试变简单的请求控制器</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并且提供一个合法的响应</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 说明需要使用 HTTP 基本身份验证，并且提供合法的证书</span></span><br><span class="line">  <span class="comment">// 他将会 设置一个 `Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 并且会覆盖在 `headers` 中自定义的 `Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 请注意这里只能设置 HTTP 基本身份验证</span></span><br><span class="line">  <span class="comment">// 对于不记名令牌等，需要使用自定义的 `Authorization` 请求头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `responseType` 指定了服务器返回的数据类型</span></span><br><span class="line">  <span class="comment">// 包括 'arraybuffer' 'document' 'json' 'text' 'stream'</span></span><br><span class="line">  <span class="comment">// 只有浏览器可用：'blob'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 指定了解码响应数据的编码方式</span></span><br><span class="line">  <span class="comment">// 注意：在 'stream' 或客户端请求的 `responseType` 被忽略</span></span><br><span class="line">  responseEncoding: <span class="string">'utf-8'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用来做为 xsrf 令牌值的 cookie 的名字</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是保存 xsrf 令牌值的 HTTP 头的名字</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许控制上传的事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生事件做些什么</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许控制下载的事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生事件做些什么</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了以字节计量的 HTTP 响应允许的最大容量</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义根据 HTTP 响应的状态码</span></span><br><span class="line">  <span class="comment">// 是 resolve 还是 reject 这个 promise</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true`（或设为 `null` 或 `undefined`），</span></span><br><span class="line">  <span class="comment">// 将会 resolve 这个 promise</span></span><br><span class="line">  <span class="comment">// 反之则 reject 这个 promise</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在 node.js 中最大的重定向数</span></span><br><span class="line">  <span class="comment">// 如果设为 0，则不允许重定向</span></span><br><span class="line">  maxRedirect: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `socketPath` 定义了在 node.js 中使用的 UNIX Socket</span></span><br><span class="line">  <span class="comment">// 比如 '/var/run/docker.sock' 来发送请求到 docker daemon</span></span><br><span class="line">  <span class="comment">// `socketPath` 与 `proxy` 中只有一个生效</span></span><br><span class="line">  <span class="comment">// 如果都被设置了，则使用 `socketPath`</span></span><br><span class="line">  socketPath: <span class="literal">null</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别定义了一个执行 http 和 https 请求时</span></span><br><span class="line">  <span class="comment">// 在 node.js 中的代理</span></span><br><span class="line">  <span class="comment">// 这允许诸如 `keepAlive` 之类的默认情况下不允许的选项</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy' 定义了代理服务器的主机名和端口</span></span><br><span class="line">  <span class="comment">// 你也可以用常规的 `http_proxy` `https_proxy` 环境变量定义你的代理</span></span><br><span class="line">  <span class="comment">// 如果你正在使用环境变量来配置代理，你也可以定义 `no_proxy` 环境变量</span></span><br><span class="line">  <span class="comment">// 这是一个用逗号分隔的不应该被代理的主机列表</span></span><br><span class="line">  <span class="comment">// 用 `false` 来禁用代理，忽略环境变量</span></span><br><span class="line">  <span class="comment">// `auth` 表示在连接这个代理的时候应该使用 HTTP 基本身份验证，并提供证书</span></span><br><span class="line">  <span class="comment">// 这将会设置 `Proxy-Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 并且覆盖已经存在的在 `headers` 中自定义的 `Proxy-Authorization`</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定了一个可以被用来取消请求的取消令牌</span></span><br><span class="line">  <span class="comment">// （查看下面的取消部分来获取更多信息）</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="响应模式"><a href="#响应模式" class="headerlink" title="响应模式"></a>响应模式</h1><p>请求的响应包含了以下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 是服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `status` 是服务器返回的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 是服务器返回的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `headers` 是服务器返回的响应头</span></span><br><span class="line">  <span class="comment">// 所有的返回头都是小写</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是提供给 `axios` 做请求的 config</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `request` 是产生这个响应的请求</span></span><br><span class="line">  <span class="comment">// 这是 node.js 中（在重定向中）的最后一个 ClientRequest 实例</span></span><br><span class="line">  <span class="comment">// 和浏览器中的 XMLHttpRequest 实例</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>then</code> 的时候，你会收到这样的响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.header);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>当使用 <code>catch</code> ，或者传递一个 rejection 回调作为 <code>then</code> 的第二个参数的时候，响应将在 <code>error</code> 对象中可用，就像在处理错误章节中说的一样。</p>
<h1 id="配置的默认值"><a href="#配置的默认值" class="headerlink" title="配置的默认值"></a>配置的默认值</h1><p>你可以指定一个默认配置应用于所有的请求。</p>
<h2 id="全局-axios-默认配置"><a href="#全局-axios-默认配置" class="headerlink" title="全局 axios 默认配置"></a>全局 axios 默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.helpers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="自定义实例默认配置"><a href="#自定义实例默认配置" class="headerlink" title="自定义实例默认配置"></a>自定义实例默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建实例的时候设置默认配置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在创建实例之后改变默认配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>

<h2 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h2><p>配置会根据优先顺序自动合并。首先是在 lib/defaults.js 里面的库默认配置，然后是实例中的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者的优先级比前者高。这里是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用库中提供的默认配置来创建一个实例</span></span><br><span class="line"><span class="comment">// 就这个例子来说，timeout 配置是 `0`，因为是库的默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖库中默认的 timeout 值</span></span><br><span class="line"><span class="comment">// 现在这个实例的所有请求会在超时之前等待 2.5 秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖这个请求的 timeout 值，因为我们知道他会花更长的时间</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>你可以在请求或者响应被 <code>then</code> 或 <code>catch</code> 处理之前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在请求发出之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在请求失败的时候做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有状态码在 2xx 范围的都会触发</span></span><br><span class="line">  <span class="comment">// 对返回的数据做些什么</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有状态码不在 2xx 范围的都会触发</span></span><br><span class="line">  <span class="comment">// 对返回的错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你需要移除一个拦截器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.interseptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interseptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>

<p>你可以给一个 axios 实例增加拦截器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response) &#123;</span><br><span class="line">      <span class="comment">// 发出请求后收到一个状态码不在 2xx 范围的回复</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// 请求发出了但是没有收到回复</span></span><br><span class="line">      <span class="comment">// `error.request` 是浏览器中 XMLHttpRequest 的实例</span></span><br><span class="line">      <span class="comment">// 也是一个 node.js 中 http.ClientRequest 的实例</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在引发错误的请求的安装过程中发生了些状况</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>validateStatus</code> 配置选项，可以配置应该抛出错误的 HTTP 状态码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">// 只 reject 状态码大于等于 500 的响应</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>toJSON</code> 可以获得关于 HTTP 错误的更多信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.toJSON());</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h1><p>你可以使用取消令牌来取消请求。</p>
<blockquote>
<p>axios 取消令牌 API 基于被弃用的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">cancelable promises proposal</a></p>
</blockquote>
<p>你可以用 <code>CancelToken.source</code> 工厂函数创建一个取消令牌：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken();</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by user.'</span>);</span><br></pre></td></tr></table></figure>

<p>你也可以通过传递一个执行函数给 <code>CancelToken</code> 构造器来创建一个取消令牌：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个执行函数接受取消函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：你可以用同一个取消令牌取消多个请求。</p>
</blockquote>
<h1 id="使用-application-x-www-form-urlencoded-表格"><a href="#使用-application-x-www-form-urlencoded-表格" class="headerlink" title="使用 application/x-www-form-urlencoded 表格"></a>使用 application/x-www-form-urlencoded 表格</h1><p>默认情况下，axios 会将 JavaScript 对象序列化为 <code>JSON</code>。如果需要以 <code>application/x-www-form-urlencoded</code> 的格式来发送数据，你可以下面的选项之一：</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>在浏览器中，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener"><code>URLSearchParams</code></a> API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意并不是所有的浏览器都支持 <code>URLSearchParams</code>，但是这里有一个可用的 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener">polyfill</a>（务必确认 polyfill 全局环境）</p>
</blockquote>
<p>你也可以用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库进行编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>或者用别的方法（ES 6）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123; <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>

<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>在 node.js 中，你可以使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener"><code>querystring</code></a> 模组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库。</p>
<blockquote>
<p>注意<br>如果你需要序列化嵌套对象，使用 <code>qs</code> 库是更合适的，因为 <code>querystring</code> 方法有些已知的问题（<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener">https://github.com/nodejs/node-v0.x-archive/issues/1665</a>）</p>
</blockquote>
<h1 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h1><p>axios <code>1.0</code> 版本之后，新的 minor 版本会发布一些重大的变化。比如 <code>0.5.1</code> 和 <code>0.5.4</code> 有着同样的 API，但是 <code>0.6.0</code> 版本会有一些重要的改变。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>axios 依赖于原生 ES6 的 Promise。如果你的环境不支持 ES6 Promises，你可以 <a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">polyfill</a>。</p>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>axios 包括一些 <a href="http://typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 Tips</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Others-Tips/</url>
    <content><![CDATA[<p>收集一些 Tips。</p>
<a id="more"></a>

<h1 id="滚动条的宽度"><a href="#滚动条的宽度" class="headerlink" title="滚动条的宽度"></a>滚动条的宽度</h1><p>滚动条的宽度在 14 ~ 19px 之间，根据操作系统不同</p>
<h1 id="jQuery-制作-Tab"><a href="#jQuery-制作-Tab" class="headerlink" title="jQuery 制作 Tab"></a>jQuery 制作 Tab</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$tabBar.on(<span class="string">'click'</span>, <span class="string">'li'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> $li = $(e.currentTarget)</span><br><span class="line">  $li</span><br><span class="line">    .addClass(<span class="string">'selected'</span>)</span><br><span class="line">    .siblings()</span><br><span class="line">    .removeClass(<span class="string">'selected'</span>)</span><br><span class="line">  <span class="keyword">const</span> index = $li.index()</span><br><span class="line">  $tabContent</span><br><span class="line">    .children()</span><br><span class="line">    .eq(index)</span><br><span class="line">    .addClass(<span class="string">'active'</span>) <span class="comment">// 一定不要用.css 和.show，样式和行为分离</span></span><br><span class="line">    .siblings()</span><br><span class="line">    .removeClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$tabBar.children().eq(<span class="number">0</span>).trigger(<span class="string">'click'</span>)  <span class="comment">// 默认触发第一个</span></span><br></pre></td></tr></table></figure>

<h1 id="jQuery-如果有-class-就删掉，没有就加上"><a href="#jQuery-如果有-class-就删掉，没有就加上" class="headerlink" title="jQuery 如果有 class 就删掉，没有就加上"></a>jQuery 如果有 class 就删掉，没有就加上</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$square.on(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  $square.toggleClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="JS-的代码不能以括号开头"><a href="#JS-的代码不能以括号开头" class="headerlink" title="JS 的代码不能以括号开头"></a>JS 的代码不能以括号开头</h1><h1 id="方法-和-函数"><a href="#方法-和-函数" class="headerlink" title="*方法 和 函数"></a><strong>*方法</strong> 和 <strong>函数</strong></h1><ul>
<li>方法是面向对象概念，一定是依附于一个对象的</li>
<li>函数是数学概念</li>
<li>都是指的 function</li>
</ul>
<h1 id="常用的画草图的软件"><a href="#常用的画草图的软件" class="headerlink" title="常用的画草图的软件"></a>常用的画草图的软件</h1><ul>
<li>balsamiq</li>
<li>figma</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line">  .then( <span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'success1'</span>)&#125;, ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'error1'</span>)&#125; )</span><br><span class="line">  .then( <span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'success2'</span>)&#125;, ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'error2'</span>)&#125; )</span><br><span class="line"><span class="comment">// error1 -&gt; success2</span></span><br></pre></td></tr></table></figure>

<h1 id="新建一个项目要考虑哪些东西？"><a href="#新建一个项目要考虑哪些东西？" class="headerlink" title="新建一个项目要考虑哪些东西？"></a>新建一个项目要考虑哪些东西？</h1><ul>
<li>创建仓库</li>
<li>声明 LICENCE<br><img src="https://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png" alt=""></li>
<li>要用什么第三方的东西？ npm</li>
<li>在 webstorm 里面搜 VCS</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>BDD（Behavior-Driven Development）：行为驱动开发，用自然语言描述需求</li>
<li>TDD（Test-Driven Development）：测试驱动开发，目的是为了让测试通过</li>
<li>Assert：断言</li>
</ul>
<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><ul>
<li>持续测试</li>
<li>持续交付</li>
<li>持续部署</li>
</ul>
<h1 id="nodejs-Client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-MySQL-client"><a href="#nodejs-Client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-MySQL-client" class="headerlink" title="nodejs Client does not support authentication protocol requested by server; consider upgrading MySQL client"></a>nodejs Client does not support authentication protocol requested by server; consider upgrading MySQL client</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ul>
<li>web server 常用的缓存数据库，数据放在内存中</li>
<li>相比于 mysql，访问速度快；但是成本更高，数据量更小</li>
<li>解决：将 web server 和 redis 拆分成两个服务，不会占用 web server 的内存，可以跨进程访问</li>
<li>为何用 redis 来存 session？session 访问频繁，对性能要求高；不用考虑断电数据丢失的问题；session 数据量不会太大</li>
</ul>
<h1 id="Vue-的渲染过程"><a href="#Vue-的渲染过程" class="headerlink" title="Vue 的渲染过程"></a>Vue 的渲染过程</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的同步渲染过程</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">div.appendChild(child) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 1</span></span><br><span class="line">body.appendChild(div) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 2</span></span><br><span class="line"><span class="built_in">console</span>.log(div.outerHTML)</span><br></pre></td></tr></table></figure>

<h1 id="不能让-A-—更新—-gt-B-的同时-B-—更新—-gt-A"><a href="#不能让-A-—更新—-gt-B-的同时-B-—更新—-gt-A" class="headerlink" title="不能让  A —更新—&gt; B 的同时 B —更新—&gt; A"></a>不能让  A —更新—&gt; B 的同时 B —更新—&gt; A</h1><h1 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h1><ol>
<li>没有需求不要写代码，没有设计稿不要写代码</li>
<li>单元测试是重构的前提</li>
<li>设计模式<ol>
<li>发布订阅模式</li>
<li>单向数据流</li>
<li>正交（props）</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>踩坑</tag>
        <tag>收集</tag>
        <tag>Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>React Props &amp; State</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-React-PropsState/</url>
    <content><![CDATA[<p>主要记录了 React 的 Props 和 State。</p>
<a id="more"></a>

<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><p>可以查看<a href="https://codesandbox.io/s/billowing-wind-d8kzw" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>可以查看<a href="https://codesandbox.io/s/silly-diffie-9yk38" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h2 id="setState-的注意事项"><a href="#setState-的注意事项" class="headerlink" title="setState 的注意事项"></a>setState 的注意事项</h2><ul>
<li><code>this.state.n += 1</code> 无效，UI 不会自动更新，需要用 <code>setState</code></li>
<li><code>setState</code> 不会马上改变 <code>state</code>，是异步更新的，推荐使用 <code>setState(函数)</code></li>
<li>不推荐 <code>this.setState(this.state)</code>，因为 React 不推荐我们修改旧的 <code>state</code>（不可变数据）</li>
</ul>
<h2 id="复杂-state"><a href="#复杂-state" class="headerlink" title="复杂 state"></a>复杂 state</h2><ul>
<li>类组件的 <code>setState</code> 会自动合并第一层，建议使用 <code>Object.assign</code> 或者 <code>...sate</code></li>
<li>函数组件不会自动合并，建议分开写</li>
</ul>
<h2 id="Vue-和-React-的区别"><a href="#Vue-和-React-的区别" class="headerlink" title="Vue 和 React 的区别"></a>Vue 和 React 的区别</h2><p>共同点：</p>
<ul>
<li>都是对视图的封装，React 是用类和函数表示一个组件，Vue 是用构造选项表示一个组件</li>
<li>都提供了 <code>creatElement</code> 的 XML 简写，React 是 JSX，Vue 是 template</li>
</ul>
<p>Vue：</p>
<ul>
<li>一个对象，对应一个虚拟 DOM，当对象的属性改变时，把属性相关的 DOM 节点全部更新</li>
<li>JS in HTML</li>
</ul>
<p>React：</p>
<ul>
<li>一个对象，对应一个虚拟 DOM，另一个对象对应另一个虚拟 DOM，对比两个更新，用 DOM Diff 算法找不同，然后局部更新 DOM</li>
<li>HTML in JS</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React Component</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-React-Component/</url>
    <content><![CDATA[<p>主要记录了 React 的组件的用法。</p>
<a id="more"></a>

<h1 id="元素（Element）与组件（Component）"><a href="#元素（Element）与组件（Component）" class="headerlink" title="元素（Element）与组件（Component）"></a>元素（Element）与组件（Component）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = React.createElement(<span class="string">'div'</span>,...) <span class="comment">// React 元素</span></span><br><span class="line"><span class="keyword">const</span> Div = <span class="function"><span class="params">()</span> =&gt;</span> React.createElement(<span class="string">'div'</span>,...) <span class="comment">// React 组件</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>目前而言，<br>React 中，一个返回 React 元素的<strong>函数</strong>就是组件<br>Vue 中，一个 <strong>构造选项</strong> 就可以表示一个组件</p>
          </div>

<h1 id="两种组件"><a href="#两种组件" class="headerlink" title="两种组件"></a>两种组件</h1><ul>
<li>函数组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">// 会自动变成 React.createElement(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的使用方法都是：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;Welcome name=<span class="string">"frank"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>可以看看 <a href="https://codesandbox.io/s/tender-nightingale-eu1ne" target="_blank" rel="noopener">这个例子</a></p>
<h1 id="React-中的标签会被翻译成什么？"><a href="#React-中的标签会被翻译成什么？" class="headerlink" title="React 中的标签会被翻译成什么？"></a>React 中的标签会被翻译成什么？</h1><p><code>&lt;div/&gt;</code> 会被翻译成 <code>React.createElement(&#39;div&#39;)</code></p>
<p><code>&lt;Welcome/&gt;</code> 会被翻译成 <code>React.createElement(Welcome)</code></p>
<h1 id="React-creatElement"><a href="#React-creatElement" class="headerlink" title="React.creatElement"></a><code>React.creatElement</code></h1><ul>
<li>如果传入一个字符串 <code>&#39;div&#39;</code> ，则会创建一个 <code>div</code></li>
<li>如果传入一个函数，则会调用该函数，获取其返回值</li>
<li>如果传入一个类，则会在前面加类前面加 <code>new</code> （执行 constructor），获取一个组件的对象，然后调用对象的 render 方法，获取其返回值</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React JSX</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-React-JSX/</url>
    <content><![CDATA[<p>JSX 介绍。</p>
<a id="more"></a>

<h1 id="引入-babel-loader"><a href="#引入-babel-loader" class="headerlink" title="引入 babel-loader"></a>引入 babel-loader</h1><h2 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h2><p>每次需要写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>使用 babel-loader</p>
<h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><h2 id="嵌入表达式"><a href="#嵌入表达式" class="headerlink" title="嵌入表达式"></a>嵌入表达式</h2><p>可以在大括号中使用任何合法的 JavaScript 表达式。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'Josh Perez'</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>使用小括号将多行的 JSX 包裹起来，避免 JS 自动加分号的缺陷</p>
          </div>

<h2 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h2><p>可以返回在 <code>if</code> 语句和 <code>for</code> 循环中使用，可以传参给变量，可以作为参数接收，可以作为返回值</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定属性"><a href="#指定属性" class="headerlink" title="指定属性"></a>指定属性</h2><p>注意如果要使用大括号包裹 JS 表达式，别在大括号外面写引号</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>注意 <code>class</code> 变成了 <code>className</code>、<code>tabindex</code> 变成了 <code>tabIndex</code> 等</p>
          </div>

<h2 id="指定子元素"><a href="#指定子元素" class="headerlink" title="指定子元素"></a>指定子元素</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="JSX-阻止-XSS"><a href="#JSX-阻止-XSS" class="headerlink" title="JSX 阻止 XSS"></a>JSX 阻止 XSS</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="JSX-代表了什么"><a href="#JSX-代表了什么" class="headerlink" title="JSX 代表了什么"></a>JSX 代表了什么</h2><p>下面两个表达方式是一样的：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React 开始</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-React-Start/</url>
    <content><![CDATA[<p>React 笔记的开始，主要记录了 React 的安装。</p>
<a id="more"></a>

<h1 id="引入-React"><a href="#引入-React" class="headerlink" title="引入 React"></a>引入 React</h1><h2 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/16.10.2/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>cjs 和 umd 的区别？</p>
<ul>
<li>cjs 全称是 CommonJS，是 Node.js 支持的模块规范</li>
<li>umd 是统一模块定义，兼容各种模块规范（包含浏览器）</li>
<li>理论上优先使用 umd，同时支持 Node.js 和浏览器</li>
<li>最新的模块规范是使用 <code>import</code> 和 <code>export</code> 关键字</li>
</ul>
<h2 id="通过-webpack-引入"><a href="#通过-webpack-引入" class="headerlink" title="通过 webpack 引入"></a>通过 webpack 引入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-create-react-app"><a href="#使用-create-react-app" class="headerlink" title="使用 create-react-app"></a>使用 create-react-app</h2><h1 id="函数与普通代码的区别"><a href="#函数与普通代码的区别" class="headerlink" title="函数与普通代码的区别"></a>函数与普通代码的区别</h1><p>看 <a href="https://codesandbox.io/s/spring-waterfall-iyekc" target="_blank" rel="noopener">这个例子</a></p>
<ul>
<li>普通代码<strong>立即求值</strong>，读取当前值</li>
<li>函数会等调用的时候再求值（<strong>延迟求值</strong>），求值时才会读取 a 的最新值</li>
</ul>
<h1 id="对比-React-元素和函数组件的区别"><a href="#对比-React-元素和函数组件的区别" class="headerlink" title="对比 React 元素和函数组件的区别"></a>对比 React <strong>元素</strong>和<strong>函数组件</strong>的区别</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App1 = React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, n) <span class="comment">// App1 是一个 React 元素</span></span><br><span class="line"><span class="keyword">const</span> App2 = <span class="function"><span class="params">()</span> =&gt;</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, n) <span class="comment">// App2 是一个 React 函数组件</span></span><br><span class="line"><span class="comment">// App2 是延迟执行的代码，会在被调用的时候执行（会获取到 n 的最新值）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>React 元素<ul>
<li><code>createElement</code> 的返回值 <code>element</code> 可以代表一个 <code>div</code></li>
<li>但是 <code>element</code> 不是真正的 DOM 对象，而是一个 <strong>虚拟 DOM</strong> 对象</li>
</ul>
</li>
<li>() ⇒ React 元素<ul>
<li>返回 <code>element</code> 的函数，也可以代表一个 <code>div</code></li>
<li>函数可以多次执行，每次获取到最新的虚拟 <code>div</code></li>
<li>React 会对比两个虚拟 <code>div</code> ，找出不同，局部更新视图</li>
<li>找不同的算法叫做 <strong>DOM Diff 算法</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Tools-webpack/</url>
    <content><![CDATA[<p>webpack 的基础使用及问题。</p>
<a id="more"></a>

<div class="note warning">
            <p>webpack 安装的所有东西都是 –dev</p>
          </div>

<h1 id="Loader-与-Plugin"><a href="#Loader-与-Plugin" class="headerlink" title="Loader 与 Plugin"></a>Loader 与 Plugin</h1><ul>
<li>翻译</li>
<li>解释：加载文件；拓展功能</li>
<li>加载一个个 JS 文件，把 JS 文件转换成低版本浏览器可以支持的（JS Loader）；加载 CSS 文件，把 CSS 变成标签，或者进行其他处理 （CSS Loader、Style Loader）；加载图片，对图片进行优化；</li>
<li>HTML Webpack Plugin 生成 HTML 文件</li>
<li>Mini CSS Extract Plugin 抽取 CSS 文件</li>
</ul>
<h1 id="加载-JavaScript-文件"><a href="#加载-JavaScript-文件" class="headerlink" title="加载 JavaScript 文件"></a>加载 JavaScript 文件</h1><p>可以这样来调用本地安装的 webpack：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/webpack —version </span><br><span class="line"><span class="comment"># 或者用 npx，但 npx 不够稳定，比如如果 node 装到了有空格的目录，可能就有问题</span></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure>

<p>webpack 自带了 JS Loader，我们需要自定义一下 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 默认为 './src/index.js'</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>HTTP Cache</strong><br>Response Header: Cache-Control</p>
</blockquote>
<p>可以设置 <code>package.json</code> 中的 <code>script</code>，让他每次自动删除之前的 <code>dist</code> 目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "rm -rf dist &amp;&amp; webpack"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后只要每次用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<h1 id="生成-HTML-文件"><a href="#生成-HTML-文件" class="headerlink" title="生成 HTML 文件"></a>生成 HTML 文件</h1><p>可以使用 <a href="https://webpack.js.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener">html-webpack-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>使用 html-webpack-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebPackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'my title'</span>,</span><br><span class="line">      template: <span class="string">'src/assets/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在 template 文件里面的 title 需要这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="加载-CSS-文件"><a href="#加载-CSS-文件" class="headerlink" title="加载 CSS 文件"></a>加载 CSS 文件</h1><p>可以使用 <a href="https://webpack.js.org/loaders/css-loader/" target="_blank" rel="noopener">css-loader</a> 和 <a href="https://webpack.js.org/loaders/style-loader/" target="_blank" rel="noopener">style-loader</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure>

<p>使用 css-loader 和 style-loader 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>CSSLoader 会把 .css 后缀的文件读到 JS 里面<br>StyleLoader 会把 style 标签放到 HTML 的 head 里面</p>
          </div>

<h1 id="预览与调试网页"><a href="#预览与调试网页" class="headerlink" title="预览与调试网页"></a>预览与调试网页</h1><p>可以使用 <a href="https://webpack.js.org/guides/development/" target="_blank" rel="noopener">webpack-dev-server</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>使用 webpack-dev-server 同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./dist'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再在 <code>package.json</code> 里面加入 <code>script</code> 方便使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "webpack-dev-server --open",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h1><p>可以使用 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<p>使用 mini-css-extract-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// all options are optional</span></span><br><span class="line">      filename: devMode ? <span class="string">'[name].css'</span> : <span class="string">'[name].[hash].css'</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">'[id].css'</span> : <span class="string">'[id].[hash].css'</span>,</span><br><span class="line">      ignoreOrder: <span class="literal">false</span>, <span class="comment">// Enable to remove warnings about conflicting order</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// you can specify a publicPath here</span></span><br><span class="line">              <span class="comment">// by default it uses publicPath in webpackOptions.output</span></span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">              hmr: process.env.NODE_ENV === <span class="string">'development'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="加载-Sass"><a href="#加载-Sass" class="headerlink" title="加载 Sass"></a>加载 Sass</h1><div class="note warning">
            <p>node sass 已经过时，应该使用 dart sass</p>
          </div>

<p>可以使用 <a href="https://webpack.js.org/loaders/sass-loader/" target="_blank" rel="noopener">sass-loader</a></p>
<p>同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options:&#123;<span class="attr">implementation</span>: <span class="built_in">require</span>(<span class="string">'dart-sass'</span>)&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h1 id="加载-Less"><a href="#加载-Less" class="headerlink" title="加载 Less"></a>加载 Less</h1><p>可以使用 <a href="https://webpack.js.org/loaders/less-loader/" target="_blank" rel="noopener">less-loader</a></p>
<h1 id="加载-Stylus"><a href="#加载-Stylus" class="headerlink" title="加载 Stylus"></a>加载 Stylus</h1><p>可以使用 <a href="https://github.com/shama/stylus-loader" target="_blank" rel="noopener">stylus-loader</a></p>
<h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>可以使用 file-loader，把文件变成文件路径</p>
<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>等到真正需要的时候再加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">import</span>(<span class="string">'./lazy.js'</span>)</span><br><span class="line"><span class="comment">// 将会得到一个 Promise 对象</span></span><br><span class="line">promise.then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">module</span>.default() <span class="comment">// 将会执行 export default 导出的函数</span></span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="在-GitHub-Pages-上部署"><a href="#在-GitHub-Pages-上部署" class="headerlink" title="在 GitHub Pages 上部署"></a>在 GitHub Pages 上部署</h1><p>第一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch gh-pages</span><br><span class="line">git checkout gh-pages</span><br><span class="line"><span class="comment"># 删除别的，只留下 dist、node_modules 和 .gitignore</span></span><br><span class="line">mv dist/* ./</span><br><span class="line">rm -rf dist</span><br></pre></td></tr></table></figure>

<p>以后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build: &amp;&amp;</span><br><span class="line">git checkout gh-pages &amp;&amp;</span><br><span class="line">rm -rf *.html *.js *.css *.png &amp;&amp;</span><br><span class="line">mv ./dist/* ./ &amp;&amp;</span><br><span class="line">rm -rf dist</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m <span class="string">'update'</span> &amp;&amp;</span><br><span class="line">git push &amp;&amp;</span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>踩坑</tag>
        <tag>收集</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>npm &amp; yarn</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Tools-npm/</url>
    <content><![CDATA[<p>收集 npm 的包和问题。</p>
<a id="more"></a>

<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br><span class="line">nrm use taobao</span><br><span class="line"><span class="comment"># 所有的全局安装都在 C:\Users\Zhang\AppData\Roaming\npm\</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn global add yrm</span><br><span class="line">yrm use taobao</span><br></pre></td></tr></table></figure>

<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>踩坑</tag>
        <tag>收集</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>一些话题</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Others-Topics/</url>
    <content><![CDATA[<p>收集大佬的推荐。</p>
<a id="more"></a>

<h1 id="一些需要掌握的技术栈"><a href="#一些需要掌握的技术栈" class="headerlink" title="一些需要掌握的技术栈"></a>一些需要掌握的技术栈</h1><h2 id="最重要的"><a href="#最重要的" class="headerlink" title="最重要的"></a>最重要的</h2><ul>
<li>React Hooks</li>
<li>ES6</li>
<li>TypeScript</li>
<li>Flutter</li>
</ul>
<h2 id="值得一学的"><a href="#值得一学的" class="headerlink" title="值得一学的"></a>值得一学的</h2><ul>
<li>Graph QL</li>
<li>PWA</li>
<li>WebAssembly</li>
<li>WebGL 3D</li>
<li>《计算的本质》</li>
</ul>
<h2 id="需要了解的"><a href="#需要了解的" class="headerlink" title="需要了解的"></a>需要了解的</h2><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><ul>
<li>语义化标签</li>
<li>音视频处理</li>
<li>canvas / webGL</li>
<li>history API</li>
<li>requestAnimationFrame</li>
<li>地理位置</li>
<li>web socket</li>
</ul>
<h3 id="CSS-3"><a href="#CSS-3" class="headerlink" title="CSS 3"></a>CSS 3</h3><ul>
<li>常规</li>
<li>动画</li>
<li>盒子模型</li>
<li>响应式布局</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>ES 3/5/6/7/8/9</li>
<li>DOM</li>
<li>BOM</li>
<li>设计模式</li>
<li>底层原理<ul>
<li>堆栈内存</li>
<li>闭包作用域 AO/VO/GO/EC/ESTACK</li>
<li>面向对象 OOP</li>
<li>This</li>
<li>EventLoop</li>
<li>浏览器渲染原理</li>
<li>回流重绘</li>
</ul>
</li>
</ul>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><ul>
<li>AJAX / Fetch / axios</li>
<li>HTTP 1.0/2.0</li>
<li>TCP</li>
<li>跨域处理方案</li>
<li>性能优化</li>
</ul>
<h3 id="Hybrid-APP-小程序"><a href="#Hybrid-APP-小程序" class="headerlink" title="Hybrid / APP / 小程序"></a>Hybrid / APP / 小程序</h3><ul>
<li>Hybrid</li>
<li>uni-app</li>
<li>RN</li>
<li>Flutter</li>
<li>MPVUE</li>
<li>Weex</li>
<li>PWA</li>
</ul>
<h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ul>
<li>webpack</li>
<li>git</li>
<li>linux / nginx</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-Tools-VSCode/</url>
    <content><![CDATA[<p>收集关于 VSCode 的用法及插件。</p>
<a id="more"></a>

<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>Vue<ul>
<li>Vetur</li>
<li>Vue VSCode Snippets</li>
</ul>
</li>
<li>TypeScript<ul>
<li>TypeScript Importer</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 标签</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-HTML-Elements/</url>
    <content><![CDATA[<p>一些常见和重点的 HTML 标签。</p>
<a id="more"></a>

<h1 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h1><ul>
<li>表示书/文章的层级<ul>
<li>标题 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code></li>
<li>章节 <code>&lt;section&gt;</code></li>
<li>文章 <code>&lt;article&gt;</code></li>
<li>段落 <code>&lt;p&gt;</code></li>
<li>头部 <code>&lt;header&gt;</code></li>
<li>脚部 <code>&lt;footer&gt;</code></li>
<li>主要内容 <code>&lt;main&gt;</code></li>
<li>旁支内容 <code>&lt;aside&gt;</code></li>
<li>划分 <code>&lt;div&gt;</code></li>
</ul>
</li>
<li>内容标签<ul>
<li>有序列表 <code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code></li>
<li>无序列表 <code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code></li>
<li>描述 <code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code> + <code>&lt;dd&gt;</code>，其中 <code>&lt;dt&gt;</code> 表示描述词，<code>&lt;dd&gt;</code> 表示描述的内容（ <code>Emmet</code> 速写: <code>dl+</code>）</li>
<li>保留空格的段落 <code>&lt;pre&gt;</code></li>
<li>分割线 <code>&lt;hr&gt;</code></li>
<li>换行 <code>&lt;br&gt;</code></li>
<li>定位符、超链接 <code>&lt;a&gt;</code></li>
<li>语气的强调 <code>&lt;em&gt;</code></li>
<li>本质的强调 <code>&lt;strong&gt;</code></li>
<li>代码 <code>&lt;code&gt;</code>，默认是内联元素，可以用 <code>&lt;pre&gt;</code> 包住 <code>&lt;code&gt;</code></li>
<li>引用 <code>&lt;quote&gt;</code></li>
<li>块级引用 <code>&lt;blockquote&gt;</code></li>
</ul>
</li>
<li>全局属性<ul>
<li><code>class</code> 类</li>
<li><code>contenteditable</code> 用户可以直接编辑页面上的东西</li>
<li><code>hidden</code> 隐藏</li>
<li><code>id</code> 标记</li>
<li><code>style</code> 样式</li>
<li><code>tabindex</code> 控制 <code>Tab键</code> 激活元素的顺序，<code>tabindex=0</code> 是最后一个，<code>tabindex=-1</code> 代表永远不会访问</li>
<li><code>title</code> 鼠标悬浮显示的内容</li>
</ul>
</li>
</ul>
<div class="note warning">
            <p><strong>为什么会有默认样式？</strong><br>因为 HTML 被发明的时候，还没有CSS<br><strong>怎么看默认样式？</strong><br>开发者工具 -&gt; Elments -&gt; Styles -&gt; user agent stylesheet<br><strong>CSS Reset?</strong><br><a href="https://dev.to/hankchizljaw/a-modern-css-reset-6p3" target="_blank" rel="noopener">Andy Bell</a><br><a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">Meyerweb</a><br><a href="https://gist.github.com/FrankFang/df5e57a0799823ed89a960a642b3a1e2" target="_blank" rel="noopener">Frank Fang</a></p>
          </div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http-server . -c-1 <span class="comment"># -c-1 表示不要缓存</span></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">parcel index.html</span><br></pre></td></tr></table></figure>

<h1 id="lt-a-gt-标签"><a href="#lt-a-gt-标签" class="headerlink" title="&lt;a&gt; 标签"></a><code>&lt;a&gt;</code> 标签</h1><h2 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a><code>href</code> 属性</h2><ul>
<li>网址<ul>
<li><code>http://google.com</code></li>
<li><code>https://google.com</code></li>
<li><code>//google.com</code> 无协议网址</li>
</ul>
</li>
<li>路径<ul>
<li><code>/a/b/c</code> 绝对路径，但是是基于 <strong>HTTP 服务</strong> 开启的根目录，不是整个计算机的根目录</li>
<li><code>a/b/c</code> 相对路径，基于当前路径的目录</li>
<li><code>index.html</code> 当前目录的文件</li>
<li><code>./index.html</code> 当前目录的文件</li>
</ul>
</li>
<li><code>#id</code></li>
<li>伪协议<ul>
<li><code>javascript:alert(1);</code><ul>
<li><code>javasrcript:;</code> 可以写一个什么都不做的a标签</li>
</ul>
</li>
<li><code>mailto:xxx@xxx.com</code> 会呼出邮件客户端</li>
<li><code>tel:1300000000</code> 会呼出拨号界面</li>
</ul>
</li>
</ul>
<h2 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a><code>target</code> 属性</h2><ul>
<li>内置名字<ul>
<li><code>_blank</code> 新标签</li>
<li><code>_top</code> 在最顶层打开（比如 <code>iframe</code> 的最外层页面）</li>
<li><code>_parent</code> 在父级窗口打开，没有 <code>_top</code> 那么高层</li>
<li><code>_self</code> 在当前页面打开（比如 <code>iframe</code> 的当前层）</li>
</ul>
</li>
<li>其他自定义的新窗口的名字（<code>window.name</code>）或者 <code>iframe</code> 的名字</li>
</ul>
<p>使用 rel=noopener 不打开新标签</p>
<h2 id="download-属性"><a href="#download-属性" class="headerlink" title="download 属性"></a><code>download</code> 属性</h2><p>下载而不是查看网页，但是大部分不支持</p>
<h1 id="lt-iframe-gt-标签"><a href="#lt-iframe-gt-标签" class="headerlink" title="&lt;iframe&gt; 标签"></a><code>&lt;iframe&gt;</code> 标签</h1><p>内嵌窗口，现在大都不用了</p>
<h1 id="lt-table-gt-标签"><a href="#lt-table-gt-标签" class="headerlink" title="&lt;table&gt; 标签"></a><code>&lt;table&gt;</code> 标签</h1><div class="note warning">
            <p>里面必须写<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>，否则浏览器也会自己加上，并且显示的顺序与实际写的这三个顺序无关，浏览器一定是按照<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>的顺序显示</p>
          </div>

<p>相关的样式有：</p>
<ul>
<li><code>table-layout</code><ul>
<li><code>auto</code> 按照内容的多少来分配宽度权重</li>
<li><code>fixed</code> 等宽</li>
</ul>
</li>
<li><code>border-collapse: collapse</code> 表示两个单元格的边线合并</li>
<li><code>border-spacing</code> 两个单元格中间的空隙</li>
</ul>
<h1 id="lt-img-gt-标签"><a href="#lt-img-gt-标签" class="headerlink" title="&lt;img&gt; 标签"></a><code>&lt;img&gt;</code> 标签</h1><blockquote>
<p>发出一个GET请求，展示一张图片</p>
</blockquote>
<h2 id="src-属性"><a href="#src-属性" class="headerlink" title="src 属性"></a><code>src</code> 属性</h2><p>可以是相对路径，也可以是绝对路径</p>
<h2 id="alt-属性"><a href="#alt-属性" class="headerlink" title="alt 属性"></a><code>alt</code> 属性</h2><p>图片加载失败的时候显示的内容</p>
<h2 id="height-和-width-属性"><a href="#height-和-width-属性" class="headerlink" title="height 和 width 属性"></a><code>height</code> 和 <code>width</code> 属性</h2><p>若只写高度或宽度，图像比例保持不变</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><code>onload</code>图片加载成功</li>
<li><code>onerror</code> 图片加载失败</li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><code>max-width: 100%</code></p>
<h1 id="lt-form-gt-标签"><a href="#lt-form-gt-标签" class="headerlink" title="&lt;form&gt; 标签"></a><code>&lt;form&gt;</code> 标签</h1><blockquote>
<p>发出一个 GET 或 POST 请求，然后刷新页面</p>
</blockquote>
<h2 id="action-属性"><a href="#action-属性" class="headerlink" title="action 属性"></a><code>action</code> 属性</h2><p>请求到哪个页面</p>
<h2 id="method-属性"><a href="#method-属性" class="headerlink" title="method 属性"></a><code>method</code> 属性</h2><p>是用 GET 还是 POST</p>
<h2 id="autocomplete-属性"><a href="#autocomplete-属性" class="headerlink" title="autocomplete 属性"></a><code>autocomplete</code> 属性</h2><p>为 <code>on</code> 则打开自动填充，下面的 <code>text</code> 要写 <code>name</code></p>
<h2 id="target-属性-1"><a href="#target-属性-1" class="headerlink" title="target 属性"></a><code>target</code> 属性</h2><p>把哪个页面（ 值可以为 <code>_blank</code> 等等）变成要请求到的那个页面（也就是说哪个页面需要刷新）</p>
<div class="note warning">
            <ul><li>一般不监听 <code>input</code> 的 <code>click</code> 事件</li><li><code>form</code> 里面的 <code>input</code> 要有 <code>name</code></li><li>一个 form 必须要有一个 <code>type=&quot;submit&quot;</code>，如果 <code>button</code> 不写 <code>type</code>，默认 <code>submit</code></li></ul>
          </div>

<div class="note warning">
            <p><strong><code>&lt;input type=&quot;submit&quot;&gt;</code> 和 <code>&lt;button type=&quot;submit&quot;&gt;</code> 的区别？</strong><br><code>input</code> 里面不能再有标签（但是文字可以用 <code>value=&quot;&quot;</code> 进行更改）<br><code>button</code> 里面可以有任何东西（包括图片等其他标签）</p>
          </div>

<h1 id="lt-input-gt-标签"><a href="#lt-input-gt-标签" class="headerlink" title="&lt;input&gt; 标签"></a><code>&lt;input&gt;</code> 标签</h1><h2 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a><code>type</code> 属性</h2><ul>
<li><code>text</code></li>
<li><code>color</code></li>
<li><code>password</code></li>
<li><code>radio</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>checkbox</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>file</code> 加上 <code>multiple</code> 属性可以同时选多个文件</li>
<li><code>hidden</code></li>
<li><code>tel</code></li>
<li><code>email</code></li>
<li><code>search</code></li>
</ul>
<h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><ul>
<li><code>onchange</code></li>
<li><code>onfocus</code></li>
<li><code>onblur</code></li>
</ul>
<h1 id="lt-textarea-gt-标签"><a href="#lt-textarea-gt-标签" class="headerlink" title="&lt;textarea&gt; 标签"></a><code>&lt;textarea&gt;</code> 标签</h1><p><code>style=&quot;resize: none&quot;</code> 让右下角不能拖动</p>
<h1 id="lt-select-gt-标签"><a href="#lt-select-gt-标签" class="headerlink" title="&lt;select&gt; 标签"></a><code>&lt;select&gt;</code> 标签</h1><p><code>&lt;option value=&quot;1&quot;&gt;星期一&lt;/option&gt;</code></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 序章</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-HTML-Overview/</url>
    <content><![CDATA[<p>WWW 和 HTML 的历史。</p>
<a id="more"></a>

<h1 id="Word-Wide-Web"><a href="#Word-Wide-Web" class="headerlink" title="Word Wide Web"></a>Word Wide Web</h1><ul>
<li>互联网，基于IP之间通信，但是无法输入地址得到一个网页</li>
<li>WWW = URL + HTTP + HTML（李爵士发明的，基于互联网实现的，输入地址得到一个网页的网络）</li>
</ul>
<h1 id="HTML-历史"><a href="#HTML-历史" class="headerlink" title="HTML 历史"></a>HTML 历史</h1><p>诞生于李爵士的一篇文章，最开始只有 18 个元素，这些元素如今还有 11 个健在，现在最新版的HTML大概有 110 个标签</p>
<h2 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h2><ul>
<li>狭义HTML 5：最新版本 HTML 语言，多了 32 个新标签</li>
<li>广义HTML 5：包括 CSS3 等朋友们</li>
</ul>
<h3 id="HTML-5-技术集合"><a href="#HTML-5-技术集合" class="headerlink" title="HTML 5 技术集合"></a>HTML 5 技术集合</h3><ul>
<li>新标签、新属性</li>
<li>新的通信技术：WebSockets、WebRTC</li>
<li>离线存储技术：LocalStorage、断网检测</li>
<li>多媒体技术：视频、音频</li>
<li>图像技术：Canvas、SVG、WebGL</li>
<li>Web增强技术：History API、全屏</li>
<li>设备相关技术：摄像头、触摸屏</li>
<li>新的样式技术：CSS3新的 Flex、Grid 的布局方式</li>
</ul>
<h1 id="HTML-起手式"><a href="#HTML-起手式" class="headerlink" title="HTML 起手式"></a>HTML 起手式</h1><p>用 <code>Emmet</code> 所提供的速写法可以很快地写出你在写 <code>HTML</code> 所需要写的一个骨架。<br>你只需要在安装了插件的编辑器（某些编辑器默认具有此功能）中输入 <code>!</code> 再敲击 <code>Tab</code>，便可以很方便地输入以下内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 表示文档类型是 HTML 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> <span class="comment">&lt;!-- html 标签，可以在这里设置语言，比如 lang="zh-CN" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="comment">&lt;!-- 这里的东西不会显示到页面上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>  <span class="comment">&lt;!-- 文件的字符编码 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置视口大小为设备宽度（以兼容手机），并设置初始缩放为 1.0 并禁用缩放 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span> <span class="comment">&lt;!-- 让 IE 浏览器使用最新的内核 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 动画</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-CSS-Animation/</url>
    <content><![CDATA[<p>用 <code>transform</code> 的性能会比直接修改 <code>left</code> 属性好，因为浏览器不会 repaint 那么多次</p>
<a id="more"></a>

<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><p>根据 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">Google 团队的文章</a>分析，我们可以将网页的渲染过程大致分为以下几步：</p>
<ol>
<li>根据 HTML 构建 HTML 树（DOM）</li>
<li>根据 CSS 构建 CSS 树（CSSOM）</li>
<li>将两棵树合并为渲染树（Render Tree）</li>
<li>布局 <strong>Layout</strong>（文档流、盒模型、计算大小和位置）</li>
<li>绘制 <strong>Paint</strong>（边框颜色、文字颜色、阴影）</li>
<li>合成 <strong>Compose</strong>（根据层叠关系展示画面）</li>
</ol>
<p><img src="/hais-notebook/images/CSS-006.png" alt=""></p>
<h1 id="更新样式"><a href="#更新样式" class="headerlink" title="更新样式"></a>更新样式</h1><div class="note warning">
            <p>一般用 JS 更新样式，比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style.background = <span class="string">'red'</span></span><br><span class="line">div.style.display = <span class="string">'none'</span></span><br><span class="line">div.classList.add(<span class="string">'red'</span>)</span><br><span class="line">div.remove()</span><br></pre></td></tr></table></figure>
          </div>

<h2 id="三种更新样式的路径"><a href="#三种更新样式的路径" class="headerlink" title="三种更新样式的路径"></a>三种更新样式的路径</h2><p>在 <a href="https://csstriggers.com/" target="_blank" rel="noopener">这里</a> 可以看到不同的属性在不同的浏览器中的更新路径</p>
<ul>
<li>JS/CSS &gt; Style &gt; Layout &gt; Paint &gt; Composite: remove</li>
<li>JS/CSS &gt; Style &gt; Paint &gt; Composite: background-color</li>
<li>JS/CSS &gt; Style &gt; Composite: transform</li>
</ul>
<h2 id="CSS-动画优化"><a href="#CSS-动画优化" class="headerlink" title="CSS 动画优化"></a>CSS 动画优化</h2><p>可以看看 <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">谷歌的这篇文档</a></p>
<ul>
<li>JS 优化：使用 <code>requestAnimationFrame</code> 代替 <code>setTimeout</code> 或者 <code>setInterval</code></li>
<li>CSS 优化：使用 <code>will-change</code> 或者 <code>translate</code></li>
</ul>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h1><blockquote>
<p>使用 <code>transform: none</code>，取消所有</p>
</blockquote>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: translateX(50px) | translateY(50%) | translateZ(50px) | translate(50px, 50px)</span><br></pre></td></tr></table></figure>

<p>视点的确定（在父元素上）： <code>perspective: 1000px</code> 表示父元素的中心为坐标原点，距离屏幕为 1000px</p>
<p>可以这样做绝对定位的居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">top</span>: 50%; <span class="selector-tag">left</span>: 50%; <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%)</span><br></pre></td></tr></table></figure>

<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>border 也会一起变</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: scaleX(&lt;number&gt;) | scaleY(&lt;number&gt;) | scale(&lt;number&gt;, &lt;number&gt;?)</span><br></pre></td></tr></table></figure>

<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>一般用来做 360 度旋转的 loading 或者按钮的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: rotate([&lt;angle&gt;|&lt;zero&gt;]) | rotateZ([&lt;angle&gt;|&lt;zero&gt;]) | rotateX([&lt;angle&gt;|&lt;zero&gt;])</span><br></pre></td></tr></table></figure>

<h2 id="扭曲"><a href="#扭曲" class="headerlink" title="扭曲"></a>扭曲</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: skewX(&lt;angle&gt;|&lt;zero&gt;) | skewY(&lt;angle&gt;|&lt;zero&gt;) | skew(&lt;angle&gt;|&lt;zero&gt;, &lt;angle&gt;|&lt;zero&gt;?)</span><br></pre></td></tr></table></figure>

<h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a><code>transition</code></h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">transition: 属性名(可以写all) 时长 过渡方式( linear | ease | ease-in | ease-in-out | cubic-bezier | step-start | step-end | steps ) 延迟</span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 3<span class="selector-tag">s</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>不是所有属性都有过渡<br><code>display: none =&gt; block</code>，一般改成 <code>visibility: hidden =&gt; visible</code></p>
          </div>

<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a><code>animation</code></h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> xxx &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  66<span class="selector-class">.66</span>% &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加动画 */</span></span><br><span class="line">animation: 时长 过渡方式 延迟 次数( infinite ) 方向( reverse | alternate | alternate-reverse ) 填充模式( none | forwards | backwards | both) 是否暂停( paused )  动画名</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 层叠上下文</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-CSS-StakingContext/</url>
    <content><![CDATA[<p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，<strong>层叠上下文</strong> 就是对这些 HTML 元素的一个 <strong>三维构想</strong>。众 HTML 元素基于其元素属性 <strong>按照优先级顺序</strong> 占据这个空间。</p>
<a id="more"></a>

<p><img src="/hais-notebook/images/CSS-004.png" alt=""></p>
<p>默认的元素的三维层叠顺序如上图所示，可以看到定位元素会超出原来的高度范畴，换句话说，<strong>原来的 background、border、块级子元素、浮动元素、内联子元素均处在 z-index = -1 ~ 0 这个区间之内</strong>。</p>
<p>每一个层叠上下文就好像一个小世界，只有这里面的 <code>z-index</code> 才能进行比较，具有不同 <code>z-index</code> 的父元素之中的子元素根本无法同台竞技。</p>
<p>这些常见的属性（或元素）可以创建一个层叠上下文：</p>
<ul>
<li><code>HTML</code>（根元素）</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>relative | absolute</code> 元素</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>flex</code> <code>grid</code> 子项</li>
<li><code>transform</code> 值不为 <code>none</code> 的元素</li>
<li><code>opacity</code> 值小于 <code>1</code> 的元素</li>
</ul>
<p>更多资料可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">MDN 文档</a> 。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 定位</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-CSS-Positioning/</url>
    <content><![CDATA[<p>定位和布局的区别：布局是平面上的，定位是垂直于屏幕的。</p>
<a id="more"></a>

<h1 id="一个-div-的分层"><a href="#一个-div-的分层" class="headerlink" title="一个 div 的分层"></a>一个 div 的分层</h1><p><img src="/hais-notebook/images/CSS-003.png" alt=""></p>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a><code>position</code></h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>默认值，当前元素在文档流中</p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a><code>relative</code></h2><ul>
<li>距离自己原来的位置的偏离（<code>top</code> / <code>bottom</code>），还是占据原来的空间</li>
<li>做位移</li>
<li>做 <code>absolute</code> 元素的爸爸</li>
<li>配合 <code>z-index</code>，默认是 <code>auto</code>，<code>auto</code> 计算出来的值为 <code>0</code></li>
<li><strong>经验</strong>：不要写 <code>z-index: 9999</code>，要学会 <code>z-index</code> 的管理</li>
</ul>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a><code>absolute</code></h2><ul>
<li>脱离原来的位置，另起一层；会相对于<strong>祖先元素中最近的</strong>一个<strong>定位元素</strong>（即非 <code>static</code> 元素）</li>
<li>可以用于悬浮显示提示内容</li>
<li><code>white-space: nowrap</code> 文字内容不换行</li>
<li>经验：<ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>善用 <code>left: 100%</code>，善用 <code>left: 50%</code>加负 <code>margin</code></li>
</ul>
</li>
</ul>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a><code>fixed</code></h2><ul>
<li>相对于视口定位，但是如果放到具有 <code>transform</code>  属性的元素里面，会有问题</li>
<li>做广告</li>
<li>做回到顶部按钮</li>
<li><strong>经验</strong><ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>手机上尽量不要使用 <code>fixed</code></li>
</ul>
</li>
</ul>
<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a><code>sticky</code></h2><p>兼容性很差</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 布局</title>
    <url>/hais-notebook/2020/02/02/2020-02-02-CSS-Layout/</url>
    <content><![CDATA[<p>如何选择布局。</p>
<a id="more"></a>

<h1 id="两种布局方式"><a href="#两种布局方式" class="headerlink" title="两种布局方式"></a>两种布局方式</h1><ul>
<li><strong>固定宽度布局</strong>：960、1000、1024</li>
<li><strong>不固定宽度布局</strong>：一般在手机上使用，主要靠文档流原理来布局</li>
<li><strong>响应式布局</strong>：PC上固定宽度，手机上不固定宽度，也就是一种<strong>混合布局</strong></li>
</ul>
<h1 id="两种布局思路"><a href="#两种布局思路" class="headerlink" title="两种布局思路"></a>两种布局思路</h1><ul>
<li>从大到小：先定下大局，然后再完善每个部分的小布局</li>
<li>从小到大：先完成小布局，然后再组合成大布局</li>
</ul>
<p><img src="/hais-notebook/images/CSS-001.png" alt=""></p>
<h1 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h1><ol>
<li>在子元素上加 <code>float: left</code> 和 <code>width</code></li>
<li>在父元素加上 <code>class=&quot;clearfix&quot;</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验：</p>
<ul>
<li>有经验者会留一些空间或最后一个不设置 <code>width</code>（可以设置一个 <code>max-width</code>）</li>
<li>不需要考虑响应式，因为手机上没有 IE，这个布局是专门为 IE 准备的</li>
<li>在IE上有BUG：最左边浮动元素的 <code>margin-left</code> 会变成双倍<ul>
<li>可以加一句兼容性写法：<code>_margin-left: ?px</code></li>
<li>也可以加上 <code>display: inline-block</code></li>
</ul>
</li>
<li>如果图片下面有空隙，加上 <code>vertical-align: middle | top</code> 就可以消除</li>
<li><strong><code>float</code> 元素外边距不合并</strong></li>
</ul>
<div class="note warning">
            <p>必要时可以采用负 margin</p>
          </div>

<p>比如说做平均布局，在所有的小块外面加一个 <code>div</code> ，然后再给这个 <code>div</code> 一个负 <code>margin</code></p>
<p><img src="/hais-notebook/images/CSS-002.png" alt=""></p>
<h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><p>这里是 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">CSS Tricks 上的 Flex 教程</a></p>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul>
<li>让一个元素变成 flex 容器：<code>display: flex | inline-flex</code></li>
<li>改变 items 的流动方向（主轴）：<code>flex-direction: row | row-reverse | column | column-reverse</code></li>
<li>改变折行：<code>flex-wrap: nowrap | wrap | wrap-revers</code></li>
<li>主轴的对齐方式：<code>justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly</code></li>
<li>次轴对齐：<code>align-items: flex-start | flex-end | center | stretch(默认)</code></li>
<li>多行对齐（基本不用）：<code>align-content: flex-start | flex-end | center | strech | space-between | space-around</code></li>
</ul>
<h2 id="Items"><a href="#Items" class="headerlink" title="Items"></a>Items</h2><ul>
<li><code>order</code>：改变显示顺序</li>
<li><code>flex-grow</code>：控制自己如何长胖（占多余所有空间的权重），默认是0（尽可能窄）</li>
<li>导航栏常用左边 logo 和右边用户头像都是 0，中间是 1</li>
<li><code>flex-shrink</code>：控制如何变瘦，（在空间不够用的时候，压缩的比例）默认是1（大家一起变小），可以写0（防止变小）</li>
<li><code>flex-basis</code>：控制基准宽度，一般用得比较少，默认是 auto（跟宽度一样）</li>
</ul>
<p>以上可以缩写为：<code>flex: grow shrink basis</code></p>
<ul>
<li><code>align-self: flex-start | flex-end</code></li>
</ul>
<p>经验：</p>
<ul>
<li>永远不要把 <code>width</code> 和 <code>height</code> 写死</li>
<li>尽量使用 <code>min-width</code> | <code>max-width</code> 等来写</li>
<li><code>margin-xxx: auto</code>，有奇效，类似于 <code>between</code></li>
</ul>
<h1 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h1><p>这里是 <a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">CSS Tricks 上的 Grid 教程</a></p>
<p><img src="/hais-notebook/images/CSS-007.png" alt=""></p>
<h2 id="Container-1"><a href="#Container-1" class="headerlink" title="Container"></a>Container</h2><ul>
<li><p>让一个元素变成 grid 容器：<code>display: grid | inline-grid</code></p>
</li>
<li><p>行和列：</p>
<ul>
<li><p><code>grid-template-columns</code>: 每一列的宽度，可以写 <code>auto</code></p>
</li>
<li><p><code>grid-template-rows</code>: 每一行的高度，可以写 <code>auto</code></p>
</li>
<li><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">  "<span class="selector-tag">aside</span> <span class="selector-tag">main</span> <span class="selector-tag">ad</span>"</span><br><span class="line">  "<span class="selector-tag">footer</span> <span class="selector-tag">fotter</span> ."</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>grid-gap</code></p>
</li>
<li><p><code>grid-column-gap</code></p>
</li>
<li><p><code>grid-row-gap</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="Items-1"><a href="#Items-1" class="headerlink" title="Items"></a>Items</h2><ul>
<li>grid-row-start</li>
<li>grid-row-end</li>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>fr：free space，类似于flex-grow</li>
<li><strong>grid-area: header;</strong></li>
<li><strong>grid-area: main;</strong></li>
<li><strong>….</strong></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基本概念</title>
    <url>/hais-notebook/2020/02/01/2020-02-01-CSS-Concepts/</url>
    <content><![CDATA[<p>主要是包括文档流、脱离文档流、盒模型、margin 合并等问题</p>
<a id="more"></a>

<h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><blockquote>
<p>这里的文档流指的是 <strong>Normal Flow</strong>，也就是 <strong>正常布局流</strong><br>当我们没有使用过任何 CSS 规则来改变元素的展现方式的时候，他们会按照正常的布局流来组织——也就是默认情况下的元素布局——这也就是我们所说的 <strong>Noraml Flow</strong>，即 <strong>文档流</strong> </p>
</blockquote>
<table>
<thead>
<tr>
<th><code>display</code></th>
<th>流动方向</th>
<th>宽度</th>
<th>高度</th>
</tr>
</thead>
<tbody><tr>
<td><code>inline</code></td>
<td>从左到右排列，<strong>行尾会截断成两行</strong></td>
<td>里面所有 inline 元素之和，不接受指定 <code>width</code></td>
<td><strong>实际高度</strong>由<strong>行高（<code>line-height</code>）间接</strong>（与字体有关，具体可以看 <a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729887779307520" target="_blank" rel="noopener">这个</a>）<strong>确定</strong>，<code>padding</code> 只能改变<strong>看得见</strong>的高度（而不是实际高度），如果没有内容，也有高度，为 <code>line-height</code></td>
</tr>
<tr>
<td><code>block</code></td>
<td>从上到下排列（每个占一行）</td>
<td>默认为 <code>auto</code>（不是100%），可以指定 <code>width</code>，但永远不要写 <code>width: 100%</code></td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code>，如果没有内容，高度为 <code>0</code></td>
</tr>
<tr>
<td><code>inline-block</code></td>
<td>从左到右排列，<strong>行尾不会分成两块</strong></td>
<td>默认为里面所有 <code>inline</code> 元素之和，但接受指定 width</td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code></td>
</tr>
</tbody></table>
<h1 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h1><blockquote>
<p>这里的溢出指的是 <strong>Overflow</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th><code>overflow</code></th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td><code>hidden</code></td>
<td>隐藏</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>滚动，就算没有溢出，依然有滚动条，<strong>如果有横向滚动条，inline 元素也只会在第一屏</strong></td>
</tr>
<tr>
<td><code>auto</code></td>
<td>没有溢出就没有滚动条，并且只显示必要的滚动条</td>
</tr>
</tbody></table>
<p>可以分开设置 <code>overflow-x</code> 和 <code>overflow-y</code></p>
<h1 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h1><blockquote>
<p>也就是 <strong>Out of flow</strong></p>
</blockquote>
<div class="note warning">
            <p>block 不计算其高度</p>
          </div>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">position: absolute | fixed;</span><br><span class="line"><span class="comment">/* OR */</span></span><br><span class="line">float: left | right;</span><br></pre></td></tr></table></figure>

<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>可以把网页中显示的 HTML 元素看成是一个个盒子，盒子具有四层：</p>
<ul>
<li>内容（content）</li>
<li>内边距（padding）</li>
<li>边框（border）</li>
<li>外边距（margin）</li>
</ul>
<table>
<thead>
<tr>
<th><code>box-sizing</code></th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td><code>content-box</code></td>
<td>指定 <code>width</code> 或 <code>height</code> 时，说的是他的最里面的 <code>content</code> 的 宽或高</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>指定 <code>width</code> 或 <code>heihgt</code> 时，除了 <code>content</code> 的宽或高之外，还包括了 <code>padding</code> 和 <code>border</code> 的厚度</td>
</tr>
</tbody></table>
<p>通过 <code>box-sizing</code> 控制，一般使用 <code>border-box</code></p>
<h1 id="Margin-合并"><a href="#Margin-合并" class="headerlink" title="Margin 合并"></a>Margin 合并</h1><p>是说我们上下两个元素若都有 margin，那么他们的 margin 将不会同时生效。有以下几个注意点：</p>
<ol>
<li>只有上下才会发生 <code>margin</code> 合并，左右不会发生</li>
<li>只有 <code>block</code> 会发生 <code>margin</code> 合并，<code>inline-block</code> 不会发生</li>
<li><code>first-child</code> 和 <code>last-child</code> 也会和 <code>parent</code> 发生 margin 合并</li>
</ol>
<p>取消 margin 合并的方法：</p>
<ol>
<li>使用 <code>overflow:hidden</code> 之后就不会再合并</li>
<li>使用 <code>display:flex</code> 之后就不会再合并</li>
<li>通过给 <code>parent</code> 上面加东西（<code>padding</code> <code>border</code> <code>overflow</code> 等）之后就不会再合并</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 序章</title>
    <url>/hais-notebook/2020/02/01/2020-02-01-CSS-Overview/</url>
    <content><![CDATA[<p>记录 CSS 的含义及基本语法。</p>
<a id="more"></a>

<h1 id="层叠的含义"><a href="#层叠的含义" class="headerlink" title="层叠的含义"></a>层叠的含义</h1><ul>
<li><strong>样式层叠</strong>：可以对同一个选择器进行样式声明</li>
<li><strong>选择器层叠</strong>：可以用不同的选择器对同一个元素进行样式声明</li>
<li><strong>文件层叠</strong>：可以用多个文件进行层叠</li>
</ul>
<h1 id="样式语法"><a href="#样式语法" class="headerlink" title="样式语法"></a>样式语法</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性名: 属性值;</span><br><span class="line">  <span class="comment">/* 注释 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="语法"><a href="#语法" class="headerlink" title="@ 语法"></a>@ 语法</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"UTF-8"</span>;   <span class="comment">/* 必须放在第一行 */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="number">2</span>.css); </span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">100px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">200px</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h1><ul>
<li>charset 是字符集的意思，但 UTF-8 不是字符集，而是字符编码(encoding)，这是历史遗留问题</li>
<li>ASCII 字符集的编码形式就是 ASCII，这个字符集只有英文</li>
<li>GB2312 字符集是中国人发明的简体中文字符集，他的编码形式也是 GB2312</li>
<li>GBK 是微软发明的中日韩（CJK）字符集，他的编码形式也是 GBK</li>
<li>unicode 是支持所有字符的字符集，他的编码形式有 UTF-8/UTF-16/UTF-32</li>
</ul>
<h1 id="找资料"><a href="#找资料" class="headerlink" title="找资料"></a>找资料</h1><ul>
<li>查资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN</a>、<a href="https://css-tricks.com/" target="_blank" rel="noopener">CSS Tricks</a>、<a href="https://www.zhangxinxu.com/wordpress/" target="_blank" rel="noopener">张鑫旭的博客</a></li>
<li>找素材（可以搜 PSD WEB）：<a href="https://www.freepik.com/" target="_blank" rel="noopener">Freepik</a>、<a href="http://dribbble.com/" target="_blank" rel="noopener">Dribbble</a>、<a href="https://cn.365psd.com/" target="_blank" rel="noopener">365 PSD</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/hais-notebook/2020/02/01/2020-02-01-Vue-Vuex/</url>
    <content><![CDATA[<p>用了几次 Vuex 之后抄一下文档。</p>
<a id="more"></a>

<p>可以先看一下 <a href="https://codesandbox.io/s/quizzical-kalam-303z8" target="_blank" rel="noopener">这个例子</a></p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Vuex 的核心就是一个状态仓库，与普通的全局对象有所不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的，store 变化 -&gt; 组件响应式更新</li>
<li>不能直接修改 store 中的状态，只能通过提交 mutation 的方式来改变状态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 定义一个初始的状态</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 定义一些 mutation 来操作状态的变更</span></span><br><span class="line">  mutation: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以通过 store.state 获取对象，或者通过 store.commit 来触发变更</span></span><br><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>Vuex 使用单一状态树，每个应用仅仅包含一个 store 实例</p>
<h2 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h2><h3 id="方法一：通过计算属性"><a href="#方法一：通过计算属性" class="headerlink" title="方法一：通过计算属性"></a>方法一：通过计算属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每个需要使用 state 的组件中就都需要导入 store</p>
<h3 id="方法二：将状态从根组件注入每个子组件"><a href="#方法二：将状态从根组件注入每个子组件" class="headerlink" title="方法二：将状态从根组件注入每个子组件"></a>方法二：将状态从根组件注入每个子组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样子组件就可以通过 <code>this.$store</code> 访问到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：mapState"><a href="#方法三：mapState" class="headerlink" title="方法三：mapState"></a>方法三：<code>mapState</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 可以使用箭头函数</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以使用普通函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若计算属性的名称与子节点名称相同，的也可以给 mapState 传一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="将-mapState-与局部计算属性混用"><a href="#将-mapState-与局部计算属性混用" class="headerlink" title="将 mapState 与局部计算属性混用"></a>将 mapState 与局部计算属性混用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h1><p>从 store 的 state 中派生出一些状态，类似于 store 的计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 可以传入 state 作为第一个参数</span></span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以传入其他 getter 作为第二个参数</span></span><br><span class="line">    doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以让 getter 返回一个函数来实现给 getter 传参</span></span><br><span class="line">    getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todo.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到时候通过 store.getters.getTodoById(2) 这样访问</span></span><br><span class="line">    <span class="comment">// 这样通过方法访问就不会有缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以像访问 State 访问这些 Getter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过 mapGetters</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">  ...mapGetters([</span><br><span class="line">  <span class="string">'doneTodosCount'</span>,</span><br><span class="line">  <span class="string">'anotherGetter'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 将 state 作为第一个参数</span></span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将 payload 作为第二个参数，大多数情况下 payload 应该传一个对象</span></span><br><span class="line">    decrement (state, payload) &#123;</span><br><span class="line">      state.count -= payload.amount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样提交</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line">store.commit(<span class="string">'decrement'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成含有 type 属性的对象</span></span><br><span class="line">sotre.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中提交</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapMutations</span></span><br><span class="line">  ...mapMutations([</span><br><span class="line">    <span class="string">'increment'</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>Mutation 必须是同步函数，因为异步会使得很难调试，无法区分谁先回调</p>
          </div>

<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态</li>
<li>Action 可以包含任意异步操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接受一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">  <span class="comment">// 这个 context 对象也有 context.state context.getters 这种方法</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以这样简化代码：</span></span><br><span class="line">  action: &#123;</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样触发，同 Mutation 一样，也支持 payload 和含有 type 的对象的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中触发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapActions</span></span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'incrementAsync'</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'incrementAsync'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Router</title>
    <url>/hais-notebook/2020/02/01/2020-02-01-Vue-Router/</url>
    <content><![CDATA[<p>用了几次 VueRouter 之后抄一下文档。</p>
<a id="more"></a>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><code>&lt;router-link/&gt;</code> 就像 <code>&lt;a&gt;</code> 标签，来链接到不同的路由</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;router-view/&gt;</code> 用来装路由匹配出来的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 引入 VueRouter</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入要被路由的组件</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'../Bar.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由，相当于定义 router 的配置选项</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo&#125;,      </span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar&#125;      </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建根实例，并使用 VueRouter</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h1><table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody><tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td><code>{ username: &#39;evan&#39; }</code></td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td><code>{ username: &#39;evan&#39;, post_id: &#39;123&#39; }</code></td>
</tr>
</tbody></table>
<div class="note warning">
            <p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用，组件的生命周期钩子不会再被调用</p>
          </div>

<p>如果想要对路由参数的变化做出响应，需要 watch $route 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 beforeRouterUpdate：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don't forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>，此时要在 <code>VueRouter</code> 的参数中增加 <code>children</code> 的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">''</span>,</span><br><span class="line">          component: UserHome</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'profile'</span>,</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'posts'</span>,</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>以 / 开头的嵌套路径会被当作根路径</p>
          </div>

<h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><h2 id="router-push-location-onComplete-onAbort"><a href="#router-push-location-onComplete-onAbort" class="headerlink" title="router.push(location, onComplete?, onAbort?)"></a><code>router.push(location, onComplete?, onAbort?)</code></h2><p>相当于 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>，两者的语法规则相同</p>
<div class="note warning">
            <p>在 Vue 实例里面，可以通过 $router 访问路由实例 <code>router</code>。因此可以调用 this.$router.push</p>
          </div>

<p>参数可以是字符串路径或者一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">'123'</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 提供了 path 之后 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>

<p><code>onComplete</code> 和 <code>onAbort</code> 参数可以传入两个回调：将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<div class="note warning">
            <p>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)</p>
          </div>

<h2 id="router-replace-location-onComplete-onAbort"><a href="#router-replace-location-onComplete-onAbort" class="headerlink" title="router.replace(location, onComplete?, onAbort?"></a><code>router.replace(location, onComplete?, onAbort?</code></h2><p>相当于 <code>router-link :to=&quot;...&quot; replace</code>，不会向 history 添加新的记录，而是替换掉当前的 history 目录</p>
<h2 id="router-go-n"><a href="#router-go-n" class="headerlink" title="router.go(n)"></a><code>router.go(n)</code></h2><p>类似 <code>window.history.go(n)</code> 意为在 history 记录中前进或后退多少步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h1 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><h2 id="全局前置导航守卫-router-beforeEach"><a href="#全局前置导航守卫-router-beforeEach" class="headerlink" title="全局前置导航守卫 router.beforeEach"></a>全局前置导航守卫 <code>router.beforeEach</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中<br>确保要调用 next 方法，否则钩子就不会被 resolved</p>
          </div>

<ul>
<li><p><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p>
</li>
<li><p><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</p>
</li>
<li><p><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code> 中的选项。</p>
</li>
<li><p><code>next(error)</code>: 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调。</p>
</li>
</ul>
<h2 id="全局解析守卫-router-beforeResolve"><a href="#全局解析守卫-router-beforeResolve" class="headerlink" title="全局解析守卫 router.beforeResolve"></a>全局解析守卫 <code>router.beforeResolve</code></h2><p>类似 <code>router.beforeEach</code>，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
<h2 id="全局后置钩子-router-afterEach"><a href="#全局后置钩子-router-afterEach" class="headerlink" title="全局后置钩子 router.afterEach"></a>全局后置钩子 <code>router.afterEach</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由独享的守卫-beforeEnter"><a href="#路由独享的守卫-beforeEnter" class="headerlink" title="路由独享的守卫 beforeEnter"></a>路由独享的守卫 <code>beforeEnter</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">    <span class="comment">// 但是可以通过传给 next 一个回调来访问组件实例          </span></span><br><span class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 通常用来禁止用户在还未保存修改前突然离开，通过 next(false) 来取消用户的导航    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导航的解析流程"><a href="#导航的解析流程" class="headerlink" title="导航的解析流程"></a>导航的解析流程</h2><ol>
<li>导航被触发</li>
<li>在失活的组件里调用离开守卫</li>
<li>调用全局的 <code>beforeEach</code> 守卫</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)</li>
<li>在路由配置里调用 <code>beforeEnter</code></li>
<li>解析异步路由组件</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code></li>
<li>调用全局的 <code>beforeResolve</code> 守卫</li>
<li>导航被确认</li>
<li>调用全局的 <code>afterEach</code> 钩子</li>
<li>触发 DOM 更新</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 选项</title>
    <url>/hais-notebook/2020/01/30/2020-01-30-Vue-Options/</url>
    <content><![CDATA[<p>记录 Vue Options 中的内容。</p>
<a id="more"></a>

<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><ul>
<li>接收内部属性</li>
<li>有两种写法：对象和函数，函数 return 一个对象</li>
<li>优先使用函数，避免两个组件共用一个 data，此外在 vue 组件中的 data 不能使用对象</li>
<li>data 有 bug</li>
</ul>
<p>关于更多 data 与 响应式的内容，可以看看 <a href="https://hais-teatime.com/post/2019-12-25-vue-1/" target="_blank" rel="noopener">我的一篇博客</a></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li>接收外部属性，一个数组</li>
<li><code>message=&quot;n&quot;</code> 传入字符串</li>
<li><code>:message=&quot;n&quot;</code> 传入 this.n 数据</li>
<li><code>:fn=&quot;add&quot;</code> 传入 this.add 函数</li>
<li>如果外部有谁用了这个组件，可以在他的 <code>template</code> 里面把数据传给这个组件</li>
<li>如果传的时候在前面加上冒号，传的就是 JS 代码（变量），<strong>比如要传数字、布尔值、数组、对象等都需要加冒号</strong></li>
<li>子组件 <strong>不能</strong> 修改父组件传来的 prop，子组件如果想要进行修改或转换，最好是定义一个本地的 data，然后把 prop 作为初值赋给 data，或者使用 computed</li>
</ul>
<p>如果想要将一个对象的所有属性都作为 prop 传入，可以使用不带参数的 <code>v-bind</code> 这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以为 prop 指定类型（<code>String</code> <code>Number</code> <code>Boolean</code> <code>Array</code> <code>Object</code> <code>Function</code> <code>Date</code> <code>Symbol</code> 或者一个自定义的构造函数）或进行验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">const</span> User = &#123;</span><br><span class="line">     template: <span class="string">'...'</span>,</span><br><span class="line">     watch: &#123;</span><br><span class="line">       <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">         <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<div class="note warning">
            <p>props 和 data 的区别：<br>如果需要传值，就放在 props 里面</p>
          </div>

<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>可以查看 <a href="https://codesandbox.io/s/beautiful-blackburn-5dn48" target="_blank" rel="noopener">在 CodeSandbox 上的这个例子</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      email: <span class="string">"harvey@example.com"</span>,</span><br><span class="line">      nickname: <span class="string">"hai"</span>,</span><br><span class="line">      phone: <span class="string">'1234567890'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123; <span class="comment">// 能够将计算而来的属性作为属性</span></span><br><span class="line">    displayName()&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">this</span>.user</span><br><span class="line">      <span class="keyword">return</span> user.nickname || user.email || user.phone</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 或者写成：</span></span><br><span class="line">    displayName: &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">this</span>.user</span><br><span class="line">        <span class="keyword">return</span> user.nickname || user.email || user.phone</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.user.nickname = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;displayName&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>computed 是有缓存的，如果 computed 依赖的属性没有变化，那么就不会重新计算<br>而普通的函数（方法），或者 getter / setter 默认是不会做缓存的，Vue 做了特殊处理</p>
          </div>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>简单来说就是当数据变化的时候执行一个函数，可以参考 <a href="https://codesandbox.io/s/dry-architecture-6cp4p" target="_blank" rel="noopener">这个简单的计算器的例子</a><br>watch 也可以用来实现 computed 的效果，可以参考 <a href="https://codesandbox.io/s/long-dust-7jb3q" target="_blank" rel="noopener">这个例子</a></p>
<div class="note warning">
            <p>什么叫数据变化？其实就是 <code>===</code> 的规则，简单类型比较值，引用类型比较地址<br><code>obj.a</code> 进行修改 → <code>obj</code> 没变<br><code>obj</code> 进行修改 → <code>obj</code> 变了</p>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    handler()&#123; <span class="built_in">console</span>.log(<span class="string">'changed'</span>) &#125;,</span><br><span class="line">    deep: <span class="literal">true</span> <span class="comment">// 这个可以使得监听到内部数据的变化，如果里面变了，那么就触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>不要使用箭头函数来定义 watcher，<code>this</code> 是 <code>window</code></p>
          </div>

<blockquote>
<p>computed 和 watch 的区别？<br>computed 是用来计算一个值的，调用的时候不需要加括号，会根据依赖缓存<br>watch 有两个比较常用的选项：<code>immediate</code> 和 <code>deep</code></p>
</blockquote>
<p>  watch 有两个选项，immediate，deep</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><ul>
<li>想要挂载到哪个节点，节点内容会被替换</li>
<li>在里面写了内容，基本上是不太可能被用户看见的，除非用户网速特别慢</li>
<li>可以用不用 el，替换为 $mount，效果一样：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(demo)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="三种写法"><a href="#三种写法" class="headerlink" title="三种写法"></a>三种写法</h3><ol>
<li>Vue 完整版，写在 HTML 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">  &#123;n&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#xxx"</span>,</span><br><span class="line">  data: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Vue 完整版，写在 options 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=xxx&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;button @click="add"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>) <span class="comment">// 注意这个时候 div#app 会被替代</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Vue 运行时版，写在 <code>.vue</code> 文件里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template 不是 HTML，是 XML，有闭合标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    data()&#123; <span class="keyword">return</span> &#123; n:<span class="number">0</span> &#125; &#125;, <span class="comment">// data 必须为函数</span></span></span><br><span class="line"><span class="actionscript">    methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* CSS-Code */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span> <span class="comment">// App 是一个 options 对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>HTML 与 XML 写法不同：<br><code>&lt;input name=&quot;username&quot;&gt;</code> - HTML<br><code>&lt;input name=&quot;username&quot;/&gt;</code> - XML<br><code>&lt;div&gt;&lt;/div&gt;</code> - HTML<br><code>&lt;div/&gt;</code> - XML</p>
          </div>

<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="展示内容"><a href="#展示内容" class="headerlink" title="展示内容"></a>展示内容</h4><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; object.a &#125;&#125; <span class="comment">&lt;!-- 表达式 --&gt;</span></span><br><span class="line">&#123;&#123; n + 1 &#125;&#125; <span class="comment">&lt;!-- 运算 --&gt;</span></span><br><span class="line">&#123;&#123; fn(n) &#125;&#125; <span class="comment">&lt;!-- 调用函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">"表达式"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>如果值为 undefined 或 null 就不显示</p>
          </div>

<h5 id="HTML-内容"><a href="#HTML-内容" class="headerlink" title="HTML 内容"></a>HTML 内容</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>span</code> 将会被 <code>rawHtml</code> 的内容所替换，并且 <code>rawHtml</code> 里面的数据绑定将会失效，因此我们不能用 <code>v-html</code> 来在 <code>template</code> 里面使用 <code>template</code>，这个时候需要用 <code>component</code> 来进行组件的组合。</p>
<h5 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-pre 不会对模板进行编译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h4><p>Mustache 语法（双大括号）并不能使用在 HTML 属性上，这时我们需要依靠 <code>v-bind</code> 来帮我们绑定属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"x"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可简写为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"x"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:style</span>=<span class="string">"&#123;border: '1px solid red', height: 100&#125;"</span>&gt;</span></span><br><span class="line">这里可以把 '100px' 写成 100</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="绑定-Class"><a href="#绑定-Class" class="headerlink" title="绑定 Class"></a>绑定 Class</h5><h6 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过设置 <code>isActive</code> 和 <code>hasError</code> 的值为 <code>true</code> 或者 <code>false</code> 来控制 <code>div</code> 是否有 <code>active</code> 和 <code>text-danger</code> 这两个 class</p>
<h6 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过给 <code>activeClass</code> 和 <code>errorClass</code> 赋值来控制 <code>div</code> 的 class</p>
<p>可以在数组语法中使用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样将始终添加 <code>errorClass</code> 里面的值，但是只有在 <code>isActive</code> 为真时才添加 <code>activeClass</code> 里面的值</p>
<p>也可以在数组语法中使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给一个自定义组件加上 class 的话，会自动渲染到他的最外面的那个元素上面，并且最外面元素自身的 class 不会被覆盖，同样也支持对象语法等</p>
<h5 id="绑定-Style"><a href="#绑定-Style" class="headerlink" title="绑定 Style"></a>绑定 Style</h5><h6 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以为 <code>activeColor</code> 和 <code>fontSize</code> 赋值，来改变 Style</p>
<h6 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>数组中可以装下多个样式对象</p>
<h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add()，自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add(1)"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add(1)，不自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"n+=1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 n+=1 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以缩写 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过 <code>$event</code> 传递原始的 DOM 事件“</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>v- 开头的就是指令： <code>v-指令名:参数=值</code>，比如 <code>v-on:click=add</code></li>
<li>如果值里面没有特殊字符，可以不加引号</li>
<li>有的指令没有参数和值，比如 <code>v-pre</code></li>
<li>有的指令没有值，比如 <code>v-on:click.prevent</code>，阻止默认动作</li>
</ul>
<h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用 --&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>有的指令支持修饰符，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@click.stop&#x3D;&quot;add&quot; 阻止冒泡</span><br><span class="line">@click.prevent&#x3D;&quot;add&quot; 阻止默认动作</span><br><span class="line">@click.stop.prevent&#x3D;&quot;add&quot;</span><br><span class="line">@keypress.13 当按下回车时执行，或者用 @keypress.enter，有很多都有别名</span><br></pre></td></tr></table></figure>

<h6 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h6><p>查看 <a href="https://codesandbox.io/s/kind-cookies-1o6rs" target="_blank" rel="noopener">这个在 CodeSandbox 上的例子</a>，或者 <a href="https://codesandbox.io/s/kind-cookies-1o6rs" target="_blank" rel="noopener">这个例子</a></p>
<ul>
<li>组件不能修改 <code>props</code> 外部数据</li>
<li><code>$emit</code> 可以触发一个事件，并传参（发布）， <code>v-on</code> 可以监听他（订阅）</li>
<li><code>$event</code> 可以获取 <code>$emit</code> 的参数</li>
<li>由于经常会出现让组件想要更新数据的情况，所以有了 <code>.sync</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:money.sync&#x3D;&quot;total&quot;</span><br><span class="line">等价于</span><br><span class="line">:money&#x3D;&quot;total&quot; v-on:update:money&#x3D;&quot;total &#x3D; $event&quot;</span><br><span class="line">update:money 是事件名</span><br></pre></td></tr></table></figure>

<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"x &gt; 0"</span>&gt;</span></span><br><span class="line">  x 大于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"x === 0"</span>&gt;</span></span><br><span class="line">  x 为 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  x 小于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有时候我们需要加上 <code>key</code> 来管理元素的复用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为 label 没有 key，所以 label 复用了，仅仅是替换掉了文字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果没有 key，那么切换的时候 input 里面的内容将会保留，这就是元素的复用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"n % 2 === 0"</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 近似等于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123;display: n%2===0 ? 'block' : 'none'&#125;"</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 但是注意，不是所有看得见的元素 display 都是 block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table 是 table，li 是 list-item --&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><code>v-if</code> 与 <code>v-show</code></p><ul><li><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>，<code>v-if</code> 则都支持</li><li><code>v-if</code> 在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，<code>v-show</code> 则只是切换了 <code>display</code> 属性</li><li>若初始条件为假，<code>v-if</code> 不会渲染，<code>v-show</code> 则会渲染</li></ul>
          </div>

<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(user, index) in users"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    索引: &#123;&#123;index&#125;&#125; 值：&#123;&#123;user.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, name, index) in obj"</span> <span class="attr">:key</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    属性名: &#123;&#123;name&#125;&#125; 属性值：&#123;&#123;value&#125;&#125; 索引: &#123;&#123;index&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><code>:key=&quot;index&quot;</code> 有 Bug， <code>v-for</code> 一定要有 <code>:key</code>，尽量要是不重合的值</p>
          </div>

<p>当 <code>v-if</code> 和 <code>v-for</code> 同时使用的时候， <code>v-for</code> 的优先级会更高，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码将只渲染未完成的 todo</p>
<p>在组件上使用 <code>v-for</code> 时需要手动将数据给传进去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p><code>v-model</code> 可以实现常用表单元素的双向绑定，包括文本、多行文本、复选框、单选按钮、选择框等</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h1><blockquote>
<p>出现的时机可以用 debugger 证明</p>
</blockquote>
<ul>
<li>beforeCreate</li>
<li>created：出现在内存中，没有出现在页面中</li>
<li>beforeMount</li>
<li>mounted：出现在页面中</li>
<li>beforeUpdate</li>
<li>updated：更新了</li>
<li>activated</li>
<li>deactivated</li>
<li>beforeDestroy</li>
<li>destroyed：消亡了再弄出来之后是新的组件，占用新的内存地址</li>
<li>errorCaptured</li>
</ul>
<h1 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h1><h2 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h2><h3 id="指令声明"><a href="#指令声明" class="headerlink" title="指令声明"></a>指令声明</h3><p>可以查看 <a href="https://codesandbox.io/s/dank-cloud-99drb" target="_blank" rel="noopener">在 CodSandbox 上的这个例子</a></p>
<p>声明全局指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'x'</span>, directiveOptions)</span><br><span class="line"><span class="comment">// 然后就可以全局使用 v-x 了</span></span><br></pre></td></tr></table></figure>

<p>声明局部指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  x: &#123; derectiveOptions &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只能在当前组件用 v-x，其子组件也不能用</span></span><br></pre></td></tr></table></figure>

<h3 id="directiveOptions"><a href="#directiveOptions" class="headerlink" title="directiveOptions"></a>directiveOptions</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bind(el, info, vnode, oldVnode) <span class="comment">// 类似 created</span></span><br><span class="line">inserted(el, info, vnode, oldVnode) <span class="comment">// 类似 mounted</span></span><br><span class="line">update(el, info, vnode, oldVnode) <span class="comment">// 类似 updated</span></span><br><span class="line">componentUpdated(el, info, vnode, oldVnode)</span><br><span class="line">unbind(el, info, vnode, oldVnode) <span class="comment">// 类似 destroyed</span></span><br></pre></td></tr></table></figure>

<h3 id="指令的作用"><a href="#指令的作用" class="headerlink" title="指令的作用"></a>指令的作用</h3><ul>
<li><strong>用于 DOM 操作</strong><ul>
<li>Vue 的实例/组件主要用于数据绑定、事件监听、DOM 更新；Vue 指令主要目的是原生 DOM 操作</li>
</ul>
</li>
<li><strong>减少重复</strong><ul>
<li>如果某个 DOM 操作经常使用/很复杂，可以封装成指令</li>
</ul>
</li>
</ul>
<h2 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h2><p>尽量不用，用 methods</p>
<h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以引入一个 vue 文件，叫做 Demo，作为 frank 组件（局部注册）</span></span><br><span class="line"><span class="comment">// 优先使用这种，但是局部注册的组件在其子组件中不可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo.vue'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    frank: Demo, <span class="comment">// 如果是 Demo: Demo，就可以简化为 Demo</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以新建一个组件，后面接受的参数与 new Vue(options) 里面的 options 一样（除了没有 el），这叫全局组件</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'my-component-name'</span>, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写，options 也跟外面的一样（除了没有 el）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    frank: options,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>组件是一个抽象概念</li>
<li>文件名没有特殊规定，如果非常讲究，可以全用小写，因为比如 Windows 10 就不分大小写</li>
<li>组件名推荐首字母大写</li>
</ul>
<h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>目的：减少 data、methods、钩子的重复，可以查看在 <a href="https://codesandbox.io/s/lingering-microservice-6cw8h" target="_blank" rel="noopener">Codesandbox 上的这个例子</a><br>选项会智能合并：data、钩子等都会合并，在冲突的时候优先使用组件自己的</p>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVue = Vue.extend(options)</span><br><span class="line"><span class="comment">// 然后就可以用</span></span><br><span class="line"><span class="keyword">new</span> MyVue(options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> MyVue <span class="keyword">from</span> <span class="string">"../MyVue.js"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  extends: MyVue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看在 <a href="https://codesandbox.io/s/amazing-frog-f9xz5" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h2 id="provide-amp-amp-inject"><a href="#provide-amp-amp-inject" class="headerlink" title="provide &amp;&amp; inject"></a>provide &amp;&amp; inject</h2><p>用于大范围的数据共用，简单数据类型不能直接更改，需要通过函数，传过去的函数的 this 会自动绑定到 Provider 上面，可以查看在 <a href="https://codesandbox.io/s/affectionate-jennings-v4y1t" target="_blank" rel="noopener">Codesandbox 上的这个例子</a></p>
<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 开始</title>
    <url>/hais-notebook/2020/01/30/2020-01-30-Vue-Start/</url>
    <content><![CDATA[<p>Vue 笔记的开始，主要记录了 Vue 的安装与历史。</p>
<a id="more"></a>

<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><ul>
<li>2015 年，1.0 版，是 MVVM 框架</li>
<li>2016 年，2.0 版，没有完全遵循 MVVM 模型</li>
<li>2019 年，2.6 版</li>
<li>2020 年，3.0 版，完全不是 MVVM</li>
</ul>
<h1 id="创建一个-vue-项目"><a href="#创建一个-vue-项目" class="headerlink" title="创建一个 vue 项目"></a>创建一个 vue 项目</h1><ul>
<li>使用 @vue-cli</li>
<li>或者使用 webpack 或者 rollup 从零开始</li>
</ul>
<h1 id="完整版和运行时版本"><a href="#完整版和运行时版本" class="headerlink" title="完整版和运行时版本"></a>完整版和运行时版本</h1><ul>
<li><strong>完整版</strong>：同时包含编译器和运行时的版本，也就是 CDN 里面的 <code>vue.js</code>，可以直接在页面里面写 ，相当于把视图放在 html 里面写</li>
<li><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切，也就是 CDN 里面的 <code>vue.runtime.js</code>，不支持从 html 里面获取视图，也不支持在 template 里面写，没有编译器（compiler），代码体积小 30%</li>
<li>webpack 中的 vue-loader 可以在最后打包的时候将 template 里面的东西编译成 JS，因此我们不需要使用完整版</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>完整版</th>
<th>运行时版</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>有 compiler</td>
<td>没有 compiler</td>
<td>compiler 占 40% 的体积</td>
</tr>
<tr>
<td>视图</td>
<td>写在 HTML 里，或者写在 template 选项中</td>
<td>写在 render 函数里，用 h 来创建标签    h 是 Vue 写好传给 render 的</td>
<td></td>
</tr>
<tr>
<td>CDN 引入</td>
<td>vue.js</td>
<td>vue.runtime.js</td>
<td>文件名不同，生产环境后缀为 .min.js</td>
</tr>
<tr>
<td>webpack 引入</td>
<td>需要配置 alias</td>
<td>默认使用此版</td>
<td></td>
</tr>
<tr>
<td>@vue/cli 引入</td>
<td>需要额外配置</td>
<td>默认使用此版</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie</title>
    <url>/hais-notebook/2020/01/30/2020-01-30-Browser-Cookie/</url>
    <content><![CDATA[<p>Cookie 是浏览器下发给浏览器的一段字符串，浏览器必须保存这个 Cookie，之后发起的相同二级域名的请求，浏览器必须附上 Cookie。</p>
<a id="more"></a>

<h1 id="Cookie-防篡改"><a href="#Cookie-防篡改" class="headerlink" title="Cookie 防篡改"></a>Cookie 防篡改</h1><p>思路一：加密，但是有安全漏洞（加密后的内容可以无限期使用）</p>
<p>思路二：把用户信息隐藏在服务器，这样我就可以自由控制 Cookie 的失效时间</p>
<ul>
<li>把用户信息放在服务器的 <code>session</code> 里，再给信息一个随机 <code>id</code></li>
<li>把随机的 <code>id</code> 发送给浏览器</li>
<li>后端读取的时候，通过 <code>session[id]</code> 获取用户信息</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略与跨域</title>
    <url>/hais-notebook/2020/01/30/2020-01-30-Browser-CrossDomain/</url>
    <content><![CDATA[<p>关于同源策略、CORS 和 JSONP 等的笔记。</p>
<a id="more"></a>

<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><ul>
<li>源：输入 <code>window.origin</code> 或者 <code>location.origin</code>，我们就可以看到 <strong>源</strong>，实际上他就是 <strong>协议 + 域名 + 端口号</strong>。</li>
<li>同源：当两个 url 的源（协议、域名、端口号）完全一致，则称之为 <strong>同源</strong>，比如 <code>https://baidu.com</code> 和 <code>https://www.baidu.com</code> 就不同源。</li>
<li>同源策略：<strong>浏览器</strong> 规定：如果 JS <strong>运行在</strong>源 A 里，那么就不能获取源 B 的数据，这就是 <strong>同源策略</strong> ——不允许不同源的资源 <strong>跨域访问</strong>。</li>
</ul>
<div class="note warning">
            <p>要注意的是，同源策略限制的是 <strong>数据的访问</strong>，引用 CSS、JS 和图片的时候，其实并不知道其内容，只是在 <strong>引用</strong>，因此不受同源策略限制。</p>
          </div>

<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><blockquote>
<p>Cross-Origin Resource Sharing</p>
</blockquote>
<p>只需要在响应头里面写 <code>Access-Control-Allow-Origin: http://foo.example</code> 就可以了，但是 IE 6、7、8、9 都不支持，得用 JSONP。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><blockquote>
<p>JSONP 和 JSON 没有多大关系</p>
</blockquote>
<p>让 <code>frank.com</code> 访问 <code>qq.com</code> 的方法：</p>
<ol>
<li><code>qq.com</code> 将 数据写到 <code>/friends.js</code></li>
<li><code>frank.com</code> 用 <code>script</code> 标签引用 <code>/friends.js</code></li>
<li><code>/friends.js</code> 执行，执行 <code>frank.com</code> 事先定义好的 <code>window.xxx</code> 函数（<code>window.xxx({friends:[...]})</code>）</li>
<li>然后 <code>frank.com</code> 通过 <code>window.xxx</code> 获取到了数据，这也是一个回调</li>
</ol>
<p>但是，JSONP 存在安全性问题：</p>
<ul>
<li>因为每个人都可以引用 js，需要进行 <code>referer</code> 检查</li>
<li>仍然存在安全问题，如果 <code>frank.com</code> 被攻陷，则 <code>qq.com</code> 也被攻陷</li>
</ul>
<p>如何自动生成 window.xxx（如何把 frank.com 定义好的函数传给后台）？</p>
<ul>
<li>通过查询参数</li>
</ul>
<blockquote>
<p>什么是 JSONP？<br>背景：当前浏览器或者由于某些因素导致不支持跨域<br>方法：请求一个 JS 文件，文件会执行一个回调，回调里面有我们的数据，回调的名字可以随机生成，我们把名字用 callback 参数传给后台，后台再返回给我们再执行<br>优点：兼容 IE、可以跨域<br>缺点：由于是 <code>script</code> 标签，所以读不到 AJAX 那么精确的状态（比如 Status、响应头等等），并且只能发 <code>GET</code> 请求，不支持 <code>POST</code></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 异步</title>
    <url>/hais-notebook/2020/01/30/2020-01-30-JS-Async/</url>
    <content><![CDATA[<p>介绍 AJAX 与异步等。</p>
<a id="more"></a>

<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><blockquote>
<p>AJAX 即 Asynchronous JavaScript and XML（异步的 JavaScript 与 XML 技术），其实就是一套综合了多项技术的浏览器端网页开发技术。Google 在它多个著名的交互应用程序中使用了这套技术，如 Google 讨论组、Google 地图、Google 搜索建议、Gmail 等，这使得人们看到了前端领域新的可能性。</p>
<p>传统的 Web 应用允许用户端填写表单（form），当提交表单时就向网页服务器发送一个请求；服务器接收并处理传来的表单，然后送回一个<strong>新的网页</strong>。</p>
<p>但这个做法浪费了许多带宽，因为在前后两个页面中的大部分 HTML 码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>与此不同，AJAX 应用可以仅向服务器发送并取回必须的数据，并在客户端采用 JavaScript 处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p>
</blockquote>
<p>简单来讲：</p>
<ol>
<li>AJAX 是浏览器上的功能，浏览器可以使用 AJAX 发请求、收响应；</li>
<li>浏览器在 <code>window</code> 上面加了一个 <code>XMLHttpRequest</code>，方便开发者通过 JS 来发请求、收响应，这是一个构造函数</li>
</ol>
<h2 id="加载-CSS-JS-HTML-XML"><a href="#加载-CSS-JS-HTML-XML" class="headerlink" title="加载 CSS / JS / HTML / XML"></a>加载 CSS / JS / HTML / XML</h2><p>如果想要使用 <code>XMLHttpRequest</code> 让浏览器来帮我们加载 CSS / JS / HTML / XML，一共需要进行四步：</p>
<ol>
<li>创建 <code>XMLHttpResquest</code> 对象</li>
<li>调用他的 <code>open()</code> 方法</li>
<li>使用 <code>onreadystatechange</code> 监听他的成功和失败事件</li>
<li>调用他的 <code>send()</code> 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/&#123;url&#125;'</span>)</span><br><span class="line">request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      alert(<span class="string">'success'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">'error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure>

<p>HTTP 里面可以装 HTML / CSS / JS / XML 等，但得知道怎么解析他们：</p>
<ul>
<li>拿到 CSS 之后生成 <code>&lt;style&gt;</code> 标签</li>
<li>拿到 JS 之后生成 <code>&lt;script&gt;</code> 标签</li>
<li>拿到 HTML 之后使用 <code>innerHTML</code> 和 DOM API，可以新建一个 <code>div</code></li>
<li>拿到 XML 之后的 <code>request.responseXML</code> 实际上已经是一个 DOM 节点了</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<p>JavaScript Object Natation，JSON 不是对象，而是一种标记语言（就像 HTML、XML、Markdown），用来展示数据，<a href="http://json.org/json-zh.html" target="_blank" rel="noopener">JSON 中文官网</a></p>
</blockquote>
<h3 id="JSON-的数据类型"><a href="#JSON-的数据类型" class="headerlink" title="JSON 的数据类型"></a>JSON 的数据类型</h3><ul>
<li>string（但是只支持双引号）</li>
<li>number（支持科学计数法）</li>
<li>bool</li>
<li>null</li>
<li>object</li>
<li>array</li>
</ul>
<div class="note warning">
            <p>JSON 中，不支持函数和变量</p>
          </div>

<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><blockquote>
<p>反序列化</p>
</blockquote>
<ul>
<li>将符合 JSON 语法的字符串转换为 JS 对应类型的数据</li>
<li>JSON 字符串 ⇒ JS 数据</li>
<li>由于 JSON 只有六种类型，所以转换出的数据也只有六种</li>
<li>如果不符合 JSON 语法，则会抛出 Error，一般用 try catch 捕获错误，比如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	object = <span class="built_in">JSON</span>.parse(<span class="string">`&#123;'name':'harvey'&#125;`</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'出错了，错误详情是：'</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(error)</span><br><span class="line">	object = &#123;<span class="string">'name'</span>: <span class="string">'no name'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object)</span><br></pre></td></tr></table></figure>

<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><blockquote>
<p>序列化</p>
</blockquote>
<ul>
<li>是 JSON.parse 的逆运算</li>
<li>JS 数据 ⇒ JSON 字符串</li>
<li>由于 JS 的数据类型比 JSON 多，所以不一定能够成功</li>
<li>如果失败，则会抛出一个 Error 对象</li>
</ul>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><ul>
<li><strong>同步</strong>： <strong>能直接拿到结果，不拿到结果就不离开</strong>，就像医院挂号一样，可能需要花上几分钟，但是 <strong>拿到号之后才会离开窗口</strong></li>
<li><strong>异步</strong>： <strong>不能直接拿到结果</strong>，比如在餐厅门口等位，拿到号之后我们可以去逛街，那什么时候真正吃上饭呢？我们可以：<ul>
<li>每 10 分钟去餐厅问一下（<strong>轮询</strong>）</li>
<li>也可以扫码用微信接收通知（<strong>回调</strong>）</li>
</ul>
</li>
</ul>
<p>AJAX 举例：当 <code>request.send()</code> 之后，并不能直接得到 <code>response</code>，必须要等待 <code>readyState</code> 变成 <code>4</code> 之后，浏览器回头调用 <code>request.onreadystatechange</code> 函数</p>
<h2 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h2><ul>
<li>写给自己的函数，不是回调</li>
<li>写给别人用的函数，放在一个地方，让他来调用，就是回调</li>
<li><code>request.onreadystatechange</code>，是写给浏览器调用的，意思是让浏览器回头调一下这个函数</li>
</ul>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">f2(f1)</span><br><span class="line"><span class="comment">// 我调用了 f2，因此 f2 不是回调</span></span><br><span class="line"><span class="comment">// 我把 f1 传给了 f2</span></span><br><span class="line"><span class="comment">// 我没有调用，而是 f2 调用了 f1</span></span><br><span class="line"><span class="comment">// 所以 f1 是回调</span></span><br></pre></td></tr></table></figure>

<h2 id="异步与回调"><a href="#异步与回调" class="headerlink" title="异步与回调"></a>异步与回调</h2><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>异步任务需要在得到结果时通知 JS 来拿结果，怎么通知呢？</p>
<ol>
<li>可以让 JS 留一个函数地址（电话号码）给浏览器</li>
<li>异步任务完成之后，浏览器调用该函数的地址（拨打电话）</li>
<li>同时 <strong>把结果作为参数</strong> 传给该函数（电话里说可以来吃了）</li>
</ol>
<p>这个函数是我写给浏览器调用的，所以是回调函数</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>异步任务需要用回调函数来通知结果</p>
<ul>
<li>但异步也可以用 <strong>轮询</strong></li>
<li>回调也不一定用在异步里面，比如 <code>array.forEach( n ⇒ console.log(n) )</code>，这就是 <strong>同步回调</strong></li>
</ul>
<h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">MDN Async Function</a></p>
<p>如果一个函数的返回值处于以下这三个内部，即为异步函数：</p>
<ul>
<li><code>setTimeout</code></li>
<li>AJAX（即 <code>XMLHttpRequest</code>）</li>
<li><code>AddEventListener</code></li>
</ul>
<p>也可以设置同步的 AJAX，<code>request.open(&quot;get&quot;, &quot;/5.json&quot;, false)</code>，但是这样会使页面在请求期间卡住</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) + <span class="number">1</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是按上面这样写，将拿不到 1 ~ 6 的随机数，而是 undefined</span></span><br><span class="line"><span class="keyword">const</span> n = 摇骰子()</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调来拿到异步的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x) &#125;</span><br><span class="line">摇骰子(f1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化代码，因为 f1 只用了一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) +<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">摇骰子(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以再简化为</span></span><br><span class="line">摇骰子(<span class="built_in">console</span>.log) <span class="comment">// 但是如果参数个数不一致就不能这样简化</span></span><br></pre></td></tr></table></figure>

<p>可以再看一下下面这道题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(array) <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 正确的写法，i 和 arr 可以省略</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> paseInt(item)</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 最开始的写法相当于</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> paseInt(item, i, arr)</span><br><span class="line">    <span class="comment">// parseInt('1', 0, arr)，0 为无效参数，忽略</span></span><br><span class="line">    <span class="comment">// parseInt('2', 1, arr)，相当于把 '2' 作为 1 进制来进行解析 =&gt; NaN</span></span><br><span class="line">    <span class="comment">// parseInt('3', 2, arr)，相当于把 '3' 作为 2 进制来进行解析 =&gt; NaN</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>如果异步任务有两个结果：成功或失败，怎么做？</p>
</blockquote>
<p>方法一：回调接受两个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./1.txt'</span>, (error, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123; <span class="built_in">console</span>.log(<span class="string">'失败'</span>); <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>方法二：使用两个回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/1.json'</span>, data=&gt;&#123;&#125;, error=&gt;&#123;&#125;)</span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/1.json'</span>, &#123;</span><br><span class="line">  success: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;, <span class="attr">fail</span>: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是这两个方法都有问题：</p>
<ol>
<li>不规范，名称五花八门，有人用 <code>success + error</code>，有人用 <code>success + fail</code>，有人用 <code>done + fail</code></li>
<li>容易出现回调地狱，代码看不懂</li>
<li>很难进行错误处理</li>
</ol>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getUser( <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  getGroups( user, groups =&gt; &#123;</span><br><span class="line">    groups.forEach( <span class="function">(<span class="params">g</span>) =&gt;</span> &#123;</span><br><span class="line">      g.filter( <span class="function"><span class="params">x</span> =&gt;</span> x.owenerId === user.id)</span><br><span class="line">        .forEach( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;success, fail&#125; = options</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method, url)</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">       success.call(<span class="literal">null</span>, request.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">        fail.call(<span class="literal">null</span>, request, request.status)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/xxx'</span>, &#123;</span><br><span class="line">  success(response)&#123;&#125;, <span class="attr">fail</span>:<span class="function">(<span class="params">request, status</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;)  <span class="comment">// 左边是 function 的缩写，右边是箭头函数</span></span><br></pre></td></tr></table></figure>

<p>↑ 上面是普通的写法，↓ 下面是 Promise 的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="comment">// return new Promise((resolve, reject)=&gt;&#123;..&#125;)</span></span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(request.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">          resolve.call(<span class="literal">null</span>, request.response)  <span class="comment">// 成功调用 resolve(result)，他再回调用第一个函数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">          reject.call(<span class="literal">null</span>, request)  <span class="comment">// 失败调用 reject(error)，他再会调用第二个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/xxx'</span>)</span><br><span class="line">  .then( <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;&#125;, (request) =&gt; &#123;&#125; )   <span class="comment">// Promise 的回调（成功/失败）只能接受一个参数</span></span><br></pre></td></tr></table></figure>

<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><ul>
<li>如果传入的参数是一个空的可迭代对象，比如空数组，则返回一个已完成（already resolved）状态的 Promise。</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。</li>
<li>其它情况下返回一个处理中（pending）的Promise。</li>
</ul>
<p>返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。（如果都成功，则成功；有一个失败，则失败）</p>
<p>返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 1337, "foo"] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>可以传入多个 promise，谁快，Promise.race() 就会跟谁一样，如果传的迭代是空的，则返回的 promise 将永远等待。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 入门</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-Tools-Git/</url>
    <content><![CDATA[<p>主要记录 Git 的基本用法及一些坑的解决。</p>
<a id="more"></a>

<h1 id="Git-本地仓库"><a href="#Git-本地仓库" class="headerlink" title="Git 本地仓库"></a>Git 本地仓库</h1><h2 id="六行配置"><a href="#六行配置" class="headerlink" title="六行配置"></a>六行配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name [username] </span><br><span class="line">git config --global user.email [useremail@example.com]</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">"code --wait"</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>git init</code></td>
<td>创建 <code>.git</code> 目录，容纳代码快照</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>准备将文件提交进 git 目录（本地仓库），路径可以是绝对路径、相对路径、<code>.</code>（当前目录）和 <code>*</code></td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看目前的状态</td>
</tr>
<tr>
<td><code>git commit</code></td>
<td>提交（实际上是复制到了.git目录）</td>
</tr>
<tr>
<td><code>git commit -m &quot;version1&quot;</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>git commit -v（--verbose）</code></td>
<td>推荐，提交理由写得更详细</td>
</tr>
<tr>
<td><code>git reset --hard xxxxxx（提交号的前六位）</code></td>
<td>这个操作会使没有 commit 过的变动消失</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看历史记录</td>
</tr>
<tr>
<td><code>git reflog</code></td>
<td>查看包括 reset 的历史记录</td>
</tr>
<tr>
<td><code>git branch xxx</code></td>
<td>基于当前的commit创建一份新的分支</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看所有分支和当前分支</td>
</tr>
<tr>
<td><code>git branch -d xxx</code></td>
<td>删除分支</td>
</tr>
<tr>
<td><code>git checkout xxx</code></td>
<td>切换分支，当前未提交的文件如果与另一个分支不冲突，切换分支的操作就不会产生影响，如果冲突，可以用git stash或合并冲突</td>
</tr>
<tr>
<td><code>git merge xxx</code></td>
<td>合并分支，先到达想要保留的分支再使用</td>
</tr>
</tbody></table>
<p><code>.gitignore</code> 文件中可以输路径来忽略不想提交的文件，比如 <code>node_modules</code> <code>DS_Store</code> <code>.idea</code> <code>.vscode</code></p>
<h1 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个私钥和公钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C [useremail@example.com]</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传一个本地仓库</span></span><br><span class="line">git remote add origin [git@github.com:Hyuain/git-demo-1.git]</span><br><span class="line">git push -u origin master <span class="comment"># 一个新的分支需要写 -u 和后面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git：创建一个新目录，与 xxx 同名</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git yyy：创建一个新目录，命名为 yyy</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git .：不会新建目录，使用当前目录容纳代码和 .git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="comment"># git stash：把文件藏起来</span></span><br><span class="line"><span class="comment"># git stash pop：再把文件取出来</span></span><br></pre></td></tr></table></figure>

<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias ga="git add"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gc="git commit -v"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gl="git pull"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gp="git push"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gco="git checkout"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gst="git status -sb"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">code ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后加上</span></span><br><span class="line"><span class="built_in">alias</span> glog=<span class="string">"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit -- | less"</span></span><br></pre></td></tr></table></figure>

<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="git-log-中文乱码"><a href="#git-log-中文乱码" class="headerlink" title="git log 中文乱码"></a>git log 中文乱码</h2><p>输入以下命令即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>

<h2 id="git-push-clone-报错"><a href="#git-push-clone-报错" class="headerlink" title="git push / clone 报错"></a>git push / clone 报错</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>防火墙添加 22 端口入站策略配置为允许，有时候不能解决问题。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ol>
<li>在 <code>~/.ssh</code> 存放密钥（<code>id_rsa</code> 和 <code>id_rsa.pub</code>）的文件夹，新建 <code>config</code>，内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User XXX@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>刷新 <code>config</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"XXX"</span></span><br><span class="line">git config --global user.email XXX@xx.com</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>有时候还是不能解决问题</p>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><ol>
<li>修改 hosts 文件，也可以进入 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress</a> 查询这域名的 IP 地址。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>刷新 DNS 缓存</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-Tools-Command/</url>
    <content><![CDATA[<p>主要记录命令行的基本用法。</p>
<a id="more"></a>

<h1 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd ~</code></td>
<td>~ 表示用户目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>Print Work Directory，展示当前的绝对路径</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>List，查看当前目录文件内容（默认不显示以 <code>.</code> 开头的文件）</td>
</tr>
<tr>
<td><code>ls [file path]</code></td>
<td>查看文件路径内容</td>
</tr>
<tr>
<td><code>ls -l</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>Concatenate，打印文件内容</td>
</tr>
<tr>
<td><code>head</code></td>
<td>展示前 10 行文件，或者 <code>-n [数字]</code></td>
</tr>
<tr>
<td><code>tail</code></td>
<td>展示后 10 行文件</td>
</tr>
<tr>
<td><code>less</code></td>
<td>进入一个可滚动的界面，按上、下（或 J、K ）滚动，按 Q 退出</td>
</tr>
</tbody></table>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>touch</code></td>
<td>创建空文件，可以同时创建多个文件；或者修改文件的更新时间</td>
</tr>
<tr>
<td><code>echo</code></td>
<td>返回你 <code>echo</code> 的东西</td>
</tr>
<tr>
<td><code>echo [content] &gt; 4.txt</code></td>
<td>创建有内容的文件，会覆盖之前的内容</td>
</tr>
<tr>
<td><code>echo [content] &gt;&gt; 4.txt</code></td>
<td>追加内容</td>
</tr>
<tr>
<td><code>echo -e &quot;[content]\n&quot; &gt;&gt; 4.txt</code></td>
<td>有换行的内容</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录，可以同时创建多个目录</td>
</tr>
<tr>
<td><code>mkdir -p a/b/c/d</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>cp [filename] [new filename]</code></td>
<td>复制文件</td>
</tr>
<tr>
<td><code>cp -r [dir] [new dir]</code></td>
<td>复制目录</td>
</tr>
</tbody></table>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>rm</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>rm -r</code></td>
<td>删除目录</td>
</tr>
<tr>
<td><code>rm -rf</code></td>
<td>强制删除（不管里面有没有内容）</td>
</tr>
</tbody></table>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>使用 VSCode 打开</td>
</tr>
<tr>
<td><code>start</code></td>
<td>使用默认程序打开</td>
</tr>
<tr>
<td><code>mv [filename] .</code></td>
<td>移动到当前目录</td>
</tr>
<tr>
<td><code>mv [filename] [new filename]</code></td>
<td>重命名文件</td>
</tr>
</tbody></table>
<h2 id="命令的组合"><a href="#命令的组合" class="headerlink" title="命令的组合"></a>命令的组合</h2><ul>
<li>成功返回 <code>0</code>，失败返回 <code>error</code> 和非 <code>0</code> 值，通过 <code>echo $?</code> 查看</li>
<li><code>&amp;&amp;</code>：第一条命令后才会执行后面的</li>
<li><code>;</code>：不管前面是否成功都会执行后面的</li>
</ul>
<h2 id="把命令变成文件"><a href="#把命令变成文件" class="headerlink" title="把命令变成文件"></a>把命令变成文件</h2><ul>
<li>MAC上需要执行：<code>chmod +x [filename]</code>，赋予执行权限</li>
<li>执行命令：<code>./[filename]</code> 或者 <code>sh [filename]</code></li>
<li>如果加入 <code>PATH</code>，就可以不用输入文件路径，也不用输入 <code>./</code>，输入文件名就能执行</li>
<li>命令行的本质就是可执行文件</li>
<li>windows 会优先去找 <code>.exe</code> 的文件</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM API</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-DOM/</url>
    <content><![CDATA[<p>Document Object Model，即将网页抽象成对象，并用 JS 进行操作的方式。</p>
<a id="more"></a>

<h1 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.id <span class="comment">// 或者直接 id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'idxxx'</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'div&gt;span:nth-child(2)'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'.red'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="获取特定的元素"><a href="#获取特定的元素" class="headerlink" title="获取特定的元素"></a>获取特定的元素</h2><ul>
<li>获取 html： <code>document.documentElement</code></li>
<li>获取 head： <code>document.head</code></li>
<li>获取 body： <code>document.body</code></li>
<li>获取 window： <code>window</code></li>
<li>获取所有元素： <code>document.all</code>，第 6 个 <code>falsy</code> 值，别的浏览器为了不使用为了 IE 设计的代码（这个是 IE 发明的）</li>
</ul>
<h2 id="获取的元素的原型"><a href="#获取的元素的原型" class="headerlink" title="获取的元素的原型"></a>获取的元素的原型</h2><p>div 的原型链：</p>
<p><code>HTMLDivElement.prototype</code> → <code>HTMLElement.prototype</code> → <code>Elment.prototype</code> → <code>Node.prototype</code> → <code>EventTarget.prototype</code> → <code>Object.prototype</code></p>
<h2 id="节点（Node）和元素（Element）的区别"><a href="#节点（Node）和元素（Element）的区别" class="headerlink" title="节点（Node）和元素（Element）的区别"></a>节点（Node）和元素（Element）的区别</h2><p>使用 x.nodeType 可以得到一个数字：</p>
<ul>
<li>1 表示 Element（也叫 Tag ）</li>
<li>3 表示 Text</li>
<li>8 表示 Comment</li>
<li>9 表示 Document</li>
<li>11 表示 DocumentFragment</li>
</ul>
<h2 id="获取附近的元素"><a href="#获取附近的元素" class="headerlink" title="获取附近的元素"></a>获取附近的元素</h2><ul>
<li>查爸爸： <code>div.parentNode</code> 或者 <code>div.parentElement</code></li>
<li>查子代： <code>div.childNodes</code> 或者 <code>div.children</code>，推荐使用后者，因为前者包括了文本节点，比如空格，两者都会实时变化</li>
<li>查兄弟姐妹： <code>div.parentNode.childNodes</code> 或者 <code>div.parentNode.children</code>，然后再排除自己</li>
<li>查看老大： <code>div.firstChild</code></li>
<li>查看老幺： <code>div.lastChild</code></li>
<li>查看上一个哥哥： <code>div.previousSibling</code>（有可能查到文本节点，可以用 <code>div.previousElementSibling</code>）</li>
<li>查看下一个弟弟： <code>div.nextSibling</code>（有可能查到文本节点，可以用 <code>div.nextElementSibling</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历一个 div 里面所有的元素</span></span><br><span class="line">travel = <span class="function">(<span class="params">node, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  fn(node)</span><br><span class="line">    <span class="keyword">if</span>(node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">      travel(node.children[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">travel(div1, (node) =&gt; <span class="built_in">console</span>.log(node))</span><br></pre></td></tr></table></figure>

<h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><h2 id="创建一个标签"><a href="#创建一个标签" class="headerlink" title="创建一个标签"></a>创建一个标签</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="创建一个文本节点"><a href="#创建一个文本节点" class="headerlink" title="创建一个文本节点"></a>创建一个文本节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">text = <span class="built_in">document</span>.createTextNode(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在标签里面插入文本"><a href="#在标签里面插入文本" class="headerlink" title="在标签里面插入文本"></a>在标签里面插入文本</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div1.appendChild(text1)</span><br><span class="line">div1.innerText = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">div1.textContent = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">//但是不能用</span></span><br><span class="line">div.appendChild(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="插入到页面中"><a href="#插入到页面中" class="headerlink" title="插入到页面中"></a>插入到页面中</h2><ul>
<li><code>document.body.appendChild(div)</code> 或者 <code>已经在页面中的元素.appendChild(div)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有 div#test1 和 div#test2</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">test1.appendChild(div)</span><br><span class="line">test2.appendChild(div)</span><br><span class="line"><span class="comment">// div 最终只会出现在 test2 里面</span></span><br></pre></td></tr></table></figure>

<ul>
<li>让两个地方都有： <code>let div2 = div1.cloneNode(true)</code>，如果后面为 <code>true</code> 则使用深拷贝，所有的后代也会被拷贝</li>
</ul>
<h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.parentNode.removeChild(div)</span><br><span class="line">div.remove()</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>如果一个 Node 被移除了页面（DOM）树，它还可以再被放回去，它暂存在了内存里面，如果想删除，<code>div = null</code>，一会儿会自动回收</p>
          </div>

<h1 id="编辑节点"><a href="#编辑节点" class="headerlink" title="编辑节点"></a>编辑节点</h1><h2 id="编辑属性"><a href="#编辑属性" class="headerlink" title="编辑属性"></a>编辑属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.className = <span class="string">'red blue'</span><span class="comment">// 会覆盖掉之前的 class，要用 div.className += ' red'</span></span><br><span class="line"></span><br><span class="line">div.classList.add(<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line">div.style = <span class="string">'color: blue'</span></span><br><span class="line"><span class="comment">// 会覆盖掉之前的 style，一般就写 style 的一部分</span></span><br><span class="line"><span class="comment">// 比如 div.style.color = 'blue'，注意大小写问题：div.style.backgroundColor</span></span><br><span class="line"></span><br><span class="line">div.setAttribute(<span class="string">'data-x'</span>, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">div.getAtrribute(<span class="string">'data-x'</span>) <span class="comment">// 强加的，这样写也行</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>如果用 <code>a.href</code> 获取属性，然后是相对路径的话，他会把域名一起弄下来<br>如果用 <code>a.href.getAttribute(&#39;href&#39;)</code> 只获取属性里面写了的部分</p>
          </div>

<h2 id="编辑事件"><a href="#编辑事件" class="headerlink" title="编辑事件"></a>编辑事件</h2><ul>
<li><code>div.onclick</code> 默认为 <code>null</code>，如果改成 <code>fn</code>，那么在点击的时候就会调用 <code>fn.call(div, event)</code>，<code>event</code> 包含了点击事件的所有信息，比如坐标</li>
<li><code>div.addEventListener</code></li>
</ul>
<h2 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h2><h3 id="编辑文本内容"><a href="#编辑文本内容" class="headerlink" title="编辑文本内容"></a>编辑文本内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerText = <span class="string">'hi'</span></span><br><span class="line">test.textContent = <span class="string">'hi'</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-HTML-内容"><a href="#修改-HTML-内容" class="headerlink" title="修改 HTML 内容"></a>修改 HTML 内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 里面的字符不能超过两万个</span></span><br></pre></td></tr></table></figure>

<h3 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 先清空</span></span><br><span class="line">test.appendChild(div) <span class="comment">//再加内容</span></span><br></pre></td></tr></table></figure>

<h2 id="跨线程"><a href="#跨线程" class="headerlink" title="跨线程"></a>跨线程</h2><p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.start</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.end</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.classList.add(<span class="string">'start'</span>)</span><br><span class="line">test.clientWidth <span class="comment">// 如果没有这句话，上下两句话就会合并，这句话会触发重新渲染</span></span><br><span class="line">test.classList.add(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><ul>
<li>标准属性，会自动同步，比如 <code>id</code> <code>className</code> <code>title</code></li>
<li><code>data-*</code> 属性，也会自动同步</li>
<li>非标准属性，不会同步到页面里，只会停留在JS 线程中，而不会自动同步到页面上</li>
</ul>
<p><img src="/hais-notebook/images/JS-007.png" alt=""><br><img src="/hais-notebook/images/JS-008.png" alt=""></p>
<div class="note warning">
            <p>自定义属性最好以 <code>data-</code> 为前缀</p>
          </div>

<h3 id="Property-和-Attribute"><a href="#Property-和-Attribute" class="headerlink" title="Property 和 Attribute"></a>Property 和 Attribute</h3><ul>
<li>Property 是 JS 线程中 div1 的所有属性</li>
<li>Attribute 是 渲染引擎中 div1 对应标签的属性</li>
<li>大部分时候，同名的 Property 和 Attribute 值相等</li>
<li>如果不是标准属性，那么他们俩只会在一开始的时候相等</li>
<li>但注意 Attribute 只支持字符串，而 Property 支持字符串、布尔等类型</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 世界</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-World/</url>
    <content><![CDATA[<p>介绍 JavaScript 这个世界从诞生开始的故事。</p>
<a id="more"></a>

<h1 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h1><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><ul>
<li>固件是固定在主板上的存储设备，里面有开机程序</li>
<li>开机程序会将文件里的 OS 加载到内存里运行</li>
</ul>
<h2 id="操作系统（以-Linux-为例）"><a href="#操作系统（以-Linux-为例）" class="headerlink" title="操作系统（以 Linux 为例）"></a>操作系统（以 Linux 为例）</h2><ul>
<li>首先加载操作系统内核</li>
<li>然后启动初始化进程，编号为 1，每个进程都有 PID</li>
<li>启动系统服务：文件、安全、联网</li>
<li>等待用户登录：输入密码登录 / ssh 登录</li>
<li>登录后，运行 shell，用户就可以和操作系统对话了</li>
<li>bash 是一种 shell，图形化界面可认为是一种 shell</li>
</ul>
<h1 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h1><h2 id="chrome-exe"><a href="#chrome-exe" class="headerlink" title="chrome.exe"></a>chrome.exe</h2><ul>
<li>运行 chrome.exe 文件</li>
<li>开启 chrome 进程，作为主进程</li>
<li>主进程会开启一些辅助进程，如网络服务、GPU 加速</li>
<li>每新建一个标签，就有可能开启一个子进程</li>
</ul>
<h2 id="浏览器的功能"><a href="#浏览器的功能" class="headerlink" title="浏览器的功能"></a>浏览器的功能</h2><ul>
<li>发起请求、下载 HTML、解析 HTML、下载 CSS、解析 CSS、渲染界面、下载 JS、解析 JS、执行 JS</li>
<li>功能模块：用户界面、渲染引擎、JS 引擎、存储等，这些功能模块属于不同的线程<ul>
<li>JS 通过<strong>跨线程通信</strong>，使渲染引擎重新渲染</li>
<li>JS 是单线程的</li>
<li>DOM 操作慢：跨线程通信慢</li>
</ul>
</li>
</ul>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><ul>
<li>浏览器用的什么 JS 引擎？<ul>
<li>Chrome 用的是 V8 引擎，C++ 编写</li>
<li>网景用的是 SpiderMonkey，后被 Firefox 使用，C++</li>
<li>Safari 用的是 JavaScriptCore</li>
<li>IE 用的是 Chakra（JScript 9）</li>
<li>Edge 用的是 Chakra (JavaScript)</li>
<li>Node.js 用的是 V8 引擎</li>
</ul>
</li>
<li>主要功能<ul>
<li>编译：把 JS 代码翻译为机器能执行的字节码或机器码</li>
<li>优化：改写代码，使其更加高效</li>
<li>执行：执行上面的字节码或机器码</li>
<li>垃圾回收：把 JS 用完的内存回收，方便之后再次使用</li>
</ul>
</li>
</ul>
<h2 id="运行-JavaScript-代码"><a href="#运行-JavaScript-代码" class="headerlink" title="运行 JavaScript 代码"></a>运行 JavaScript 代码</h2><ul>
<li>准备工作<ul>
<li>提供 API： window、document、setTimeout（这些功能成为运行环境 runtime env）</li>
</ul>
</li>
<li>内存图<ul>
<li><img src="/hais-notebook/images/JS-002.png" alt=""></li>
<li>红色区域（存放数据，但不会存变量名）<ul>
<li>Stack 栈：每个数据顺序存放，非对象都存在 Stack</li>
<li>Heap 堆：每个数据随机存放，对象都存在 Heap（数组、函数）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JavaScript-世界"><a href="#JavaScript-世界" class="headerlink" title="JavaScript 世界"></a>JavaScript 世界</h1><blockquote class="blockquote-center"><p><strong>JS 公式：<code>对象.__proto__ === 其构造函数.prototype</code></strong><br><strong>根公理：<code>Object.prototype</code> 是所有对象的（直接或间接）原型</strong><br><strong>函数公理：所有函数都是由 <code>Function</code> 构造的</strong></p>
</blockquote>

<p><img src="/hais-notebook/images/JS-003.png" alt=""><br><img src="/hais-notebook/images/JS-004.png" alt=""><br><img src="/hais-notebook/images/JS-005.png" alt=""><br><img src="/hais-notebook/images/JS-006.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Function</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Function/</url>
    <content><![CDATA[<p>正式介绍 JavaScript 中的函数。</p>
<a id="more"></a>

<h1 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h1><h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参</span>) </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>) </span>&#123; 函数体 &#125; <span class="comment">// 右边的部分也叫函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">形参</span>)</span>&#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 如果函数的声明是在 = 右边</span></span><br><span class="line"><span class="comment">// fn 的作用域只能在 = 右边</span></span><br><span class="line"><span class="comment">// 别的地方不能用 fn 这个名字</span></span><br></pre></td></tr></table></figure>

<h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入参数 =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> 语句</span><br><span class="line">&#125;</span><br><span class="line">x =&gt; (&#123; <span class="attr">name</span>: <span class="string">'...'</span> &#125;) <span class="comment">// 如果要返回对象，就要加圆括号</span></span><br></pre></td></tr></table></figure>

<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数可以先使用再声明，因为 function 会跑到最前面<br>但是 <code>let fn = function(){}</code> 不是函数提升，他不能先使用再声明，因为这句话是赋值，右边的匿名函数不会提升</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li><strong>全局变量与局部变量</strong>：在 <strong>顶级作用域</strong> 声明的变量是全局变量（比如 window 上的变量是全局变量）；其他的都是局部变量</li>
<li><strong>就近原则</strong>：如果有多个作用域有同名变量 <code>a</code>，那么查找 <code>a</code> 的声明时，就向上取最近的作用域</li>
<li><strong>作用域的确定与函数的执行无关（JavaScript 的作用域为静态作用域），但变量的值在函数执行的时候才能确定</strong></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>函数用到了外部的变量，则函数+这个变量=闭包，作用域遵循就近原则</p>
</blockquote>
<p>闭包的作用：隐藏局部变量，暴露操作函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = createAdd()</span><br><span class="line">add() <span class="comment">// 1</span></span><br><span class="line">add() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>闭包的缺点：容易内存泄露。注意，虽然闭包并不会造成内存泄露，真实原因是 JS 引擎的实现有问题。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>复制内存图中 stack 里面的东西（简单类型复制值，对象复制地址）</p>
<h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>实际上就是变量声明： <code>var x = arguments[0]</code></p>
<div class="note warning">
            <p>形参可多可少</p>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>每个函数都有返回值，默认是 <code>undefined</code></li>
<li>只有函数才有返回值</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><ul>
<li>JS 在调用函数之前，需要把函数的环境 push 到一个数组（调用栈）里面，等函数执行完之后把环境 pop 出来，然后 return 到之前的环境中</li>
<li>递归很容易把栈压满：爆栈</li>
<li>调用栈最长有多少？Chrome 12578；Firefox 26773；Node 12536</li>
</ul>
<h1 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h1><blockquote>
<p>关于 this 更多的内容可以看看这篇文章—— <a href="https://hais-teatime.com/post/2019-12-24-this/" target="_blank" rel="noopener">再看 this</a>。</p>
</blockquote>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>调用函数即传入 arguments， arguments 是包含传入参数的伪数组</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><code>this</code> 的存在是为了解决函数获取一个对象的引用的问题</li>
<li>如果不给任何的条件， <code>this</code> 为 <code>window</code></li>
<li>如果想要指定 <code>this</code>，要用 <code>fn.call(xxx, 1, 2, 3)</code> 传入 <code>this</code> 和 <code>arguments</code>（如果传入的 <code>this</code> 不是对象，将会默认封装成对象，除非加上 <code>&#39;use strict&#39;</code>，JS的糟粕）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this: '</span> + <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">1</span>) <span class="comment">// 'this: 1'</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>) <span class="comment">// 'this: undefined'</span></span><br></pre></td></tr></table></figure>

<h3 id="两种调用函数的方法"><a href="#两种调用函数的方法" class="headerlink" title="两种调用函数的方法"></a>两种调用函数的方法</h3><h4 id="隐式传递"><a href="#隐式传递" class="headerlink" title="隐式传递"></a>隐式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi()</span><br><span class="line"><span class="comment">// 会自动地把 person 传到函数里，作为 this</span></span><br></pre></td></tr></table></figure>

<h4 id="显式传递"><a href="#显式传递" class="headerlink" title="显式传递"></a>显式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi.call(person)</span><br><span class="line"><span class="comment">// 手动把 person 传到函数里，作为 this</span></span><br><span class="line"><span class="comment">// apply 跟 call 的区别就是后面要加中括号（参数传的是数组）</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">p1, p2</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>, p1, p2) &#125;</span><br><span class="line"><span class="keyword">let</span> f3 = f1.bind( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125;, <span class="string">'hi'</span> )</span><br><span class="line">f3()  <span class="comment">// 等价于 f1.call( &#123;name:'hai'&#125;, 'hi' )</span></span><br><span class="line">      <span class="comment">// 相当于让 f3 的 this 和 arguments 永远等于这个</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>没有 <code>arguments</code> 和 <code>this</code>，里面的 <code>this</code> 就是外面的 <code>this</code>，就算加 <code>call</code> 也没有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">fn() <span class="comment">// window</span></span><br><span class="line">fn.call( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125; ) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>只想要一个局部变量，而不想要一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="regexp">/-/</span><span class="number">1</span>*<span class="regexp">/! function ()&#123; var a = 2; console.log(a) &#125; ()</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明了一个全局函数，立即调用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Array/</url>
    <content><![CDATA[<p>JS 的数组不是典型的数组，而是一个对象；<strong>元素的数据类型可以不同，内存不一定连续，是通过字符串下标（而不是数字下标）获取元素</strong>。</p>
<a id="more"></a>

<h1 id="获得新数组"><a href="#获得新数组" class="headerlink" title="获得新数组"></a>获得新数组</h1><h2 id="新建数组"><a href="#新建数组" class="headerlink" title="新建数组"></a>新建数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的简便定义</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的标准写法</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者只传入一个参数，表示数组的长度</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以','分隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'1,2,3'</span>.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有间隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'123'</span>.split(<span class="string">''</span>)</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象转换</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转化为字符串</span></span><br><span class="line"><span class="keyword">let</span> str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<p>数组对象除了 <code>__proto__</code> 之外，还包括 <strong>索引</strong> 和 <strong>长度（<code>length</code>）</strong> 这两个自身属性。</p>
<div class="note warning">
            <p><strong>伪数组</strong>：伪数组的原型链中没有数组的原型<br>比如 <code>let divList = document.querySelector(&#39;div&#39;)</code> 将得到一个伪数组；一个普通的对象只是加上 <code>length</code> 属性，也将得到一个伪数组。<br>通常我们需要把它转化为数组来使用<br><code>let divArray = Array.from(divList)</code></p>
          </div>

<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr1.concat(arr2) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h2 id="截取数组"><a href="#截取数组" class="headerlink" title="截取数组"></a>截取数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">2</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">0</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];  <span class="keyword">delete</span> arr[<span class="string">'0'</span>]</span><br><span class="line"><span class="comment">// arr 为 [ empty, 'b', 'c']，如果3个都是 empty，称为稀疏数组，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改 length 也可以删除数组的元素，不推荐</span></span><br><span class="line"></span><br><span class="line">arr.shift()</span><br><span class="line"><span class="comment">// 删除最开始的元素，并返回他，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.pop()</span><br><span class="line"><span class="comment">// 删除最后一个元素，并返回他，arr 被修改</span></span><br><span class="line"> </span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，并返回删除的部分，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，增加 'x' 和 'y'</span></span><br><span class="line"><span class="comment">// 并返回删除的部分，arr 被修改</span></span><br></pre></td></tr></table></figure>

<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="built_in">Object</span>.values(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`$(index) : $(item)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两种基本没有区别</span></span><br><span class="line"><span class="comment">// 但 for 关键字有 continue 和 break，forEach 没有</span></span><br><span class="line"><span class="comment">// for 是块级作用域，forEach 是函数作用域</span></span><br></pre></td></tr></table></figure>

<h2 id="查找单个元素"><a href="#查找单个元素" class="headerlink" title="查找单个元素"></a>查找单个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexOf(item) <span class="comment">// 有就会返回 index，没有就会返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> ===<span class="number">0</span>) </span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> ===<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素对应的索引</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><strong>索引越界</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[arr.length] === <span class="literal">undefined</span></span><br><span class="line">a[<span class="number">-1</span>] === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
          </div>

<h1 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push()</span><br><span class="line"><span class="comment">// 在尾部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.unshift()</span><br><span class="line"><span class="comment">// 在头部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">8</span>, <span class="number">0</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 增加 'x' 和 'y'，并返回删除的部分（[]），arr 被修改</span></span><br></pre></td></tr></table></figure>

<h1 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reverse() <span class="comment">// arr 被修改</span></span><br><span class="line">arr.sort() <span class="comment">// arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.sort( <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a &gt; b ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a === b ) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回 1，a 在 b 之后</span></span><br><span class="line"><span class="comment">// 返回 0，不变</span></span><br><span class="line"><span class="comment">// 返回 -1，b 在 a 之后</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.score - b.score) <span class="comment">// 按 score 从小到大排序</span></span><br></pre></td></tr></table></figure>

<h1 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h1><p>得到新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map： n 变 n</span></span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter：n 变少</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce：n 变 1</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item, <span class="number">0</span>)</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result.concat(item * item), [])</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span></span><br><span class="line">  result.concat(item % <span class="number">2</span> === <span class="number">1</span> ? [] : item), [])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Object</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Object/</url>
    <content><![CDATA[<p>简单来说，对象实际上就是无序的数据集合，或者说是 <strong>键/值对（Key/Value Paris）</strong>的集合.</p>
<a id="more"></a>

<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>对象有以下这样几种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的简便声明</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 对象的标准写法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对象也可以作为参数直接传入函数</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这里我们需要注意以下几个细节：</p>
<ul>
<li>键名是字符串，不是标识符，可以是任意字符</li>
<li>引号可以省略，省略之后就只能写标识符或者以数字开头</li>
<li><strong>就算引号省略了，键名也还是字符串</strong>（不一定，键名也可能是函数、日期、正则等）</li>
<li>奇怪的属性名： <code>1e2</code> 会变成 <code>&#39;100&#39;</code>， <code>.234</code> 会变成 <code>&#39;0.234&#39;</code>， <code>0xFF</code> 会变成 <code>&#39;255&#39;</code></li>
<li>变量也可以作为属性名，比如：<code>let obj = { [p1]: &#39;harvey&#39; }</code>，这样就会用 <code>p1</code> 里面的值了，<strong>中括号里面的东西都会先求值</strong></li>
</ul>
<h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><h2 id="隐藏的属性"><a href="#隐藏的属性" class="headerlink" title="隐藏的属性"></a>隐藏的属性</h2><p><strong>每一个</strong> 对象都有一个隐藏属性 <code>__proto__</code>，这个属性存着 <strong>一个对象的地址</strong>，这个对象包含了这类对象（普通对象、数组、函数等）的 <strong>共有属性</strong></p>
<p><code>__proto__</code> 里面存的实际上就是 <strong>原型的地址</strong></p>
<p>因此，<strong>每一个对象都有原型</strong></p>
<p>比如 <code>obj = {}</code>，他的原型的地址就存储在 <code>obj.__proto__</code> 中，而<code>obj.__proto__</code> 也是一个对象，因此他也有原型，但我们规定，他的原型值为 <code>null</code></p>
<h2 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h2><p>有以下两种删除对象属性的方法：</p>
<ol>
<li><code>obj.name = undefined</code>，这样做只会删除属性的值，不会把属性完全删除</li>
<li><code>delete obj.name</code>，同时删除属性名和属性值，或者用 <code>delete obj[&#39;name&#39;]</code> 也是可以的</li>
</ol>
<p>删除完成后可以对删除的结果进行检查：</p>
<ol>
<li><code>&#39;name&#39; in obj</code>，检查 <code>&#39;name&#39;</code> 是不是 <code>obj</code> 的属性名，如果是用上面的第一种方法删除，检查的结果将是 <code>true</code>；如果是第二种方法删除，则会返回 <code>false</code>；注意属性名有引号（因为属性名实际上是字符串）</li>
<li><code>&#39;name&#39; in obj &amp;&amp; obj.name === undefined</code>，检查是否含有属性名且值为 <code>undefined</code>，如果是上面第一种方法删除，则会返回 <code>true</code></li>
</ol>
<h2 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h2><ul>
<li><code>Object.keys(obj)</code>，查看 <code>obj</code> 的 <strong>自身</strong> 属性名</li>
<li><code>Object.values(obj)</code>，查看 <code>obj</code> 的  <strong>自身</strong> 属性值</li>
<li><code>Object.entries(obj)</code>，返回结果包含两个数组，第一个数组是 <code>obj</code> 的 <strong>自身</strong> 属性名，第二个数组是 <code>obj</code> 的 <strong>自身</strong> 属性值</li>
<li><code>console.dir(obj)</code>，查看 <code>obj</code> 的 <strong>自身属性 + 共有属性</strong></li>
<li><code>in</code>，查看是不是 <strong>自身属性 + 共有属性</strong> （相当于所有属性）</li>
<li><code>obj.hasOwnProperty(&#39;toString&#39;)</code>，查看 <code>&#39;toString&#39;</code> 是不是 <code>&#39;obj&#39;</code> <strong>自身的</strong> 属性</li>
</ul>
<div class="note warning">
            <p><code>obj.name</code> 等价于 <code>obj[&#39;name&#39;]</code>，不等价于 <code>obj[name]</code></p>
          </div>

<h2 id="添加或修改属性"><a href="#添加或修改属性" class="headerlink" title="添加或修改属性"></a>添加或修改属性</h2><p>直接赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'name'</span>] = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'na'</span>+<span class="string">'me'</span>] = <span class="string">'harvey'</span> <span class="comment">// 因为属性名本质是字符串，上面三句话实际上是一样的</span></span><br></pre></td></tr></table></figure>

<p>批量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj, &#123;<span class="attr">p1</span>:<span class="number">1</span>, <span class="attr">p2</span>:<span class="number">2</span>, <span class="attr">p3</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>但是，不能直接修改共有属性（原型上的属性）：比如，不能通过 <code>obj.toString</code> 来修改原型上的<code>&#39;toString&#39;</code>，这样只会为 <code>obj</code> 增添一个本身的<code>&#39;toString&#39;</code> 属性，而不会修改原型，除非这样写代码（但是这是不推荐的）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型的属性</span></span><br><span class="line">obj.__proto__.toString =</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString =</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(common)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">person.__proto__ = common <span class="comment">// 原型链增加一个环节</span></span><br></pre></td></tr></table></figure>

<h1 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h1><div class="note warning">
            <p>所有的函数自带 prototype<br>prototype 中自带 constructor<br>constructor 里面的东西就是函数的内容</p>
          </div>

<h2 id="new-X"><a href="#new-X" class="headerlink" title="new X()"></a>new X()</h2><ol>
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>X.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现一个类似 new 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.b = b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> X(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NEW</span>(<span class="params">fun, arguments</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = &#123;&#125;</span><br><span class="line">    newObj.__proto__ = fun.prototype</span><br><span class="line">    fun.apply(newObj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = NEW(X, [<span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="构造函数-X"><a href="#构造函数-X" class="headerlink" title="构造函数 X"></a>构造函数 <code>X</code></h2><ul>
<li><code>X</code> 自身用于添加新对象的<strong>自身的属性</strong></li>
<li><code>X.prototype</code> 负责保存对象的<strong>共用属性</strong></li>
</ul>
<p>一般来讲有这样的代码规范：</p>
<ul>
<li>所有构造函数首字母大写，被构造出来的对象首字母小写</li>
<li><code>new</code> 后面的函数使用名词；其他的函数一般用动词开头</li>
</ul>
<h2 id="如何确定一个对象的原型？"><a href="#如何确定一个对象的原型？" class="headerlink" title="如何确定一个对象的原型？"></a>如何确定一个对象的原型？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.__proto__ === 其构造函数.prototype</span><br></pre></td></tr></table></figure>

<h2 id="数据类型与对象的分类"><a href="#数据类型与对象的分类" class="headerlink" title="数据类型与对象的分类"></a>数据类型与对象的分类</h2><blockquote>
<p> 数据类型是 JavaScript 数据的类型，一共有 7 种；<br> 对象的分类则有无数种，常见的有 Array、Function、Date、RegExp 等</p>
</blockquote>
<p>我们常见的有这几种类型的对象：</p>
<ul>
<li><p>数组对象</p>
<ul>
<li>自身属性：<code>&#39;0&#39;</code> <code>&#39;1&#39;</code> <code>&#39;2&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;push&#39;</code> <code>&#39;pop&#39;</code> <code>&#39;shift&#39;</code> <code>&#39;unshift&#39;</code> <code>&#39;join&#39;</code></li>
</ul>
</li>
<li><p>函数对象</p>
<ul>
<li>自身属性：<code>&#39;name&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;call&#39;</code> <code>&#39;apply&#39;</code> <code>&#39;bind&#39;</code></li>
</ul>
</li>
</ul>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><blockquote>
<p><strong>Q: window 是谁构造出来的？</strong><br>A: 可以通过 constructor 属性看出构造者</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Object 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Function 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的，浏览器构造了 Function，然后指定它的构造者是自己</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数据类型与运算符</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-DataTypes-Operators/</url>
    <content><![CDATA[<p>JavaScript 有 7 种数据类型，3 种变量声明的方式，以及一些奇怪的运算符。</p>
<a id="more"></a>

<h1 id="字符存储"><a href="#字符存储" class="headerlink" title="字符存储"></a>字符存储</h1><ul>
<li>如何存数字？十进制转二进制，用十六进制（HEX）表示二进制</li>
<li>如何存字符？转换为数字，48 号表示 0，65 号表示 A，97 号表示 a</li>
<li>如何表示汉字（GB、GBK）？0000~FFFF，16 位，2 字节</li>
<li>Unicode 已收录 13 万字符（大于 16 位），全世界通用，以后还会继续扩充；缺点：两个字节不够用了，至少要三个字节</li>
<li>UTF-8：通过变长的存法，减小容量</li>
</ul>
<h1 id="7-种数据类型"><a href="#7-种数据类型" class="headerlink" title="7 种数据类型"></a>7 种数据类型</h1><blockquote>
<p>4 基 2 空 1 对象</p>
</blockquote>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote>
<p>64 位浮点数组成</p>
</blockquote>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p><code>0</code> <code>+0</code> <code>-0</code><br><code>Infinity</code> <code>+Infinity</code> (1/0) <code>-Infinity</code> (1/-0)<br><code>NaN</code>（0/0，但他还是一个数字，NaN不等于NaN）</p>
<h3 id="范围和精度"><a href="#范围和精度" class="headerlink" title="范围和精度"></a>范围和精度</h3><p><img src="/hais-notebook/images/JS-001.png" alt=""></p>
<p>范围：<code>Number.MAX_VALUE</code> 到 <code>Number.MIN_VALUE</code><br>精度：大概是 15 个十进制有效数字</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>每个字符两个字节（阉割版 UTF-8，两个字符定长）</p>
</blockquote>
<h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>单引号、双引号、反引号，引号不是字符串的一部分</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><code>\r</code> 表示回车， <code>\uFFFF</code> 表示对应的 Unicode 字符， <code>\xFF</code> 表示前256个 Unicode 字符</p>
<h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><p>字符串本来不应该有属性，只有对象才有属性，但是这个有渊源</p>
<ul>
<li>长度： <code>s.length</code></li>
<li>下标： <code>s[0]</code></li>
<li>base64 转码： <code>window.btoa</code> 编码， <code>window.atob</code> 反编码</li>
</ul>
<h2 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h2><blockquote>
<p>否定运算、相等运算、比较运算可以得到 bool 值</p>
</blockquote>
<div class="note warning">
            <p><strong>5 个 falsy 值</strong><br><code>undefined</code> <code>null</code> <code>0</code> <code>NaN</code> <code>&#39;&#39;</code></p>
          </div>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><blockquote>
<p>每个 Symbol 都不一样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>如果声明了没有赋值，默认是 <code>undefined</code><br>如果函数没有写 <code>return</code>，默认是 <code>undefined</code></p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>习惯上把非对象空值写成 undefined，对象空值写成 null；<br>null 通常表示即该处不应该有值，undefined 通常表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><div class="note warning">
            <p>数组、函数、日期都是 Object，不是单独的数据类型，但是使用 <code>typeof</code> 的时候，可以分辨出 function</p>
          </div>

<h1 id="3-种变量声明的方式"><a href="#3-种变量声明的方式" class="headerlink" title="3 种变量声明的方式"></a>3 种变量声明的方式</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ul>
<li>过时的，不好的</li>
<li>函数作用域</li>
<li>可以重复声明</li>
<li>可以先使用再声明</li>
<li>全局声明的 <code>var</code> 变量会变成 <code>window</code> 的属性</li>
</ul>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul>
<li>新的，更合理的</li>
<li>遵循块作用域</li>
<li>不能重复声明</li>
<li>可以赋值，也可以不赋值</li>
<li>必须先声明再使用</li>
<li>全局声明的 <code>let</code> 变量不会再变成 <code>window</code> 的属性</li>
<li><code>let</code> 配合 <code>for</code> 循环有奇效</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>跟 <code>let</code> 几乎一样，但声明时必须赋值，且不能再更改</p>
<div class="note warning">
            <p>变量声明指定值的时候同时也指定了类型，但是 <strong>值和类型都可以随意变化</strong></p>
          </div>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a>Number</h3><ul>
<li>余数 <code>-x % 7</code> 为 <code>-(x % 7)</code></li>
<li>指数 <code>x ** 3</code></li>
<li>自增 <code>a++</code> 表达式的值是 <code>a</code> 加之前的值， <code>++a</code> 表达式的值是 <code>a</code> 加之后的值</li>
<li>求值运算符 <code>+</code>，附属运算符 <code>-</code></li>
</ul>
<h3 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h3><ul>
<li>连接运算 <code>+</code></li>
</ul>
<div class="note warning">
            <p><code>number + string</code>，变成字符串<br><code>string - number</code>，变成数字</p>
          </div>

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><ul>
<li>模糊相等，发生自动类型转换，别用两个等于</li>
<li>JavaScript 三位一体</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title="==="></a>===</h3><p>全等，基本类型看值是否相等，对象看地址是否相等</p>
<ul>
<li><code>[] !== []</code></li>
<li><code>{} !== {}</code></li>
<li><code>NaN !== NaN</code></li>
</ul>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 防止 console.log 报错（防御性编程）</span></span><br><span class="line">a = a || <span class="number">100</span> <span class="comment">// 但是五个 falsy 值都会让 a 为假，因此有 bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用函数来赋初值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><h3 id="或与否"><a href="#或与否" class="headerlink" title="或与否"></a>或与否</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> | <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1111</span></span><br><span class="line">(<span class="number">0b1111</span> &amp; <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1010</span></span><br><span class="line">(~<span class="number">0b1010</span>).toString <span class="comment">// 涉及到补码，留坑</span></span><br></pre></td></tr></table></figure>

<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> ^ <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>按位取反可以用 <code>^1</code></p>
          </div>

<h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">(<span class="number">0b0010</span> &lt;&lt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="头部补零的右移运算符"><a href="#头部补零的右移运算符" class="headerlink" title="头部补零的右移运算符"></a>头部补零的右移运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="如何使用运算符判断奇偶？"><a href="#如何使用运算符判断奇偶？" class="headerlink" title="如何使用运算符判断奇偶？"></a>如何使用运算符判断奇偶？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">偶数 &amp; <span class="number">1</span> === <span class="number">0</span></span><br><span class="line">奇数 &amp; <span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-gt-gt-lt-lt-gt-gt-gt-来取整"><a href="#使用-gt-gt-lt-lt-gt-gt-gt-来取整" class="headerlink" title="使用 ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; | 来取整"></a>使用 <code>~</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> <code>|</code> 来取整</h3><blockquote>
<p>位运算不支持小数，会自动抹去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~ <span class="number">6.83</span> <span class="comment">// 6</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> | <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt;&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-来交换-a-b-的值"><a href="#使用-来交换-a-b-的值" class="headerlink" title="使用 ^ 来交换 a b 的值"></a>使用 <code>^</code> 来交换 <code>a</code> <code>b</code> 的值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版语法</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符"></a>点运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 属性值</span><br></pre></td></tr></table></figure>

<p>如果不是对象，JS会创建一个对象，用完之后再自动删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.xxx = <span class="string">'harvey'</span> <span class="comment">// 'harvey'</span></span><br><span class="line">a.xxx <span class="comment">// undefiend</span></span><br></pre></td></tr></table></figure>

<h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h3><blockquote>
<p>求表达式的值或执行语句，然后 <code>void</code> 的值总为 <code>undefined</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 表达式或语句</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止假动作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"example.com"</span> <span class="attr">onclick</span>=<span class="string">"console.log(hi); return false;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(console.log('hi'))"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote>
<p>表示取后面的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// a 为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'hi'</span>); <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> (<span class="built_in">console</span>.log(<span class="string">'hi'</span>), x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 跟上面是一样的，先执行 console.log，再让 return 为x + 1</span></span><br></pre></td></tr></table></figure>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>圆括号的优先级最高</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 表达式与语句</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Expressions/</url>
    <content><![CDATA[<p>JavaScript 的表达式与语句，包括标识符、block 等概念。</p>
<a id="more"></a>

<h1 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h1><ul>
<li>表达式一般都有值，语句可能有也可能没有</li>
<li>语句一般会改变环境（声明、赋值），逗号表示语句没完</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>          <span class="comment">// 值为 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)      <span class="comment">// 值为函数的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log    <span class="comment">// 值为函数本身</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// 值为函数的返回值：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><code>retrun</code> 后面不能接回车，否则相当于返回 <code>undefined</code></p>
          </div>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 JavaScript 中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。（有时候也可以用其他的 Unicode 字符，比如中文，比如 Emoji）</p>
<h2 id="代码区块-block"><a href="#代码区块-block" class="headerlink" title="代码区块 block"></a>代码区块 block</h2><p>简单来说就是把代码用大括号包在一起</p>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>如果前面是 <strong>真的</strong>，就执行后面的（若前面是假的，表达式的值为前面；若前面是真的，表达式的值为后面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.f1 &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'f1 存在'</span>)</span><br><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 因为 IE 没有 console.log，所以可以这样写防止出错</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="||"></a>||</h2><p>如果前面是 <strong>假的</strong>，就执行后面的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a || <span class="number">100</span> <span class="comment">// 可以用于设置保底值</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 5 5 5 5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">a</span>:<span class="number">1</span> &#125; <span class="comment">// a 是一个 label，值是 1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 序章</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Overview/</url>
    <content><![CDATA[<p>JavaScript 的历史和评价的简单介绍。</p>
<a id="more"></a>

<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>1994 年，网景公司（当时叫 Mosaic Communications）发布了一款名为 <strong>Mosaic Netscape</strong> 的网页浏览器，在四个月内，这款浏览器就占据了四分之三的浏览器市场，并成为 1990 年代互联网的主要浏览器。</p>
<blockquote>
<p>因为世界最早流行的图形接口网页浏览器 <strong>NCSA Mosaic</strong> 是美国国家超级电脑应用中心（NCSA）与 1993 年发布的，网景公司为了避免版权纠纷，将浏览器改名为 <strong>Netscape Navigator</strong>，而公司则改名为 <strong>Netscape Communications</strong>。</p>
</blockquote>
<p>这款浏览器发布之后，网景意识到，<strong>光有静态的页面是不行的，需一种网页脚本语言，使得浏览器可以与网页互动。</strong></p>
<p>1995 年，昇阳（Sun）正式向市场推出 Java，网景公司看到 Java 的前景，决定与之结盟，并在浏览器中支持 Java，但如果直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂。</p>
<p>同年，网景招募了布兰登（Brendan Eich），授意其开发一款 <strong>“未来的脚本语言”</strong> ，这种语言需要：“看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手。”——这个决定就排除了 Perl、Python、Tcl 或 Scheme 这些选项，同时也促成了 JavaScript 的诞生。</p>
<p>由于对 Java 不感兴趣，布兰登只用了十天时间就设计出了这款语言的原型，并命名为 <strong>Mocha</strong>，后续又改名为 <strong>LiveScript</strong>，但在 1995 年 12 月，公司为了蹭 Java 的热度，改名为 <strong>JavaScript</strong>。而事实上，JavaScript 和 Java 关系并不大。</p>
<blockquote>
<p>总的来说，布兰登的设计思路是这样的：</p>
<ol>
<li>借鉴 C 的基本语法；</li>
<li>借鉴 Java 的数据类型和内存管理；</li>
<li>借鉴 Scheme，将函数提升到“第一等公民”（first class）的地位；</li>
<li>借鉴 Self，使用基于原型（prototype）的继承机制。</li>
</ol>
</blockquote>
<p>由于 JavaScript 在浏览器上的大获成功，微软（Microsoft）在后续推出的 IE 3 上也使用了 <strong>JScript</strong> ——这与 JavaScript 是类似、但不同标准的语言。于是当年市场上出现了两者对峙的情况，网页设计者通常会在主页放上“用Netscape可达到最佳效果”或“用IE可达到最佳效果”的标志。</p>
<p>1996 年 11 月，网景正式向 <strong>欧洲计算机制造商协会（ECMA）</strong> 提交语言标准；1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。自然 JavaScript 也成为了 ECMAScript 最著名的实现之一。</p>
<p>由于只有短短十天的设计时间，而且世界上之前没有出现过结合了函数式编程和对象编程的语言，以及发展的迅速导致没有时间调整设计，JavaScript 成功成为了有着众多设计缺陷的语言，在这里不做细谈。</p>
<p>2001 年，微软发布 Windows XP，并捆绑了 IE 6。由于 Windows XP 迅速爆火以及长期的垄断，IE 6 也随之占据非常高的市场份额。前文已经说过，IE 6 对 JavaScript 支持并不好，同时 IE 6 对 CSS 标准的支持也不尽完善，导致前端技术的发展进入了漫长的蛰伏期。</p>
<p>2004 年，谷歌（Google）发布爆款应用 Gmail。这款应用在刚推出时，容量就比起其他受欢迎的电子邮箱服务如雅虎和微软的 Hotmail 多出过百倍，成为市场爆品，同时也让众多开发者看到了页面交互的巨大前景和可能性。</p>
<p>2005 年，Jesse 将谷歌用到的技术命名为 AJAX。</p>
<p>2006 年，至今为止最为长寿的 JavaScript 库—— jQuery，发布。</p>
<p>2008 年，谷歌发布 Chrome 浏览器；同年，Chrome 的使用率上升至 1%。其使用高性能 JavaScript 引擎 V8。</p>
<p>2009 年，Ryan 基于 V8 写了 Node.js。</p>
<p>2010 年，Isaac 基于 Node.js 写了 npm。</p>
<p>2010 年，TJ 受 Sinatra 启发，写了 Express.js。赶上了这几波顺风车的 JavaScript 迅速发展，并将触手伸向了后端。自此，JavaScript 也能胜任后端的一些工作了。</p>
<p>2012 年，Chrome 全球占有率达到 33%，超越 IE 跃居首位。</p>
<p>2015 年 12 月，Chrome 中国占有率达到 37%，超越 IE。</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><ul>
<li>JS 是历史的选择，最开始浏览器支持 Java、Flash、VBScript，只有 JS 活到了最后</li>
<li>JS 低开高走，一开始是一个玩具语言，但每次都走对了风口（ECMA 标准、Gmail、移动端、Node.js）</li>
<li>对于初学者，目前可以忽略与 IE 相关的知识</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
</search>
