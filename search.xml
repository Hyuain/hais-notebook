<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法</title>
    <url>/hais-notebook/2022/02/05/Algorithm/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="数组">数组</h1>
<h2 id="查找">查找</h2>
<h3 id="二分查找">二分查找</h3>
<p><a href="https://leetcode.cn/problems/binary-search/submissions/">LeetCode.204</a></p>
<p>前提</p>
<ul>
<li>数组是有序的</li>
<li>数组中无重复元素</li>
</ul>
<p>时间复杂度 O(log(n))</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">binarySearch</span> = (<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) &#123; <span class="keyword">return</span> -<span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">      <span class="comment">// 如果写成这样，意味着新的 right 需要在下一次循环被考虑</span></span><br><span class="line">      <span class="comment">// 所以当 left === right 的时候，循环还不能终止</span></span><br><span class="line">      right = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新的 left 总是需要被考虑的，所以下面这行一般没有第二种写法</span></span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<h3 id="选择排序">选择排序</h3>
<p>每次从剩下的部分选择最小的排到前面来，O(n^2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">minIndex</span> = numbers =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[i] &lt; numbers[index]) &#123;</span><br><span class="line">      index = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">selectionSort</span> = numbers =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span> - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="title function_">minIndex</span>(numbers.<span class="title function_">slice</span>(i))</span><br><span class="line">    <span class="keyword">if</span> (i !== index) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = numbers[index]</span><br><span class="line">      numbers[index] = numbers[i]</span><br><span class="line">      numbers[i] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<p>找出 Pivot，把小于 Pivot 的放左边，大于 Pivot 的放右边，最好 O(nlogn)，最坏 O(n^2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = numbers =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> numbers</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(numbers.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> pivot = numbers.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[i] &lt;= pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(numbers[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(numbers[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>([pivot], <span class="title function_">quickSort</span>(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序">冒泡排序</h3>
<p>两两比较，如果后者比前者小，则交换，最终每次循环使得最大数冒泡到最后去（O(n^2)，最好 O(n)）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bubbleSort</span> = numbers =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> length = numbers.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (numbers[i + <span class="number">1</span>] &lt; numbers[i]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = numbers[i + <span class="number">1</span>]</span><br><span class="line">        numbers[i + <span class="number">1</span>] = numbers[i]</span><br><span class="line">        numbers[i] = temp</span><br><span class="line">        swapped = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!swapped) <span class="keyword">break</span></span><br><span class="line">    length--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组去重">数组去重</h2>
<blockquote>
<p>恰当地利用对象和 Map key 的唯一性可以实现对 <code>'1'</code> 和 <code>1</code> 的区分、对象的去重，以及 <code>undefined</code> <code>null</code> <code>NaN</code> 的良好识别。</p>
</blockquote>
<p>使用数组 <code>[ 1, 1, '1', '1', 0, 0, &#123; a: 1 &#125;, &#123; a: 1 &#125;, x, y, z, undefined, undefined, null, null, NaN, NaN ]</code> 输出进行实验，其中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> y = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> z = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重循环">双重循环</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">let</span> isRepeat</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    isRepeat = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArray.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>[i] === newArray[j])&#123;</span><br><span class="line">        isRepeat = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepeat) &#123;</span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code></p>
<h3 id="indexof"><code>indexOf</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (newArray.<span class="title function_">indexOf</span>(current) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      newArray.<span class="title function_">push</span>(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code></p>
<h3 id="相邻元素去重先排序">相邻元素去重（先排序）</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">sort</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>[i] !== <span class="variable language_">this</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code>，<code>undefined</code>（会丢失）</p>
<h3 id="filter"><code>filter</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> newArray = <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="title function_">indexOf</span>(item) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code>（会丢失）</p>
<h3 id="reduce先排序"><code>reduce</code>（先排序）</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sort</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">length</span> === <span class="number">0</span> || result[result.<span class="property">length</span> - <span class="number">1</span>] !== current) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code></p>
<h3 id="includes"><code>includes</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">      newArray.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象</p>
<h3 id="对象键值对">对象键值对</h3>
<p>利用对象中 key 的不可重复性去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="variable language_">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="variable language_">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象（存进去的时候所有对象都变成了 <code>[object Object]</code>）、<code>'1'</code> 和 <code>1</code></p>
<h4 id="改进版本-1">改进版本 1</h4>
<p>可以区分 <code>'1'</code> 和 <code>1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="keyword">typeof</span> <span class="variable language_">this</span>[i] + <span class="variable language_">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="variable language_">this</span>[i] + <span class="variable language_">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进版本-2">改进版本 2</h4>
<p>可以区分对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj[<span class="keyword">typeof</span> <span class="variable language_">this</span>[i] + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>[i])]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="variable language_">this</span>[i] + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>[i])] = <span class="literal">true</span></span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<h3 id="map">Map</h3>
<p>利用 Map 的 key 唯一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">get</span>(<span class="variable language_">this</span>[i])) &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(<span class="variable language_">this</span>[i], <span class="literal">true</span>)</span><br><span class="line">      newArray.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> (!map.<span class="title function_">has</span>(item) &amp;&amp; map.<span class="title function_">set</span>(item, <span class="literal">true</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能去重：对象，可以像上面的对象键值对方法一样处理</p>
<h3 id="set">Set</h3>
<p>Set 类似于数组，但成员的值都是唯一的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化为</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">this</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以简化为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="title class_">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能去重：对象</p>
<h2 id="例题">例题</h2>
<h3 id="电话号码的组合公式运算">电话号码的组合（公式运算）</h3>
<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode.17</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">telComb</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> map = [<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line">  <span class="keyword">const</span> num = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 保存键盘映射后的字母内容，比如 23 =&gt; [&#x27;abc&#x27;, &#x27;def&#x27;]</span></span><br><span class="line">  <span class="keyword">const</span> code = []</span><br><span class="line">  num.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[item]) &#123;</span><br><span class="line">      code.<span class="title function_">push</span>(map[item])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">combine</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr[<span class="number">0</span>].<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">1</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归的精髓，用临时结果 result 替换掉前面两项</span></span><br><span class="line">    arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">2</span>, result)</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">combine</span>(arr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">combine</span>(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卡牌分组-归类运算">卡牌分组 （归类运算）</h3>
<p><a href="https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/">LeetCode.914</a></p>
<p>问题的核心是求最大公约数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">辗转相除： gcd(a, b) = gcd(b, a % b)</span><br><span class="line">更相减损： gcd(a, b) = a &gt; b ? gcd(a - b, b) : gcd(a, b - a)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">cardGroup</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  <span class="keyword">const</span> str = arr.<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 再将相同的进行分组（多张或者单张为一组）</span></span><br><span class="line">  <span class="keyword">const</span> group = str.<span class="title function_">match</span>(<span class="regexp">/(\d)\1+|\d/g</span>)</span><br><span class="line">  <span class="comment">// 求最大公约数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gcd</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">gcd</span>(b, a % b)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进入处理之前检查，如果 group 为空或者 group.length === 1，就不找公约数</span></span><br><span class="line">  <span class="keyword">while</span> (group.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = group.<span class="title function_">shift</span>().<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> b = group.<span class="title function_">shift</span>().<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> v = <span class="title function_">gcd</span>(a, b)</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      group.<span class="title function_">unshift</span>(<span class="string">&#x27;0&#x27;</span>.<span class="title function_">repeat</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 group 为空，或者每组的数量小于 1，则为 false</span></span><br><span class="line">  <span class="keyword">return</span> group.<span class="property">length</span> ? group[<span class="number">0</span>].<span class="property">length</span> &gt; <span class="number">1</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2 id="例题-1">例题</h2>
<h3 id="反转字符串中的单词">反转字符串中的单词</h3>
<p><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">LeetCode.557</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> array = str.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> result = array.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更优雅的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">          .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">          .<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .<span class="title function_">split</span>(<span class="regexp">/\s/g</span>)</span><br><span class="line">          .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">          .<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 match API</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .<span class="title function_">match</span>(<span class="regexp">/[\w&#x27;]+/g</span>)</span><br><span class="line">          .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">          .<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数二进制子串">计数二进制子串</h3>
<p><a href="https://leetcode.cn/problems/count-binary-substrings/">LeetCode.696</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">count</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 建立数据结构，堆栈、保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="comment">// 给定任意子输入都返回第一个符合条件的字符串</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">match</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> j = str.<span class="title function_">match</span>(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">repeat</span>(j.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">RegExp</span>.<span class="property">$1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 for 循环控制程序运行流程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.<span class="property">length</span> - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sub = <span class="title function_">match</span>(str.<span class="title function_">slice</span>(i))</span><br><span class="line">    <span class="keyword">if</span>(sub)&#123;</span><br><span class="line">      result.<span class="title function_">push</span>(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈">栈</h1>
<h2 id="例题-2">例题</h2>
<h3 id="实现一个简单的计算器">实现一个简单的计算器</h3>
<p>利用后缀表达和栈可以实现一个简单的计算器</p>
<h4 id="算式的后缀表达">算式的后缀表达</h4>
<p>我们平时使用的是中缀表达（Infix Notation），形式是 <strong>操作数 运算符 操作数</strong>，比如 1 + 1</p>
<p>后缀表达（Postfix Notation, Reverse Polish Notation）的形式是 <strong>操作数 操作数 运算符</strong>，比如 1 1 +</p>
<p>要得到后缀表达，只需要：</p>
<ul>
<li>操作数顺序不变</li>
<li>操作符根据优先级加在操作数后面</li>
</ul>
<p>比如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> 10 + (44 - 1) * 3 + 9 / 2</span><br><span class="line"> 10       44       1       3       9       2</span><br><span class="line"> 10      (44       1 -)    3      (9       2 /)</span><br><span class="line"> 10     ((44       1 -)    3 *)   (9       2 /)</span><br><span class="line">(10     ((44       1 -)    3 *) +)(9       2 /)</span><br><span class="line">(10     ((44       1 -)    3 *) +)(9       2 /) +</span><br><span class="line"> 10 44 1 - 3 * + 9 2 / +</span><br><span class="line"> </span><br><span class="line"> 1 - 2 - 5 + 6 / 5</span><br><span class="line"> 1 2 - 5 - 6 5 / +</span><br><span class="line"> </span><br><span class="line"> (22 / 7 + 4) * (6 - 2)</span><br><span class="line"> 22 7 / 4 + 6 2 - *</span><br></pre></td></tr></table></figure>
<h4 id="计算器的例子">计算器的例子</h4>
<ol type="1">
<li><p>先得到后缀表达</p></li>
<li><p>遇到操作数入栈，遇到运算符则将将前两个出栈并进行运算</p></li>
<li><p>将结果入栈</p></li>
</ol>
<p>计算 3 - 2 - 1：</p>
<ol type="1">
<li><p>先得到后缀表达 3 2 - 1</p></li>
<li><p>push 3</p></li>
<li><p>push 2</p></li>
<li><p>遇到运算符 -</p>
<ol type="1">
<li>pop 出 2</li>
<li>pop 出 3</li>
<li>3 - 2 = 1</li>
<li>push 1</li>
</ol></li>
<li><p>push 1</p></li>
<li><p>遇到运算符 -</p>
<ol type="1">
<li>pop 出 1</li>
<li>pop 出 1</li>
<li>1 - 1 = 0</li>
<li>push 0</li>
</ol></li>
<li><p>结果是栈顶的 0</p></li>
</ol>
<h1 id="队列">队列</h1>
<h2 id="队列的实现">队列的实现</h2>
<p>用环形队列可以节约内存，并且入队和出队都能得到 O(1) 的时间复杂度：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithmn-Queue-Implementation.jpg" alt="环形队列" /><figcaption aria-hidden="true">环形队列</figcaption>
</figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用 TypeScript 仅供参考，提供此种实现方案的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该队列最多 9 个元素</span></span><br><span class="line">  <span class="keyword">private</span> q = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">private</span> front = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> rear = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Full&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>[<span class="variable language_">this</span>.<span class="property">rear</span>] = x</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rear</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="property">q</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">front</span> === <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">front</span> = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">front</span> ++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">isFull</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// rear 在 front 左边，表示套圈了</span></span><br><span class="line">    <span class="comment">// 另外注意 rear 指向的是队尾的最后一位，是一个空元素</span></span><br><span class="line">    <span class="comment">// 所以队列的最大容量是数组的长度 - 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> + <span class="number">1</span> === <span class="variable language_">this</span>.<span class="property">front</span> || <span class="variable language_">this</span>.<span class="property">front</span> === <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// rear 和 front 相等时，定义为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">front</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树">二叉树</h1>
<h2 id="定义">定义</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">val</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val: <span class="built_in">number</span> = <span class="number">0</span>, left: TreeNode | <span class="literal">null</span> = <span class="literal">null</span>, right: TreeNode | <span class="literal">null</span> = <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历">遍历</h2>
<h3 id="深度优先">深度优先</h3>
<h4 id="递归写法">递归写法</h4>
<p>递归三步：</p>
<ol type="1">
<li>确定参数和返回值</li>
<li>确定终止条件</li>
<li>确定每次需要做的事情</li>
</ol>
<h5 id="前序中左右">前序（中左右）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">current: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!current) &#123;	<span class="keyword">return</span> &#125;</span><br><span class="line">  cb?.(current)							<span class="comment">// 中</span></span><br><span class="line">  <span class="title function_">traversal</span>(current.<span class="property">left</span>)   <span class="comment">// 左</span></span><br><span class="line">  <span class="title function_">traversal</span>(current.<span class="property">right</span>)  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序左中右">中序（左中右）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">current: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!current) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="title function_">traversal</span>(current.<span class="property">left</span>)   <span class="comment">// 左</span></span><br><span class="line">  cb?.(current)             <span class="comment">// 中</span></span><br><span class="line">  <span class="title function_">traversal</span>(current.<span class="property">right</span>)  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序左右中">后序（左右中）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">current: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!current) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="title function_">traversal</span>(current.<span class="property">left</span>)   <span class="comment">// 左</span></span><br><span class="line">	<span class="title function_">traversal</span>(current.<span class="property">right</span>)  <span class="comment">// 右</span></span><br><span class="line">  cb?.(current)							<span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代写法">迭代写法</h4>
<h5 id="前序中左右-1">前序（中左右）</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithm-Tree-1.gif" alt="二叉树的前序遍历（迭代法）" /><figcaption aria-hidden="true">二叉树的前序遍历（迭代法）</figcaption>
</figure>
<p>入栈顺序为 中、<strong>右、左</strong>，这样才能保证出栈顺序为 中、<strong>左、右</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]          <span class="comment">// 中入栈</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>() <span class="comment">// 出栈，可以看出中最先出栈，然后是左，然后是右</span></span><br><span class="line">    cb?.(current)								<span class="comment">// 处理</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">right</span>) <span class="comment">// 右入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">left</span>)  <span class="comment">// 左入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序左中右-1">中序（左中右）</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithm-Tree-2.gif" alt="二叉树的中序遍历（迭代法）" /><figcaption aria-hidden="true">二叉树的中序遍历（迭代法）</figcaption>
</figure>
<p>需要借助指针来跟踪当前访问的节点</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> current = root</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">while</span> (current || stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current)        <span class="comment">// 入栈</span></span><br><span class="line">      current = current.<span class="property">left</span>     <span class="comment">// 准备左入栈（第一次会一直入栈直到最左下角的元素，那才是处理的起点）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = stack.<span class="title function_">pop</span>()      <span class="comment">// 出栈，可以看出左最先出栈，然后是中，然后是右</span></span><br><span class="line">      cb?.(current)							 <span class="comment">// 处理</span></span><br><span class="line">      current = current.<span class="property">right</span>    <span class="comment">// 准备右入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序左右中-1">后序（左右中）</h5>
<p>先写前序遍历（中左右），写的时候把左右入栈顺序颠倒，就是中右左，然后反转 result 数组就是后序遍历</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traversal = (<span class="attr">root</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>): <span class="title class_">TreeNode</span>[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()</span><br><span class="line">    result.<span class="title function_">push</span>(current)</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">reverse</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统一风格的迭代写法">统一风格的迭代写法</h4>
<p>使用标记法，在需要处理的元素入栈之后推入 <code>null</code>，这样栈里面就有两种元素：</p>
<ol type="1">
<li>需要处理的元素，他后面会接一个 <code>null</code></li>
<li>需要进一步访问其子结点的元素，他后面不会接 <code>null</code></li>
</ol>
<h5 id="中序左中右-2">中序（左中右）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">if</span> (!current) &#123;					   	<span class="comment">// 出栈时遇到 null，说明下一个元素需要处理</span></span><br><span class="line">      cb?.(stack.<span class="title function_">pop</span>())</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">right</span>) &#125;	<span class="comment">// 右入栈，待访问</span></span><br><span class="line">    stack.<span class="title function_">push</span>(current, <span class="literal">null</span>)													<span class="comment">// 中入栈，待处理</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">left</span>) &#125;    <span class="comment">// 左入栈，待访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithm-Tree-3.gif" alt="二叉树的中序遍历（统一迭代法）" /><figcaption aria-hidden="true">二叉树的中序遍历（统一迭代法）</figcaption>
</figure>
<h5 id="前序中左右-2">前序（中左右）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">      cb?.(stack.<span class="title function_">pop</span>())</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">right</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">left</span>) &#125;</span><br><span class="line">    stack.<span class="title function_">push</span>(current, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序左右中-2">后序（左右中）</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root: TreeNode | <span class="literal">null</span>, cb?: (node: TreeNode) =&gt; <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">      cb?.(stack.<span class="title function_">pop</span>())</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="title function_">push</span>(current, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">right</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123; stack.<span class="title function_">push</span>(current.<span class="property">left</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先">广度优先</h3>
<blockquote>
<p>即层序遍历</p>
</blockquote>
<h4 id="迭代法">迭代法</h4>
<p>使用队列和一个缓存当前层的数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">traversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>[] = [root]</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentLevel = []</span><br><span class="line">    <span class="keyword">const</span> currentLevelSize = queue.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentLevelSize; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>()</span><br><span class="line">      currentLevel.<span class="title function_">push</span>(current.<span class="property">val</span>)</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">left</span>) &#123; queue.<span class="title function_">push</span>(current.<span class="property">left</span>) &#125;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">right</span>) &#123; queue.<span class="title function_">push</span>(current.<span class="property">right</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(currentLevel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法">递归法</h4>
<p>传入 deep 可以不管当前递归到哪里了，自己属于哪一层</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">traversal</span>(<span class="params">current: TreeNode | <span class="literal">null</span>, result: <span class="built_in">number</span>[][], deep: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!current) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result[deep]) &#123; result[deep] = [] &#125;</span><br><span class="line">        result[deep].<span class="title function_">push</span>(current.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">traversal</span>(current.<span class="property">left</span>, result, deep + <span class="number">1</span>)</span><br><span class="line">        <span class="title function_">traversal</span>(current.<span class="property">right</span>, result, deep + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="title function_">traversal</span>(root, result, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划">动态规划</h1>
<h2 id="背包问题">背包问题</h2>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithm-Bag-1.png" alt="背包问题分类" /><figcaption aria-hidden="true">背包问题分类</figcaption>
</figure>
<h3 id="背包">01背包</h3>
<p>有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>假设物品如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr class="even">
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr class="odd">
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<h4 id="暴力解法">暴力解法</h4>
<p>每个物品有两个状态，选或不选，可以用回溯法暴力求解，比如树的每一层就对应着一个物品，左节点是加了的情况，右节点是不加的情况。</p>
<p>时间复杂度是 O(2^n)。</p>
<h4 id="二位数组动态规划">二位数组动态规划</h4>
<h5 id="确定-dp-数组及下标的含义">1. 确定 dp 数组及下标的含义</h5>
<p><code>dp[i][j]</code> 表示从物品 <code>0 ~ i</code> 中任意取，放进容量为 <code>j</code> 的背包，其总价值是多少。</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Algorithm-Bag-2.png" alt="dp[i][j]的含义" /><figcaption aria-hidden="true">dp[i][j]的含义</figcaption>
</figure>
<h5 id="确定递推公式">2. 确定递推公式</h5>
<ul>
<li><p>不放物品 <code>i</code>，那么 <code>dp[i][j]</code> 就等于 <code>dp[i-1][j]</code></p></li>
<li><p>放物品 <code>i</code>，背包容量为 <code>j-weight[i]</code> 时的价值为 <code>dp[i-1][j-weight[i]]</code>，在此基础上再加上 <code>value[i]</code> 即可</p>
<ul>
<li>注意 <code>j - weight[i]</code> 可能为负，这种情况背包容量为 j 时，只装物品 i 也装不下，<code>dp[i][j] = dp[i-1][j]</code></li>
</ul></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>
<h5 id="dp-数组的初始化">3. dp 数组的初始化</h5>
<ul>
<li>背包容量 j 为 0 时，总价值为 0：<code>dp[i][0] = 0</code></li>
<li>在放第 0 个物品（i 为 0）时：
<ul>
<li>如果放不下（<code>j &lt; weight[0]</code>），则 <code>dp[0][j] = 0</code></li>
<li>如果能放下（<code>j &gt;= weight[0]</code>），则 <code>dp[0][j] = value[0]</code></li>
</ul></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放不下的情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; weight[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">  dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 能放下的情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">let</span> j = weight[<span class="number">0</span>]; j &lt; bagweight; j++) &#123;</span><br><span class="line">  dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的值初始化为什么都不影响（因为会被覆盖），我们可以先生成一个全是 0 的二维数组，然后初始化 <code>value[0]</code> （能放下物品 0 的情况）</p>
<h5 id="确定遍历的顺序">4. 确定遍历的顺序</h5>
<p>根据递推公式，先遍历 i 还是 j 都不影响</p>
<h5 id="最终代码">最终代码</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> weightBagProblem = (</span><br><span class="line">  <span class="attr">weight</span>: <span class="built_in">number</span>[], <span class="attr">value</span>: <span class="built_in">number</span>[], <span class="attr">size</span>: <span class="built_in">number</span>,</span><br><span class="line">): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> goodsNum = weight.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(goodsNum)</span><br><span class="line">  	.<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">  	.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">  <span class="comment">// j = 0 的时候全部为 0</span></span><br><span class="line">  <span class="comment">// i = 0 的时候能放下时为 value[0]，否则为 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = weight[<span class="number">0</span>]; j &lt;= size; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; goodsNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[goodsNum - <span class="number">1</span>][size]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一维数组动态规划滚动数组">一维数组动态规划（滚动数组）</h4>
<p>在二维数组中，递推公式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>
<p>如果每次把第 <code>i - 1</code> 行复制到第 <code>i</code> 行，那么公式变为这样：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>
<p>看出来都是同一行的数据，可以考虑用一维数组来解这个问题。</p>
<h5 id="确定-dp-数组及下标的含义-1">1. 确定 dp 数组及下标的含义</h5>
<p><code>dp[j]</code> 表示容量为 <code>j</code> 的背包的最大价值。</p>
<h5 id="确定递推公式-1">2. 确定递推公式</h5>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>
<p>也是两种情况，要么放 <code>i</code>，要么不放 <code>i</code>：</p>
<ul>
<li>不放 <code>i</code>：<code>dp[j] = dp[j]</code></li>
<li>放 <code>i</code>：<code>dp[j] = dp[j - weight[i]] + value[i]</code></li>
</ul>
<p>相当于就是上面二维数组的公式中把 <code>[i]</code> 去掉了。</p>
<h5 id="dp-数组的初始化-1">3. dp 数组的初始化</h5>
<ul>
<li>背包容量为 0 时，<code>dp[0] = 0</code></li>
<li>根据递推公式，剩下的可以随意初始化，如果题目给的价值都是正整数，那么其他项初始化为 <code>0</code> 就可以了</li>
</ul>
<h5 id="确定遍历的顺序-1">4. 确定遍历的顺序</h5>
<p>注意：</p>
<ul>
<li>根据递推公式，必须 <code>i</code> 在外层，<code>j</code> 在内层（相当于二维数组的逐行遍历），因为 <code>dp[i - 1][j - weight[i]]</code> 相当于要依赖上一行前几位的运算结果</li>
<li>遍历 <code>j</code> 的时候，一定要倒序遍历，因为顺序的话物品可能会被加入多次：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">weight[<span class="number">0</span>] = <span class="number">1</span>; value[<span class="number">0</span>] = <span class="number">15</span>;</span><br><span class="line">dp[<span class="number">1</span>] = dp[<span class="number">1</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">15</span></span><br><span class="line">dp[<span class="number">2</span>] = dp[<span class="number">2</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">30</span> <span class="comment">// value[0] 又加入了一次</span></span><br></pre></td></tr></table></figure>
<p>这个加入多次的问题在二维数组中不存在，因为：</p>
<ul>
<li>二维数组第 0 行是通过初始化给的，我们遍历是从 1 开始的</li>
<li>之后每一行都是借助 <strong>上一行</strong> 的数据算出来的（看递推公式），所以顺序遍历本行并不会有影响</li>
</ul>
<p>一维数组中，相当于 <strong>把上一行的数据原位重复利用</strong>，如果顺序遍历的话，相当于后面的数据用了 <strong>本行</strong> 的数据，就可能会重复放入物品</p>
<h5 id="最终代码-1">最终代码</h5>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">weightBagProblem</span> = (<span class="params"></span></span><br><span class="line"><span class="params">	weight: <span class="built_in">number</span>[], value: <span class="built_in">number</span>[], size: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> goodsNum = weight.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; goodsNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里必须从大遍历到小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = size; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">      dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[size]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包">完全背包</h3>
<p>有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，其价值是 value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>假设物品如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr class="even">
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr class="odd">
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<h4 id="遍历顺序问题">遍历顺序问题</h4>
<p>完全背包最核心的就是遍历顺序问题，在完全背包中需要从小到大进行遍历，因为一样物品可以被添加多次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; goodsNum; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = weight[i]; j &lt;= size; j++) &#123;</span><br><span class="line">    dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="求最大价值时的遍历顺序">求最大价值时的遍历顺序</h5>
<p>另外之前 0 1 背包中，要求物品在外层，重量在内层，因为下一行需要 <code>dp[i - 1][j - weight[i]]</code>，会依赖上一行前几位的运算结果</p>
<p>而在完全背包中，是可以重量在外层，物品在内层的。因为 <code>dp[j - weight[i]]</code>，依赖的是本行的运算结果，只有 <code>dp[0]</code> 是继承的上一行的数据，如果先遍历列，也可以拿到上一行 <code>dp[i - 1][0]</code>（因为是同一列的）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历背包容量（列），再遍历物品（行）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; weight.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="求装满方式时的遍历顺序">求装满方式时的遍历顺序</h5>
<p>如果是问最大价值，dp 数组里面存的是最大价值，最大价值与怎样凑成最大价值无关，因此物品、重量谁在内层谁在外层并不关键。</p>
<p>但如果问背包的装满方式，遍历顺序就会影响很大了，得看题目问的是组合问题还是排列问题。</p>
<p>拿零钱兑换问题（<a href="https://leetcode.cn/problems/coin-change-ii/">LeetCode.518 Coin Change II</a>）举例，给定一个总额和一堆无限多的币值，问总额有多少种组合方式。组合问题不关心顺序。</p>
<ol type="1">
<li>确定 dp 数组及下标的含义：<code>dp[j]</code> 表示凑成总额为 <code>j</code> 时，有多少种钱币组合方式</li>
<li>确定递推公式：<code>dp[j] += dp[j - coins[i]]</code></li>
<li>初始化：<code>dp[0] = 1</code>，否则后面推导出来的都是 0（但是这其实并没有什么真正的含义）。其他的初始化为 <code>0</code></li>
<li>确定遍历顺序</li>
</ol>
<p>如果外层钱币（物品），内层总额（重量）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= coins.<span class="property">length</span>; i++) &#123;    <span class="comment">// 物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 重量</span></span><br><span class="line">    dp[j] += dp[j - coins[i]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设 <code>coins = [1, 5]</code>，那么这种情况就是先把 1 带进去看，再把 5 带进去看，得到的方法数只会有 {1, 5}，而不会有 {5, 1}，因此 <code>dp[j]</code> 里面存的是组合数。</p>
<p>如果交换遍历顺序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123;        <span class="comment">// 重量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.<span class="property">length</span>; i++) &#123; <span class="comment">// 物品</span></span><br><span class="line">    <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      dp[j] += dp[j - coins[i]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背包容量的每一个值，都会重新计算一遍 1 和 5，所以包含了 {1, 5} 和 {5, 1} 两种情况。，<code>dp[j]</code> 里面存的就是排列数。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>翻译：Angular 如何检查变化</title>
    <url>/hais-notebook/2021/05/17/Angular-ChangeDetection/</url>
    <content><![CDATA[<p>翻译文章 <a href="https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/">Angular Change Detection - How Does It Really Work?</a> 。</p>
<span id="more"></span>
<ul>
<li>下文中 CD 指 Change Detection，即变化检查；CDr 指 Change Detector，即变化检查器</li>
</ul>
<h1 id="目录">目录</h1>
<ul>
<li>CD 是如何进行的？</li>
<li>Angular 的变化检查器是什么样的？</li>
<li>默认的 CD 机制是怎样进行的</li>
<li>开启/关闭 CD ，手动触发他</li>
<li>避开 CD 循环：生产模式和开发模式</li>
<li><code>OnPush</code> CD 模式究竟做了什么？</li>
<li>使用 Immutable.js 来简化 Angular 应用的构建</li>
<li>总结</li>
</ul>
<p>如果想要了解更多关于 OnPush CD 机制，请查阅 <a href="https://blog.angular-university.io/onpush-change-detection-how-it-works">这篇文章</a> 。</p>
<h1 id="cd-是如何实现的">CD 是如何实现的？</h1>
<p>当组件的数据变化的时候，Angular 可以探测到，并重新渲染视图来相应这次变化。为了理解工作原理，我们需要首先意识到 JavaScript 中整个运行时都是可重写的。我们可以重写类似于 <code>String</code> 或 <code>Number</code> 等方法。</p>
<h1 id="重写浏览器的默认机制">重写浏览器的默认机制</h1>
<p>Angular 启动的时候，将一些底层的的浏览器 API（比如浏览器用来注册事件的 <code>addEventListener</code>）替换掉，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是新版的 addEventListener</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEventListener</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用原生的 addEventListener</span></span><br><span class="line">  <span class="title function_">callRealAddEventListener</span>(eventName, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 先调用原生的 callback</span></span><br><span class="line">    <span class="title function_">callback</span>(...)</span><br><span class="line">    <span class="comment">// 再运行 Angular 添加的功能</span></span><br><span class="line">    <span class="keyword">var</span> changed = angular.<span class="title function_">runChangeDetection</span>()</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      angular.<span class="title function_">reRenderUIPart</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的 <code>addEventListener</code> 会给事件处理器添加更多的功能：除了调用回调函数之外，还让 Angular 可以检测到变化并更新视图。</p>
<h1 id="这个底层的运行时替换是怎样工作的">这个底层的运行时替换是怎样工作的？</h1>
<p>一个叫 <a href="https://github.com/angular/zone.js/">Zone.js</a> 的 Angular 自带的库完成了这个工作。</p>
<p>Zone 其实就是一个在多个 JavaScript 虚拟机执行回合之中幸存下来的执行上下文——这是一个可以用来为浏览器增加更多功能的很普遍的机制。Angular 内部使用 Zones 来触发 CD ，但 Zone 也可以用来做应用分析（比如内存占用、程序复杂度等）、跨越不同的 JavaScript 虚拟机回合进行长堆栈跟踪。</p>
<h1 id="浏览器异步-api-支持">浏览器异步 API 支持</h1>
<p>为了支持 CD ，下面这些常用的浏览器机制也被修改了：</p>
<ul>
<li>所有的浏览器事件（click、mouseover、keyup 等）</li>
<li><code>setTimeout()</code> 和 <code>setInterval()</code></li>
<li>Ajax HTTP 请求</li>
</ul>
<p>事实上，为了无感知地触发 Angular CD ，Zone.js 也修改了很多别的浏览器 API，比如 Websocket。可以看看 Zone.js 的 <a href="https://github.com/angular/zone.js/tree/master/test/patch">一段测试代码</a> 看看现在支持了哪些 API。</p>
<p>这个机制的局限性在于：如果出于某些原因，Zone.js 不支持某个浏览器的异步 API，那么 CD 就不会被触发。比如 IndexedDB 的回调。</p>
<p>上面解释了 CD 是怎样触发的，但是触发之后他到底是怎样运作的呢？</p>
<h1 id="cd-树">CD 树</h1>
<p>在应用的启动阶段，每个 Angular 组件都与一个 CDr 建立关联。比如下面的 <code>TodoItem</code> 组件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;todo-item&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;span (click)=&quot;onToggle()&quot; class=&quot;todo noselect&quot;&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;todo.owner.firstName&#125;&#125; - &#123;&#123;todo.description&#125;&#125; - completed: &#123;&#123;todo.completed&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/span&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TodoItem</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  <span class="attr">todo</span>: <span class="title class_">Todo</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Output</span>()</span><br><span class="line">  toggle = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>&lt;<span class="title class_">Object</span>&gt;()</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">onToggle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toggle</span>.<span class="title function_">emit</span>(<span class="variable language_">this</span>.<span class="property">todo</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个组件会接受一个 <code>Todo</code> 对象作为输入，并且当 todo 状态发生改变的时候发出一个事件。来搞点花样，<a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo.ts#L11">Todo class</a> 里面还嵌套了一个对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> description: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> completed: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> owner: Owner <span class="comment">// 嵌套了 Owner 对象</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Todo</code> 有一个属性 <code>owner</code>，<code>owner</code> 也是一个对象（有属性 <code>firstName</code> 和 <code>lastName</code>）。</p>
<h1 id="todoitem-的-cdr-长什么样子">TodoItem 的 CDr 长什么样子？</h1>
<p>事实上，我们可以在运行时看到 CDr 长什么样子！我们只需要在 Todo class 里面加一些代码来在访问他的属性的时候 <a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo.ts#L11">打一个断点</a> 。</p>
<p>到达断点的时候，我们可以跟着调用栈看到 CDr：</p>
<p><img src="https://raw.githubusercontent.com/jhades/blog.angular-university.io/master/ng2-change-detection/images/change.jpg" /></p>
<p>别担心，你不需要去 debug 这些代码。这里也没有引入什么魔法，他只是一个在应用的启动阶段创建的简单的 Javascript 方法。但是他到底做了什么呢？</p>
<h1 id="默认的-cd-机制是怎么工作的">默认的 CD 机制是怎么工作的？</h1>
<p>这个方法最开始看起来可能非常奇怪，还有一些奇怪名字的变量。但是我们来仔细看看，可以注意到他在做一些非常简单的事情：他会比较每个表达式中使用的属性现在和之前的值，如果一个属性现在和之前的值不一样，他会将 <code>isChanged</code> 设为 <code>true</code>。</p>
<p>它使用了 <code>looseNotIdentical()</code> 来比较两个值，<a href="https://github.com/angular/angular/blob/50548fb5655bca742d1056ea91217a3b8460db08/modules/angular2/src/facade/lang.ts#L367">这个方法</a> 使用了 <code>===</code> 运算符，并且对 <code>NaN</code> 进行了一些特殊处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">looseIdentical</span>(<span class="params">a, b</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a === b || <span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="built_in">isNaN</span>(a) &amp;&amp; <span class="built_in">isNaN</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对于嵌套对象-owner-又怎么样呢">对于嵌套对象 <code>owner</code> 又怎么样呢？</h1>
<p>我们可以看到在 CDr 的代码中，<code>owner</code> 中的对象也被检查了，但是只检查了 <code>firstName</code>，并没有检查 <code>lastName</code>。</p>
<p>这是因为 <code>lastName</code> 并没有被 template 使用！——同样地，Todo 中的 <code>id</code> 属性也没有被检查。</p>
<p>对此，我们可以说：</p>
<blockquote>
<p>默认情况下，Angular CD 是检查 template 表达式中的值是否变化。他会检查所有的组件。</p>
</blockquote>
<p>我们也可以总结一下：</p>
<blockquote>
<p>默认情况下，Angular 不会做对象的深比较来检查便捷化，他只会关心在 template 中使用的属性。</p>
</blockquote>
<h1 id="为什么-cd-默认这样工作">为什么 CD 默认这样工作？</h1>
<p>Angular 的主要目标之一就是变得更透明和易用，因此框架的使用者不需要为了更有效率地使用它而去进行很冗长的 debug 或者了解他的内部机制。</p>
<p>如果你熟悉 AngularJs，想一下 <code>$digest()</code> 和 <code>$apply()</code> 以及所有使用/不使用他们的时候的坑。Angular 的主要目标之一就是避免他们。</p>
<h1 id="为什么不比较引用">为什么不比较引用？</h1>
<p>事实上，Javascript 的对象都是可变的，Angular 想要对此给予全力的支持。</p>
<p>想象一下如果 Angular 默认 CD 机制是基于组件输入的引用的比较（而不是默认的机制）。这样的话即便是像 TODO 这样简单的应用都需要一些技巧来创建：开发者需要非常小心地来创建一个新的 Todo，而不是只是更新属性。</p>
<p>但就像我们将要看到的那样，如果有必要的话，也可以自定义 Angular 的CD 。</p>
<h1 id="性能如何">性能如何？</h1>
<p>注意 TodoList 组件的CD 器是怎样创建对 <code>todos</code> 属性的显式引用的。</p>
<p>另一个方法是动态地遍历组件的属性，让代码具有普遍性（generic）——而不是为了这个组件特异化（specific）。这样我们就不用在每次组件创建的时候都创建一个CD 器了！所以应该怎么做呢？</p>
<h1 id="先看看虚拟机里面是什么样的">先看看虚拟机里面是什么样的</h1>
<p>上面说的一切都与 Javascript 虚拟机有关。进行动态比较的代码并不能被虚拟机即时编译器（VM just-in-time compiler）优化为本地代码（native code）。</p>
<p>特异化的代码对每个组件输入的属性有非常明确的访问，他们就像我们自己写的代码一样，而且虚拟机可以非常轻松地将他们转换为本地代码。</p>
<p>用生成的特异化 CDr 的结果就是：会非常快、可预测和易读。</p>
<p>接下来我们来讨论一下性能，有办法可以优化 CD 吗？</p>
<h1 id="onpush-cd-模式"><code>OnPush</code> CD 模式</h1>
<p>如果我们的 Todo 列表非常的大，我们可以配置这个 <code>TodoList</code> 组件，使用 <code>OnPush</code> 策略，让他只有在 Todo 列表变化的时候才会更新自己。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&quot;todo-list&quot;</span>,</span><br><span class="line">  <span class="attr">changeDetection</span>: <span class="title class_">ChangeDetectionStrategy</span>.<span class="property">OnPush</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TodoList</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后在整个列表外面加两个按钮：</p>
<ul>
<li>一个按钮直接修改 TodoItem，来改变他的状态</li>
<li>一个按钮给整个 TodoList 增加一个新的 TodoItem</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;todo-list [todos]=&quot;todos&quot;&gt;&lt;/todo-list&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;toggleFirst()&quot;&gt;Toggle First Item&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;addTodo()&quot;&gt;Add Todo to List&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="attr">todos</span>: <span class="title class_">Array</span> = initialData</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toggleFirst</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">todos</span>[<span class="number">0</span>].<span class="property">completed</span> = ! <span class="variable language_">this</span>.<span class="property">todos</span>[<span class="number">0</span>].<span class="property">completed</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTodo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newTodos = <span class="variable language_">this</span>.<span class="property">todos</span>.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    newTodos.<span class="title function_">push</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Todo</span>(<span class="number">1</span>, <span class="string">&quot;TODO 4&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">Owner</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">todos</span> = newTodos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看他们不同的表现：</p>
<ul>
<li>第一个按钮 "Toggle First Item" 没有起作用！因为 <code>toggleFirst()</code> 函数直接改变了列表的第一个元素。<code>TodoList</code>。<code>TodoList</code> 无法检测到这个这个变化，因为输入的 <code>todos</code> 引用没有发生变化</li>
<li>第二个按钮生效了！注意 <code>addTodo()</code> 创建了一个 todo list 的副本，然后在这个副本上增加一个项，最后用这个副本替代掉原来的 todos。因为输入的 todos 的引用发生了变化，这就触发了检查。</li>
<li>第二个按钮中，直接修改这个 todo list 是不会生效的，我们需要一个新的 list</li>
</ul>
<h1 id="onpush-真的只是检查引用吗"><code>OnPush</code> 真的只是检查引用吗？</h1>
<p>这不是问题，就算你将 <code>TodoItem</code> 也改成 <code>OnPush</code> 模式，你仍然可以做到只是点击一个 todo 就 toggle 他。</p>
<p>因为 <code>OnPush</code> 不只是在组件输入变化的时候进行检查，组件触发的事件同样会触发CD 。</p>
<p>正如 Victor Savkin 在他的博客中所说：</p>
<blockquote>
<p>如果使用 OnPush 检查器的时候，框架会在他输入的属性变化的时候、他发出事件的时候、Observable 触发事件的时候，检查 OnPush 组件</p>
</blockquote>
<p>尽管 <code>OnPush</code> 可能会使得性能更好，在使用可变对象时，他的引入会带来更高的复杂度。这会引发一些很难找到原因和重现的 BUG。但是也有可以灵活使用 <code>OnPush</code> 的方法。</p>
<h1 id="使用-immutable.js-来简化-angular-应用的构建">使用 <code>Immutable.js</code> 来简化 Angular 应用的构建</h1>
<p>如果我们只用不可变的对象和列表来构建应用，我们显然就可以在任何地方使用 <code>OnPush</code> 了，并且不会导致 CD 的 BUG。这是因为“修改”不可变对象的唯一方法是创建一个新的对象来替代它。 对于不可变对象，我们可以保证：</p>
<ul>
<li>一个新的不可变对象永远都会触发 <code>OnPush</code> 的 CD</li>
<li>不可能产生因为忘记创建一个对象的新副本而引发的错误</li>
</ul>
<p>用 Immutable.js 库是个不错的选择，这个库提供了构建应用的基础，比如不可变对象、Map、列表等。</p>
<h1 id="避免-cd-循环生产模式-vs-开发模式">避免 CD 循环：生产模式 vs 开发模式</h1>
<p>Angular CD 的一个重要特性就是，与 AngluarJS 不同，他强制使用单向数据流：当我们的 controller 更新的时候，CD 会运行并更新 view。</p>
<p>但是更新 view 并不会触发变化（变化又会触发新的视图更新，在 AngularJS 中这被称为 digest cycle）。</p>
<h1 id="怎样在-angular-中触发-cd-循环">怎样在 Angular 中触发 CD 循环？</h1>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;todo-list&#x27;</span>,</span><br><span class="line">  <span class="attr">directives</span>: [<span class="title class_">TodoItem</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li *ngFor=&quot;#todo of todos;&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;todo-item [todo]=&quot;todo&quot; (toggle)=&quot;onToggle($event)&quot;&gt;&lt;/todo-item&gt;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">           &lt;/ul&gt;</span></span><br><span class="line"><span class="string">           &lt;button (click)=&quot;blowup()&quot;&gt;Trigger Change Detection Loop&lt;/button&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TodoList</span> <span class="keyword">implements</span> <span class="title class_">AfterViewChecked</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  <span class="attr">todos</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Todo</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  <span class="attr">callback</span>: <span class="title class_">Function</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Output</span>()</span><br><span class="line">  addTodo = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>&lt;<span class="title class_">Object</span>&gt;();</span><br><span class="line"></span><br><span class="line">  clicked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onToggle</span>(<span class="params">todo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;toggling todo..&quot;</span>);</span><br><span class="line">    todo.<span class="property">completed</span> = !todo.<span class="property">completed</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">blowup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Trying to blow up change detection...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clicked</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">addTodo</span>.<span class="title function_">emit</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngAfterViewChecked</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callback</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">clicked</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;changing status ...&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种情况是使用生命周期钩子：比如在 <code>TodoList</code> 组件中，我们可以在 <code>ngAfterViewChecked</code> 中通过回调函数去改变另外一个组件绑定的值，这时候就会得到一个警告：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EXCEPTION: Expression &#x27;&#123;&#123;message&#125;&#125; in App@3:20&#x27; has changed after it was checked</span><br></pre></td></tr></table></figure>
<p>这个错误只有在开发模式下会出现，在生产模式下将不会抛错，这个 issue 也不会被检测到。</p>
<h1 id="cd-issues-会很频繁吗">CD issues 会很频繁吗？</h1>
<p>事实上我们不应该触发 CD 循环，以防万一，我们我们在开发阶段应该一直使用开发模式来避免这个问题。 因为 Angular 在开发模式下，总是会进行两次 CD（第二次就是用来检测这个问题）；而在生产模式下，CD 只会执行一次。</p>
<h1 id="开关-cd并手动触发他">开/关 CD，并手动触发他</h1>
<p>在一些特殊的情况下，我们不想触发 CD。设想这样一种情况，我们从后端通过 Websocket 拿到了大量的数据，我们想要每 5 秒钟更新 UI 的一部分。为了达成这个目的，我们需要在最开始的时候注入 CDr：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> ref: ChangeDetectorRef,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    ref.<span class="title function_">detach</span>()</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="title function_">detectChanges</span>()</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最开始 detach 了 CDr（这会关闭自动的 CD），然后每 5 秒通过 <code>detectChanges</code> 手动触发一次。</p>
<h1 id="总结">总结</h1>
<p>Angular CD 是一个框架内置的特性，用于保证组件数据和 HTML 模板视图的同步。</p>
<p>CD 会检测常规的浏览器事件（比如点击）、HTTP 请求，以及其他类型的事件，并决定每个组件的视图是否需要更新。</p>
<p>有中不同的 CD：</p>
<ul>
<li>默认 CD：对于组件树种所有的组件，Angular 通过比较 template 中表达式的在事件前后的值，来决定视图是否更新</li>
<li><code>OnPush</code> CD：他会检查是否有新的数据确实地被推到了组件中（可以通过组件 input 或者使用 async pipe 订阅了的 Observable）</li>
</ul>
<p>Angular <strong>默认</strong> CD 机制与 AngularJS 非常接近，他会检查 template 表达式在浏览器事件前后的值来看是否有变化。他对 <strong>所有</strong> 的组件都会这么做，但也有几点不同：</p>
<ul>
<li>其一是 Angular 中没有 CD 循环（AngularJS 中叫 digest cycle）。这允许我们在只看 template 和 controller 的情况下能推导出每个组件。</li>
<li>其二是由于 CDr 是被构建出来的，Angular 中的 CD 机制会快很多。</li>
<li>第三是与 AngularJS 不同，Angular 中的 CD 机制是可定制的。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Angular</title>
    <url>/hais-notebook/2020/03/24/Angular/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="modules">Modules</h1>
<p>Angular 里面有自己的模块化系统，也就是 NgModule，他与 ES6 的模块系统不同，又互为补充。每个 Angular 应用中都有一个 <strong>根模块（AppModule）</strong>，并且位于 <code>app.module.ts</code> 中，可以通过引导这个模块来启动整个应用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NgModule</span> &#125;      <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>:      [ <span class="title class_">BrowserModule</span> ], <span class="comment">// 这个模块中的 component templates 需要使用到的模块</span></span><br><span class="line">  <span class="attr">providers</span>:    [ <span class="title class_">Logger</span> ],        <span class="comment">// 这个模块中全局 services 的 creators</span></span><br><span class="line">  <span class="attr">declarations</span>: [ <span class="title class_">AppComponent</span> ],  <span class="comment">// 包括了这个 NgModule 下的 components、directives、pipes</span></span><br><span class="line">  <span class="attr">exports</span>:      [ <span class="title class_">AppComponent</span> ],  <span class="comment">// 包括了可能在其他模块使用的东西</span></span><br><span class="line">  <span class="attr">bootstrap</span>:    [ <span class="title class_">AppComponent</span> ]   <span class="comment">// 应用的主视图，也就是 root component，只有根模块才有这个属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>模块可以为其中的组件提供一个编译上下文环境（compilation context），根模块一定会有一个根视图</p>
<h1 id="components">Components</h1>
<p>每个应用都至少一个组件，也就是 root component，Angular 的组件一般长这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123; <span class="comment">// @Component 装饰器指出接下来的这个类是个组件类，并且指定元数据，组件的元数据将告诉 Angular 怎样将模板与组件关联起来并构成视图</span></span><br><span class="line">  <span class="attr">selector</span>:    <span class="string">&#x27;app-hero-list&#x27;</span>, <span class="comment">// 一个 CSS 选择器，告诉 Angular 在哪个标签插入组件实例</span></span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./hero-list.component.html&#x27;</span>, <span class="comment">// 该组件 HTML 模板文件相对于这个组件文件的地址</span></span><br><span class="line">  <span class="attr">providers</span>:  [ <span class="title class_">HeroService</span> ] <span class="comment">// 当前组件所需的 services 的 providers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HeroListComponent</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板语法">模板语法</h1>
<p>Angular 采用形如这样的模板语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hero List<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>Pick a hero from the list<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;selectHero(hero)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;hero.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">&quot;selectedHero&quot;</span> [<span class="attr">hero</span>]=<span class="string">&quot;selectedHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>@Component</code> 元数据会告诉 Angular 模板从哪里找：</p>
<ul>
<li>可以直接将模板写在 <code>@Component</code> 元数据的 <code>template</code> 中</li>
<li>可以将模板文件的地址告诉 <code>@Component</code> 元数据的 <code>template</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认将模板文件单独放置</span></span><br><span class="line">ng generate component hero</span><br><span class="line"><span class="comment"># -t 是 inlineTemplate=true 的简写</span></span><br><span class="line">ng generate component hero -t </span><br></pre></td></tr></table></figure>
<h2 id="数据绑定">数据绑定</h2>
<p>与 Vue 比较类似，Angular 这样几种数据绑定方式：</p>
<ul>
<li>从组件到 DOM <code>&#123;&#123;value&#125;&#125;</code> <code>[property]="value"</code> <code>bind-property="value"</code></li>
<li>从 DOM 到组件 <code>(event)="handler"</code> <code>on-event="value"</code></li>
<li>双向数据绑定 <code>[(ng-model)]="property"</code> <code>bindon-target="expression"</code></li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/component-databinding.png" alt="Angular 的数据绑定1" /><figcaption aria-hidden="true">Angular 的数据绑定1</figcaption>
</figure>
<p>在父子组件中也是如此：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/parent-child-binding.png" alt="Angular 的数据绑定2" /><figcaption aria-hidden="true">Angular 的数据绑定2</figcaption>
</figure>
<p>其插值语法、表达式、<code>on</code>、<code>bind</code>、<code>bindon</code> 等于 Vue 类似</p>
<h2 id="管道">管道</h2>
<p>Angular 自带了一些管道，可以帮助我们将输入值转换为对应的输出值，<code>|</code> 被称为 <strong>管道操作符</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default format: output &#x27;Jun 15, 2015&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Today is &#123;&#123;today | date&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- fullDate format: output &#x27;Monday, June 15, 2015&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The date is &#123;&#123;today | date:&#x27;fullDate&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shortTime format: output &#x27;9:43 AM&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The time is &#123;&#123;today | date:&#x27;shortTime&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="指令">指令</h2>
<p>Angular 自带了一些指令，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 结构型指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">&quot;selectedHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 属性型指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="service-and-dependency-injection">Service and Dependency Injection</h1>
<p>组件可以把诸如获取数据、验证用户输入、往控制台写日志等等委托给各种服务，可以在需要时将服务 <strong>注入</strong> 到组件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">any</span></span>)   &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg); &#125;</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">msg: <span class="built_in">any</span></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(msg); &#125;</span><br><span class="line">  <span class="title function_">warn</span>(<span class="params">msg: <span class="built_in">any</span></span>)  &#123; <span class="variable language_">console</span>.<span class="title function_">warn</span>(msg); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HeroService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">heroes</span>: <span class="title class_">Hero</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> backend: BackendService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> logger: Logger</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getHeroes</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">backend</span>.<span class="title function_">getAll</span>(<span class="title class_">Hero</span>).<span class="title function_">then</span>( <span class="function">(<span class="params">heroes: Hero[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">logger</span>.<span class="title function_">log</span>(<span class="string">`Fetched <span class="subst">$&#123;heroes.length&#125;</span> heroes.`</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">heroes</span>.<span class="title function_">push</span>(...heroes); <span class="comment">// fill cache</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heroes</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="httpclient">HttpClient</h1>
<h2 id="引入">引入</h2>
<p>可以在 <code>app.module.ts</code> 中引入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HttpClientModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/common/http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="title class_">HttpClientModule</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在需要使用的 service 中注入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HttpClient</span>, <span class="title class_">HttpHeaders</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/common/http&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HeroService</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> http: HttpClient </span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getHeroes</span>(): <span class="title class_">Observable</span>&lt;<span class="title class_">Hero</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Hero</span>[]&gt;(<span class="string">&#x27;/someurl&#x27;</span>) <span class="comment">// 他会返回一个 Observable 对象，里面具体的类型是 Hero[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="obersavble">Obersavble</h1>
<ul>
<li>提供了 publishers 和 subscribers 之间传递数据的方式</li>
<li>在 subscribe 的时候才会执行，而不是 define 的时候</li>
<li>可以传递多个任意类型的数据</li>
</ul>
<h2 id="基本使用-1">基本使用</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Observable 实例，他定义了一个 subscriber 函数</span></span><br><span class="line"><span class="comment">// 这个函数在 subscribe() 的时候才会执行</span></span><br><span class="line"><span class="comment">// 这个函数定义了如何获取数据、生成 values 和 messages</span></span><br><span class="line"><span class="keyword">const</span> locations = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">watchId</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;geolocation&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    watchId = navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(<span class="function">(<span class="params">position: Position</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">next</span>(position);</span><br><span class="line">    &#125;, <span class="function">(<span class="params">error: PositionError</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observer.<span class="title function_">error</span>(<span class="string">&#x27;Geolocation not available&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">      navigator.<span class="property">geolocation</span>.<span class="title function_">clearWatch</span>(watchId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 subscribe() 方法之后</span></span><br><span class="line"><span class="comment">// 并传入一个定义了 handler（next、error、complete，其中 next 是必须的）的对象（observer）</span></span><br><span class="line"><span class="comment">// 返回一个 Subscription 对象，其中有一个 unsubscribe() 方法</span></span><br><span class="line"><span class="keyword">const</span> locationSubscription = locations.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current Position: &#x27;</span>, position);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error Getting Location: &#x27;</span>, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  locationSubscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">&#125;, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="stream">stream</h3>
<p>observable 可以表示任意数据类型，我们将 observable 发布（publish）出来的数据称为流（stream）</p>
<h3 id="custom-fromevent-function">custom fromEvent function</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fromEvent</span>(<span class="params">target, eventName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">e</span>) =&gt; observer.<span class="title function_">next</span>(e);</span><br><span class="line">    target.<span class="title function_">addEventListener</span>(eventName, handler);  </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      target.<span class="title function_">removeEventListener</span>(eventName, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ESC_KEY</span> = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>;</span><br><span class="line"><span class="keyword">const</span> subscription = <span class="title function_">fromEvent</span>(nameInput, <span class="string">&#x27;keydown&#x27;</span>)</span><br><span class="line">  .<span class="title function_">subscribe</span>(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">keyCode</span> === <span class="variable constant_">ESC_KEY</span>) &#123;</span><br><span class="line">      nameInput.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="multicasting">Multicasting</h3>
<p>通常一个 observable 会为每一个调用了 subscribe() 的 observer 创建一次新的、独立的执行。当 observer 调用 subscribe() 的时候，observable 会连接上一个 event handler 并将值传递给 observer。</p>
<p>但是在有的时候，我们可能会想要每个 subscription 都拿到同样的值，这就叫 multicasting。下面是一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sequenceSubscriber</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSequence</span>(<span class="params">arr, idx</span>) &#123;</span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">next</span>(arr[idx]);</span><br><span class="line">      <span class="keyword">if</span> (idx === arr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        observer.<span class="title function_">complete</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">doSequence</span>(arr, ++idx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">doSequence</span>(seq, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> <span class="title class_">Observable</span>(sequenceSubscriber);</span><br><span class="line"></span><br><span class="line">sequence.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1st subscribe&#x27;</span> + num); &#125;,</span><br><span class="line">  <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1st sequence finished.&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 subscribe 两次，那么就会产生两个不同的 stream</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  sequence.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2nd subscribe&#x27;</span> + num); &#125;,</span><br><span class="line">    <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2nd sequence finished.&#x27;</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(at 1 second): 1st subscribe: 1</span><br><span class="line">(at 1.5 seconds): 2nd subscribe: 1</span><br><span class="line">(at 2 seconds): 1st subscribe: 2</span><br><span class="line">(at 2.5 seconds): 2nd subscribe: 2</span><br><span class="line">(at 3 seconds): 1st subscribe: 3</span><br><span class="line">(at 3 seconds): 1st sequence finished</span><br><span class="line">(at 3.5 seconds): 2nd subscribe: 3</span><br><span class="line">(at 3.5 seconds): 2nd sequence finished</span><br></pre></td></tr></table></figure>
<p>将其转换为 multicasting observer：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multicastSequenceSubscriber</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">const</span> observers = [];</span><br><span class="line">  <span class="comment">// 只会产生一组值，被广播给每个 subscriber，因此只有一个 timerId</span></span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 subscriber function，当执行 subscribe() 的之后被调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    observers.<span class="title function_">push</span>(observer);</span><br><span class="line">    <span class="comment">// 如果是第一个 subscription，开始这个 sequence</span></span><br><span class="line">    <span class="keyword">if</span> (observers.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      timeoutId = <span class="title function_">doSequence</span>(&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="params">val</span>) &#123;</span><br><span class="line">          <span class="comment">// 遍历所有的 observers 并通知所有的 subscriptions</span></span><br><span class="line">          observers.<span class="title function_">forEach</span>(<span class="function"><span class="params">obs</span> =&gt;</span> obs.<span class="title function_">next</span>(val));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">complete</span>(<span class="params"></span>) &#123;</span><br><span class="line">          observers.<span class="title function_">slice</span>(<span class="number">0</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">obs</span> =&gt;</span> obs.<span class="title function_">complete</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, seq, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">        observers.<span class="title function_">splice</span>(observers.<span class="title function_">indexOf</span>(observer), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (observers.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSequence</span>(<span class="params">observer, arr, idx</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    observer.<span class="title function_">next</span>(arr[idx]);</span><br><span class="line">    <span class="keyword">if</span> (idx === arr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      observer.<span class="title function_">complete</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">doSequence</span>(observer, arr, ++idx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multicastSequence = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="title function_">multicastSequenceSubscriber</span>());</span><br><span class="line"></span><br><span class="line">multicastSequence.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1st subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">  <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1st sequence finished.&#x27;</span>); &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.5s 后再次 subscribe，不会发送第一个值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  multicastSequence.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2nd subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">    <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2nd sequence finished.&#x27;</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1500</span>);</span><br></pre></td></tr></table></figure>
<h2 id="rxjs">RxJS</h2>
<p>RxJS ( Reactive Extensions for JavaScript ) 是一个响应式编程（一种考虑异步数据流和数据变化）库</p>
<h3 id="create-observable">Create Observable</h3>
<p>RxJS 提供多种函数，可以通过多种方法从事件、Promise、计时器等创建 observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">from</span>(<span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint&#x27;</span>));</span><br><span class="line">data.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">response</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(response); &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">err</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">  <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Completed&#x27;</span>); &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// interval</span></span><br><span class="line"><span class="keyword">const</span> secondsCounter = <span class="title function_">interval</span>(<span class="number">1000</span>);</span><br><span class="line">secondsCounter.<span class="title function_">subscribe</span>(<span class="function"><span class="params">n</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`It&#x27;s been <span class="subst">$&#123;n&#125;</span> seconds since subscribing!`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// fromEvent</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-element&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mouseMoves = <span class="title function_">fromEvent</span>(el, <span class="string">&#x27;mousemove&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> subscription = mouseMoves.<span class="title function_">subscribe</span>(<span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Coords: <span class="subst">$&#123;event.clientX&#125;</span> X <span class="subst">$&#123;event.clientY&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">clientX</span> &lt; <span class="number">40</span> &amp;&amp; event.<span class="property">clientY</span> &lt; <span class="number">40</span>) &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax</span></span><br><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/ajax&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> apiData = <span class="title function_">ajax</span>(<span class="string">&#x27;/api/data&#x27;</span>);</span><br><span class="line">apiData.<span class="title function_">subscribe</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">status</span>, res.<span class="property">response</span>));</span><br></pre></td></tr></table></figure>
<h3 id="operators">Operators</h3>
<p>操作符执行操作，转换原来的 observable 值，并且返回一个包含转换后的值的 observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = <span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareValues = <span class="title function_">map</span>(<span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val * val);</span><br><span class="line"><span class="keyword">const</span> squareNums = <span class="title function_">squareValues</span>(nums);</span><br><span class="line"></span><br><span class="line">squareNums.<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>pipe</code> 将操作符连接在一起，我们将一组被应用在 observable 上的操作符称为一个 recipe，需要调用 <code>subscribe()</code> 来生成这个 recipe 操作之后的结果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = <span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareOddVals = <span class="title function_">pipe</span>(</span><br><span class="line">  <span class="title function_">filter</span>(<span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</span><br><span class="line">  <span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareOdd = <span class="title function_">squareOddVals</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写：</span></span><br><span class="line"><span class="comment">// const squareOdd = nums.pipe(</span></span><br><span class="line"><span class="comment">//   filter((n: number) =&gt; n % 2 !== 0),</span></span><br><span class="line"><span class="comment">//   map(n =&gt; n * n)</span></span><br><span class="line"><span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">squareOdd.<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>
<h3 id="error-handling">Error Handling</h3>
<p>除了 subscription 中的 error handler 之外，还可以使用 <code>catchError</code> 操作符来处理错误，通过这个操作符可以提供一个备用的解决方案，并且不中断运行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiData = <span class="title function_">ajax</span>(<span class="string">&#x27;/api/data&#x27;</span>).<span class="title function_">pipe</span>(</span><br><span class="line">  <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Value expected!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">response</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">of</span>([]))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">apiData.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data: &#x27;</span>, x); &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">err</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;errors already caught and this will not run&#x27;</span>); &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>catchError</code> 可以让错误快速恢复，搭配 <code>retry</code> 还可以进行多次重试：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiData = <span class="title function_">ajax</span>(<span class="string">&#x27;/api/data&#x27;</span>).<span class="title function_">pipe</span>(</span><br><span class="line">  <span class="title function_">retry</span>(<span class="number">3</span>),</span><br><span class="line">  <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Value expected!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">response</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">of</span>([]))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="angular-中的-observables">Angular 中的 Observables</h2>
<h3 id="组件间传值">组件间传值</h3>
<p>Angular 提供了 <code>EventEmitter</code> API，通过 <code>@Output()</code> 就可以发布数据，<code>EventEmitter</code> 就是基于 RxJS Subject 的。 当 <code>emit()</code> 的时候，他会将值传递给任意订阅了的 observer 的 <code>next()</code> 方法。下面是一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父组件监听自定义的 open 和 close 事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">zippy</span> (<span class="attr">open</span>)=<span class="string">&quot;onOpen($event)&quot;</span> (<span class="attr">close</span>)=<span class="string">&quot;onClose($event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">zippy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子组件 emit 这两个自定义事件，并传递值</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;zippy&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;zippy&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div (click)=&quot;toggle()&quot;&gt;Toggle&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div [hidden]=&quot;!visible&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-content&gt;&lt;/ng-content&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ZippyComponent</span> &#123;</span><br><span class="line">  visible = <span class="literal">true</span>;</span><br><span class="line">  <span class="meta">@Output</span>() open = <span class="keyword">new</span> <span class="title class_">EventEmmiter</span>&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line">  <span class="meta">@Output</span>() close = <span class="keyword">new</span> <span class="title class_">EventEmmiter</span>&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toggle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">visible</span> = !<span class="variable language_">this</span>.<span class="property">visible</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">visible</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">open</span>.<span class="title function_">emit</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">close</span>.<span class="title function_">emit</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="http">HTTP</h3>
<p>Angular 的 <code>HttpClient</code> API 也将会返回 observables，这有一些优点：</p>
<ul>
<li>Observables 不会修改从服务端获取的数据</li>
<li>可以通过 <code>unsubscribe()</code> 方法取消请求</li>
<li>可以配制请求</li>
</ul>
<h3 id="async-pipe">Async pipe</h3>
<p>AsyncPipe 会 subscribe 一个 observable 或 promise，并且返回他发出的最新值</p>
<h3 id="router">Router</h3>
<p><code>Router.events</code> 也是以 observables 的形式提供事件的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span>, <span class="title class_">NavigationStart</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; filter &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">RoutableComponent</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line">  <span class="attr">navStart</span>: <span class="title class_">Observable</span>&lt;<span class="title class_">NavigationStart</span>&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">navStart</span> = router.<span class="property">events</span>.<span class="title function_">pipe</span>(</span><br><span class="line">      <span class="title function_">filter</span>(<span class="function"><span class="params">event</span> =&gt;</span> event <span class="keyword">instanceof</span> <span class="title class_">NavigationStart</span>)</span><br><span class="line">    ) <span class="keyword">as</span> <span class="title class_">Observable</span>&lt;<span class="title class_">NavigationStart</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">navStart</span>.<span class="title function_">subscribe</span>(<span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Navigation Started!&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区分-observables-和其他技术">区分 Observables 和其他技术</h2>
<h3 id="observables-和-promises">Observables 和 Promises</h3>
<ul>
<li>Observables 是 declarative，当调用 <code>subscribe()</code> 的时候才会执行，而 Promise 在定义后会马上执行</li>
<li>Observables 提供多个值，而 Promises 值提供一个值</li>
<li>Observables 有链式调用和 subscribe()</li>
</ul>
<h4 id="创建与订阅">创建与订阅</h4>
<ul>
<li>Observables 在 consumer subscribe 的时候才会执行，并且每个 subscription 都拥有自己独立的计算</li>
<li>Promises 在创建的时候执行，并且在创建的时候就已经开始计算结果了，每个 then 分享同样的结果，并且不能中断或者重启</li>
</ul>
<h4 id="链式调用">链式调用</h4>
<ul>
<li>Observables 将转换数据与最终获取（订阅）的过程分开了，只有订阅（subscription）才会让 subscriber 函数开始计算结果</li>
<li>Promises 并不会区分中间与最后的 then</li>
</ul>
<h4 id="取消">取消</h4>
<ul>
<li>Observables 可以在 subscriber 函数中返回 unsubscribe 方法，并可使用 <code>subscription.unsubscribe()</code> 进行调用</li>
<li>Promises 则无法取消</li>
</ul>
<h4 id="错误处理">错误处理</h4>
<ul>
<li>Observables 会将错误传递给 subscriber 的 error handler（在调用 <code>subscribe()</code> 的时候定义）</li>
<li>Promises 将错误传递给子 Promises</li>
</ul>
<h3 id="observables-与-eventhandlers">Observables 与 EventHandlers</h3>
<ul>
<li>都定义了通知处理方法（notification handlers），并且通过他们来随着时间变化的处理多个值</li>
<li>subscribe 一个 observables 相当于添加一个事件监听，不同在于 observables 可以在传递给 handler 之前对数据进行转换和处理</li>
<li>可以在比如 HTTP 请求之类的异步操作中使用 Observables 来处理事件，这样可以增加上下文的紧密度</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   都需要定义 handlers</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Clicked&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Events API</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建并开始监听</span></span><br><span class="line">buttonEl.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line"><span class="comment">// 取消监听</span></span><br><span class="line">buttonEl.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Observable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> clicks$ = <span class="title function_">fromEvent</span>(buttonEl, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="keyword">const</span> subscription = clicks$.<span class="title function_">subscribe</span>(handler)</span><br><span class="line"><span class="comment">// 取消监听</span></span><br><span class="line">subscription.<span class="title function_">unsubscribe</span>()</span><br></pre></td></tr></table></figure>
<h1 id="approutingmodule">AppRoutingModule</h1>
<p>在 Angular 中，我们通过一个分离的、顶级的模块来用于导航，通常我们将其命名为 <code>AppRoutingModule</code>，他通常在 <code>src/app</code> 文件夹的 <code>app-routing.module.ts</code> 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ng generate module app-routing --flat --module=app</span><br><span class="line"><span class="comment"># --flat 是他不会再在 src/app 中新建其他的文件夹</span></span><br><span class="line"><span class="comment"># --module=app 则使得其被写在 AppModule 的 imports 中</span></span><br></pre></td></tr></table></figure>
<p>通常我们需要将这个文件改造成这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NgModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterModule</span>, <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HeroesComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./heroes/heroes.component&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DashboardComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dashboard/dashboard.component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HeroDetailComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./hero-detail/hero-detail.component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Routes</span> = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">redirectTo</span>: <span class="string">&#x27;/dashboard&#x27;</span>, <span class="attr">pathMatch</span>: <span class="string">&#x27;full&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>, <span class="attr">component</span>: <span class="title class_">DashboardComponent</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;detail/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">HeroDetailComponent</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;heroes&#x27;</span>, <span class="attr">component</span>: <span class="title class_">HeroesComponent</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">RouterModule</span>.<span class="title function_">forRoot</span>(routes)],</span><br><span class="line">  <span class="comment">// 由于我们是在应用的 root level 定义路由，因此需要使用 forRoot</span></span><br><span class="line">  <span class="comment">// forRoot 方法提供了路由中需要的 service providers 和 directives</span></span><br><span class="line">  <span class="attr">exports</span>: [<span class="title class_">RouterModule</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后需要在 html 模板中这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">&quot;/heroes&quot;</span>&gt;</span>Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>+this.route.snapshot.paramMap.get('id')</code> 这样的方法来从当前的地址中获取到 params</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Blockchain</title>
    <url>/hais-notebook/2023/01/16/Blockchain/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="etherum">Etherum</h1>
<iframe src="https://xmind.works/share/SmAWvzOo" style="width: 100%; height: 600px; border: none;">
</iframe>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记：《计算机科学精粹》</title>
    <url>/hais-notebook/2021/05/09/Book-ComputerScienceDistilled/</url>
    <content><![CDATA[<p>有幸得贵人赠书《计算机科学精粹》，将纸质版读书笔记提炼誊抄至此。</p>
<span id="more"></span>
<h1 id="第一章预备知识">第一章：预备知识</h1>
<h2 id="逻辑">逻辑</h2>
<h3 id="运算符">运算符</h3>
<blockquote>
<p>我们称 <code>-&gt;</code> 为条件运算符，可读作「若……，则……」</p>
</blockquote>
<p>一个示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A: 泳池暖和</span><br><span class="line">B: 我去游泳</span><br><span class="line">A -&gt; B: 如果泳池暖和，我就去游泳</span><br></pre></td></tr></table></figure>
<h4 id="换质位法">换质位法</h4>
<p>指的是这两句话含义相同（即逆否命题与原命题含义相同）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A -&gt; B: 如果泳池暖和，我就去游泳</span><br><span class="line">!B -&gt; !A: 如果我不去游泳，那么泳池就不暖和</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><code>A -&gt; B</code> 和 <code>B -&gt; A</code> 含义并不相同！</p>
</div>
<h4 id="双条件">双条件</h4>
<p>若要使 <code>A -&gt; B</code> 和 <code>B -&gt; A</code> 都成立，则需要使用双条件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A &lt;-&gt; B: 当且仅当泳池暖和，我才去游泳</span><br></pre></td></tr></table></figure>
<h3 id="布尔代数">布尔代数</h3>
<h4 id="结合律">结合律</h4>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A and ( B and C ) = ( A and B ) and C</span><br><span class="line">A or ( B or C ) = ( A or B ) or C</span><br></pre></td></tr></table></figure>
<h4 id="分配律">分配律</h4>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A and ( B or C ) = ( A and B ) or ( A and C )</span><br><span class="line">A or ( B and C ) = ( A or B ) and ( A or C )</span><br></pre></td></tr></table></figure>
<h4 id="德摩根定律">德摩根定律</h4>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">!( A and B ) = !A or !B</span><br><span class="line">!( A or B ) = !A and !B </span><br></pre></td></tr></table></figure>
<h2 id="计数">计数</h2>
<h3 id="乘法">乘法</h3>
<p>两个不相关事件的可能性用乘法计算：</p>
<p><span class="math display">\[
{m}\cdot{n}
\]</span></p>
<h3 id="排列">排列</h3>
<p>n 个项的排列方式种数：</p>
<p><span class="math display">\[
n!
\]</span></p>
<p>n 个元素中选 m 个排成一列：</p>
<p><span class="math display">\[
A_{n}^{m} = \frac{n!}{(n-m)!}
\]</span></p>
<p>n 个元素中，r 个相同排成一列：</p>
<p><span class="math display">\[
\frac{n!}{r!}
\]</span></p>
<h3 id="组合">组合</h3>
<p>n 个不同元素，选 m 个并成一组（与顺序无关）：</p>
<p><span class="math display">\[
\tbinom{n}{m} = C_{n}^{m} = \frac{n!}{m!(n-m)!}
\]</span></p>
<h3 id="概率">概率</h3>
<ul>
<li>独立事件：两个事件的结果不会相互影响，概率相乘</li>
<li>互斥事件：两个事件结果不能同时发生，概率相加</li>
<li>对立事件：两个互斥事件概率涵盖所有可能的结果，概率之和为 1</li>
</ul>
<h1 id="第二章复杂度">第二章：复杂度</h1>
<h2 id="时间复杂度的计算">时间复杂度的计算</h2>
<p>例：选择排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 外层循环执行 n-1 次，每次执行赋值、交换两项操作，共 2n-2 次</span></span><br><span class="line">  <span class="keyword">for</span> (current = <span class="number">1</span> ... list.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    smallest = current</span><br><span class="line">    <span class="comment">// 内层循环执行 n-1（外层第一次）、n-2（外层第二次）、n-3 次，共计 (n*n-n)/2 次赋值与交换操作，也就是 n*n-n 次操作 </span></span><br><span class="line">    <span class="keyword">for</span> (i = current + <span class="number">1</span> ... list.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i] &lt; list[current]) &#123;</span><br><span class="line">        smallest = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.<span class="title function_">swap_items</span>(current, smallest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此上述选择排序算法总计进行了 <span class="math inline">\(T(n) = n^2 + n - 2\)</span> 次操作</p>
<h2 id="大-o-符号">大 O 符号</h2>
<p>表示最坏情况下算法成本函数的主项，比如选择排序的时间复杂度可记为 <span class="math inline">\(O(n^2)\)</span></p>
<h2 id="空间复杂度的计算">空间复杂度的计算</h2>
<p>比如对于选择排序，只需要一组固定的变量作为存储空间，因此空间复杂度可以记为 <span class="math inline">\(O(1)\)</span></p>
<h1 id="第三章策略">第三章：策略</h1>
<p>本章主要讲解这几种策略：</p>
<ul>
<li>通过 <strong>迭代</strong> 处理 <em>重复性</em> 任务</li>
<li>通过 <strong>递归</strong> 进行优雅地 <em>迭代</em></li>
<li>资源允许时使用 <strong>蛮力法</strong></li>
<li>测试不可行的选择并 <strong>回溯</strong></li>
<li>采用 <strong>启发法</strong> 合理缩短求解的时间</li>
<li>采用 <strong>分治法</strong> 求解难题</li>
<li><strong>动态地</strong> 识别重复问题，避免浪费资源</li>
<li>对问题 <strong>定界</strong> 缩小求解范围</li>
</ul>
<h2 id="迭代">迭代</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   ┌──────┐循环(每一步操作就被称为迭代)</span><br><span class="line">   │      │                           满足条件 </span><br><span class="line">求解过程 ────────────────────────────────────────────&gt; 目标</span><br><span class="line">   ↑      │</span><br><span class="line">   └──────┘</span><br></pre></td></tr></table></figure>
<p>例：合并两个排好序的数组</p>
<p>比如将 <code>[1, 3, 5, 7]</code> 与 <code>[2, 4, 6, 8]</code> 合并为 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">while</span> (list1.<span class="property">has_item</span> || list2.<span class="property">has_item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list1.<span class="property">top_item</span> &gt; list2.<span class="property">top_item</span>) &#123;</span><br><span class="line">      temp = list1.<span class="property">remove_top_item</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp = list2.<span class="property">remove_top_item</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(fish)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：嵌套循环与幂集</p>
<blockquote>
<p>对于给定对象 S 的集合，其幂集是 S 的全部子集构成的集合</p>
</blockquote>
<p>比如有几种花，花可以调配香水，我们需要求出能调配的所有可能的香水。</p>
<p>使用迭代的思维：</p>
<ul>
<li>若没有花，一种无味的香水，记做0</li>
<li>若有一种花：0、A</li>
<li>若有两种花：0、A、0+B、A+B</li>
<li>若有三种花：0、A、0+B、A+B、0+C、A+C、0+B+C、A+B+C</li>
</ul>
<p>不难发现，多加一种花，就是把之前的复制一遍，再给复制之后的每种香水加上新的花。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">powerSet</span>(<span class="params">flowers</span>) &#123;</span><br><span class="line">  fragrances = <span class="title class_">Set</span>.<span class="property">new</span></span><br><span class="line">  fragrances.<span class="title function_">add</span>(<span class="title class_">Set</span>.<span class="property">new</span>)</span><br><span class="line">  <span class="keyword">for</span> (flower <span class="keyword">in</span> flowers) &#123;</span><br><span class="line">    <span class="comment">// 复制已有的香水</span></span><br><span class="line">    new_fragrances = <span class="title function_">copy</span>(fragrances)</span><br><span class="line">    <span class="keyword">for</span> (fragrance <span class="keyword">in</span> new_fragrances) &#123;</span><br><span class="line">      <span class="comment">// 给复制之后的香水加上新的花</span></span><br><span class="line">      fragrance.<span class="title function_">add</span>(flower)</span><br><span class="line">    &#125;</span><br><span class="line">    fragrances = fragrances + new_fragrances</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragrances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种构建幂集的方式时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，每增加一次循环，时间将会增加一倍。这种方法也可以用于构建真值表，每种花是否加入用布尔值进行表示。</p>
<h2 id="递归">递归</h2>
<blockquote>
<p>函数自己调用自己</p>
</blockquote>
<p>例：判断回文字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (word.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (word.<span class="property">first_char</span> != word.<span class="property">last_char</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  w = word.<span class="property">remove_first_and_last_char</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isPalindrome</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归与迭代：递归算法通常更短，但由于其执行时大量调用自身，从而引入计算开销。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">迭代：</span><br><span class="line">START =&gt; 1 =&gt; 2 =&gt; 3 =&gt; END</span><br><span class="line"></span><br><span class="line">递归：</span><br><span class="line">START =&gt; 1 =&gt; 2 =&gt; 3</span><br><span class="line">                   ↓</span><br><span class="line">  END &lt;= 1 &lt;= 2 &lt;= 3</span><br></pre></td></tr></table></figure>
<h2 id="蛮力法穷举法">蛮力法（穷举法）</h2>
<p>有时候，蛮力法的时间复杂度很高（<span class="math inline">\(O(n^2)\)</span>），比如最佳交易日问题；有时候他的时间复杂度也并不会是最差的，比如对于 NP 完全问题（背包问题，对其求幂集，然后进行逐行检查）。</p>
<blockquote>
<p>对于 NP 完全问题，只有指数算法才能解决这个问题。</p>
</blockquote>
<h2 id="回溯法">回溯法</h2>
<p>例：八皇后问题。在棋盘上放置八个后，如何才能让他们不相互攻击？</p>
<p>核心：仅搜索 <strong>可行的</strong> 位置，比如：第一个可随意摆放，第二个不能与第一个相互攻击，……这种情况下可能摆不满八个就不能继续摆了，这时就需要 <strong>回溯</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queens</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (board.<span class="property">has_8_queens</span>) <span class="keyword">return</span> board</span><br><span class="line">  <span class="keyword">for</span> (position <span class="keyword">in</span> board.<span class="property">unattacked_positions</span>) &#123;</span><br><span class="line">    board.<span class="title function_">place_queen</span>(position)</span><br><span class="line">    solution = <span class="title function_">queens</span>(board)</span><br><span class="line">    <span class="keyword">if</span> (solution) <span class="keyword">return</span> solution</span><br><span class="line">    board.<span class="title function_">remove_queen</span>(position)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启发法">启发法</h2>
<blockquote>
<p>依靠直觉找出一种够好的方法</p>
</blockquote>
<h3 id="贪心法">贪心法</h3>
<p>一种常用的启发法。他：</p>
<ol type="1">
<li>永远不会回退到之前的选择</li>
<li>尝试在每一步都做出最佳选择</li>
<li>无后效性</li>
</ol>
<p>例：邪恶背包问题。小偷不会计算出最佳的装背包方法。他会不断地将最值钱的东西放入背包，直到背包塞满。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greedy_knapsack</span>(<span class="params">items, max_weight</span>) &#123;</span><br><span class="line">  bag_weight = <span class="number">0</span></span><br><span class="line">  bag_items = <span class="title class_">List</span>.<span class="property">new</span></span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="title function_">sort_by_value</span>(items)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_weight &gt;= bag_weight + item.<span class="property">weight</span>) &#123;</span><br><span class="line">      bag_weight += item.<span class="property">weight</span></span><br><span class="line">      bag_items.<span class="title function_">append</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bag_items</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用贪心法解决电网问题">利用贪心法解决电网问题</h3>
<p>贪心法有时也能获得最优解：</p>
<p>例：如何使用最短的输电线将所有的定居点接入电网？</p>
<ol type="1">
<li>从尚未连入电网的定居点中，选择与已有电力供应的定居点最近的，连接他们</li>
<li>重复，直到左右的定居点都连入电网</li>
</ol>
<h2 id="分治法">分治法</h2>
<blockquote>
<p>将问题分解为若干个小问题</p>
</blockquote>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge_sort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (list.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> list</span><br><span class="line">  left = list.<span class="property">left_half</span></span><br><span class="line">  right = list.<span class="property">right_half</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">merge_sort</span>(left), <span class="title function_">merge_sort</span>(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最佳交易日问题">最佳交易日问题</h3>
<p>例：给出一段时间内的每日金价，找出一个买入日期、一个卖出日期，达到利润最大化。</p>
<p>思路：将时间一分为二，分别找出前半段和后半段的最佳交易。整个时间段的最佳交易日则可能是：</p>
<ol type="1">
<li>前半段买入并卖出</li>
<li>后半段买入并卖出</li>
<li>前半段买入后半段卖出</li>
</ol>
<p>前两个情况就是两个子问题，第三种情况则是在前半段的最低价买入，后半段的最高价卖出。 递归的终点就是当天买入当天卖出，收益为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trade</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  former = prices.<span class="property">first_half</span></span><br><span class="line">  later = prices.<span class="property">last_half</span></span><br><span class="line">  case3 = <span class="title function_">max</span>(later) - <span class="title function_">min</span>(former)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">max</span>(<span class="title function_">trade</span>(former), <span class="title function_">trade</span>(later), case3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题">背包问题</h3>
<p>我们将第 <span class="math inline">\(i\)</span> 件物品的重量记为 <span class="math inline">\(w_i\)</span>，价值记为 <span class="math inline">\(v_i\)</span>。将选择的物品数量记为 <span class="math inline">\(n\)</span>，背包容量记为 <span class="math inline">\(c\)</span>，背包的总价值记为 <span class="math inline">\(K(n,c)\)</span>。</p>
<p>当考察到第 <span class="math inline">\(n\)</span> 件物品的时候（<span class="math inline">\(K(n,c)\)</span>），有两种情况：</p>
<ol type="1">
<li><span class="math inline">\(K(n-1,c)\)</span>：不拿第 <span class="math inline">\(n\)</span> 件物品，留给之前 <span class="math inline">\(n-1\)</span> 次选择的容量仍然为 <span class="math inline">\(c\)</span></li>
<li><span class="math inline">\(K(n-1,c-w_n)+v_n\)</span>：拿第 <span class="math inline">\(n\)</span> 件物品，留给之前 <span class="math inline">\(n-1\)</span> 次选择的容量就要减去第 <span class="math inline">\(n\)</span> 次的重量</li>
</ol>
<p>因此我们得到这样的递归公式：</p>
<p><span class="math display">\[
K(n,c)=max(K(n-1,c),K(n-1,c-w_n)+v_n)
\]</span></p>
<h2 id="动态规划">动态规划</h2>
<blockquote>
<p>找出重复的子问题，对每个重复的子问题只计算一次</p>
</blockquote>
<h3 id="利用记忆化求解斐波那契数">利用记忆化求解斐波那契数</h3>
<p>这是一个普通的斐波那契数计算函数，可以看出他对很多数进行了重复计算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将每次计算的结果存起来，这种 <strong>记忆化</strong> 的技巧可以提高 fib 算法的性能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">M = &#123; <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n not <span class="keyword">in</span> M) &#123;</span><br><span class="line">    M[n] = <span class="title function_">dfib</span>(n - <span class="number">1</span>) + <span class="title function_">dfib</span>(n - <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> M[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用记忆化求解背包问题">利用记忆化求解背包问题</h3>
<p>不难发现，在用分治法求解背包问题的时候，也会有很多重复的计算，可以用类似的方法将计算结果记下来，提升性能。</p>
<h3 id="利用自底向上法求解最佳交易问题">利用自底向上法求解最佳交易问题</h3>
<p>用分治法求最佳交易日的递归中，不存在重复调用，<strong>但存在重复计算</strong>——算法不断地在将数据一分为二后求最大值和最小值（比如我们需要找出房间里最高的人、最高的男人和最高的女人，我们不需要先测量所有人的身高找出最高的人，再测量所有的男人以找到最高的男人，再测量所有的女人以找到最高的女人）。</p>
<p>我们之前使用的都是 <strong>自顶向下</strong> 法来解决问题，这种方法中，输入不断减小，直到到达基线条件。我们也可以采用 <strong>自底向上</strong> 法：首先计算基线条件，然后不断组合，直到得到通解（感觉有点像数学归纳法）。</p>
<p>假设第 <span class="math inline">\(n\)</span> 天的金价为 <span class="math inline">\(P(n)\)</span>，且在第 <span class="math inline">\(n\)</span> 天卖出是的买入最佳交易日为 <span class="math inline">\(B(n)\)</span>。</p>
<ul>
<li><span class="math inline">\(B(1)\)</span>：在第一天卖出只能在第一天买入，因此 <span class="math inline">\(B(1) = 1\)</span></li>
<li><span class="math inline">\(B(2)\)</span>：如果在第二天卖出，可以在第一天买入，也可以在第一天卖出
<ul>
<li>若 <span class="math inline">\(P(2) &lt; P(1)\)</span>，则在第二天买入，<span class="math inline">\(B(2) = 2\)</span></li>
<li>若 <span class="math inline">\(P(2) \ge P(1)\)</span>，则在第一天买入，<span class="math inline">\(B(2) = 1\)</span></li>
</ul></li>
<li><span class="math inline">\(B(3)\)</span>：如果在第三天卖出，可以在第三天买入，也可以在前两天的最佳交易日买入
<ul>
<li>若 <span class="math inline">\(P(3) &lt; P(B(2))\)</span>，则在第三天买入，<span class="math inline">\(B(3) = 3\)</span></li>
<li>若 <span class="math inline">\(P(3) \ge P(B(2))\)</span>，则在前两天的最佳交易日买入，<span class="math inline">\(B(3) = B(2)\)</span></li>
</ul></li>
<li>……</li>
</ul>
<p>由此可以得到：</p>
<p><span class="math display">\[
B(n) =
\begin{cases}
n, &amp; P(n) &lt; P(B(n-1)) \\
B(n-1), &amp; P(n) \ge P(B(n-1))
\end{cases}
\]</span></p>
<p>然后我们就可以求得所有的 <span class="math inline">\(B\)</span>，从而求得对应的利润：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trade_dp</span>(<span class="params">P</span>) &#123;</span><br><span class="line">  B[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  sell_day = <span class="number">1</span></span><br><span class="line">  best_profit = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt;= P.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    B[n] = P[n] &lt; P[B[n - <span class="number">1</span>]] ? n : B[n - <span class="number">1</span>]</span><br><span class="line">    profit = P[n] - P[B[n]]</span><br><span class="line">    <span class="keyword">if</span> (profit &gt; best_profit) &#123;</span><br><span class="line">      sell_day = n</span><br><span class="line">      best_profit = profit</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; sell_day, <span class="attr">buy_day</span>: B[sell_day], best_profit &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trade_dp</code> 算法对输入列表的每个元素执行一组固定的简单操作，因此时间复杂度为 <span class="math inline">\(O(n)\)</span>，比之前讨论的 <span class="math inline">\(O(n \cdot log n)\)</span> 算法有很大的提升。但由于辅助向量 <span class="math inline">\(B\)</span> 的元素数量与输入一样多，因此它的空间复杂度是 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="分支定界法">分支定界法</h2>
<blockquote>
<p>有助于预测最佳差的路径，避免在这些路径上浪费时间</p>
</blockquote>
<h3 id="上界与下界">上界与下界</h3>
<p>比如在之前讨论的邪恶背包问题中，<code>greedy_knapsack</code> 算法给出了最优利润的下界，这个下界可能接近（也可能不接近）最优利润。</p>
<p>现在来看另一种形式的背包问题，所有的物品均为粉末，我们可以将物品的一部分放入背包。我们同样可以用贪心法求解，始终将最优性价比的物品放入背包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">powdered_knapsack</span>(<span class="params">items, max_weight</span>) &#123;</span><br><span class="line">  bag_weight = <span class="number">0</span></span><br><span class="line">  bag_items = <span class="title class_">List</span>.<span class="property">new</span></span><br><span class="line">  items = <span class="title function_">sort_by_value_weight_ratio</span>(items)</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">    <span class="comment">// 有可能这件物品总重量比剩下的容量大</span></span><br><span class="line">    weight = <span class="title function_">min</span>(max_weight - bag_weight, item.<span class="property">weight</span>)</span><br><span class="line">    bag_weight = bag_weight + weight</span><br><span class="line">    value = weight * item.<span class="property">value_weight_ratio</span></span><br><span class="line">    bagged_value = bagged_value + value</span><br><span class="line">    bag_items.<span class="title function_">append</span>(item, weight)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bag_items, bag_value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>powdered_knapsack</code> 算法实际上给出了不可分割物品版本最优利润的上界。</p>
<h3 id="背包问题的上界与下界">背包问题的上界与下界</h3>
<blockquote>
<p>看书 P56 的图解比较舒服</p>
</blockquote>
<p>如果要求出解背包问题最优解，时间复杂度为 <span class="math inline">\(O(2^n)\)</span>。但我们利用 <code>greedy_knapsack</code> 和 <code>powdered_knapsack</code> 可以很快速地求出背包问题最优利润的下界和上界。</p>
<p>假设我们有 ABCDE 五件物品，容量为 10 的背包。我们求出他的上界和下界。 然后用类似于分治法的思维往下分解，考虑放入 E 和不放入 E 的两种场景。最终我们发现上界和下界收束了。</p>
<ol type="1">
<li>将问题分解为若干子问题</li>
<li>找出子问题的上界和下界</li>
<li>比较所有分支的界限</li>
<li>对最可行的子问题重复第 1 步</li>
</ol>
<h1 id="第四章数据">第四章：数据</h1>
<ul>
<li><strong>过程抽象</strong>：将复杂的过程隐藏在调用的后面，使得算法更加简单</li>
<li><strong>数据抽象</strong>：隐藏数据处理过程的细节</li>
<li><strong>抽象数据模型</strong>：可以用抽象数据模型来讨论问题，在代码中也应该使用抽象数据模型封装好的接口，这样当底层的数据结构发生改变的时候也不用改变程序中的其他代码
<ul>
<li>常见的抽象数据模型：栈、队列、优先队列、列表、排序列表、映射、集合</li>
</ul></li>
<li><strong>数据结构</strong>：抽象数据模型的底层具体实现</li>
</ul>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
<th>适用的抽象数据模型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数组</td>
<td>易于编写，可以立即访问到任何元素</td>
<td>内存中需要大量分配连续空间，删除或添加中间元素比较麻烦</td>
<td>栈、列表、队列</td>
</tr>
<tr class="even">
<td>链表</td>
<td>每个单元可以保存在内存的任何位置，可以很容易地增删元素</td>
<td>无法立即检索到某个元素，没有其他信息的情况下无法获取到前一个单元的地址</td>
<td>栈、列表、队列</td>
</tr>
<tr class="odd">
<td>双向链表</td>
<td>在链表的基础上可以向两个方向移动</td>
<td>无法立即检索到某个元素，两个指针增加代码复杂性，需要更多内存</td>
<td>栈、列表、队列</td>
</tr>
<tr class="even">
<td>树</td>
<td>与链表类似</td>
<td></td>
<td>文件目录结构等有层次关系的数据</td>
</tr>
<tr class="odd">
<td>二叉查找树</td>
<td>查找速度很快</td>
<td></td>
<td>映射、集合</td>
</tr>
<tr class="even">
<td>二叉堆</td>
<td>可以立即检索到最大（或最小）的元素</td>
<td></td>
<td>优先队列</td>
</tr>
<tr class="odd">
<td>图</td>
<td>非常灵活</td>
<td></td>
<td>几乎可以表示任何类型的数据、人际关系</td>
</tr>
<tr class="even">
<td>散列表</td>
<td>查找元素的时间复杂度为 <span class="math inline">\(O(1)\)</span>，且比树插入删除更快</td>
<td>需要预先分配大量连续内存，空间不足时散列冲突会显著影响性能</td>
<td>映射、集合</td>
</tr>
</tbody>
</table>
<h2 id="抽象数据类型">抽象数据类型</h2>
<p><strong>抽象数据类型（ADT）</strong> 是一组有意义的操作规范，ADT 定义的接口用于处理保存给定类型数据的变量。</p>
<h2 id="常见抽象">常见抽象</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p>编程语言内置的数据类型，无需调用外部模块即可使用。总是包括整数、浮点数，以及对他们的简单操作等。</p>
<h3 id="栈">栈</h3>
<blockquote>
<p>后进先出（LIFO）。用于处理一堆元素，并且只对栈顶的元素进行操作。</p>
</blockquote>
<ul>
<li><code>push(e)</code>：将元素 <code>e</code> 添加到栈顶</li>
<li><code>pop()</code>：检索并删除栈顶元素</li>
</ul>
<p>比如文本编辑器为了实现撤销功能，可以用栈。</p>
<h3 id="队列">队列</h3>
<blockquote>
<p>先进先出（FIFO）。检索到的元素总是最先加入的元素。</p>
</blockquote>
<ul>
<li><code>enqueue(e)</code>：将元素 <code>e</code> 添加到队列后端</li>
<li><code>dequeue()</code>：删除并返回队列最前端的元素</li>
</ul>
<h3 id="优先队列">优先队列</h3>
<blockquote>
<p>队列的基础上，增加了 <strong>优先级</strong>，比如排队就诊的队列中，重病急诊患者优先级最高。</p>
</blockquote>
<ul>
<li><code>enqueue(e, p)</code>：根据优先级 <code>p</code> 将元素 <code>e</code> 添加到队列</li>
<li><code>dequeue()</code>：删除并返回队列最前端的元素</li>
</ul>
<h3 id="列表">列表</h3>
<blockquote>
<p>不受限制地将元素重新排序，或者对任意位置的元素进行访问、插入、删除。</p>
</blockquote>
<ul>
<li><code>insert(n, e)</code>：将元素 <code>e</code> 插入到位置 <code>n</code></li>
<li><code>remove(n)</code>：删除位置 <code>n</code> 的元素</li>
<li><code>get(n)</code>：获取位置 <code>n</code> 的元素</li>
<li><code>sort()</code>：将列表中的元素排序</li>
<li><code>slice(start, end)</code>：返回从位置 <code>start</code> 到 <code>end</code> 的字列表</li>
<li><code>reverse()</code>：反转列表的顺序</li>
</ul>
<h3 id="排序列表">排序列表</h3>
<blockquote>
<p>一个始终保持排序状态的列表。</p>
</blockquote>
<ul>
<li><code>insert(e)</code>：将元素 <code>e</code> 插入到正确的位置</li>
<li><code>remove(n)</code>：删除位置 <code>n</code> 的元素</li>
<li><code>get(n)</code> 获取位置 <code>n</code> 的元素</li>
</ul>
<h3 id="映射">映射</h3>
<blockquote>
<p>即字典。用来存储 <strong>键</strong> 和 <strong>值</strong> 之间的映射关系。可以通过键来查询映射，并获取到对应的值。</p>
</blockquote>
<ul>
<li><code>set(key, value)</code>：添加键值映射</li>
<li><code>delete(key)</code>：删除 <code>key</code> 及其关联的值</li>
<li><code>get(key)</code>：获取 <code>key</code> 关联的值</li>
</ul>
<h3 id="集合">集合</h3>
<blockquote>
<p>若干 <strong>唯一</strong> 元素的 <strong>无序</strong> 集合。</p>
</blockquote>
<ul>
<li><code>add(e)</code>：添加元素</li>
<li><code>list()</code>：列出集合中的元素</li>
<li><code>delete(e)</code>：删除集合中的元素 <code>e</code></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>描述了数据在计算机内存中的组织与访问方式</li>
<li>提供了在数据处理模块中实现 ADT 的方法</li>
</ul>
<h3 id="数组">数组</h3>
<blockquote>
<p>计算机在内存中分配连续的存储空间，然后按顺序将元素写入该空间，并用特殊的 <code>NULL</code> 令牌标记序列的结束</p>
</blockquote>
<p>假设数组从地址 <span class="math inline">\(s\)</span> 开始存储，每个元素的长度为 <span class="math inline">\(b\)</span> 字节，那么如果需要访问第 <span class="math inline">\(n\)</span> 个元素，则只需要从地址 <span class="math inline">\(s+(b·n)\)</span> 开始取出 <span class="math inline">\(b\)</span> 字节即可</p>
<p>因此我们可以 <strong>立即</strong> 访问到任何元素</p>
<p>数组可以用来实现栈、列表、队列，易于编写且可以即时访问，但也存在缺点：</p>
<ul>
<li>内存中大量分配连续空间不太现实，如果要对数组进行扩展，内存中可能没有足够的连续可用空间</li>
<li>删除中间元素需要将之后所有的元素前移，添加中间元素需要将之后的所有元素后移</li>
</ul>
<h3 id="链表">链表</h3>
<blockquote>
<p>每个单元包含一个指针，指向下一个单元的地址，包含空指针的单元标记了链的结束</p>
</blockquote>
<p>列表可以很容易地增删元素，并且每个单元可以保存在内存的任何位置</p>
<p>可以利用链表实现栈、列表、队列</p>
<p>列表的不足之处：</p>
<ul>
<li>无法立即检索到第 <span class="math inline">\(n\)</span> 个元素</li>
<li>在没有其他信息的情况下，无法获取到链中前一个单元的地址，于是没办法删除这个单元</li>
</ul>
<h3 id="双向链表">双向链表</h3>
<blockquote>
<p>每个单元包含两个指针，分别指向签一个单元和后一个单元</p>
</blockquote>
<p>即便只给出一个单元的地址，也可以删除这个单元，但仍然无法立即访问第 <span class="math inline">\(n\)</span> 个元素</p>
<h3 id="树">树</h3>
<blockquote>
<p>每个单元中包含着指向其他单元的指针，但这些单元及其指针并不是像链表一样线性排列，而是呈树状结构</p>
</blockquote>
<p>特别适合保存文件目录结构、军队的命令链等具有层次关系的数据</p>
<ul>
<li><strong>结点</strong>：每个单元称为一个结点</li>
<li><strong>边</strong>：从一个单元指向另一个单元的指针</li>
<li><strong>根节点</strong>：位于树顶端的结点，他是唯一没有 <strong>父结点</strong> 的结点。除了根结点外，每个结点都 <strong>有且仅有</strong> 一个父结点</li>
<li><strong>兄弟节点</strong>：具有相同父结点的两个结点</li>
<li><strong>叶结点</strong>：没有任何子结点的结点</li>
<li><strong>路径</strong>：两个结点之间的路径是从一个结点到另一个结点的 <strong>一组结点与边</strong></li>
<li><strong>层次</strong>：结点的层次是该结点与根节点的路径长度</li>
<li><strong>高度</strong>：树中最深结点的高度</li>
<li><strong>森林</strong>：树的集合</li>
</ul>
<h3 id="二叉查找树">二叉查找树</h3>
<blockquote>
<p>一种能实现高效搜索的特殊树结构</p>
</blockquote>
<p>树中的结点最多可以有两个子结点，根据结点的键值对确定其位置。父结点左侧的子结点必须小于父结点，右侧的子结点必须大于父结点。</p>
<p>我们可以很容易在这种特殊的树上搜索具有给定键值对的某个结点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">find_node</span>(<span class="params">binary_tree, value</span>) &#123;</span><br><span class="line">  node = binary_tree.<span class="property">root_node</span></span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">value</span> == value) &#123; <span class="keyword">return</span> node &#125;</span><br><span class="line">    node = value &gt; node.<span class="property">value</span> ? node.<span class="property">right</span> : node.<span class="property">left</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;NOT FOUND&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素时，我们需要在树中搜索这个值。采用搜索中探索的最后一个节点，并使其的左指针或右指针指向新节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert_node</span>(<span class="params">binary_tree, new_node</span>) &#123;</span><br><span class="line">  node = binary_tree.<span class="property">root_node</span></span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    last_node = node</span><br><span class="line">    node = new_node.<span class="property">value</span> &gt; node.<span class="property">value</span> ? node.<span class="property">right</span> : node.<span class="property">left</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_node.<span class="property">value</span> &gt; last_node.<span class="property">value</span>) &#123;</span><br><span class="line">    last_node.<span class="property">right</span> = new_node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_node.<span class="property">left</span> = new_node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的平衡">树的平衡</h4>
<p>有时候二叉树会变得很高（比如我们一直插入大于前一个结点的键值对时，我们可能会得到类似链表的结构），这是就需要通过 <strong>树的平衡</strong> 来得到尽可能矮的树。</p>
<p>因为树的大部分操作都涉及跟踪结点之间的链接，当树特别高的时候，结点之间的平均路径就会变长，需要访问内存的次数就会变多。</p>
<p>我们可以这样构建一棵完美平衡的二叉查找树：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">build_balanced</span>(<span class="params">nodes</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes.<span class="property">is_empty</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line">  middle = nodes.<span class="property">length</span> / <span class="number">2</span></span><br><span class="line">  left = nodes.<span class="title function_">slice</span>(<span class="number">0</span>, middle - <span class="number">1</span>)</span><br><span class="line">  right = nodes.<span class="title function_">slice</span>(middle + <span class="number">1</span>, nodes.<span class="property">length</span>)</span><br><span class="line">  balanced = <span class="title class_">BinaryTree</span>.<span class="title function_">new</span>(&#123; <span class="attr">root</span>: nodes[middle] &#125;)</span><br><span class="line">  balanced.<span class="property">left</span> = <span class="title function_">build_balanced</span>(left)</span><br><span class="line">  balanced.<span class="property">right</span> = <span class="title function_">build_balanced</span>(right)</span><br><span class="line">  <span class="keyword">return</span> balanced </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的平衡成本很高，因此需要权衡平衡的时机。</p>
<ul>
<li>一个由 <span class="math inline">\(n\)</span> 个结点构成的二叉查找树，他的最大高度是 <span class="math inline">\(n\)</span>（类似一个链表），完美平衡时的最小高度为 <span class="math inline">\(log_2 n\)</span></li>
<li>搜索一个元素的复杂度与树的高度成正比，最坏情况下需要搜索到最低的叶节点</li>
<li>搜索 <span class="math inline">\(n\)</span> 个元素的平衡二叉树，时间复杂度为 <span class="math inline">\(O(log n)\)</span></li>
<li>因此我们经常选择这种结构来实现集合、映射</li>
</ul>
<p>为了有效处理变化很大的二叉树，人们发明了 <strong>自平衡二叉树</strong>，他会在插入或删除的时候保持平衡的状态，比如红黑树、AVL树、B树等。</p>
<h3 id="二叉堆">二叉堆</h3>
<blockquote>
<p>二叉堆是一种特殊的二叉查找树，可以立即检索到最大（或最小）的元素，在实现优先队列中非常有用</p>
</blockquote>
<p>父结点的左侧的子结点小于右侧的子结点，且父结点必须大于（或小于）他的两个子结点。</p>
<p>由于最大（或最小）元素始终是树的根节点，查找最大（或最小）元素时的时间复杂度为 <span class="math inline">\(O(1)\)</span>；搜索或插入节点的时间复杂度依然为 <span class="math inline">\(O(log n)\)</span></p>
<h3 id="图">图</h3>
<blockquote>
<p>图与树类似，但图没有子结点、父结点、根节点，任何节点可以有多个入边或出边</p>
</blockquote>
<p>图是最灵活的数据结构，几乎可以表示任何类型的数据</p>
<h3 id="散列表">散列表</h3>
<blockquote>
<p>散列表查找元素的时间复杂度为 <span class="math inline">\(O(1)\)</span></p>
</blockquote>
<p>散列表与数组类似，需要预先分配大块连续存储空间，但散列表中的元素并非存储在有序序列中，而是由 <strong>散列函数</strong> 确定位置。</p>
<ul>
<li><strong>散列函数</strong>：输入一个需要存储的元素，输出一个随机生成的数字，作为存储元素的位置（地址）。通过该地址就可以实现对元素的即时检索</li>
<li><strong>散列冲突</strong>：对于两个不同的输入，散列函数有时候会返回相同的存储地址，冲突发生时，两个元素必须保存在相同的地址（比如使用从这个地址开始的链表）。为了减少散列冲突，应确保散列表中至少存在50%的可用空间，否则可能由于过于频繁的冲突降低散列表的性能</li>
</ul>
<p>散列表常用于实现映射和集合。他比树有更高的插入、删除速度，但需要大量连续的内存才能正常工作</p>
<h1 id="第五章算法">第五章：算法</h1>
<h2 id="排序">排序</h2>
<h3 id="选择排序">选择排序</h3>
<blockquote>
<p>在 i ... list.length 的中找到最小的，放到 i 的位置</p>
</blockquote>
<p>选择排序的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，人们常用这种算法来排序扑克牌</p>
<h3 id="插入排序">插入排序</h3>
<blockquote>
<p>将第 i 项插入之前已经排好序的列表中</p>
</blockquote>
<p>插入排序也是一种具有二次成本的算法，但他在排序几乎已经排序的数组时非常有效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertion_sort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ... list.<span class="property">length</span>) &#123;</span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span> (j.<span class="property">notNull</span> &amp;&amp; list[j - <span class="number">1</span>] &gt; list) &#123;</span><br><span class="line">      list.<span class="title function_">swap_items</span>(j, j - <span class="number">1</span>)</span><br><span class="line">      j = j - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序-1">归并排序</h3>
<blockquote>
<p>将数据分成两份，对其分别进行排序，再合并，时间复杂度为 <span class="math inline">\(O(n log n)\)</span></p>
</blockquote>
<h3 id="快速排序">快速排序</h3>
<blockquote>
<p>随机选一个基准；将大于他的放在右边，小于他的放在左边；然后对左右分别继续操作；再合并左、基准、右</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (list.<span class="property">length</span> &lt; <span class="number">2</span>) &#123; <span class="keyword">return</span> list &#125;</span><br><span class="line">  <span class="keyword">if</span> (list.<span class="property">lenght</span> == <span class="number">2</span>) &#123; <span class="keyword">return</span> list[<span class="number">0</span>] &gt; list[<span class="number">1</span>] ? list.<span class="title function_">swap</span>(<span class="number">0</span>, <span class="number">1</span>) : list &#125;</span><br><span class="line">  pivotIndex = list.<span class="property">length</span> / <span class="number">2</span></span><br><span class="line">  left = list.<span class="title function_">slice</span>(<span class="number">0</span>, pivotIndex)</span><br><span class="line">  right = list.<span class="title function_">slice</span>(pivotIndex, list.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">quickSort</span>(left), list[pivotIndex], <span class="title function_">quickSort</span>(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索">搜索</h2>
<p>选择好的数据结构，比如二分查找树、散列表等，可以大幅提高查找效率</p>
<h3 id="顺序搜索">顺序搜索</h3>
<blockquote>
<p>最简单的搜索，从头开始找，时间复杂度为 <span class="math inline">\(O(n)\)</span></p>
</blockquote>
<h3 id="二分查找">二分查找</h3>
<blockquote>
<p>元素位于排序数组中可以用二分查找，时间复杂度为 <span class="math inline">\(O(n)\)</span></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">items, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (items.<span class="property">isNull</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line">  i = items.<span class="property">length</span> / <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> (key == items[i]) &#123; <span class="keyword">return</span> i &#125;</span><br><span class="line">  sliced = key &gt; items[i]</span><br><span class="line">    ? items.<span class="title function_">slice</span>(i + <span class="number">1</span>, items.<span class="property">length</span>)</span><br><span class="line">    : items.<span class="title function_">slice</span>(<span class="number">0</span>, i)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">binarySearch</span>(sliced, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图-1">图</h2>
<h3 id="图的搜索">图的搜索</h3>
<h4 id="深度优先搜索dfs">深度优先搜索（DFS）</h4>
<blockquote>
<p>沿着图的边逐渐深入，达到某个与任何新结点都没有边相连的结点时，就返回前一个结点继续这个过程</p>
</blockquote>
<ul>
<li>借助栈来跟踪搜索路径：将探索的结点压入栈中，需要返回时弹出来</li>
<li>回溯策略就是利用这种方式搜索</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DFS</span>(<span class="params">startNode, key</span>) &#123;</span><br><span class="line">  nextNodes = <span class="title class_">Stack</span>.<span class="title function_">new</span>()</span><br><span class="line">  <span class="comment">// 由于是图，没有父子关系，我们需要记住访问过哪些了</span></span><br><span class="line">  seenNodes = <span class="title class_">Set</span>.<span class="title function_">new</span>()</span><br><span class="line">  </span><br><span class="line">  nextNodes.<span class="title function_">push</span>(startNode)</span><br><span class="line">  seenNodes.<span class="title function_">add</span>(startNode)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (nextNodes.<span class="property">notEmpty</span>) &#123;</span><br><span class="line">    node = nextNodes.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">key</span> == key) &#123; <span class="keyword">return</span> node &#125;</span><br><span class="line">    <span class="keyword">for</span> (n <span class="keyword">in</span> node.<span class="property">connectedNodes</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!seenNodes.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">        nextNodes.<span class="title function_">push</span>(n)</span><br><span class="line">        seenNodes.<span class="title function_">add</span>(n)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先搜索bfs">广度优先搜索（BFS）</h4>
<blockquote>
<p>逐层对图进行探索</p>
</blockquote>
<ul>
<li>用队列跟踪访问的结点：完成探索后，我们将它的子结点插入队列，然后取出下一个结点进行探索</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BFS</span>(<span class="params">startNode, key</span>) &#123;</span><br><span class="line">  nextNodes = <span class="title class_">Queue</span>.<span class="title function_">new</span>()</span><br><span class="line">  <span class="comment">// 由于是图，没有父子关系，我们需要记住访问过哪些了</span></span><br><span class="line">  seenNodes = <span class="title class_">Set</span>.<span class="title function_">new</span>()</span><br><span class="line">  </span><br><span class="line">  nextNodes.<span class="title function_">enqueue</span>(startNode)</span><br><span class="line">  seenNodes.<span class="title function_">add</span>(startNode)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (!nextNodes.<span class="title function_">isEmpty</span>(nextNodes)) &#123;</span><br><span class="line">    node = nextNodes.<span class="title function_">dequeue</span>()</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">key</span> == key) &#123; <span class="keyword">return</span> node &#125;</span><br><span class="line">    <span class="keyword">for</span> (n <span class="keyword">in</span> node.<span class="property">connectedNodes</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!seenNodes.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">        nextNodes.<span class="title function_">enqueue</span>(n)</span><br><span class="line">        seenNodes.<span class="title function_">add</span>(n)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何选择">如何选择</h4>
<div class="note warning"><p>DFS 和 BFS 其实只在跟踪结点的存储方式上有所不同：DFS 使用栈，而 BFS 使用队列。</p>
</div>
<ul>
<li>DFS 只需要存储“从哪个节点来”，BFS 则需要存储整个搜索的边界，当数据量十分庞大的时候，BFS 会消耗过多的内存</li>
<li>如果正在搜索的结点距离起始点不太远，选择成本较高的 BFS 就比较划算，因为能更快地找到指定节点</li>
<li>如果需要探索图的全部节点，最好使用 DFS，因为易于实现且内存占用更少</li>
</ul>
<h3 id="图着色">图着色</h3>
<p>抽象模型：给固定数量的“颜色”，必须为图中的每个结点分配一种颜色，且通过边相连的结点不能共享同一种颜色。</p>
<p>例：给一张基站及其小区的地图，位于相邻小区的基站必须工作在不同频率以避免干扰，且有四种频率可供选择，那么应该为每个基站分配哪种频率？</p>
<blockquote>
<p>书中没有给出解，感觉可以尝试使用回溯法解决，跟八皇后问题有点像</p>
</blockquote>
<h3 id="寻路">寻路</h3>
<p>可以使用 BFS 或 DFS 策略找出较短的路径，但不如用 <strong>戴克斯特拉算法</strong>。</p>
<ul>
<li>使用优先队列跟踪探索过程：完成新结点的探索之后，将结点之间的连接添加进优先队列，结点的优先级是连接该节点与起始节点的边的权重</li>
<li>负权重的路径可能会导致负循环——这会使得算法陷入无限循环</li>
<li>如果搜索的图过于庞大，可以考虑使用 <strong>双向搜索</strong>，即：两个搜索进程从起始点和目标点同时进行，如果一个搜索区域中的任意节点出现在了另一个搜索区域中，就说明找到了符合条件的路径。</li>
</ul>
<h3 id="pagerank">PageRank</h3>
<p>分析网页并呈现最相关的给用户。可以将万维网建模为一张图，其中的结点表示网页，边表示网页之间的链接。</p>
<ul>
<li>如果一个网页包括许多来自其他重要页面的链接，那么这个网页也很重要</li>
<li>初始阶段，图中的网页具有相同的“分值”</li>
<li>每轮计算完成后，每个页面将各自的分值分发给与之链接的页面</li>
<li>重复进行，直到分值达到稳定分布，每个页面的稳定分值叫做 PageRank，使用 PageRank 来确定网页的重要性</li>
</ul>
<h2 id="运筹学">运筹学</h2>
<blockquote>
<p>做出最佳决策，更好地管理人力与资源，涉及 <strong>最大化</strong> 或 <strong>最小化</strong> 目标</p>
</blockquote>
<ul>
<li>航空公司用运筹学优化航班时刻表</li>
<li>炼油厂找出原料的最佳配比</li>
<li>用运筹学调度劳动力和设备</li>
</ul>
<h3 id="线性最优化问题">线性最优化问题</h3>
<blockquote>
<p>能用线性方程对问题的目标与约束条件进行建模的问题</p>
</blockquote>
<p>例：文件柜采购。</p>
<ul>
<li>文件柜 X 的价格为 10 元，占地 6 平米，能存放 8 立方米的文件；</li>
<li>文件柜 Y 的价格为 20 元，占地 8 平米，能存放 12 立方米的文件；</li>
<li>预算为 140 元，可用面积为 72 平米，如何采购才能放最多的文件？</li>
</ul>
<p>设 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 分别表示两种文件柜的数量，<span class="math inline">\(z\)</span> 为总容量，有：</p>
<p><span class="math display">\[
z = 8x + 12y
\]</span></p>
<p>现在我们要让 <span class="math inline">\(z\)</span> 最大，同时有这些约束条件：</p>
<ul>
<li>预算约束：<span class="math inline">\(10x + 20y \leq 140\)</span></li>
<li>面积约束：<span class="math inline">\(6x + 8y \leq 72\)</span></li>
<li>其他约束：<span class="math inline">\(x \geq 0\)</span>，<span class="math inline">\(y \geq 0\)</span></li>
</ul>
<p>可以在坐标轴中将约束方程画出来，得到约束区域，然后从中找出 <span class="math inline">\(z\)</span> 最大的点即可。</p>
<p>这被称为 <strong>单纯形法</strong>，可以用单纯形法求解器得到解。</p>
<h3 id="网络流问题">网络流问题</h3>
<p>例：补给网络。连接各个城市的铁路构成了铁路网，每条铁路有最大运力，求从一个给定的生产城市每天可以运送多少物资到一个给定的消费城市。</p>
<ul>
<li>每条铁路用一个变量来表示，表示通过这条铁路运送的物资量</li>
<li>所有铁路不能超过其运力</li>
<li>除了生产和消费城市以外，所有城市的流入量与流出量相等</li>
</ul>
<h1 id="第六章数据库">第六章：数据库</h1>
<p><strong>数据库管理系统（DBMS）</strong> 是用于管理数据库的一种特殊软件，他负责数据的组织和与存储。</p>
<h2 id="关系型数据库">关系型数据库</h2>
<p>关系型数据库可以很容易地避免信息重复与数据不一致的问题，是目前使用最广泛的数据库系统。</p>
<ul>
<li>在关系模型中，数据被划分为不同的 <strong>表</strong></li>
<li><strong>行</strong> 代表数据条目</li>
<li><strong>列</strong> 是数据条目具有的不同属性</li>
<li>通常会为列指定可以容纳的数据类型，也可以指定其他条件，比如必须、唯一</li>
<li>通常将列称为 <strong>字段</strong>，比如仅能存储整数的列称为 <strong>整数字段</strong></li>
<li>字段与限制的组合称为表的 <strong>模式</strong></li>
<li>违反表的模式的行将无法进入数据库系统，这是关系型数据库的优点，也是他的局限性所在</li>
</ul>
<h3 id="关系">关系</h3>
<blockquote>
<p>通过将不同的表中数据关联起来，避免一个表中的数据重复</p>
</blockquote>
<p>为了支持关系的使用，每张表都有一个特殊的标识字段（ID），用于引用表中特定的行，每行的 ID 都是唯一的。</p>
<ul>
<li><p>主键：表的 ID 字段</p></li>
<li><p>外键：记录其他航 ID 的引用的字段</p></li>
<li><p>规范化的：一个数据库以完全不存在重复信息的方式进行组织</p></li>
<li><p>规范化：将包含重复数据的数据库转换为不包含重复数据的过程</p></li>
</ul>
<h3 id="模式迁移">模式迁移</h3>
<blockquote>
<p>模式迁移脚本可以帮助我们升级模式并转换现有数据，这些脚本通常还具备撤销更改的功能</p>
</blockquote>
<h3 id="sql">SQL</h3>
<blockquote>
<p>一种语句，描述了需要检索的数据</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> customers.name, customers.phone</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> orders.customer <span class="operator">=</span> customers.id</span><br><span class="line"><span class="keyword">WHERE</span> orders.amount <span class="operator">&gt;</span> <span class="number">100.00</span></span><br></pre></td></tr></table></figure>
<h3 id="索引">索引</h3>
<blockquote>
<p>为了能通过给定 ID 快速检索到数据条目，DBMS 构建了一个辅助<strong>索引</strong>，用来将 ID 映射到在内存中的地址</p>
</blockquote>
<p>索引实际上是一种自平衡二叉查找树，表中每一行对应着树中的每一个结点。结点的键是索引字段中的值（比如 ID）。</p>
<p>通常 DBMS 为数据库的每一个主键都建立一个索引。如果经常需要通过搜索其他字段来查找寄存器（比如通过姓名搜索客户），可以指示 DBMS 为这些字段建立额外的索引。</p>
<ul>
<li><strong>唯一性约束</strong>。具有唯一性约束的字段通常会自动建立索引。因为在插入新的行的时候，我们需要快速检查这个字段是否重复，因此需要为其建立索引。</li>
<li><strong>排序</strong>。在建立索引的字段中，索引有助于以排序顺序获取行。比如如果以“姓名”字段作为索引，那么无需额外的计算就能够按姓名对行进行排序。当需要对两个字段进行排序时，可以使用 <strong>联合索引</strong> 对多个字段进行索引。</li>
<li><strong>性能</strong>。由于在表中插入或删除一个寄存器时，必须更新表的全部索引，如果表的索引很多，更新、插入、删除的计算开销就会变大（树的平衡）。此外，索引会占用磁盘空间。</li>
</ul>
<h3 id="事务">事务</h3>
<blockquote>
<p>以<strong>原子方式</strong>执行数据库操作的列表。即在一步之内执行完毕，不会出现只执行一半的情况。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">value</span> <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">value</span> <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<h2 id="非关系数据库">非关系数据库</h2>
<p>关系数据库的局限性：</p>
<ul>
<li>随着程序越来越复杂，会有越来越多的表</li>
<li>查询会变得越来越大，越来越难理解</li>
<li><code>JOIN</code> 操作会逐渐增多，增加计算成本</li>
</ul>
<blockquote>
<p><strong>非关系模型</strong> 抛弃了表格关系，几乎不需要合并来自多个数据条目的信息，使用不同于 SQL 的查询语言，也被成为 <strong>NoSQL 数据库</strong></p>
</blockquote>
<h3 id="文档存储">文档存储</h3>
<blockquote>
<p>数据条目完全按应用程序所需要的方式保存</p>
</blockquote>
<p>文档存储中不存在“表”和“行”，数据条目称为 <strong>文档</strong>，相关文档被分组在 <strong>集合</strong> 中。</p>
<p>文档包括一个主键，但一般不会使用 <code>JOIN</code> 操作来跟踪跨文档的关系。如果多个文档需要共享相关数据，那么应该将数据复制到文档中。</p>
<h3 id="键值对存储">键值对存储</h3>
<blockquote>
<p>在有组织且持久的数据存储方式中，<strong>简直对存储</strong> 是最简单的形式，主要在缓存中使用（特别是需要频繁访问缓存时）</p>
</blockquote>
<h3 id="图数据库">图数据库</h3>
<blockquote>
<p>将数据条目存储为结点，关系存储为边</p>
</blockquote>
<p>图数据库是最灵活的数据库类型，没有表和集合，以最直观的方式存储网络化数据。如果数据结构类似某种网络、存在大量重要的关系时，可以使用图数据库。</p>
<p>图数据库还可以实现不同类型的面向图的查询，比如将公交数据存在图中，就能直接查询两个给定公交车站之间的最佳直达路线。</p>
<h3 id="sql-与-nosql-的比较">SQL 与 NoSQL 的比较</h3>
<ul>
<li>关系数据库：能最大限度利用数据结构并消除重复</li>
<li>非关系数据库：以应用程序为中心，便于根据用户的需求进行访问和使用。能快速有效存储大量易失性的非结构化数据，不必担心固定模式与模式迁移；但用户需要负责更新跨文档与集合的重复信息，并采取措施保证数据的一致性</li>
</ul>
<h2 id="分布式数据库">分布式数据库</h2>
<p>比如在这些场景中，DBMS 运行在多台协同工作的计算机中，构成一个分布式数据库系统：</p>
<ul>
<li>超级大容量的数据</li>
<li>并发数超级高的数据</li>
<li>任务关键型数据</li>
</ul>
<h3 id="单主机复制">单主机复制</h3>
<ul>
<li>以一台计算机作为主机</li>
<li>主机与多台从机相连，每台都有一份数据库的副本</li>
<li>主机响应外界的读写查询，并转发给从机，使各个从机保持同步</li>
</ul>
<p>因此，可以处理更多的读查询、可靠性也提高了</p>
<h3 id="多主机复制">多主机复制</h3>
<ul>
<li>集群中的所有计算机都成为主机</li>
<li>负载均衡设备将传入的读写查询分给集群中的计算机</li>
<li>每台计算机都有一份完整的数据库副本</li>
</ul>
<p>因此，可以处理更多的并发写查询</p>
<h3 id="分片">分片</h3>
<ul>
<li>如果数据库收到大量写查询，很难让所有主机中的数据库保持同步，因为某些计算机可能空间不够</li>
<li>于是将数据库切分到各个计算机中</li>
<li>查询路由器将读写查询分发到对应分片的计算机</li>
<li>可以将分片与复制结合起来使用，降低单点故障的风险</li>
</ul>
<h3 id="数据一致性">数据一致性</h3>
<ul>
<li>可以使用一些数据库提供的工具来缓解数据不一致的问题，但这会降低数据库系统的性能</li>
<li>需要在一致性与性能之间作出权衡</li>
<li>如果数据库查询并非严格执行一致性，则可以认为他们追求<strong>最终一致性</strong>，即保证数据在一段时间后能<strong>最终</strong> 达到一致性</li>
</ul>
<h2 id="地理数据库">地理数据库</h2>
<p>许多通用的 DBMS 都支持 GIS（地理信息系统）扩展，应当使用提供 GIS支持的数据库引擎来处理地理数据</p>
<h2 id="序列化格式">序列化格式</h2>
<ul>
<li><strong>SQL（结构化查询语言）</strong>
<ul>
<li>序列化关系数据库时最常见的格式</li>
<li>通过编写 SQL 命令来复制数据库及其细节</li>
<li>大部分关系型数据库系统提供“转储”和“恢复”命令，前者用于创建数据库的 SQL 序列化文件，后者用于将这类“转储”文件加载回数据库系统</li>
</ul></li>
<li><strong>XML（可扩展标记语言）</strong>
<ul>
<li>另一种表示结构化数据的方式</li>
<li>但不依赖于关系模型或某种数据库的实现</li>
</ul></li>
<li><strong>JSON（JavaScript 对象表示法）</strong>
<ul>
<li>大部分人认可的序列化格式</li>
<li>JSON 还有其他衍生格式：BSON（二进制 JSON）可以大幅提高 JSON 的数据处理效率；JSON-LD（关联数据的 JSON）则将 XML 结构的强大功能引入 JSON</li>
</ul></li>
<li><strong>CSV（逗号分隔值）</strong>
<ul>
<li>数据交换的最简单形式</li>
<li>数据以文本形式存储，每行包含一个元素，元素属性通过逗号隔开</li>
<li>有助于实现简单的数据转储，但不适合表示复杂的数据</li>
</ul></li>
</ul>
<h1 id="第七章计算机">第七章：计算机</h1>
<h2 id="体系结构">体系结构</h2>
<h3 id="存储器">存储器</h3>
<ul>
<li>总线：传输相同数据的一组信号线</li>
<li>地址总线：传输地址的 8 条信号线</li>
<li>数据总线：传输数据的 8 条信号线</li>
</ul>
<h3 id="cpu">CPU</h3>
<ul>
<li>指令集：CPU 可以执行的所有操作的集合</li>
<li>CPU 的工作流程：
<ol type="1">
<li>从程序计数器 Program Counter 指定的存储地址获取指令</li>
<li>PC 自增</li>
<li>执行命令</li>
<li>返回步骤 1</li>
</ol></li>
<li>PC 会在 CPU 上电时复位为默认值，这时就是计算机中第一条待执行指令的地址，通常是一个不可变的内置程序（在个人计算机中，这种程序通常称为基本输入输出系统 BIOS</li>
<li>CPU 时钟：CPU 每秒可执行的基本操作数</li>
<li>CPU 体系结构：x86、ARM 等，不同的 CPU 体系结构意味着 CPU 指令集、以及将指令编码为数字的方式的不同</li>
<li>32位与64位体系结构：CPU 在一条机器指令中最多可以对多少位二进制数执行求和、比较与移动操作</li>
<li>大端序与小端序：按从左至右的顺序在 RAM 和 CPU 中存储数字，称为小端序；反之称为大端序。目前大部分 CPU 采用小端序，在解析来自网络交换机的数据时要尤其注意字节序不匹配的问题</li>
<li>模拟器：模拟目标机器，假定与其拥有形同的硬件，将指令进行解码并执行</li>
</ul>
<h2 id="编译器">编译器</h2>
<ul>
<li>图灵完备：机器能遵循包含指令的程序，以便:
<ul>
<li>对存储器中的数据进行读写</li>
<li>执行条件分支：如果存储地址具有给定的值，则跳转到程序的另一个点</li>
</ul></li>
<li>无论计算的复杂性或难度如何，都可以采用简单的读取、写入、分支指令来表达</li>
<li>一种称为 <code>MOV</code>（数据传送）的 CPU 指令是图灵完备的，通过 <code>MOV</code> 指令可以严格地表达任何类型的代码</li>
<li>编译器可以将代码从复杂的语言转换为简单的语言</li>
</ul>
<h3 id="操作系统">操作系统</h3>
<ul>
<li>程序可以借助操作系统使用不同的硬件</li>
<li>程序创建特殊的 <strong>系统调用</strong>，请求操作系统执行所需的输入、输出操作</li>
<li>编译器负责将输入、输出命令转换为合适的系统调用</li>
<li>因此，不同的操作系统需要不同的编译后代码</li>
</ul>
<h3 id="编译优化">编译优化</h3>
<ul>
<li>编译器会尝试修改部分代码来提高执行效率</li>
<li>比如通常不使用递归性能会更佳，但编译器会自动重写简单的递归函数，因此我们在写代码的时候应更注重易读性，减少在不必要的微操作下浪费时间</li>
</ul>
<h3 id="脚本语言">脚本语言</h3>
<ul>
<li>JavaScript、Python、Ruby 等语言在执行时并不会被编译为机器码，他们被称为 <strong>脚本语言</strong></li>
<li>脚本语言的代码由 <strong>解释器</strong> 而非 CPU 执行</li>
<li>解释器实时转译并执行代码，因此通常运行速度会比编译之后的代码 <strong>慢很多</strong>，但也省去了编译的时间</li>
</ul>
<h3 id="反汇编与逆向工程">反汇编与逆向工程</h3>
<ul>
<li>反汇编：可以对二进制程序进行解码，将用于编码 CPU 指令的数字转换为人类可读的指令序列</li>
<li>逆向工程：查看这些 CPU 指令，并尝试分析他们的用途</li>
</ul>
<h2 id="存储器层次结构">存储器层次结构</h2>
<h3 id="时间局部性和空间局部性">时间局部性和空间局部性</h3>
<ul>
<li>时间局部性：访问某个存储地址时，可能很快会再次访问该地址</li>
<li>空间局部性：访问某个存储地址时，可能会很快访问与之相邻的地址</li>
<li>将这些存储地址保存在 CPU 寄存器中，有助于避免大部分对 RAM 的昂贵操作</li>
<li>一级缓存：10KB 左右，一种集成在 CPU 内部并且速度极快的辅助存储器，读取速度仅比寄存器稍慢（约 10 个 CPU 周期）。可以将可能访问的 RAM 中的数据复制进去</li>
<li>二级缓存：200KB 左右，读取速度约 100 个 CPU 周期</li>
</ul>
<h3 id="第一级存储器和第二级存储器">第一级存储器和第二级存储器</h3>
<ul>
<li>第一级存储器：通常指 RAM，速度约 1000 个 CPU 周期</li>
<li>第二级存储器：存储应用和数据的磁盘，速度约 100 万个 CPU 周期</li>
</ul>
<h3 id="外部存储器和第三级存储器">外部存储器和第三级存储器</h3>
<ul>
<li>并非总是在线和可用的，比如磁带、CD 等</li>
</ul>
<h1 id="第八章程序设计">第八章：程序设计</h1>
<h2 id="语言学">语言学</h2>
<p>编程语言依靠三种基本的构建模块来操作信息：<strong>值</strong> 表示信息，<strong>表达式</strong> 产生值，<strong>语句</strong> 使用值向计算机发出指令。</p>
<h3 id="值">值</h3>
<p>值又被称为变成语言的“头等功名”，编程语言会支持与值有关的各种操作。</p>
<h3 id="表达式">表达式</h3>
<p>可以通过编写 <strong>字面量</strong> 或调用 <strong>函数</strong> 两种方式创建值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个字面量表达式，我们创建了一个值 3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 这是一个函数的调用，创建了一个与洛杉矶当前时间相等的值</span></span><br><span class="line"><span class="title function_">getPacificTime</span>()</span><br><span class="line"><span class="comment">// 我们通过运算符将简单表达式连接起来，就构成了复杂表达式</span></span><br><span class="line"><span class="number">3</span> + <span class="title function_">getPacificTime</span>()</span><br></pre></td></tr></table></figure>
<h3 id="语句">语句</h3>
<p>语句用于指示计算机 <strong>执行</strong> 某种操作，比如 <code>console.log("Hello World")</code>。</p>
<ul>
<li>定义：某些编程语言提供称为<strong>定义</strong>的特殊语句，他通过添加不存在的实体（如新的值或函数）来改变程序状态</li>
<li>名称绑定：为了引用所定义的实体，需要将名称与实体关联起来</li>
</ul>
<h2 id="变量">变量</h2>
<p>变量是最重要的名称绑定，变量将名称与保存值的存储地址关联在一起，作为“别名”使用</p>
<h3 id="变量类型">变量类型</h3>
<p>大部分编程语言中，需要为变量指定一种类型，以便程序了解如何解释在变量内存块中读取的1和0，也有助于在处理变量时发现错误</p>
<h3 id="变量作用域">变量作用域</h3>
<ul>
<li>作用域定义了变量的有效位置和可供使用的范围</li>
<li>上下文（或称环境）表示在程序的某个给定点，所有可用名称绑定的集合</li>
<li>命名空间构成了所有全局可用名称的集合</li>
</ul>
<h2 id="范式">范式</h2>
<p>范式是定义科学领域的概念与实践的特定集合，比如牛顿学派和相对论学派就是物理学两种不同的范式。目前存在三种主要的编程范式：<strong>命令式编程</strong>、<strong>声明式编程</strong>、<strong>逻辑式编程</strong></p>
<h3 id="命令式编程">命令式编程</h3>
<p>通过特定的命令指示计算机在每一步必须执行的操作，每条命令都会改变计算机的状态，构成程序的命令序列将依次执行</p>
<h4 id="机器码编程">机器码编程</h4>
<ul>
<li>早期程序员需要用 1 和 0 将代码输入计算机</li>
<li>后来人们使用助记符编写 CPU 指令序列，比如 <code>CP</code> <code>MOV</code> <code>CMP</code></li>
<li>接着人们编写了一种程序，可以将助记符转换为等效的二进制数，这就是 <strong>汇编语言</strong></li>
<li>现在汇编语言多用于对微波炉、早期车载计算机等系统进行编程，或者用于追求极致性能的地方</li>
</ul>
<h4 id="结构化编程">结构化编程</h4>
<ul>
<li>程序最初是通过 <code>GOTO</code> 来控制执行流，可以在代码中跳转执行</li>
<li>面条式代码：不同的执行流与 <code>GOTO</code> 和 <code>JUMP</code> 命令交织在一起，很难阅读</li>
<li>戴克斯特拉于 1968 年发表了“GOTO有害论”</li>
<li>此后程序员开始使用控制结构（<code>if</code> <code>else</code> <code>while</code> <code>for</code>）等编写程序</li>
</ul>
<h4 id="过程式编程">过程式编程</h4>
<ul>
<li>将代码组织到过程中，在避免代码重复的同事也提高了代码的可重用性</li>
<li>比如我们可以创建一个函数，然后在不同的地方调用这个函数</li>
<li>利用过程更容易对相关代码分组，将他们划分为不同的逻辑部分</li>
</ul>
<h3 id="声明式编程">声明式编程</h3>
<p><strong>声明式编程</strong>旨在声明所需要的结果，关心的是要实现<strong>哪些</strong>目标，而不是<strong>如何</strong>实现目标</p>
<h4 id="函数式编程">函数式编程</h4>
<ul>
<li>在函数式编程范式中，函数不仅仅是过程，他们声明两个或多个元素之间的关系，类似于数学函数</li>
<li>函数是头等公民，与其他基本数据类型的处理并无二致</li>
<li>高阶函数：函数可以将其他的函数作为输入参数，也可以返回其他函数作为输出，这被称为 <strong>高阶函数</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如 sort 函数传入两个函数，coordinates 包含一个地理位置列表，closer_to_home 接受两个参数，并返回离家近的那个</span></span><br><span class="line"><span class="title function_">sort</span>(coordinates, closer_to_home)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，比如 filter 函数和 map 函数</span></span><br><span class="line">odd_numbers = <span class="title function_">filter</span>(numbsers, number_is_odd)</span><br><span class="line">squard_numbers = <span class="title function_">map</span>(numbers, square)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再同理，我们可以编写一个 reduce 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">list, inital_val, func</span>)  &#123;</span><br><span class="line">  accumulator = inital_val</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    accumulator = <span class="title function_">func</span>(accumulator, item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="闭包">闭包</h5>
<p>高阶函数将对值的引用 <strong>包含</strong> 到所生成的函数中。支持 <strong>闭包</strong> 的函数能“记住”内容，并访问到所包含值的环境</p>
<h5 id="柯里化">柯里化</h5>
<p>闭包的应用之一，对于传入多个函数的参数，可以利用闭包将函数的执行分解为多个步骤</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"><span class="comment">// sum 理应传入两个参数。假设只用一个参数就可以调用它，并且 sum(3) 返回的不是数字，而是一个经过 **经过柯里化** 的新函数</span></span><br><span class="line">sum_three = <span class="title function_">sum</span>(<span class="number">3</span>) <span class="comment">// 这句话调用 sum 函数并使用 3 作为第一个参数，并返回一个新函数，对 3 的引用包含在这个新函数中</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sum_three</span>(<span class="number">1</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">special_sum = <span class="title function_">sum</span>(<span class="title function_">get_number</span>()) <span class="comment">// 创建 special_sum 函数不会调用 get_number 函数，对 get_number 的引用包含在 special_sum 中，仅当需要对 special_sum 求值时才会调用 get_number 函数，这就是 **惰性求值**</span></span><br></pre></td></tr></table></figure>
<h6 id="模板函数">模板函数</h6>
<p>闭包也可以用来生成一组遵循模板的相关函数，使用函数模板可以提高代码的可读性并避免重复：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">power_generator</span> (base) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">power</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(x, base)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> power</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 power_generator 生成计算幂的不同函数</span></span><br><span class="line">square = <span class="title function_">power_generator</span>(<span class="number">2</span>)</span><br><span class="line"><span class="title function_">square</span>(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">cube = <span class="title function_">power_generator</span>(<span class="number">3</span>)</span><br><span class="line"><span class="title function_">cube</span>(<span class="number">2</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h6 id="管理函数内部状态">管理函数内部状态</h6>
<p>创建一个有记忆功能的累加器，我们可以使用闭包而不借助全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">make_adder</span> () &#123;</span><br><span class="line">  n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">adder</span> (x) &#123;</span><br><span class="line">    n += x</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_adder = <span class="title function_">make_adder</span>()</span><br><span class="line"><span class="title function_">my_adder</span>(<span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">my_adder</span>(<span class="number">2</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记：《程序是怎么跑起来的》</title>
    <url>/hais-notebook/2021/05/13/Book-HowProgramWorks/</url>
    <content><![CDATA[<p>将之前的读书笔记腾挪至此。</p>
<span id="more"></span>
<h1 id="cpu">CPU</h1>
<p>简单来讲，CPU 由寄存器、控制器、运算器和时钟组成（也可以认为时钟位于 CPU 的外部）</p>
<h2 id="寄存器">寄存器</h2>
<p>程序是把寄存器作为对象来描述的，寄存器可以用于存放 <strong>指令</strong> 或者 <strong>数据</strong>，通过地址将这，其中 <strong>数据</strong> 又分为 “用于运算的值” 和 “表示内存地址的值”，这又对应了多种不同的寄存器</p>
<h3 id="程序计数器">程序计数器</h3>
<p>程序计数器决定程序的流程，存的实际上是当前执行的指令的地址</p>
<h4 id="顺序执行">顺序执行</h4>
<p>由于指令可能占据多个内存地址，每次执行时程序计数器的值只需要增加与指令长度相当的数值就可以了</p>
<h4 id="条件分支和循环">条件分支和循环</h4>
<p>使用跳转指令（jump）可以让程序计数器的值设定为任意值</p>
<h3 id="函数的调用">函数的调用</h3>
<ul>
<li><p>函数在调用（call）的时候实际上就是将程序计数器的值设定为函数所在的地址，执行完成之后再跳回（return）到调用原点的地址</p></li>
<li><p>call 指令会把调用函数后需要执行的命令地址存在 “栈” 内</p></li>
<li><p>return 指令会把保存在 “栈” 中的地址再设定回程序计数器中</p></li>
</ul>
<h3 id="标志寄存器">标志寄存器</h3>
<p>在进行运算的时候，标志寄存器负责用标志的形式存储计算结果，这些计算结果在执行判断的时候可以用上，比如对于32位的寄存器，他的第 0、1、2 位为 1 时分别表示“运算结果为正、运算结果为 0 、运算结果为负”</p>
<p>在 CPU 中的大小比较实际上是做减法运算，然后将结果的正负保存在标志寄存器中</p>
<h3 id="基址寄存器和变址寄存器">基址寄存器和变址寄存器</h3>
<p>基址寄存器的值不变化，而变址寄存器的值变化（相当于数组索引的数值），可以综合使用这两个寄存器来表示数组，比如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> 实际地址 = 基址寄存器的值 + 变址寄存器的值</span><br><span class="line">    ↓           ↓             ↓</span><br><span class="line">10000000  =  10000000  +  00000000</span><br><span class="line">10000001  =            +  00000001</span><br><span class="line">10000002  =            +  00000002</span><br><span class="line">  ....                      ....</span><br><span class="line">1000FFFF  =            +  0000FFFF</span><br></pre></td></tr></table></figure>
<h1 id="二进制">二进制</h1>
<h2 id="移位运算">移位运算</h2>
<ul>
<li><p>左移运算，高位溢出丢弃，低位补 <code>0</code></p></li>
<li><p>右移运算，低位溢出丢弃，高位补 <code>0</code> 或 <code>1</code></p></li>
</ul>
<h3 id="补码">补码</h3>
<p>二进制最高位其实是符号位，为 <code>0</code> 时表示整数，为 <code>1</code> 时表示负数，但是需要注意的是：<code>1</code> 是 <code>00000001</code>，但 <code>-1</code> 并不是 <code>10000001</code>，而是 <code>11111111</code></p>
<h4 id="补码的计算">补码的计算</h4>
<p>按位取反，再 +1：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-1  -&gt;  00000001  -&gt;  11111110  -&gt;  11111111</span><br></pre></td></tr></table></figure>
<h4 id="补码的作用">补码的作用</h4>
<p>计算机内的减法运算其实都是用加法运算实现的，这也是使用二进制补码来表示负数的重要原因之一，比如对于运算 <code>1 - 1</code>（也就是 <code>1 + (- 1)</code>），答案应该为 <code>0</code> ；但若用 <code>10000001</code> 表示 <code>-1</code>，则运算结果为 <code>10000010</code>，是不正确的</p>
<p>如果使用补码来表示 -1，即 <code>11111111</code>，则运算结果为正确的 <code>00000000</code>，最高位的 <code>1</code> 溢出舍弃</p>
<p>有一个重要的结论：<strong>二进制按位取反后加 <code>1</code> 的结果，与原来的正值相加，结果为 <code>0</code></strong></p>
<p>因为，按位取反与原数相加，必得 <code>11111111</code>，加 <code>1</code> 之后，最高位溢出，答案为 <code>0</code></p>
<h3 id="逻辑右移和算术右移">逻辑右移和算术右移</h3>
<h4 id="逻辑右移">逻辑右移</h4>
<p>当二进制数的值表示 <strong>图形模式</strong> 而非 <strong>数值</strong> 时，移位后需要在最高位补 0</p>
<h4 id="算术右移">算术右移</h4>
<p>考虑到符号位的存在，移位后需要在高位重新填充符号位的值，这就是算术右移：</p>
<p><code>-4</code> （<code>11111100</code>）算术右移之后为 <code>-1</code> (<code>11111111</code>)，空出来的高位由符号位 <code>1</code> 填充</p>
<h4 id="符号扩充">符号扩充</h4>
<p>如果将 8 位二进制数转换为 16 位或 32 位等，多出来的高位，依旧用符号位的值填充即可</p>
<h2 id="逻辑运算">逻辑运算</h2>
<p>将二进制数表示的信息作为四则运算的数值来处理，就是 <strong>算术运算</strong>；而单纯像图形一样处理 <code>0</code> 和 <code>1</code> 的罗列，就是 <strong>逻辑运算</strong></p>
<p>逻辑运算有四种：非（NOT）、与（AND）、或（OR）、异或（XOR/EOR）</p>
<h2 id="二进制小数">二进制小数</h2>
<p>二进制小数存在精度问题，因为二进制位只能表示以 1/2、1/4、1/8、1/16 等位权组合而成的小数，这导致很多十进制小数是没办法用有限的二进制小数表示的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0.0000  -&gt;  0</span><br><span class="line">0.0001  -&gt;  0.0625</span><br><span class="line">0.0010  -&gt;  0.125</span><br><span class="line">0.0011  -&gt;  0.1875</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="浮点数">浮点数</h3>
<p>计算机内部无法直接使用像 <code>1011.0011</code> 这样的带小数点的表现形式，通常的编程语言提供了两种表示小数的数据类型：<strong>单精度浮点数</strong> 和 <strong>双精度浮点数</strong>，前者用 32 位，后者用 64 位来表示全体小数</p>
<p>浮点数用 <strong>符号</strong>、<strong>尾数</strong>、<strong>基数</strong> 和 <strong>指数</strong> 这四部分来表示小数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> ±    m  ×  n   ^   e</span><br><span class="line"> ↓    ↓     ↓       ↓</span><br><span class="line">符号  尾数  基数     指数</span><br></pre></td></tr></table></figure>
<p>其中符号部分占 1 位，指数部分占 8/11 位，尾数部分占 23/52 位（IEEE 规定）</p>
<h4 id="正则表达式和-excess-系统">正则表达式和 EXCESS 系统</h4>
<p>尾数部分使用 <strong>正则表达式</strong> 来表示，二进制数规定尾数部分一定满足 “<strong>小数点前面的值固定为 1</strong>”，这样我们就可以不保存小数点前面的值了</p>
<p>指数部分使用 <strong>EXCESS 系统</strong> 来表示，因为有可能有负值，因此将所有可以表示的数分为两半，中间为 0，比如单精度浮点数用 <code>01111111</code> 表示 0，<code>10000000</code> 表示 <code>1</code>，<code>01111110</code> 表示 <code>-1</code></p>
<h1 id="内存">内存</h1>
<h2 id="内存的物理工作机制">内存的物理工作机制</h2>
<p>比如对于某个内存 IC，它有数个引脚：</p>
<ul>
<li><p>VCC、GND：电源</p></li>
<li><p>D0 ~ D7：数据信号，一共 8 个引脚，代表一次可以输出 8 位（1 Byte）的数据</p></li>
<li><p>A0 ~ A9：地址信号，一共 10 个引脚，代表可以有 2 ^ 10 个地址，可以存储 2 ^ 10 Byte，即 1 KB 的数据</p></li>
<li><p>RD、WR：控制信号，表示是读数据还是写数据</p></li>
</ul>
<p>比如要写数据，WR 为 1，然后通过地址信号指定写入地址，数据信号指定写入值即可</p>
<h2 id="内存的逻辑模型">内存的逻辑模型</h2>
<p>内存就像一幢楼房，每楼代表一个地址，地址是连续的。编程语言通过指定 <strong>数据类型</strong> 来指定占用的楼层数（内存大小）</p>
<h2 id="指针">指针</h2>
<p>在某些变成语言中会有指针，比如 C。简单的来讲，<strong>指针</strong> 也是一种变量，他存储着数据的内存地址</p>
<h2 id="数组">数组</h2>
<p>数组是多个同样的数据类型在内存中连续排列的形式，每个元素通过连续的编号（索引）被区分来开，需要注意的是 JS 的数组并不是这种严格意义上的数组</p>
<h3 id="栈队列以及环形缓冲区">栈、队列以及环形缓冲区</h3>
<p>栈和队列都可以不通过指定地址和索引来读写数组的元素，其中栈用的是 LIFO 的方式，而队列则是 FIFO</p>
<p>队列一般是以环状缓冲区（ring buffer）的方式来实现的</p>
<h3 id="链表">链表</h3>
<p>在数组的各个元素中，除了数据的值以外，给其附带上下一个元素的索引，即可实现链表，通过链表可以高效地追加或删除数据</p>
<h3 id="二叉树">二叉树</h3>
<p>在链表的基础上往数组增加元素的时候，考虑到数据的大小关系，将其分为左右两个方向，这样可以增加查找的效率</p>
<h1 id="磁盘">磁盘</h1>
<h2 id="磁盘缓存">磁盘缓存</h2>
<p>磁盘缓存是将磁盘中读取出来的数据存储到内存空间的方式，可以大大提高磁盘数据的访问速度</p>
<h2 id="磁盘的物理结构">磁盘的物理结构</h2>
<p>磁盘将其物理表面划分成多个空间来使用，划分的方式有 <strong>扇区方式</strong> 和 <strong>可变长方式</strong>；前者是固定空间，而后者则将磁盘划分为长度可变的空间</p>
<p>在 Windows 中，一般就采取扇区方式：将磁盘表面分成若干个同心圆的空间（<strong>磁道</strong>），再把磁道按照固定大小划分成（<strong>扇区</strong>）</p>
<p>此外，在 Windows 中，在逻辑层面读写磁盘的单位是扇区的整数倍<strong>簇</strong>，根据磁盘容量不同，1 簇可以是 512 B、1 KB、2 KB 等。<strong>不同的文件是不能存储在同一簇中的</strong>，但需要注意的时候，程序可以在逻辑上以字节为单位对内容进行读写</p>
<h1 id="数据压缩">数据压缩</h1>
<h2 id="rle-算法">RLE 算法</h2>
<p>简单来说就是将文件内容用 “数据 × 重复次数” 的形式来表示，比如用 <code>A3B2C9</code> 表示 <code>AAABBCCCCCCCCC</code></p>
<p>该算法的主要缺点是不适合文本文件的压缩，而比较适合经常连续出现的图像、文件等</p>
<h2 id="哈夫曼算法">哈夫曼算法</h2>
<p>简单来说就是将出现频率很高的字符用更短的位数来表示（比如小于 8 位），出现频率低的字符用长编码来表示</p>
<p>比如摩尔斯编码就是将在文本中出现频率比较高的字符用短编码来表示，但是需要注意的是文件在存储的时候仍然是以 8 位的字节为单位的</p>
<p>可以用二叉树来实现哈夫曼编码</p>
<h2 id="可逆压缩与非可逆压缩">可逆压缩与非可逆压缩</h2>
<p>比如对 EXE 文件、文本文件，他们的每个字符、数值都有具体的含义，因此必须要还原到和压缩前同样的内容，因此称为 <strong>可逆压缩</strong>；</p>
<p>而图片压缩之后有一些模糊也可以接受，不必使用同样的算法，有的算法是无法还原到之前相同的内容的，称为 <strong>非可逆压缩</strong></p>
<h1 id="汇编语言">汇编语言</h1>
<ul>
<li><p>汇编语言 = 本地代码（机器语言） + 助记符</p>
<ul>
<li>汇编语言 --汇编器进行汇编--&gt; 本地代码</li>
<li>汇编语言 &lt;--反汇编程序进行反汇编-- 本地代码</li>
</ul></li>
</ul>
<h1 id="硬件控制">硬件控制</h1>
<h2 id="in-与-out-指令">IN 与 OUT 指令</h2>
<p>Windows 控制硬件借助的是输入和输出指令，比较具有代表性的就是 IN 和 OUT 指令：<strong>IN 指令</strong> 通过指定的端口号输入数据，并存储在 CPU 内部的寄存器中；<strong>OUT 指令</strong> 则把 CPU 寄存器中存储的数据，输出到指定的端口</p>
<p><strong>I/O 控制器</strong> 用来是用来交换计算机主机通外围设备电流特性的 IC，他内部有用于临时保存输入输出数据的内存（端口）</p>
<p>I/O 端口号是所有的外围设备都必需的</p>
<h2 id="irq">IRQ</h2>
<p>IRQ（Interrupt Request）是 <strong>中断请求</strong>，用来暂停当前正在运行的程序，并跳转到其他程序运行，这种机制被称为 <strong>中断处理</strong></p>
<p>实施中断请求的是连接外围设备的 I/O 控制器，实施中断处理程序的是 CPU，外围设备的中断请求会使用 <strong>中断编号</strong> 进行标记，操作系统和 BIOS 会提供响应中断编号的中断处理程序</p>
<p>IRQ 只对于需要中断处理的外围设备是必需的</p>
<h2 id="dma">DMA</h2>
<p>DMA（Direct Memory Access）是指在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送。磁盘等通过利用 DMA 可以让大量的数据在短时间内传送到主内存，节省了 CPU 作为中介的时间</p>
<p>DMA 只对于需要 DMA 机制的外围设备是必需的</p>
<h2 id="文字及图片的显示机制">文字及图片的显示机制</h2>
<p>显示器中显示的信息一直都存在 VRAM（Video RAM）中，只要往 VRAM 中写入数据，该数据就会在显示器中显示出来——这是由操作系统或者 BIOS 听的，并借助中断来进行处理的</p>
<p>现在的计算机中，显卡等硬件中一般都有与主内存像独立的 VRAM 和 GPU（Graphics Processing Unit）</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记：《JavaScript 设计模式与开发实践》</title>
    <url>/hais-notebook/2021/05/13/Book-JavaScriptDesignPattern/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="基础知识">基础知识</h1>
<h2 id="面向对象的-javascript">面向对象的 JavaScript</h2>
<h3 id="动态类型">动态类型</h3>
<blockquote>
<p>动态类型语言的变量类型要到程序运行时才能确定，比如 JavaScript</p>
</blockquote>
<ul>
<li>Duck Typing 鸭子类型：如果他走起来像鸭子，叫起来也是鸭子，那么他就是鸭子</li>
<li>面向接口编程：在动态类型语言中，我们可以很轻松地实现”面向接口编程，而不是面向实现编程“。比如若一个对象有 <code>pop</code> 和 <code>push</code> 方法，那么他就可以被当做栈来使用</li>
</ul>
<h3 id="多态">多态</h3>
<blockquote>
<p>同一个操作作用于不同的对象上面，可以产生不同的解释和执行结果。比如让鸭子和鸡都执行“叫”命令，他们会按照自己的方式叫出不同的叫声</p>
</blockquote>
<ul>
<li>可以使用继承得到多态的效果：鸡和鸭都分别继承“动物“抽象类，动物类定义了”叫“</li>
<li>多态在面向对象设计中的作用：可以将过程化的条件分支语句转换为对象的多态性，从而减少这种条件分支语句</li>
</ul>
<h3 id="封装">封装</h3>
<p>将信息隐藏起来，可以封装数据、实现、类型、变化等</p>
<h4 id="封装数据">封装数据</h4>
<p>有的语言通过语法解析来实现，同时提供了 <code>private</code> <code>public</code> <code>protected</code> 等关键字确定访问权限</p>
<p>JavaScript 中可以通过变量的作用域来实现封装，书中介绍了基于 <code>var</code> 的函数作用于特性的模拟 <code>public</code> 和 <code>private</code> 的方法，在 ES6 中同样可以通过闭包达到类似的封装效果</p>
<h4 id="封装实现">封装实现</h4>
<p>比较常见的封装，封装一些功能，然后提供 API 给外界使用</p>
<h4 id="封装类型">封装类型</h4>
<p>在静态类型语言中经常涉及到封装类型：通常是通过提供抽象类和接口来实现的。</p>
<h4 id="封装变化">封装变化</h4>
<p>把系统中稳定不变的部分和容易变化的部分隔离开来</p>
<h2 id="this-call-apply"><code>this</code> <code>call</code> <code>apply</code></h2>
<p>TODO: 以后再详细读这个部分</p>
<h2 id="闭包和高阶函数">闭包和高阶函数</h2>
<p>TODO：以后再详细读这个部分</p>
<h1 id="设计模式">设计模式</h1>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p>
</blockquote>
<h3 id="简单的单例模式">简单的单例模式</h3>
<p>通过 <code>Singleton.getInstance</code> 来获取 <code>Singleton</code> 类的唯一对象，但增加了这个类的不透明性：不能通过 <code>new</code> 直接来构造这个对象，需要通过对象提供的 <code>getInstance</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Singleton</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="透明的单例模式">透明的单例模式</h3>
<p>用户可以直接使用 <code>new</code> 构造一个对象，并且不管 <code>new</code> 多少次，得到的都是全局唯一的单例。这里使用了自执行函数和闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CreateDiv</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">RealCreateDiv</span> = <span class="keyword">function</span> (<span class="params">html</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">html</span> = html</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">RealCreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">RealCreateDiv</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>缺点是复杂，并且如果有一天我们想要用这个类构造出多例，就得深入业务代码去改</p>
<h3 id="利用代理实现单例模式">利用代理实现单例模式</h3>
<p>我们可以将实现单例的代码给抽离出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先写一个普通的构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CreateDiv</span> = <span class="keyword">function</span> (<span class="params">html</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">html</span> = html</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">CreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再引入代理类 proxySingletonCreateDiv</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProxySingletonCreateDiv</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">html</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(html)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">ProxySingletonCreateDiv</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">ProxySingletonCreateDiv</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="惰性单例">惰性单例</h3>
<p>在需要的时候才创建出单例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSingle = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result || ( result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span> ) )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略模式">策略模式</h2>
<p>定义一些列算法，把他们一个个封装起来，并且使他们可以相互替换</p>
<h3 id="使用策略模式计算奖金">使用策略模式计算奖金</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calculateBonus = <span class="keyword">function</span> (<span class="params">performanceLevel, salary</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&#x27;B&#x27;</span>) <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calculateBonus</code> 函数非常庞大且缺乏可扩展性、复用性</p>
<p>基于策略模式的程序至少包含两部分：</p>
<ul>
<li>一组策略类：策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类 Context：接受客户请求，然后把请求委托给一个策略类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> performanceS = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line">performanceS.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> performanceA = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line">performanceA.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> performanceB = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line">performanceB.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Bonus</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">salary</span> = <span class="literal">null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">strategy</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setSalary</span> = <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">salary</span> = salary</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setStrategy</span> = <span class="keyword">function</span> (<span class="params">strategy</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getBonus</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strategy</span>.<span class="title function_">calculate</span>(<span class="variable language_">this</span>.<span class="property">salary</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以这样写让代码更简洁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="string">&quot;S&quot;</span>: <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;A&quot;</span>: <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;B&quot;</span>: <span class="keyword">function</span> (<span class="params">salary</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">calculateBonus</span> = (<span class="params">level, salary</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[level](salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用策略模式实现缓动动画">使用策略模式实现缓动动画</h3>
<p><a href="https://stackblitz.com/edit/js-e9bzig">DEMO 在这里</a></p>
<p>目标：一个动画类 + 一些缓动算法，让小球在页面中运动 思路： - 运动开始前，需要记录一些信息： - 小球的原始位置 - 小球的目标位置 - 动画开始的时间点 - 动画持续时间 - 然后用 <code>setInterval</code> 创建一个定时器，每 19ms 循环一次，传入当前信息，输出下一个位置 - 更新 div 的 CSS 属性</p>
<h4 id="常见的缓动算法">常见的缓动算法</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tween = &#123;</span><br><span class="line">  <span class="comment">// t - 当前时间</span></span><br><span class="line">  <span class="comment">// b - 原始位置</span></span><br><span class="line">  <span class="comment">// c - 目标位置</span></span><br><span class="line">  <span class="comment">// d - 动画持续时间</span></span><br><span class="line">  <span class="title function_">linear</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * t / d + b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">easeIn</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * ( t /= d ) * t + b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">strongEaseIn</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * (( t /= d ) * t ** <span class="number">4</span> + <span class="number">1</span>) + b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">strongEaseOut</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * (( t = t / d - <span class="number">1</span> ) * t ** <span class="number">4</span> + <span class="number">1</span>) + b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sineaseIn</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * ( t /= d ) * t ** <span class="number">2</span> + b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sineaseOut</span>(<span class="params">t, b, c, d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * (( t = t / d - <span class="number">1</span> ) * t ** <span class="number">2</span> + <span class="number">1</span>) + b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记：《计算机程序的构造和解释》</title>
    <url>/hais-notebook/2023/01/17/Book-StructureAndInterpretationOfComputerPrograms/</url>
    <content><![CDATA[<p>关于程序设计与算法，本书主要使用 Lisp 的方言 Scheme 进行举例，这门语言拥有将过程表示为数据的能力。</p>
<span id="more"></span>
<h1 id="过程抽象">过程抽象</h1>
<p>## 程序设计的基本元素</p>
<p>每种语言都提供了 <strong>基本表达式、组合的方法、抽象的方法</strong>，能够将简单的认识组合起来形成更复杂的认识。</p>
<h3 id="表达式与组合式">表达式与组合式</h3>
<p>组合式就是复合表达式，用来把 <strong>过程</strong> 应用于这些数上。下面就是一些组合式。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> <span class="number">137</span> <span class="number">349</span> <span class="number">2354</span> <span class="number">11</span>)</span><br><span class="line">(<span class="name"><span class="built_in">-</span></span> <span class="number">1000</span> <span class="number">334</span>)</span><br></pre></td></tr></table></figure>
<p>运算符放在运算对象的左边，称为 <strong>前缀表示</strong>，他的优点是能够适用于可能带有任意个实参的过程。</p>
<h4 id="组合式的求值">组合式的求值</h4>
<ul>
<li>过程实际上是 <strong>递归</strong> 的，需要对组合式的每个子元素执行相同的过程</li>
<li><strong>树形累积</strong>：可以采用一棵树的图形来表示组合式的求值过程</li>
</ul>
<h3 id="命名和环境">命名和环境</h3>
<p>将名字标识符称为 <strong>变量</strong>，他的 <strong>值</strong> 就是他所对应的那个对象。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> size <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="过程定义与复合过程">过程定义与复合过程</h3>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">&lt;name&gt;</span> &lt;formal parameters&gt;) &lt;body&gt;)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br><span class="line">(<span class="name">square</span> <span class="number">21</span>)</span><br><span class="line">(<span class="name">square</span> (<span class="name"><span class="built_in">+</span></span> <span class="number">2</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sum-of-squares</span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</span><br></pre></td></tr></table></figure>
<h4 id="复合过程的求值">复合过程的求值</h4>
<p>可以使用 <strong>代换模型</strong> 来进行思考（注意这并不是解释器的实际工作方式）：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">sum-of-squares</span> <span class="number">6</span> <span class="number">10</span>)</span><br><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name">square</span> <span class="number">6</span>) (<span class="name">square</span> <span class="number">10</span>))</span><br><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">6</span> <span class="number">6</span>) (<span class="name"><span class="built_in">*</span></span> <span class="number">10</span> <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h4 id="应用序与正则序">应用序与正则序</h4>
<ul>
<li><p>正则序：完全展开而后归约</p></li>
<li><p>应用序：先求值参数而后应用，可以避免对表达式的重复求值</p></li>
</ul>
<h3 id="条件表达式和谓词">条件表达式和谓词</h3>
<p>有多种表达式可以表达 <code>|x|</code> 的值：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cond</span></span> (<span class="name">&lt;p1&gt;</span> &lt;e1&gt;)</span><br><span class="line">      (<span class="name">&lt;p2&gt;</span> &lt;e2&gt;)</span><br><span class="line">      ...</span><br><span class="line">      (<span class="name">&lt;pn&gt;</span> &lt;en&gt;))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">&gt;</span></span> x <span class="number">0</span>) x)</span><br><span class="line">        ((<span class="name"><span class="built_in">=</span></span> x <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>) -x)))</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;p&gt;</code> 被称为 <strong>谓词</strong>，他是一个 <strong>表达式</strong>，他的值被解释为真或者假。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">if</span></span> &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">-</span></span> x)</span><br><span class="line">      x))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>Browser</title>
    <url>/hais-notebook/2020/01/30/Browser/</url>
    <content><![CDATA[<p>Cookie 是浏览器下发给浏览器的一段字符串，浏览器必须保存这个 Cookie，之后发起的相同二级域名的请求，浏览器必须附上 Cookie。</p>
<span id="more"></span>
<h1 id="cookie">Cookie</h1>
<h2 id="cookie-防篡改">Cookie 防篡改</h2>
<p>思路一：加密，但是有安全漏洞（加密后的内容可以无限期使用）</p>
<p>思路二：把用户信息隐藏在服务器，这样我就可以自由控制 Cookie 的失效时间</p>
<ul>
<li>把用户信息放在服务器的 <code>session</code> 里，再给信息一个随机 <code>id</code></li>
<li>把随机的 <code>id</code> 发送给浏览器</li>
<li>后端读取的时候，通过 <code>session[id]</code> 获取用户信息</li>
</ul>
<h2 id="cookielocalstoragesessionstorage-和-session">Cookie、LocalStorage、SessionStorage 和 Session</h2>
<h3 id="cookie-和-session-的区别">Cookie 和 Session 的区别</h3>
<p>Cookie 是服务器发给浏览器的一段字符串，每次浏览器在访问对应域名的时候，都需要把这个字符串带上 Session 是会话，表示浏览器与服务器一段时间内的会话</p>
<ul>
<li>一般 Cookie 在浏览器上，Session 在服务器上</li>
<li>Session 一般是基于 Cookie 来实现的（把 SessionID 放到 Cookie 里面）</li>
</ul>
<h3 id="cookie-和-localstorage-的区别">Cookie 和 LocalStorage 的区别</h3>
<ul>
<li>Cookie 上限一般为 4K，LocalStorage 为 5M</li>
<li>Cookie 一般存储用户信息，LocalStorage 一般存储不重要的数据</li>
<li>Cookie 需要发送到服务器上，LocalStorage 不发送到服务器上</li>
</ul>
<h3 id="localstorage-和-sessionstorage-的区别">LocalStorage 和 SessionStorage 的区别</h3>
<p>LocalStorage 一般不过期，SessionStorage 一般在 Session 结束的时候过期（比如关闭浏览器的时候）</p>
<h1 id="同源策略">同源策略</h1>
<ul>
<li>源：输入 <code>window.origin</code> 或者 <code>location.origin</code>，我们就可以看到 <strong>源</strong>，实际上他就是 <strong>协议 + 域名 + 端口号</strong>。</li>
<li>同源：当两个 url 的源（协议、域名、端口号）完全一致，则称之为 <strong>同源</strong>，比如 <code>https://baidu.com</code> 和 <code>https://www.baidu.com</code> 就不同源。</li>
<li>同源策略：<strong>浏览器</strong> 规定：如果 JS <strong>运行在</strong>源 A 里，那么就不能获取源 B 的数据，这就是 <strong>同源策略</strong> ——不允许不同源的资源 <strong>跨域访问</strong>。</li>
</ul>
<div class="note warning"><p>要注意的是，同源策略限制的是 <strong>数据的访问</strong>，引用 CSS、JS 和图片的时候，其实并不知道其内容，只是在 <strong>引用</strong>，因此不受同源策略限制。</p>
</div>
<h2 id="cors">CORS</h2>
<blockquote>
<p>Cross-Origin Resource Sharing</p>
</blockquote>
<p>只需要在响应头里面写 <code>Access-Control-Allow-Origin: http://foo.example</code> 就可以了，但是 IE 6、7、8、9 都不支持，得用 JSONP。</p>
<h2 id="jsonp">JSONP</h2>
<blockquote>
<p>JSONP 和 JSON 没有多大关系</p>
</blockquote>
<p>让 <code>frank.com</code> 访问 <code>qq.com</code> 的方法：</p>
<ol type="1">
<li><code>qq.com</code> 将 数据写到 <code>/friends.js</code></li>
<li><code>frank.com</code> 用 <code>script</code> 标签引用 <code>/friends.js</code></li>
<li><code>/friends.js</code> 执行，执行 <code>frank.com</code> 事先定义好的 <code>window.xxx</code> 函数（<code>window.xxx(&#123;friends:[...]&#125;)</code>）</li>
<li>然后 <code>frank.com</code> 通过 <code>window.xxx</code> 获取到了数据，这也是一个回调</li>
</ol>
<p>但是，JSONP 存在安全性问题：</p>
<ul>
<li>因为每个人都可以引用 js，需要进行 <code>referer</code> 检查</li>
<li>仍然存在安全问题，如果 <code>frank.com</code> 被攻陷，则 <code>qq.com</code> 也被攻陷</li>
</ul>
<p>如何自动生成 window.xxx（如何把 frank.com 定义好的函数传给后台）？</p>
<ul>
<li>通过查询参数</li>
</ul>
<blockquote>
<p>什么是 JSONP？ 背景：当前浏览器或者由于某些因素导致不支持跨域 方法：请求一个 JS 文件，文件会执行一个回调，回调里面有我们的数据，回调的名字可以随机生成，我们把名字用 callback 参数传给后台，后台再返回给我们再执行 优点：兼容 IE、可以跨域 缺点：由于是 <code>script</code> 标签，所以读不到 AJAX 那么精确的状态（比如 Status、响应头等等），并且只能发 <code>GET</code> 请求，不支持 <code>POST</code></p>
</blockquote>
<p>一个代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = settings.<span class="property">data</span> || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> key = settings.<span class="property">key</span> || <span class="string">&#x27;callback&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> callback = settings.<span class="property">callback</span> || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  data[key] = <span class="string">&#x27;__onGetData__&#x27;</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">__onGetData__</span> = <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(response)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> query = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    query.<span class="title function_">push</span>(key + <span class="string">&#x27;=&#x27;</span> + data.<span class="property">key</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.<span class="property">src</span> = url + <span class="string">&#x27;?&#x27;</span> + <span class="built_in">encodeURIComponent</span>(query.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>))</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浏览器架构">浏览器架构</h1>
<h2 id="浏览器的多进程架构">浏览器的多进程架构</h2>
<h3 id="chrome-的多进程架构">Chrome 的多进程架构</h3>
<p>浏览器可以是单进程的，也可以是多进程的（不同的进程间可以通过IPC通信），不同的浏览器使用不同的架构，比如对于 Chrome：</p>
<ul>
<li><strong>浏览器进程 Browser Process</strong>：负责浏览器 Tab 的前进、后退、地址栏、书签栏、网络请求、文件访问等</li>
<li><strong>渲染进程 Renderer Process</strong>：负责一个 Tab 内的显示相关工作</li>
<li><strong>插件进程 Plugin Process</strong>：负责控制插件</li>
<li><strong>GPU 进程 GPU Process</strong>：负责处理 GPU 任务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2.png" /></p>
<p>当我们在浏览器地址栏输入 URL 后：</p>
<ol type="1">
<li><strong>Browser Process</strong> 会向 URL 发请求，获取 HTML 内容，将 HTML 交给 <strong>Renderer Process</strong></li>
<li><strong>Renderer Process</strong> 解析 HTML 内容，如果遇到网络请求就又返回给 <strong>Browser Process</strong> 进行加载；同时通知 <strong>Browser Process</strong> 需要 <strong>Plugin Process</strong> 加载插件资源</li>
<li>解析完成后，<strong>Renderer Process</strong> 计算得到图像帧，并将其交给 <strong>GPU Process</strong></li>
<li><strong>GPU Process</strong> 将图像帧转化为图像显示在屏幕上</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3.png" /></p>
<h3 id="多进程架构的好处">多进程架构的好处</h3>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4.png" /></p>
<ol type="1">
<li>容错性。防止崩溃传染</li>
<li>安全性。浏览器针对不同的进程限制了不同的权限，并为其提供沙盒运行环境，使其更加安全可靠</li>
<li>更高的响应速度。避免各个任务抢占 CPU 资源</li>
</ol>
<h3 id="多进程架构优化">多进程架构优化</h3>
<p>一个 Tab 对应一个 <strong>Renderer Process</strong>，进程之间的内存无法共享，而不同的进程内存常常有相同的内容，此时需要优化。</p>
<h4 id="浏览器的进程模式">浏览器的进程模式</h4>
<p>Chrome 提供了四种进程模式（Process Models），不同的进程会对 Tab 进程做不同的处理。</p>
<ul>
<li><strong>Process-per-site-instance</strong> (default)：同一个 site-instance 使用一个进程</li>
<li><strong>Process-per-site</strong>：同一个 site 使用一个进程</li>
<li><strong>Process-per-tab</strong>：同一个 tab 使用一个进程</li>
<li><strong>Single Process</strong>：所有 tab 共用一个进程</li>
</ul>
<p>其中：</p>
<ul>
<li><strong>site</strong> 指的是相同的 domain name(比如 google.com) 和 scheme(比如 https://)。比如 a.baidu.com 和 b.baidu.com 就可以理解为一个 site（这与同源策略不同，同源策略还涉及子域名和端口）</li>
<li><strong>site-instance</strong> 指的是一组 connected pages from the same site。connected 即 can obtain references to each other in script code。比如满足下面两种情况，并打开的新页面和旧页面就属于同一个 site，那么他们就属于一个 site-instance：
<ul>
<li>用户通过 <code>&lt;a&gt;</code> 标签打开的页面</li>
<li>通过 Javascript 代码打开的新页面（比如 <code>window.open</code>）</li>
</ul></li>
</ul>
<p>举个栗子：若使用 <strong>Process-per-site-instance</strong> 模式，当打开一个 tab 访问 a.baidu.com，再打开一个 tab 访问 b.baidu.com，就是两个进程；若在 a.baidu.com 中，通过 Javascript 代码打开了 b.baidu.com，就会使用同一个进程。</p>
<p>因此实际上这是介于 <strong>Process-per-site</strong> 和 <strong>Process-per-tab</strong> 之间的一种模式。</p>
<h1 id="导航过程">导航过程</h1>
<h2 id="网页加载过程">网页加载过程</h2>
<p><strong>Browser Process</strong> 又划分为不同的工作线程：</p>
<ul>
<li><strong>UI Thread</strong>：控制浏览器上的按钮和输入框</li>
<li><strong>Network Thread</strong>：处理网络请求（Chrome 72以后，已将network thread单独摘成network service process，当然也可以通过 chrome://flags/#network-service-in-process修改配置，将其其作为线程运行在Browser Process中 的提出）</li>
<li><strong>Storage Thread</strong>：控制文件的访问</li>
</ul>
<h3 id="第一步处理输入">第一步：处理输入</h3>
<p>在浏览器地址栏输入内容，按下回车之后 <strong>UI Thread</strong> 会判断输入的内容是搜索关键词还是 URL，然后跳转至搜索引擎或请求 URL。</p>
<h3 id="第二步开始导航">第二步：开始导航</h3>
<p><strong>UI Thread</strong> 会将 URL 交给网络进程，并显示一个 Loading 图标。然后网络进程会进行诸如 DNS 寻址、建立 TLS 等连接进行资源请求。如果收到服务器的301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。</p>
<h3 id="第三步读取响应">第三步：读取响应</h3>
<p>网络进程收到响应之后会开始解析 HTTP 响应报文，然后根据 <code>Content-Type</code> 字段确定媒体类型（MIME Type）：如果媒体类型是 HTML 文件，则会交给渲染进程进行下一步工作；如果是 Zip 或者其他文件，会把相关数据交给下载管理器。</p>
<p>与此同时，浏览器会进行 <a href="https://safebrowsing.google.com/">Safe Browsing</a> 安全检查，有可能会展示一个警告页。除此之外，还会做 <a href="https://www.chromium.org/Home/chromium-security/corb-for-developers">CORB</a> 检查来确定敏感的跨站数据不会发送到渲染进程。</p>
<h3 id="第四步查找渲染进程">第四步：查找渲染进程</h3>
<p>检查完毕之后，网络线程会通知UI线程，说数据已经准备好了。UI线程会查找到一个渲染进程进行网页渲染。</p>
<h3 id="第五步提交导航">第五步：提交导航</h3>
<p>此时，数据和渲染进程都已经准备好了，浏览器进程会向渲染进程发送 IPC 消息来确认导航。渲染进程接收到数据后，会告诉浏览器进程导航已经提交了，页面开始加载。</p>
<p>这时导航栏会更新，安全指示符更新，访问历史列表更新。</p>
<h3 id="第六步初始化加载完成">第六步：初始化加载完成</h3>
<p>渲染进程渲染完毕之后（页面及内部的 iframe 都触发了 onload 事件），会向浏览器进程发送 IPC 消息，告知浏览器进程。UI 线程就会取消 Loading 状态。</p>
<h2 id="网页渲染原理">网页渲染原理</h2>
<p>渲染进程其实主要就是渲染 HTML + CSS + JS，将其转化为用户可交互的 Web 页面。他包含这几个线程：</p>
<ul>
<li><strong>Main Thread</strong>：一个主线程</li>
<li><strong>Work Thread</strong>：多个工作线程</li>
<li><strong>Compositor Thread</strong>：一个合成器线程</li>
<li><strong>Raster Thread</strong>：多个光栅化线程</li>
</ul>
<h3 id="构建-dom">构建 DOM</h3>
<p>当渲染进程收到导航的确认信息之后，开始接受来自浏览器进程的数据。此时，主线程会转化为 DOM 对象。</p>
<h3 id="子资源加载">子资源加载</h3>
<p>在构建 DOM 的过程中，会解析到图片、CSS、Javascript 等资源，这些资源需要从网络或者缓存中获取，主线程在构建 DOM 过程中如果遇到了这些资源，逐一发起请求去获取。而为了提升效率，浏览器也会运行预加载扫描程序，如果 HTML 中存在 <code>img</code> <code>link</code> 等，预加载扫描程序会把这些请求传递给网络线程进行资源下载。</p>
<h3 id="javascript-的加载与执行">Javascript 的加载与执行</h3>
<p>构建 DOM 的过程中，如果遇到 <code>&lt;script&gt;</code> 标签，会停止对 HTML 的解析，去加载执行 Javascript 代码，因为 Javascript 代码可能会改变 DOM 的结构。</p>
<p>但我们也可以在 <code>&lt;script&gt;</code> 上添加 <code>async</code> <code>defer</code> 等属性，让浏览器不要阻塞。</p>
<blockquote>
<p>defer 仅适用于外部脚本。并且 defer 会保证脚本之间的<strong>执行</strong>的相对顺序，前面的脚本先执行，且一定会在 DOMContentLoaded 之前执行。 async 不会保证脚本的相对顺序，谁先下载好谁先执行，且与 DOMContentLoaded 执行顺序无关。</p>
</blockquote>
<h3 id="样式计算style-calculation">样式计算：Style Calculation</h3>
<p>主线程在解析页面时，遇到 <code>&lt;style&gt;</code> 或 <code>&lt;link&gt;</code> 标签的 CSS 资源，会加载 CSS 代码，并以此确定每个 DOM 节点的 <strong>计算样式（Computed Style）</strong>。</p>
<h3 id="布局layout">布局：Layout</h3>
<p>主线程会遍历 <strong>DOM</strong> 及相关元素的 <strong>计算样式</strong>，构建出包含每个元素的页面 <strong>坐标信息</strong> 及 <strong>盒子模型大小</strong> 的布局树（Render Tree）。遍历过程中，会跳过隐藏的元素（display: none）；另外，伪元素虽然在 DOM 上不可见，但是在布局树上是可见的。</p>
<h3 id="绘制paint">绘制：Paint</h3>
<p>主线程会遍历布局树（Layout Tree），生成一系列的绘画记录（Paint Records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记。</p>
<blockquote>
<p>关于他们与 CSS 动画的关系，看这篇笔记：<a href="/hais-notebook/2020/02/01/CSS/" title="CSS">CSS</a></p>
</blockquote>
<h3 id="合成compositing">合成：Compositing</h3>
<blockquote>
<p>将 文档结构、元素的样式、元素的几何关系、绘画顺序 这些信息转化为显示器中的像素的过程，叫做 <strong>光栅化(Rasterizing)</strong>。</p>
</blockquote>
<h4 id="什么是合成">什么是合成</h4>
<h5 id="简单的绘制方式">简单的绘制方式</h5>
<p>最简单的绘制方法就是只光栅化视口（Viewport）内的内容，如果滚动了页面，就移动光栅帧（Rastered Frame）并且光栅化更多的内容：</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/15.gif" /></p>
<p>Chrome 最开始就是使用的这种方式，他的缺点在于每当页面滚动，光栅线程都需要对新视图的内容进行光栅化——这会导致性能损耗。于是 Chrome 采用合成的方式来优化这种情况。</p>
<h5 id="采用合成的方式提高性能">采用合成的方式提高性能</h5>
<p>合成就是 <strong>将页面分成若干层</strong>，然后分别对他们进行光栅化，最后在一个单独的线程——合成线程中合成一个页面。 当用户滚动页面的时候，由于各个层都已经光栅化了，浏览器只需要合成一个新的帧来展示滚动之后的效果。 页面动画也是类似，将页面上的层移动并构建出一个新的帧。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/16.gif" /></p>
<h4 id="主线程与元素分层">主线程与元素分层</h4>
<p><strong>主线程</strong> 需要遍历布局树来构建一棵层次树（Layer Tree）。对于有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change">will-change</a> 属性的元素，会被看做是单独的一层；没有 <code>will-change</code> CSS 属性的元素，浏览器会根据情况决定是否把元素放在单独的层——如果层数过多，可能这个合成过程比光栅化还要慢。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/17.png" /></p>
<h4 id="合成器线程光栅化线程">合成器线程、光栅化线程</h4>
<p>一旦 Layer Tree 被创建，渲染顺序被确定，主线程会把这些信息通知给 <strong>合成器线程</strong>，<strong>合成器线程</strong> 开始对每一层进行光栅化。有的层可以达到整个页面的大小，因此合成器线程需要将他们切成小块的图块（tiles）。之后将这些小图块分别发送给一系列的 <strong>光栅化线程</strong> 进行光栅化，结束后 <strong>光栅化线程</strong> 会将每个图块的光栅化结果存在 <strong>GPU 线程</strong> 的内存中。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/18.png" /></p>
<p>为了优化显示体验，<strong>合成线程</strong> 可以给不同的 <strong>光栅化线程</strong> 赋予不同的优先级，将那些在视口中或者视口附近的层优先光栅化。</p>
<p>当图层上面的图块都被光栅化后，<strong>合成线程</strong> 会收集图块上面的 <strong>绘画四边形（Draw Quads）</strong> 信息来构建一个 <strong>合成帧（Compositor Frame）</strong></p>
<blockquote>
<p>绘画四边形：包含图块在内存的位置、图块在页面的位置之类的信息 合成帧：代表一个帧的内容的绘画四边形的集合。</p>
</blockquote>
<h4 id="提交合成帧">提交合成帧</h4>
<p>当以上步骤完成之后，合成线程会通过 IPC 向浏览器进程提交（Commit）一个渲染帧。这时浏览器线程的 UI 进程也可能提交合成帧来改变浏览器的UI。这些合成帧都会被发送给 GPU 然后展示在屏幕上。如果合成线程收到了页面滚动事件，他会再构建一个合成帧发送给 GPU 来更新页面。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/19.png" /></p>
<p>由于合成的过程没有涉及到主线程，因此合成线程不需要等待样式的计算以及 Javascript 执行完成。因此 <a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">合成相关的动画最流畅</a>，比如 <code>transform</code> <code>opacity</code>。</p>
<h1 id="浏览器处理事件">浏览器处理事件</h1>
<p>以点击事件为例，当鼠标点击页面的时候：</p>
<ol type="1">
<li>浏览器进程 Browser Process 最先接收到事件信息，他知道了事件的类型和位置，然后把事件信息传递给渲染进程。</li>
<li>渲染进程 Renderer Process 会根据事件发生的坐标，找到目标对象，并运行绑定的监听函数。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/20.png" /></p>
<h2 id="渲染进程中的合成器线程接收事件">渲染进程中的合成器线程接收事件</h2>
<p>比如对于页面滚动，如果我们没有绑定页面滚动事件，合成器线程可以独立于主线程创建合成帧；但如果页面绑定了滚动事件，合成器线程需要先等待主线程的事件处理完成之后才能创建合成帧。</p>
<p>当页面合成时，合成器线程会标记页面中有绑定事件处理器的区域为 <strong>非快速滚动区域（Non-Fast Scrollable Region）</strong>。如果这些区域发生事件，合成器线程就会先把事件发送给主线程，否则他就会直接合成新的帧。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/21.png" /></p>
<p>因此，我们需要注意全局事件绑定，比如有时候我们使用事件委托，将目标元素的事件发送给根元素 body 来进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span> === area) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这段代码下，整个 body 被绑定了事件监听器，也就意味着整个页面都视为非快速滚动区域，合成器每次都需要与主线程通信并且等待反馈。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/22.png" /></p>
<p>我们为了提升性能可以这样改一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span> === area) &#123;</span><br><span class="line">    <span class="comment">// 注意这时候就不能调用 preventDefault 了，因为合成器线程不会再等待主线程的反馈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="查找事件对象-event-target">查找事件对象 Event Target</h2>
<p>当事件没有发生在非快速滚动区域的时候，合成器线程会向主线程发送事件信息，主线程获取到事件信息之后会通过命中测试（Hit Test）去找到事件的目标对象——命中测试会遍历在绘制阶段生成的绘画记录（Paint Record）来找到包含事件发生坐标上的元素对象。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/23.png" /></p>
<h2 id="浏览器对事件的优化">浏览器对事件的优化</h2>
<p>一般我们的屏幕是 60 fps，但某些事件触发频率可以超过这个数值（比如 <code>wheel</code> <code>mousewheel</code> <code>mousemove</code> <code>pointermove</code> <code>touchmove</code>，他们一般会每秒触发60~120次）。对于相对较低的屏幕刷新率来说，这样主线程就会触发过量的命中测试和 JavaScript 代码，浪费性能。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/24.png" /></p>
<p>为了优化这个问题，浏览器会合并这些连续的事件，延迟到下一帧渲染时进行——也就是 <code>requestAnimationFrame</code> 之前。</p>
<p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/25.png" /></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/hais-notebook/2020/02/01/CSS/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="introduction">Introduction</h1>
<h2 id="层叠的含义">层叠的含义</h2>
<ul>
<li><strong>样式层叠</strong>：可以对同一个选择器进行样式声明</li>
<li><strong>选择器层叠</strong>：可以用不同的选择器对同一个元素进行样式声明</li>
<li><strong>文件层叠</strong>：可以用多个文件进行层叠</li>
</ul>
<h2 id="样式语法">样式语法</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性名: 属性值;</span><br><span class="line">  <span class="comment">/* 注释 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法">@ 语法</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;   <span class="comment">/* 必须放在第一行 */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="number">2</span>.css); </span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">100px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">200px</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="charset">charset</h2>
<ul>
<li>charset 是字符集的意思，但 UTF-8 不是字符集，而是字符编码(encoding)，这是历史遗留问题</li>
<li>ASCII 字符集的编码形式就是 ASCII，这个字符集只有英文</li>
<li>GB2312 字符集是中国人发明的简体中文字符集，他的编码形式也是 GB2312</li>
<li>GBK 是微软发明的中日韩（CJK）字符集，他的编码形式也是 GBK</li>
<li>unicode 是支持所有字符的字符集，他的编码形式有 UTF-8/UTF-16/UTF-32</li>
</ul>
<h2 id="找资料">找资料</h2>
<ul>
<li>查资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN</a>、<a href="https://css-tricks.com/">CSS Tricks</a>、<a href="https://www.zhangxinxu.com/wordpress/">张鑫旭的博客</a></li>
<li>找素材（可以搜 PSD WEB）：<a href="https://www.freepik.com/">Freepik</a>、<a href="http://dribbble.com/">Dribbble</a>、<a href="https://cn.365psd.com/">365 PSD</a></li>
</ul>
<h1 id="concepts">Concepts</h1>
<h2 id="文档流">文档流</h2>
<blockquote>
<p>这里的文档流指的是 <strong>Normal Flow</strong>，也就是 <strong>正常布局流</strong> 当我们没有使用过任何 CSS 规则来改变元素的展现方式的时候，他们会按照正常的布局流来组织——也就是默认情况下的元素布局——这也就是我们所说的 <strong>Noraml Flow</strong>，即 <strong>文档流</strong></p>
</blockquote>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th><code>display</code></th>
<th>流动方向</th>
<th>宽度</th>
<th>高度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inline</code></td>
<td>从左到右排列，<strong>行尾会截断成两行</strong></td>
<td>里面所有 inline 元素之和，不接受指定 <code>width</code></td>
<td><strong>实际高度</strong>由<strong>行高（<code>line-height</code>）间接</strong>（与字体有关，具体可以看 <a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729887779307520">这个</a>）<strong>确定</strong>，<code>padding</code> 只能改变<strong>看得见</strong>的高度（而不是实际高度），如果没有内容，也有高度，为 <code>line-height</code></td>
</tr>
<tr class="even">
<td><code>block</code></td>
<td>从上到下排列（每个占一行）</td>
<td>默认为 <code>auto</code>（不是100%），可以指定 <code>width</code>，但永远不要写 <code>width: 100%</code></td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code>，如果没有内容，高度为 <code>0</code></td>
</tr>
<tr class="odd">
<td><code>inline-block</code></td>
<td>从左到右排列，<strong>行尾不会分成两块</strong></td>
<td>默认为里面所有 <code>inline</code> 元素之和，但接受指定 <code>width</code></td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code></td>
</tr>
</tbody>
</table>
<h2 id="溢出">溢出</h2>
<blockquote>
<p>这里的溢出指的是 <strong>Overflow</strong></p>
</blockquote>
<table>
<thead>
<tr class="header">
<th><code>overflow</code></th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hidden</code></td>
<td>隐藏</td>
</tr>
<tr class="even">
<td><code>scroll</code></td>
<td>滚动，就算没有溢出，依然有滚动条，<strong>如果有横向滚动条，inline 元素也只会在第一屏</strong></td>
</tr>
<tr class="odd">
<td><code>auto</code></td>
<td>没有溢出就没有滚动条，并且只显示必要的滚动条</td>
</tr>
</tbody>
</table>
<p>可以分开设置 <code>overflow-x</code> 和 <code>overflow-y</code></p>
<h2 id="脱离文档流">脱离文档流</h2>
<blockquote>
<p>也就是 <strong>Out of flow</strong></p>
</blockquote>
<div class="note warning"><p>block 不计算其高度</p>
</div>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute | fixed;</span><br><span class="line"><span class="comment">/* OR */</span></span><br><span class="line"><span class="attribute">float</span>: left | right;</span><br></pre></td></tr></table></figure>
<h2 id="盒模型">盒模型</h2>
<p>可以把网页中显示的 HTML 元素看成是一个个盒子，盒子具有四层：</p>
<ul>
<li>内容（content）</li>
<li>内边距（padding）</li>
<li>边框（border）</li>
<li>外边距（margin）</li>
</ul>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><code>box-sizing</code></th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>content-box</code></td>
<td>指定 <code>width</code> 或 <code>height</code> 时，说的是他的最里面的 <code>content</code> 的 宽或高</td>
</tr>
<tr class="even">
<td><code>border-box</code></td>
<td>指定 <code>width</code> 或 <code>heihgt</code> 时，除了 <code>content</code> 的宽或高之外，还包括了 <code>padding</code> 和 <code>border</code> 的厚度</td>
</tr>
</tbody>
</table>
<p>通过 <code>box-sizing</code> 控制，一般使用 <code>border-box</code></p>
<h2 id="margin-合并">Margin 合并</h2>
<blockquote>
<p>跟 BFC 有关系</p>
</blockquote>
<p>是说我们上下两个元素若都有 <code>margin</code>，那么他们的 <code>margin</code> 将不会同时生效。有以下几个注意点：</p>
<ol type="1">
<li>只有上下才会发生 <code>margin</code> 合并，左右不会发生</li>
<li>只有 <code>block</code> 会发生 <code>margin</code> 合并，<code>inline-block</code> 不会发生（生成了 BFC）</li>
<li><code>first-child</code> 和 <code>last-child</code> 也会和 <code>parent</code> 发生 <code>margin</code> 合并</li>
</ol>
<p>取消 margin 合并的方法，主要是靠生成 BFC：</p>
<ol type="1">
<li>使用 <code>overflow:hidden</code> 之后就不会再合并</li>
<li>使用 <code>display:flex</code> 之后就不会再合并</li>
<li>通过给 <code>parent</code> 上面加东西（<code>padding</code> <code>border</code> <code>overflow</code> 等）之后就不会再合并</li>
</ol>
<h2 id="bfc">BFC</h2>
<blockquote>
<p>BFC （块级格式化上下文）就是一块小区域，一块独立的布局环境，在这个区域之内的任何布局和定位都不会影响到外面，外面也不能影响到里面。</p>
</blockquote>
<h3 id="bfc-的作用">BFC 的作用</h3>
<ol type="1">
<li>同一个 BFC 内会发生垂直方向的 Margin 合并，如果是不同 BFC 则不会</li>
<li>形成了 BFC 的区域不会与 float 元素重叠，可以与浮动元素形成左右自适应布局</li>
<li>清除浮动，因为浮动元素的高度也会被 BFC 纳入计算，因此可以解决高度塌陷的问题</li>
</ol>
<h3 id="如何形成-bfc">如何形成 BFC</h3>
<ol type="1">
<li><code>float: left</code></li>
<li><code>position: absolute</code></li>
<li><code>overflow: hidden</code>，经常使用</li>
<li><code>display: inline-block</code></li>
<li><code>display: table-cell</code></li>
</ol>
<h1 id="layout">Layout</h1>
<h2 id="两种布局方式">两种布局方式</h2>
<ul>
<li><strong>固定宽度布局</strong>：960、1000、1024</li>
<li><strong>不固定宽度布局</strong>：一般在手机上使用，主要靠文档流原理来布局</li>
<li><strong>响应式布局</strong>：PC上固定宽度，手机上不固定宽度，也就是一种<strong>混合布局</strong></li>
</ul>
<h2 id="两种布局思路">两种布局思路</h2>
<ul>
<li>从大到小：先定下大局，然后再完善每个部分的小布局</li>
<li>从小到大：先完成小布局，然后再组合成大布局</li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Layout.png" alt="两种布局思路" /><figcaption aria-hidden="true">两种布局思路</figcaption>
</figure>
<h2 id="float">Float</h2>
<ol type="1">
<li>在子元素上加 <code>float: left</code> 和 <code>width</code></li>
<li>在父元素加上 <code>class="clearfix"</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验：</p>
<ul>
<li>有经验者会留一些空间或最后一个不设置 <code>width</code>（可以设置一个 <code>max-width</code>）</li>
<li>不需要考虑响应式，因为手机上没有 IE，这个布局是专门为 IE 准备的</li>
<li>在 IE 上有 BUG：最左边浮动元素的 <code>margin-left</code> 会变成双倍
<ul>
<li>可以加一句兼容性写法：<code>_margin-left: ?px</code></li>
<li>也可以加上 <code>display: inline-block</code></li>
</ul></li>
<li>如果图片下面有空隙，加上 <code>vertical-align: middle | top</code> 就可以消除</li>
<li><strong><code>float</code> 元素外边距不合并</strong></li>
</ul>
<div class="note warning"><p>必要时可以采用负 margin</p>
</div>
<p>比如说做平均布局，在所有的小块外面加一个 <code>div</code> ，然后再给这个 <code>div</code> 一个负 <code>margin</code></p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Layout-Minus-Margin.png" alt="负Margin" /><figcaption aria-hidden="true">负Margin</figcaption>
</figure>
<h2 id="flex">Flex</h2>
<p>这里是 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">CSS Tricks 上的 Flex 教程</a></p>
<h3 id="container">Container</h3>
<ul>
<li>让一个元素变成 flex 容器：<code>display: flex | inline-flex</code></li>
<li>改变 items 的流动方向（主轴）：<code>flex-direction: row | row-reverse | column | column-reverse</code></li>
<li>改变折行：<code>flex-wrap: nowrap | wrap | wrap-revers</code></li>
<li>主轴的对齐方式：<code>justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly</code></li>
<li>次轴对齐：<code>align-items: flex-start | flex-end | center | stretch(默认)</code></li>
<li>多行对齐（基本不用）：<code>align-content: flex-start | flex-end | center | strech | space-between | space-around</code></li>
</ul>
<h3 id="items">Items</h3>
<ul>
<li><code>order</code>：改变显示顺序</li>
<li><code>flex-grow</code>：控制自己如何长胖（占多余所有空间的权重），默认是0（尽可能窄）</li>
<li>导航栏常用左边 logo 和右边用户头像都是 0，中间是 1</li>
<li><code>flex-shrink</code>：控制如何变瘦，（在空间不够用的时候，压缩的比例）默认是1（大家一起变小），可以写0（防止变小）</li>
<li><code>flex-basis</code>：控制基准宽度，一般用得比较少，默认是 auto（跟宽度一样）</li>
</ul>
<p>以上可以缩写为：<code>flex: grow shrink basis</code></p>
<ul>
<li><code>align-self: flex-start | flex-end</code></li>
</ul>
<p>经验：</p>
<ul>
<li>永远不要把 <code>width</code> 和 <code>height</code> 写死</li>
<li>尽量使用 <code>min-width</code> | <code>max-width</code> 等来写</li>
<li><code>margin-xxx: auto</code>，有奇效，类似于 <code>between</code></li>
</ul>
<h2 id="grid">Grid</h2>
<p>这里是 <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">CSS Tricks 上的 Grid 教程</a></p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Grid.png" alt="Grid布局" /><figcaption aria-hidden="true">Grid布局</figcaption>
</figure>
<h3 id="container-1">Container</h3>
<ul>
<li>让一个元素变成 grid 容器：<code>display: grid | inline-grid</code></li>
<li>行和列：
<ul>
<li><code>grid-template-columns</code>: 每一列的宽度，可以写 <code>auto</code></li>
<li><code>grid-template-rows</code>: 每一行的高度，可以写 <code>auto</code></li>
<li><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line">  <span class="string">&quot;header header header&quot;</span></span><br><span class="line">  <span class="string">&quot;aside main ad&quot;</span></span><br><span class="line">  <span class="string">&quot;footer fotter .&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>grid-gap</code></li>
<li><code>grid-column-gap</code></li>
<li><code>grid-row-gap</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="items-1">Items</h3>
<ul>
<li>grid-row-start</li>
<li>grid-row-end</li>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>fr：free space，类似于flex-grow</li>
<li><strong>grid-area: header;</strong></li>
<li><strong>grid-area: main;</strong></li>
<li><strong>....</strong></li>
</ul>
<h2 id="水平垂直居中的方案">水平垂直居中的方案</h2>
<h3 id="定位三种">定位：三种</h3>
<ol type="1">
<li><code>absolute</code> + <code>margin</code>：需要知道自己的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><code>absolute</code> + <code>margin</code>：不需要知道自己的宽高，但是得有宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>absolute</code> + <code>translate</code>： 不需要知道自己的宽高，不需要有具体的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-1"><code>flex</code></h3>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javascript">JavaScript</h3>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-id">#box</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">HTML</span> = <span class="variable language_">document</span>.<span class="property">documentElement</span>,</span><br><span class="line">      winW = <span class="variable constant_">HTML</span>.<span class="property">clientWidth</span>,</span><br><span class="line">      winH = <span class="variable constant_">HTML</span>.<span class="property">clientHeight</span>,</span><br><span class="line">      boxW = box.<span class="property">offsetWidth</span>, <span class="comment">// 带边框的宽，也可以用 getBoundingClientReact</span></span><br><span class="line">      boxH = box.<span class="property">offsetHeight</span> <span class="comment">// 带边框的高</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">left</span> = (winW - boxW) / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">top</span> = (winH - boxH) / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="table-cell"><code>table-cell</code></h3>
<p>要求父级有固定宽高，相当于给文本居中</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左右固定中间自适应布局">左右固定、中间自适应布局</h2>
<h3 id="float-负-margin"><code>float</code> + 负 <code>margin</code></h3>
<p>圣杯布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双飞翼布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>, <span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calc"><code>calc</code></h3>
<p>兼容到 IE 9，渲染会比较慢</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: calc(<span class="number">100%</span> - <span class="number">400px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-2"><code>flex</code></h3>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位">定位</h3>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="positioning">Positioning</h1>
<p>定位和布局的区别：布局是平面上的，定位是垂直于屏幕的。</p>
<h2 id="一个-div-的分层">一个 div 的分层</h2>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Position.png" alt="一个div的分层" /><figcaption aria-hidden="true">一个div的分层</figcaption>
</figure>
<h2 id="position"><code>position</code></h2>
<h3 id="static"><code>static</code></h3>
<p>默认值，当前元素在文档流中</p>
<h3 id="relative"><code>relative</code></h3>
<ul>
<li>距离自己原来的位置的偏离（<code>top</code> / <code>bottom</code>），还是占据原来的空间</li>
<li>做位移</li>
<li>做 <code>absolute</code> 元素的爸爸</li>
<li>配合 <code>z-index</code>，默认是 <code>auto</code>，<code>auto</code> 计算出来的值为 <code>0</code></li>
<li><strong>经验</strong>：不要写 <code>z-index: 9999</code>，要学会 <code>z-index</code> 的管理</li>
</ul>
<h3 id="absolute"><code>absolute</code></h3>
<ul>
<li>脱离原来的位置，另起一层；会相对于<strong>祖先元素中最近的</strong>一个<strong>定位元素</strong>（即非 <code>static</code> 元素）</li>
<li>可以用于悬浮显示提示内容</li>
<li><code>white-space: nowrap</code> 文字内容不换行</li>
<li>经验：
<ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>善用 <code>left: 100%</code>，善用 <code>left: 50%</code>加负 <code>margin</code></li>
</ul></li>
</ul>
<h3 id="fixed"><code>fixed</code></h3>
<ul>
<li>相对于视口定位，但是如果放到具有 <code>transform</code> 属性的元素里面，会有问题</li>
<li>做广告</li>
<li>做回到顶部按钮</li>
<li><strong>经验</strong>
<ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>手机上尽量不要使用 <code>fixed</code></li>
</ul></li>
</ul>
<h3 id="sticky"><code>sticky</code></h3>
<p>兼容性很差</p>
<h1 id="staking-context">Staking Context</h1>
<p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，<strong>层叠上下文</strong> 就是对这些 HTML 元素的一个 <strong>三维构想</strong>。众 HTML 元素基于其元素属性 <strong>按照优先级顺序</strong> 占据这个空间。</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Staking-Context.png" alt="CSS 层叠上下文" /><figcaption aria-hidden="true">CSS 层叠上下文</figcaption>
</figure>
<p>默认的元素的三维层叠顺序如上图所示，可以看到定位元素会超出原来的高度范畴，换句话说，<strong>原来的 background、border、块级子元素、浮动元素、内联子元素均处在 z-index = -1 ~ 0 这个区间之内</strong>。</p>
<p>每一个层叠上下文就好像一个小世界，只有这里面的 <code>z-index</code> 才能进行比较，具有不同 <code>z-index</code> 的父元素之中的子元素根本无法同台竞技。</p>
<p>这些常见的属性（或元素）可以创建一个层叠上下文：</p>
<ul>
<li><code>HTML</code>（根元素）</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>relative | absolute</code> 元素</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>flex</code> <code>grid</code> 子项</li>
<li><code>transform</code> 值不为 <code>none</code> 的元素</li>
<li><code>opacity</code> 值小于 <code>1</code> 的元素</li>
</ul>
<p>更多资料可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">MDN 文档</a> 。</p>
<h1 id="animation">Animation</h1>
<p>用 <code>transform</code> 的性能会比直接修改 <code>left</code> 属性好，因为浏览器不会 repaint 那么多次</p>
<h2 id="浏览器的渲染过程">浏览器的渲染过程</h2>
<p>根据 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">Google 团队的文章</a>分析，我们可以将网页的渲染过程大致分为以下几步：</p>
<ol type="1">
<li>根据 HTML 构建 HTML 树（DOM）</li>
<li>根据 CSS 构建 CSS 树（CSSOM）</li>
<li>将两棵树合并为渲染树（Render Tree）</li>
<li>布局 <strong>Layout</strong>（文档流、盒模型、计算大小和位置）</li>
<li>绘制 <strong>Paint</strong>（边框颜色、文字颜色、阴影）</li>
<li>合成 <strong>Compose</strong>（根据层叠关系展示画面）</li>
</ol>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Browser-Render-Process.png" alt="浏览器渲染过程" /><figcaption aria-hidden="true">浏览器渲染过程</figcaption>
</figure>
<h2 id="更新样式">更新样式</h2>
<div class="note warning"><p>一般用 JS 更新样式，比如 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">div.<span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure></p>
</div>
<h3 id="三种更新样式的路径">三种更新样式的路径</h3>
<p>在 <a href="https://csstriggers.com/">这里</a> 可以看到不同的属性在不同的浏览器中的更新路径</p>
<ul>
<li>JS/CSS &gt; Style &gt; Layout &gt; Paint &gt; Composite: remove</li>
<li>JS/CSS &gt; Style &gt; Paint &gt; Composite: background-color</li>
<li>JS/CSS &gt; Style &gt; Composite: transform</li>
</ul>
<h3 id="css-动画优化">CSS 动画优化</h3>
<p>可以看看 <a href="https://developers.google.com/web/fundamentals/performance/rendering">谷歌的这篇文档</a></p>
<ul>
<li>JS 优化：使用 <code>requestAnimationFrame</code> 代替 <code>setTimeout</code> 或者 <code>setInterval</code></li>
<li>CSS 优化：使用 <code>will-change</code> 或者 <code>transform</code></li>
</ul>
<h2 id="transform"><code>transform</code></h2>
<blockquote>
<p>使用 <code>transform: none</code>，取消所有</p>
</blockquote>
<h3 id="位移">位移</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50px</span>) | <span class="built_in">translateY</span>(<span class="number">50%</span>) | <span class="built_in">translateZ</span>(<span class="number">50px</span>) | <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">50px</span>)</span><br></pre></td></tr></table></figure>
<p>视点的确定（在父元素上）： <code>perspective: 1000px</code> 表示父元素的中心为坐标原点，距离屏幕为 1000px</p>
<p>可以这样做绝对定位的居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>; <span class="attribute">left</span>: <span class="number">50%</span>; <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>)</span><br></pre></td></tr></table></figure>
<h3 id="缩放">缩放</h3>
<p>border 也会一起变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scaleX</span>(&lt;number&gt;) | <span class="built_in">scaleY</span>(&lt;number&gt;) | <span class="built_in">scale</span>(&lt;number&gt;, &lt;number&gt;?)</span><br></pre></td></tr></table></figure>
<h3 id="旋转">旋转</h3>
<p>一般用来做 360 度旋转的 loading 或者按钮的交互</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>([&lt;angle&gt;|&lt;zero&gt;]) | <span class="built_in">rotateZ</span>([&lt;angle&gt;|&lt;zero&gt;]) | <span class="built_in">rotateX</span>([&lt;angle&gt;|&lt;zero&gt;])</span><br></pre></td></tr></table></figure>
<h3 id="扭曲">扭曲</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(&lt;angle&gt;|&lt;zero&gt;) | <span class="built_in">skewY</span>(&lt;angle&gt;|&lt;zero&gt;) | <span class="built_in">skew</span>(&lt;angle&gt;|&lt;zero&gt;, &lt;angle&gt;|&lt;zero&gt;?)</span><br></pre></td></tr></table></figure>
<h2 id="transition"><code>transition</code></h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: 属性名(可以写all) 时长 过渡方式( linear | ease | ease-in | ease-in-out | cubic-bezier | step-start | step-end | steps ) 延迟</span><br><span class="line">transition: width <span class="number">2s</span> linear <span class="number">3s</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>不是所有属性都有过渡 <code>display: none =&gt; block</code>，一般改成 <code>visibility: hidden =&gt; visible</code></p>
</div>
<h2 id="animation-1"><code>animation</code></h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> xxx &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">66.66%</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加动画 */</span></span><br><span class="line"><span class="attribute">animation</span>: 时长 过渡方式 延迟 次数( infinite ) 方向( reverse | alternate | alternate-reverse ) 填充模式( none | forwards | backwards | both) 是否暂停( paused )  动画名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Topics From Chromium Blogs</title>
    <url>/hais-notebook/2022/06/16/ChromiumBlogs/</url>
    <content><![CDATA[<p>Read some articles in chromium blogs or relative wikis, and take these memos.</p>
<span id="more"></span>
<h1 id="architecture">Architecture</h1>
<h2 id="multi-process-architecture">Multi-process Architecture</h2>
<blockquote>
<p><a href="https://blog.chromium.org/2008/09/multi-process-architecture.html">Multi-process Architecture</a> - Thursday, September 11, 2008</p>
<p>Overview: One browser process + many renderer processes (roughly one for each tab) + plugin processes (one for each plugin)</p>
</blockquote>
<ol type="1">
<li>Three different types of processes: browser, renderers, and plug-ins.
<ol type="1">
<li><em>Browser</em>. There's only <strong>one</strong> browser process, which manages the tabs, windows, and "chrome" of the browser. This process also handles all interactions with the disk, network, user input, and display, but it makes no attempt to parse or render any content from the web.</li>
<li><em>Renderers</em>. The browser process creates <strong>many</strong> renderer processes, each responsible for rendering web pages. The renderer processes contain all the complex logic for handling HTML, JavaScript, CSS, images, and so on. We achieve this using the open source WebKit rendering engine, which is also used by Apple's Safari web browser. Each renderer process is run in a sandbox, which means it has almost <strong>no direct access to your disk, network, or display</strong>. <strong>All interactions with web apps, including user input events and screen painting, must go through the browser process.</strong> This lets the browser process monitor the renderers for suspicious activity, killing them if it suspects an exploit has occurred.</li>
<li><em>Plug-ins</em>. The browser process also creates <strong>one process for each type of plug-in that is in use</strong>, such as Flash, Quicktime, or Adobe Reader. These processes just contain the plug-ins themselves, along with some glue code to let them interact with the browser and renderers.</li>
</ol></li>
<li>Create browser process -&gt; Create one renderer process for each instance of a web site you visit.</li>
<li>You can think of this as using <strong>a different process for each tab in the browser</strong>, but <strong>allowing two tabs to share a process</strong> if they are related to each other and are showing the same site.</li>
</ol>
<h1 id="security">Security</h1>
<h1 id="javascript">JavaScript</h1>
<h2 id="jit-just-in-time-compilation">JIT: Just-in-time compilation</h2>
<blockquote>
<p>V8 uses <a href="https://v8.dev/blog/turbofan-jit">TurboFan JIT</a>.</p>
<p>Overview:</p>
<ol type="1">
<li>JIT = AOT + interpretation</li>
<li>Source code -&gt; bytecode -&gt; machine code</li>
<li>Generating better machine code increase initial delay</li>
</ol>
</blockquote>
<ol type="1">
<li>Introduction:
<ol type="1">
<li>JIT is a way of executing computer code that involves compilation <strong>during execution of a program</strong> (at <strong>run time</strong>) rather than before execution.</li>
<li>This may consist of <a href="https://en.wikipedia.org/wiki/Source_code"><em>source code</em></a> translation but is more commonly <a href="https://en.wikipedia.org/wiki/Bytecode"><em>bytecode</em></a> translation to <a href="https://en.wikipedia.org/wiki/Machine_code"><em>machine code</em></a>, which is then executed directly.</li>
<li>JIT compilation is a <strong>combination</strong> of the two traditional approaches to translation to machine code - <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation"><em>ahead-of-time compilation</em></a> (<em>AOT</em>), and <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)"><em>interpretation</em></a> - and combines some advantages and drawbacks of both.</li>
<li>Roughly, JIT compilation combines <strong>the speed of compiled code</strong> with <strong>the flexibility of interpretation</strong>, with <strong>the overhead of an interpreter</strong> and <strong>the additional overhead of compiling and <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linking</a></strong> (not just interpreting).</li>
</ol></li>
<li>Design:
<ol type="1">
<li>Source code is translated to an intermediate representation known as <em>bytecode</em>.</li>
<li><em>Bytecode</em> is not the machine code for any particular computer, and may be portable among computer architectures. The <em>bytecode</em> may then be <strong>interpreted</strong> by, or run on <strong>a virtual machine</strong>.</li>
<li><em>Traditional interpreted virtual machine</em> vs. <em>JIT</em>
<ol type="1">
<li><em>The traditional interpreted virtual machine</em>: simply <strong>interpret the bytecode</strong>, generally with much lower performance.</li>
<li><em>The JIT compiler</em>: reads the bytecodes in many sections (or in full, rarely) and <strong>compiles</strong> them dynamically <strong>into machine code</strong> so the program can run faster. This can be done per-file, per-function or even on any arbitrary code fragment; the code can be compiled when it is about to be executed (hence the name "just-in-time"), and then <strong>cached and reused</strong> later without needing to be recompiled.</li>
</ol></li>
<li>Because a JIT must render and execute a native binary image at runtime, true machine-code JITs necessitate platforms that allow for data to be executed at runtime, making using such JITs on a <a href="https://en.wikipedia.org/wiki/Harvard_architecture"><em>Harvard architecture</em></a>-based machine impossible; the same can be said for certain operating systems and virtual machines as well.</li>
</ol></li>
<li><em>Startup time delay</em> or <em>warm-up time</em>: the time taken to load and compile the bytecode. The more optimization JIT performs, the better the code it will generate, but the initial delay will also increase.</li>
</ol>
<h2 id="ignition-interpreter">Ignition Interpreter</h2>
<blockquote>
<p>See <a href="https://v8.dev/blog/ignition-interpreter">this blog</a>.</p>
</blockquote>
<ol type="1">
<li>Code is initially compiled by <em>baseline compiler</em>, which can generated non-optimized machine code quickly.</li>
<li>The compiled code is analyzed during runtime and optionally re-compiled dynamically with a more advanced optimizing compiler for peak performance.</li>
<li>JITed machine code can consume a significant amount of memory, so V8 uses Ignition to compile JavaScript functions to a concise bytecode. This bytecode is then executed by a interpreter.</li>
</ol>
<h2 id="garbage-collection">Garbage Collection</h2>
<blockquote>
<p>See <a href="https://v8.dev/blog/free-garbage-collection">this blog</a>.</p>
<p>Overview: Two ways to find garbage: tracing garbage collection &amp; reference counting</p>
</blockquote>
<p>There are several kinds of garbage collection:</p>
<ol type="1">
<li><em>Tracing garbage collection</em>
<ol type="1">
<li>Based on <em>reachability</em> (An object is <strong>reachable</strong> if it is <strong>referred to by a root</strong>, or is <strong>referred to by a reachable object</strong>; that is, if it can be reached from the roots by following references.)</li>
<li><em>Object</em>: A contiguous block of memory forming a single logical structure, objects are the units of allocation, deallocation, etc.</li>
<li>If an object is <strong>not reachable</strong>, there is no way the mutator could ever access it, and therefore it <strong>cannot be live</strong>.</li>
<li>In each collection cycle, some or all of the objects are <em>condemned</em> (those objects are candidates for recycling), and the graph is traced to find which of the condemned objects are reachable. Those that were not reachable may be reclaimed.</li>
<li>Typical scenes:
<ol type="1">
<li><em>Copying garbage collection</em>: relocate reachable objects, and then reclaim objects are left behind.</li>
<li><em>Generational garbage collection</em>: see next part.</li>
</ol></li>
</ol></li>
<li><em>Reference counting</em>
<ol type="1">
<li>Keeping a count in each object, of how many references there are to the object.</li>
<li>The reference count is incremented for each new reference, and is decremented if a reference is overwritten, or if the referring object is recycled.</li>
<li>Advantages:
<ol type="1">
<li>Can reclaim objects promptly.</li>
<li>Pauses are typically fairly short, but removing a single reference may cause the recycling of a large number of objects at once.</li>
<li>It can be implemented without any support from the language or compiler.</li>
</ol></li>
<li>Problems:
<ol type="1">
<li><strong>The reference count filed size is limited</strong>, system will break down if there are too many references.</li>
<li><strong>Performance penalty</strong>, since the count need to be maintained after every modification of pointers.</li>
<li><strong>Object will become larger</strong> to store the reference count.</li>
<li><strong>Cyclic data structure</strong> problems.</li>
</ol></li>
<li>Typical scenes:
<ol type="1">
<li><em>Distributed garbage collection</em>: The garbage collection in a system where objects might not reside in the same address space or even on the same machine. Because the costs of synchronization and communication between processes are particularly high for a <em>tracing garbage collector</em>, so other techniques, including <em>weighted reference counting</em>, are commonly used instead.</li>
</ol></li>
</ol></li>
</ol>
<h3 id="generational-garbage-collection">Generational Garbage Collection</h3>
<blockquote>
<p>See <a href="https://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection">this website</a>.</p>
<p>Overview: Based on "young is more likely to die than old"</p>
</blockquote>
<ol type="1">
<li>Generational garbage collection is <em>tracing garbage collection</em> that makes use of the <em>generational hypothesis</em>.</li>
<li><em>Generational hypothesis (also say Infant mortality)</em>: in most cases, young objects are much more likely to die than old objects.</li>
<li>Objects are gathered together <strong>in generations</strong>. New objects are allocated in the <em>youngest</em> or <em>nursery</em> generation, and promoted to (or become) <em>older</em> generations if they survive. <strong>Objects in older generations are condemned less frequently</strong>, saving CPU time.</li>
</ol>
<h3 id="v8s-garbage-collection-engine">V8's Garbage Collection Engine</h3>
<blockquote>
<p>V8 uses a generational garbage collector. See <a href="https://v8.dev/blog/trash-talk">this article</a>.</p>
<p>Overview:</p>
<ol type="1">
<li>Split into young (nursery and intermediate) and old.</li>
<li>Major GC collects garbage in the entire heap, including marking, sweeping and copaction.</li>
<li>Minor GC is responsible for the young generation, using semi-space allocation strategy.</li>
<li>Orinoco is a project try to improve GC performance.</li>
</ol>
</blockquote>
<h4 id="generational-layout">Generational Layout</h4>
<p>Split the JavaScript heap into:</p>
<ol type="1">
<li><strong>A small young generation</strong> for newly allocated objects (split further into <em>nursery</em> and <em>intermediate</em> sub-generations).</li>
<li><strong>A large old generation</strong> for long living objects.</li>
</ol>
<p>Objects are first allocated into the <em>nursery</em>. If they survive the next GC, they remain in the young generation but are considered <em>intermediate</em>. If they survive yet another GC, they are moved into the old generation.</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-GC-1.svg" alt="Generational layout of GC in V8" /><figcaption aria-hidden="true">Generational layout of GC in V8</figcaption>
</figure>
<h4 id="major-gc-full-mark-compact">Major GC (Full Mark-Compact)</h4>
<p>The Major GC collects garbage from the entire heap.</p>
<ol type="1">
<li><em>Marking</em>: Marking reachable objects from the root.</li>
<li><em>Sweeping</em>: Add the gaps in memory left by dead objects into a <em>free-list</em>. In the future when we want to allocate memory, we just look at the free-list and find an appropriately sized chunk of memory.</li>
<li><em>Compaction</em>: if needed, evacuate/compact some pages, to make use of the small and scattered gaps within the memory left behind by dead objects.</li>
</ol>
<h4 id="minor-gc-scavenger">Minor GC (Scavenger)</h4>
<p>The Minor GC (Scavenger) collects garbage in the young generation.</p>
<ol type="1">
<li>It uses a <em>semi-space allocation</em> strategy, where <em>nursery</em> object are initially allocated in the young generation’s active semi-space.</li>
<li>Once that semi-space becomes full, a <em>scavenge</em> operation (also use marking to check reachability) will move live objects to other semi-space, and become <em>intermediate</em>. If a object is already <em>intermediate</em>, it will be promoted to the old generation.</li>
<li>The new semi-spaces becomes active, and all the remaining objects in old semi-space are discarded.</li>
</ol>
<p>Unlike Major GC, in scavenging we actually do these three steps - marking, evacuating, and pointer-updating - all interleaved, rather than in distinct phases.</p>
<h4 id="orinoco">Orinoco</h4>
<p>Orinoco is the codename of the GC project and try to obtain better performance.</p>
<ol type="1">
<li><strong>Parallel</strong>: <em>Main Thread</em> and <em>Helper Threads</em> do a roughly equal amount of work at the same time.</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-GC-2.svg" /></p>
<ol start="2" type="1">
<li><strong>Incremental</strong>: The main thread does a small amount of work intermittently.</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-GC-3.svg" /></p>
<ol start="3" type="1">
<li><strong>Concurrent</strong>: The main thread executes JavaScript constantly, and helper threads do GC work totally in the background.</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-GC-4.svg" /></p>
<h2 id="regexp">RegExp</h2>
<h3 id="lookbehind-assertions">Lookbehind assertions</h3>
<blockquote>
<p>See <a href="https://v8.dev/blog/regexp-lookbehind-assertions">this blog</a>.</p>
<p>Overview:</p>
<ol type="1">
<li>V8's lookbehind implementation supports patterns of arbitrary length (can use <code>*</code> <code>+</code>)</li>
<li>Some strange features because of the implementation</li>
</ol>
</blockquote>
<ol type="1">
<li>Two ways to implement lookbehind assertions:
<ol type="1">
<li>Perl: Requires fixed length, so cannot use <code>*</code> <code>+</code>. Because the regular expression engine can step back by that fixed length and match.</li>
<li>.NET framework: Can match patterns of arbitrary length. It simply matches the lookbehind pattern backwards (reading characters against the normal read direction).</li>
</ol></li>
<li>A capturing group with a <em>quantifier captures</em> the last match. Usually, that is the right-most match. But inside a lookbehind assertion, we match from right to left, therefore the left-most match is captured:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="title function_">h</span>(?=\w)/.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>);  <span class="comment">// [&#x27;h&#x27;]</span></span><br><span class="line"><span class="regexp">/h(?=(\w))/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>);  <span class="comment">// [&#x27;h&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"><span class="regexp">/h(?=(\w)&#123;2&#125;)/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>);  <span class="comment">// [&#x27;h&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"><span class="regexp">/h(?=(\w)+)/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>);  <span class="comment">// [&#x27;h&#x27;, &#x27;r&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;=(\w)&#123;2&#125;)r/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>); <span class="comment">// [&#x27;r&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"><span class="regexp">/(?&lt;=(\w)+)r/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>); <span class="comment">// [&#x27;r&#x27;, &#x27;h&#x27;]</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>A capturing group can be referenced via back reference after it has been captured. Usually, the back reference has to be to the right of the capture group. Otherwise, it would match the empty string, as nothing has been captured yet. However, inside a lookbehind assertion, the match direction is reversed:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=(o)d\<span class="number">1</span>)r/.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>); <span class="comment">// null</span></span><br><span class="line"><span class="regexp">/(?&lt;=\1d(o))r/</span>.<span class="title function_">exec</span>(<span class="string">&#x27;hodor&#x27;</span>); <span class="comment">// [&#x27;r&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="object-iteration">Object Iteration</h2>
<h3 id="ecma-specification">ECMA Specification</h3>
<blockquote>
<p>See <a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">this document</a>.</p>
</blockquote>
<ol type="1">
<li>JavaScript objects mostly behave like dictionaries, with <em>string</em> keys and <em>arbitrary objects</em> as values.</li>
<li>The specification treat <em>integer-indexed properties</em> and <em>other properties</em> differently during <em>iteration</em>. Other than that, the different properties behave mostly the same.</li>
</ol>
<h3 id="fast-properties-in-v8">Fast Properties In V8</h3>
<blockquote>
<p>See <a href="https://v8.dev/blog/fast-properties">this blog</a>.</p>
</blockquote>
<h4 id="named-properties-vs.-elements">Named Properties vs. Elements</h4>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-1.png" alt="A basic JavaScript object looks like in memory" /><figcaption aria-hidden="true">A basic JavaScript object looks like in memory</figcaption>
</figure>
<ol type="1">
<li>Elements and properties are stored in two separate data structures which makes adding and accessing properties or elements more efficient for different usage patterns.</li>
<li><em>Elements</em>:
<ol type="1">
<li>Most of time, V8 represents <em>elements</em> as <em>simple arrays</em> internally, since methods (like <code>pop</code> <code>slice</code> in <code>Array.prototype</code>) access properties in consecutive ranges.</li>
<li>But sometimes switch to a sparse <em>dictionary-based</em> representation to save memory.</li>
</ol></li>
<li><em>Named properties</em>:
<ol type="1">
<li>They are stored in a similar way in a separate <em>array</em>.</li>
<li>We cannot simply use the <em>key</em> to deduce their <em>position</em> within the properties array, we need some additional metadata - In V8, every JavaScript object has a <em>HiddenClass</em> associated.</li>
<li>The <em>HiddenClass</em> stores information about the <em>shape</em> of an object, a <em>mapping</em> from property names to indices into the properties, and so on.</li>
</ol></li>
</ol>
<h4 id="hiddenclasses-and-descriptorarrays">HiddenClasses and DescriptorArrays</h4>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-2.png" alt="Overview of HiddenClass in V8" /><figcaption aria-hidden="true">Overview of HiddenClass in V8</figcaption>
</figure>
<ol type="1">
<li><p>The first field of any object on V8 heap points to a HiddenClass.</p></li>
<li><p>The third bit field of HiddenClass stores the number of properties, and a pointer to the <em>descriptor array</em>.</p></li>
<li><p>The <em>descriptor array</em> contains information about <em>named properties</em>, like <em>the name itself</em> and <em>the position</em> where value is stored. (there is no entry of <em>indexed properties</em> in the <em>descriptor array</em>)</p></li>
<li><p>Objects with the same structure (e.g. the same named properties in the same order) share the same HiddenClass.</p></li>
</ol>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-3.png" alt="HiddenClass change when add new properties" /><figcaption aria-hidden="true">HiddenClass change when add new properties</figcaption>
</figure>
<ol start="5" type="1">
<li>V8 creates a <em>transition tree</em> that links the HiddenClasses together.</li>
</ol>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-4.png" alt="Transition tree" /><figcaption aria-hidden="true">Transition tree</figcaption>
</figure>
<ol start="6" type="1">
<li>If we create a <strong>new object</strong> that gets a different property added, in this case property <code>"d"</code>, V8 creates a <strong>separate branch</strong> for the new HiddenClasses.</li>
</ol>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-5.png" alt="Transition tree with branches" /><figcaption aria-hidden="true">Transition tree with branches</figcaption>
</figure>
<ol start="7" type="1">
<li>Adding <em>array-indexed properties</em> does <strong>not</strong> create new HiddenClasses.</li>
</ol>
<h4 id="the-three-different-kinds-of-named-properties">The three different kinds of named properties</h4>
<ol type="1">
<li>A simple object such as <code>&#123;a: 1, b: 2&#125;</code> can have various internal presentations in V8.</li>
<li>While JavaScript objects behave like simple <em>dictionaries</em> from outside, V8 tries to avoid dictionaries because they hamper certain optimizations such as <em>inline caches</em>.</li>
</ol>
<h5 id="in-object-properties">1. In-object Properties</h5>
<p>In-object properties stored directly on the object themselves. These are the fastest properties available in V8.</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-6.png" alt="In-object and fast properties" /><figcaption aria-hidden="true">In-object and fast properties</figcaption>
</figure>
<h5 id="fast-properties">2. Fast Properties</h5>
<ol type="1">
<li>Fast properties are stored in the <em>linear properties store</em>, and can simply accessed by index.</li>
<li>To get from the property name actual position in the properties store, we have to consult the <em>descriptor array</em> on <em>HiddenClass</em>.</li>
</ol>
<h5 id="slow-properties">3. Slow Properties</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-7.png" alt="Object with slow properties" /><figcaption aria-hidden="true">Object with slow properties</figcaption>
</figure>
<ol type="1">
<li>Many properties get added and deleted from an object. They are slow properties.</li>
<li>An object with slow properties has a self-contained dictionary as a properties store. <strong>All the properties meta information</strong> is no longer stored in the descriptor array on the HiddenClass but <strong>directly in the properties' dictionary</strong>.</li>
<li>Properties can be added and removed without updating the HiddenClass.</li>
<li><em>Inline caches</em> don't work with those dictionary properties.</li>
</ol>
<h4 id="elements-or-array-indexed-properties">Elements or array-indexed properties</h4>
<p>There are several types of elements.</p>
<h5 id="packed-or-holey-elements">Packed or Holey Elements</h5>
<p>To ways to get hole: delete an indexed element or just don't defined it (like <code>[1,,3]</code>).</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">1</span>]);          <span class="comment">// Prints &#x27;b&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o[<span class="number">1</span>];                <span class="comment">// Introduces a hole in the elements store.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">1</span>]);          <span class="comment">// Prints &#x27;undefined&#x27;; property 1 does not exist.</span></span><br><span class="line">o.<span class="property">__proto__</span> = &#123;<span class="number">1</span>: <span class="string">&#x27;B&#x27;</span>&#125;;     <span class="comment">// Define property 1 on the prototype.</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">0</span>]);          <span class="comment">// Prints &#x27;a&#x27;.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">1</span>]);          <span class="comment">// Prints &#x27;B&#x27;.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">2</span>]);          <span class="comment">// Prints &#x27;c&#x27;.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o[<span class="number">3</span>]);          <span class="comment">// Prints undefined</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-8.png" alt="Holey elements example" /><figcaption aria-hidden="true">Holey elements example</figcaption>
</figure>
<ol type="1">
<li>Given that element properties are self-contained (we don't store information about element on the HiddenClass), we need a special value (called <code>the_hole</code>) to mark properties that are not present.</li>
<li>This is crucial for the performance of Array functions. Because if we know that there are no holes (the elements store is packed), we can perform local operations without expensive lookups on the prototype chain.</li>
</ol>
<h5 id="fast-or-dictionary-elements">Fast or Dictionary Elements</h5>
<ol type="1">
<li>Fast elements are simple <em>VM-internal arrays</em> where the <em>property index</em> maps to the in <em>index in the elements store</em>.</li>
<li>The simple presentation is rather wasteful for very large <em>sparse/holey arrays</em>. V8 creates a <em>dictionary</em> where we store a <em>key-value-descriptor triplets</em>.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sparseArray = [];</span><br><span class="line">sparseArray[<span class="number">9999</span>] = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// Creates an array with dictionary elements.</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>V8 resorts to slow elements whenever you define an indexed properties with a custom descriptor.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="comment">// 0 is slow element</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(array, <span class="number">0</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;fixed&#x27;</span> <span class="attr">configurable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">0</span>]);      <span class="comment">// Prints &#x27;fixed&#x27;.</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&#x27;other value&#x27;</span>;   <span class="comment">// Cannot override index 0.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">0</span>]);      <span class="comment">// Still prints &#x27;fixed&#x27;.</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>Array functions perform considerably slower on objects with slow elements.</li>
</ol>
<h5 id="semi-and-double-elements">Semi and Double Elements</h5>
<ol type="1">
<li>If you only store integers in an Array, a common use-case, the GC does not have to look at the array, as integers are directly encoded as so called <em>small integers (Smis)</em> in place.</li>
<li>Unlike Smis, floating point numbers are usually represented as full objects occupying several words. However, V8 stores raw doubles for pure double arrays to avoid memory and performance overhead.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,   <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Smi Packed</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>,    , <span class="number">3</span>];  <span class="comment">// Smi Holey, a2[1] reads from the prototype</span></span><br><span class="line"><span class="keyword">const</span> b1 = [<span class="number">1.1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Double Packed</span></span><br><span class="line"><span class="keyword">const</span> b2 = [<span class="number">1.1</span>,  , <span class="number">3</span>];  <span class="comment">// Double Holey, b2[1] reads from the prototype</span></span><br></pre></td></tr></table></figure>
<h5 id="special-elements">Special Elements</h5>
<p>There are more types: TypedArrays, string wrappers, arguments objects.</p>
<h5 id="the-elementsaccessor">The ElementsAccessor</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Memo-ChromiumBlogs-OI-9.png" alt="What happens when call array methods" /><figcaption aria-hidden="true">What happens when call array methods</figcaption>
</figure>
]]></content>
      <categories>
        <category>Memo</category>
      </categories>
  </entry>
  <entry>
    <title>命令行基础</title>
    <url>/hais-notebook/2020/01/29/Command/</url>
    <content><![CDATA[<p>主要记录命令行的基本用法。</p>
<span id="more"></span>
<h1 id="文件的增删改查">文件的增删改查</h1>
<h2 id="查">查</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cd ~</code></td>
<td>~ 表示用户目录</td>
</tr>
<tr class="even">
<td><code>pwd</code></td>
<td>Print Work Directory，展示当前的绝对路径</td>
</tr>
<tr class="odd">
<td><code>ls</code></td>
<td>List，查看当前目录文件内容（默认不显示以 <code>.</code> 开头的文件）</td>
</tr>
<tr class="even">
<td><code>ls [file path]</code></td>
<td>查看文件路径内容</td>
</tr>
<tr class="odd">
<td><code>ls -l</code></td>
<td>查看更新时间</td>
</tr>
<tr class="even">
<td><code>cat</code></td>
<td>Concatenate，打印文件内容</td>
</tr>
<tr class="odd">
<td><code>head</code></td>
<td>展示前 10 行文件，或者 <code>-n [数字]</code></td>
</tr>
<tr class="even">
<td><code>tail</code></td>
<td>展示后 10 行文件</td>
</tr>
<tr class="odd">
<td><code>less</code></td>
<td>进入一个可滚动的界面，按上、下（或 J、K ）滚动，按 Q 退出</td>
</tr>
</tbody>
</table>
<h2 id="增">增</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>touch</code></td>
<td>创建空文件，可以同时创建多个文件；或者修改文件的更新时间</td>
</tr>
<tr class="even">
<td><code>echo</code></td>
<td>返回你 <code>echo</code> 的东西</td>
</tr>
<tr class="odd">
<td><code>echo [content] &gt; 4.txt</code></td>
<td>创建有内容的文件，会覆盖之前的内容</td>
</tr>
<tr class="even">
<td><code>echo [content] &gt;&gt; 4.txt</code></td>
<td>追加内容</td>
</tr>
<tr class="odd">
<td><code>echo -e "[content]\n" &gt;&gt; 4.txt</code></td>
<td>有换行的内容</td>
</tr>
<tr class="even">
<td><code>mkdir</code></td>
<td>创建目录，可以同时创建多个目录</td>
</tr>
<tr class="odd">
<td><code>mkdir -p a/b/c/d</code></td>
<td>创建多级目录</td>
</tr>
<tr class="even">
<td><code>cp [filename] [new filename]</code></td>
<td>复制文件</td>
</tr>
<tr class="odd">
<td><code>cp -r [dir] [new dir]</code></td>
<td>复制目录</td>
</tr>
</tbody>
</table>
<h2 id="删">删</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>rm</code></td>
<td>删除</td>
</tr>
<tr class="even">
<td><code>rm -r</code></td>
<td>删除目录</td>
</tr>
<tr class="odd">
<td><code>rm -rf</code></td>
<td>强制删除（不管里面有没有内容）</td>
</tr>
</tbody>
</table>
<h2 id="改">改</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>code</code></td>
<td>使用 VSCode 打开</td>
</tr>
<tr class="even">
<td><code>start</code></td>
<td>使用默认程序打开</td>
</tr>
<tr class="odd">
<td><code>mv [filename] .</code></td>
<td>移动到当前目录</td>
</tr>
<tr class="even">
<td><code>mv [filename] [new filename]</code></td>
<td>重命名文件</td>
</tr>
</tbody>
</table>
<h2 id="命令的组合">命令的组合</h2>
<ul>
<li>成功返回 <code>0</code>，失败返回 <code>error</code> 和非 <code>0</code> 值，通过 <code>echo $?</code> 查看</li>
<li><code>&amp;&amp;</code>：第一条命令后才会执行后面的</li>
<li><code>;</code>：不管前面是否成功都会执行后面的</li>
</ul>
<h2 id="把命令变成文件">把命令变成文件</h2>
<ul>
<li>MAC上需要执行：<code>chmod +x [filename]</code>，赋予执行权限</li>
<li>执行命令：<code>./[filename]</code> 或者 <code>sh [filename]</code></li>
<li>如果加入 <code>PATH</code>，就可以不用输入文件路径，也不用输入 <code>./</code>，输入文件名就能执行</li>
<li>命令行的本质就是可执行文件</li>
<li>windows 会优先去找 <code>.exe</code> 的文件</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>在线课程：计算机组成原理</title>
    <url>/hais-notebook/2021/07/11/Course-ComputationStructures/</url>
    <content><![CDATA[<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2017/index.htm">Computation Structures (6.004) From MIT OCW</a></p>
<span id="more"></span>
<h1 id="信息的基础-basic-of-information">信息的基础 Basic Of Information</h1>
<h2 id="何为信息-information">何为信息 Information</h2>
<blockquote>
<p>信息可以 <strong>消除不确定性</strong></p>
<p>Data communicated or received that <strong>resolves uncertainty</strong> about a particular fact or circumstances.</p>
</blockquote>
<p>比如，我们从 52 张扑克牌中选择一张，如果没有“信息”，那么就有 52 种可能性；但如果告诉你这是一张红桃，那么就只剩下 13 种可能性了——这就是信息。</p>
<h2 id="如何量化信息-quantifying-information">如何量化信息 Quantifying Information</h2>
<p>对于离散的随机变量 <span class="math inline">\(X\)</span></p>
<ul>
<li>有 <span class="math inline">\(N\)</span> 个可能的值：<span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, ..., <span class="math inline">\(x_n\)</span></li>
<li>分别对应可能性：<span class="math inline">\(p_1\)</span>, <span class="math inline">\(p_2\)</span>, ..., <span class="math inline">\(p_n\)</span></li>
</ul>
<p>那么 <span class="math inline">\(x_i\)</span> 携带的信息量（如果将该信息用 0/1 来进行编码，需要的位数）就是： <span class="math display">\[
I(x_i)=log_2(\frac 1{p_i})
\]</span> 其中 <span class="math inline">\(\frac 1{p_i}\)</span> 衡量的是 <span class="math inline">\(x_i\)</span> 的不确定度。 <span class="math display">\[
I(红桃)=log_2(\frac 1{\frac{13}{52}})=2 bits
\]</span> 对于 N 选 M 类型的问题，可以写作： <span class="math display">\[
I(x_i)=log_2(\frac 1{M\cdot(\frac 1N)})=log_2(\frac NM)bits
\]</span> 有时候会得到 <span class="math inline">\(I\)</span> 包含小数点，比如 5.17，这表明为了编码一条信息，我们需要 6 bits，但如果编码 100 条，我们可能不需要 600 bits，而是 520 bits。</p>
<blockquote>
<p>由上述公式易得，如果某条信息对应的可能性越小，那么他的信息量就越多，就需要越多的 bits 来进行编码。</p>
</blockquote>
<h2 id="信息熵-entropy">信息熵 Entropy</h2>
<blockquote>
<p>信息熵 <span class="math inline">\(H(X)\)</span> 是每条信息的信息量的平均数</p>
</blockquote>
<p><span class="math display">\[
H(x)=E(I(x))=\sum_{i=1}^N p_i \cdot log_2(\frac 1{p_i})
\]</span></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-1.png" /></p>
<p><span class="math inline">\(H(X)\)</span> 是我们对一段数据进行编码时，所需要的能完整表示其所携带的信息的最少 bits</p>
<h2 id="编码-encoding">编码 Encoding</h2>
<blockquote>
<p>编码是数据与二进制数之间的 <strong>清晰（unambiguous）</strong> 映射</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-2.png" /></p>
<p>一个二进制树：</p>
<ol type="1">
<li>所有的被编码的符号都位于该二进制树叶节点上</li>
<li>从根节点到该符号位于的叶节点的路径，即为编码</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-3.png" /></p>
<h3 id="定长编码-fixed-length-encoding">定长编码 Fixed-length Encoding</h3>
<ol type="1">
<li>所有选择的概率是相同的</li>
<li>在二进制树中，每个符号到根节点的长度是相同的</li>
<li>可以很方便地在一段信息的编码中找到指定的位置</li>
<li>通常会比较低效</li>
</ol>
<p><span class="math display">\[
H(x)=\sum_{i=1}^N \frac 1N \cdot log_2(\frac 1{\frac 1N})=log_2(N)
\]</span></p>
<p>例如：</p>
<ol type="1">
<li>4-bit 的十进制数的二进制编码：<span class="math inline">\(log_2(10)=3.322\)</span></li>
<li>7-bit 的 ASCII：<span class="math inline">\(log_2(94)=6.555\)</span></li>
</ol>
<h4 id="编码有符号的数字-encoding-signed-integers">编码有符号的数字 Encoding Signed Integers</h4>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-4.png" /></p>
<p>这个编码方式有两个问题：</p>
<ol type="1">
<li>出现了 +0 和 -0，这是无意义的</li>
<li>除了加法运算之外，需要额外实现一套减法系统</li>
</ol>
<h4 id="二进制补码-twos-complement-encoding">二进制补码 Two's Complement Encoding</h4>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-5.png" /></p>
<p>二进制补码就解决了上述两个问题。在二进制补码中，最高位 <strong>不是符号位</strong>，而是拥有一个 <strong>负的权重</strong>。</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-6.png" /></p>
<ul>
<li>通过二进制补码，我们可以额观察到， -1 和 1 相加为 0</li>
<li>同时我们可以将 B-A 变为 B+(-A)，并且通过上述计算找出了 -A 的表达形式，即 (-1-A) + 1；-1 用二进制表示全部为 1，因此 (-1-A) 其实就是 <strong>按位取反</strong>。</li>
</ul>
<h3 id="变长编码-variable-length-encoding">变长编码 Variable-length Encoding</h3>
<p>目标：将出现概率大的字符用尽可能短的编码来表示，将出现概率小的字符用长的编码来表示。</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-7.png" /></p>
<h4 id="霍夫曼算法-huffmans-algorithm">霍夫曼算法 Huffman's Algorithm</h4>
<ol type="1">
<li>自底向上地考虑，先构建一颗二进制子树，他们的叶节点是概率最小的两个符号</li>
<li>这棵子树的根节点的概率是这两个叶节点之和，然后在此基础上，使用概率第三小的符号添加新的子树</li>
<li>以此类推，直到所有的符号都用完</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-8.png" /></p>
<p>为了找到更有效的方法，我们可以进一步地考察组合的概率：</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-9.png" /></p>
<h2 id="错误校验-error-detection-and-correction">错误校验 Error Detection and Correction</h2>
<h3 id="汉明距离-hamming-distance">汉明距离 Hamming Distance</h3>
<blockquote>
<p>两个字符串对应位置不同的字符的个数。即将一个字符串变成另一个字符串所需要替换的字符个数</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-10.png" /></p>
<h3 id="单点错误-single-bit-error">单点错误 Single-bit Error</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-11.png" /></p>
<p>对于只有一位的编码，汉明距离是 1。发生单点错误后的，我们无法知道到底有没有发生错误，因此需要添加一个奇偶校验位（parity bit），提高他的最小汉明距离，这样就能检测出是否有单点错误了。</p>
<h3 id="多点错误-multi-bit-error">多点错误 Multi-bit Error</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-12.png" /></p>
<p>同样的，如果我们将汉明距离提升到 3，我们可以检测出两位的错误。为了检测出 <span class="math inline">\(E\)</span> 位的错误，我们需要将汉明距离提升至 <span class="math inline">\(E + 1\)</span></p>
<h3 id="错误校正-error-correction">错误校正 Error Correction</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-13.png" /></p>
<p>以单点错误为例，如果汉明距离为 2，我们无法校正这个错误，我们只知道他错了，但是如果我们将汉明距离提升至 3，我们就能纠正这个错误的位。</p>
<p>同理，为了校正 <span class="math inline">\(E\)</span> 位的错误，我们需要将汉明距离提升至 <span class="math inline">\(2E + 1\)</span></p>
<h1 id="数字的抽象-the-digital-abstraction">数字的抽象 The Digital Abstraction</h1>
<blockquote>
<p>可以用电磁现象来传输数据，比如电压、相位、电流、频率</p>
</blockquote>
<p>我们可以用每个点的电压来保存一张黑白相片的信息，比如 0V 表示黑色、1V 表示白色、0.37V 表示 37% 灰阶。但这样的方式会使得数据容易在原器件的处理过程中损耗，因此在处理时需要进行数字抽象，大于一定电压为 1、小于一定电压为 0。</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-14.png" /></p>
<p>并且，元件的输出需要比输入更加严格，以留出足够多的噪声余量。</p>
<h2 id="电压转换特性-voltage-transfer-characteristic">电压转换特性 Voltage Transfer Characteristic</h2>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-15.png" /></p>
<p>如图所示是一个缓冲器的 VTC，对于任意输入的比 <span class="math inline">\(V_{IL}\)</span> 小的值，需要得到一个比 <span class="math inline">\(V_{OL}\)</span> 小的值（因此大于 <span class="math inline">\(V_{OL}\)</span> 的值都是不允许的）；对于输入任意比 <span class="math inline">\(V_{IH}\)</span> 大的值，需要得到比 <span class="math inline">\(V_{OH}\)</span> 大的值（因此小于 <span class="math inline">\(V_{OH}\)</span> 的值都是不允许的），这样就得到了阴影部分的禁止区域。</p>
<p>注意：</p>
<ol type="1">
<li>在 <span class="math inline">\(V_{IL} &lt; V_{IN} &lt; V_{IH}\)</span> 的区间内，VTC 可以是任意形状的</li>
<li>中间的长方形一定是瘦长的，因为 <span class="math inline">\(V_{OH}-V_{OL}&gt;V_{IH}-V_{IL}\)</span>。因此 VTC 的斜率一定有某处是大于 1 的，并且整条 VTC 是非线性的</li>
</ol>
<h1 id="cmos">CMOS</h1>
<p>我们需要找到一种设备，他满足 VTC，并且足够小且能耗低，来帮助我们完成逻辑运算：金属-氧化物-半导体场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET）。</p>
<h2 id="n-channel-mosfet">N-Channel MOSFET</h2>
<h3 id="物理结构">物理结构</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-16.png" /></p>
<p>集成电路（Integrated Circuit, IC）建造在掺杂了硼的硅晶体薄片上（这种硼掺杂硅被称为 p 型半导体）。IC 包含一个贴着 p 型基底的电触点（bulk terminal），因此我们可以控制他的电压。</p>
<p>上面有一层绝缘的二氧化硅，基底与栅极（gate）之间的二氧化硅层非常薄，因此导电的门可以很容易地影响到下面的基底。</p>
<p>门是由导电材料构成的（比如金属、多晶硅等）。栅极、绝缘的二氧化硅层、p 型基底，这三者组成了一个电容器。早期的栅极是由金属构成的，因此 Metal-Oxide-Semiconductor (MOS) 实际上指的就是这个结构。</p>
<p>在栅极的两侧有给电子原子（比如磷）掺杂 p 型基底的长方体区域，这些区域在掺杂了磷原子后变成了 n 型半导体，并分别称为源级（source）和漏级（drain）。</p>
<p>MOSFET 就像一个可以通过电压控制的开关，当开关导通时，电流就会从漏级流向源级，电流的大小 <span class="math inline">\(I_{DS}\)</span> 由 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(W\)</span> 决定，通常我们说的 14nm 处理器，其实就是指的 <span class="math inline">\(L\)</span> 的长度为 14nm。</p>
<h3 id="电学特性">电学特性</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-17.png" /></p>
<p>通常我们将具有高电位的一级叫漏级，另一极叫源级。当 MOSFET 被制造出来的时候，他就有一个特定的阈值电压 <span class="math inline">\(V_{TH}\)</span>，他会告诉我们何时从非导通变成导通，对于 n-channel MOSFET，这个电压通常是 0.5V。</p>
<ol type="1">
<li><p>第一张图片展现的是非导通时的状态，这时候栅极和源级的电压小于阈值。</p></li>
<li><p>当 n 型半导体和 p 型半导体接触的时候，他们之间会有一个耗尽区（depletion region），这个区域将源级和漏级隔开。</p></li>
<li><p>当 <span class="math inline">\(V_{GS}\)</span> 逐渐升高，栅极上的正电荷越来越多，吸引了越来越多的基体上的电子。当超过阈值的时候，电场力将基底的电子从价电子带拉升到导带，新的自由电子向栅极移动，然后在薄薄的氧化物层聚集。</p></li>
<li><p>当氧化物层聚集了足够多的电子，p 型半导体变成 n 型半导体，并且在源级和漏级中间形成了一个 n 型半导体通道——这层也被称为反转层。于是漏级和源级就被导通了，他们之间的电压为 <span class="math inline">\(V_{DS}\)</span>。</p></li>
<li><p>当 <span class="math inline">\(V_{DS}\)</span> 大于 <span class="math inline">\(V_{GS}\)</span> 之后，漏级一侧也会吸引大量电子，通道内电场的形状将会发生改变，<span class="math inline">\(I_{DS}\)</span> 就不会再随着 <span class="math inline">\(V_{DS}\)</span> 上升了。</p></li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-18.png" /></p>
<p><span class="math inline">\(V_{GS}\)</span> 越大，栅极底部吸引的电子也就越多，反转层也就越厚，电流也就越大。</p>
<p>当 <span class="math inline">\(V_{DS}\)</span> 比 <span class="math inline">\(V_{GS}\)</span> 小时，MOSFET 就像遵循欧姆定律的电阻一样；而当 <span class="math inline">\(V_{DS}\)</span> 比 <span class="math inline">\(V_{GS}\)</span> 大时，通道在漏极截止，并且 <span class="math inline">\(I_{DS}\)</span> 也不会继续升高了。</p>
<h2 id="cmos-1">CMOS</h2>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-19.png" /></p>
<ul>
<li><p>为什么叫 n-channel MOSFT？因为导通时，反转层就像 n 型半导体一样。</p></li>
<li><p>控制 n-channel MOSFET 导通的电压（高电压，可以认为是数字 1），会使得 p-channel MOSFET 断开。</p></li>
<li><p>n-channel 和 p-channel MOSFT 相辅相成，就是我们所说的 complementary MOS (CMOS)。</p></li>
</ul>
<h3 id="上拉电路与下拉电路-pullup-and-pulldown-circuits">上拉电路与下拉电路 Pullup and Pulldown Circuits</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-20.png" /></p>
<ol type="1">
<li>在将信号节点连着 GND 的下拉电路（pulldown circuits）中，只使用 NFETs (n-channel MOSFETs)。当下拉电路导通时，信号节点为 0V，并标记为数字 0。</li>
<li>在上拉电路（pullup circuits）中，只使用 PFETs (p-channel MOSFETs)。</li>
</ol>
<p>如果我们用相反的 FETs 来构造上拉或下拉电路，信号水平会下降，也会丢失噪声容限。</p>
<h3 id="门电路">门电路</h3>
<h4 id="inveter">Inveter</h4>
<p>考察一个用一下拉电路（有一个 NFET、输出端连着 GND）和一上拉电路（有一个 PFET、输出端连着 <span class="math inline">\(V_{DD}\)</span> 组成的反转器：输入为 0 的时候，NFET 断开、PFET 导通，输出端与 <span class="math inline">\(V_{DD}\)</span> 连通；反之输入为 1 的时候，NFET 导通、PFET 断开，输出端接地。</p>
<p>如果输入电压 <span class="math inline">\(V_{IN}\)</span> 介于 0 和 1 之间，可能 PFET 和 NFET 都被导通了。此时输入电压微小的变化都可能导致输入出电压较大的变化</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-21.png" /></p>
<h4 id="nand">NAND</h4>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-22.png" /></p>
<h4 id="更多的门">更多的门</h4>
<h5 id="如何做出一个-cmos-逻辑电路">如何做出一个 CMOS 逻辑电路</h5>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-23.png" /></p>
<ol type="1">
<li>找到满足需求的 PFETs 组成的上拉电路</li>
<li>将 PFETs 换成 NFETs，串联改并联、并联改串联，画出一个下拉电路</li>
<li>将上拉电路和下拉电路组合起来，形成一个完全互补的 CMOS</li>
</ol>
<h5 id="方法的局限性">方法的局限性</h5>
<p>但是，由于之前的规定和 MOSFETs 的特性，当输入电流上升的时候（NFET 导通、接地，PFET 断开、断开与 <span class="math inline">\(V_{DD}\)</span> 的连接），输出的电流是在下降的。也就是说，我们不能用 CMOS 来做正向的逻辑判断（<span class="math inline">\(A \cdot B\)</span>），只能用来做反向逻辑判断（<span class="math inline">\(\overline A \cdot \overline B\)</span>）。</p>
<h2 id="时序规则-timing-specification">时序规则 Timing Specification</h2>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-24.png" /></p>
<p>R 是导线的纯电阻、C 是导线和 MOSFET 栅极的纯电容。</p>
<h3 id="传播延迟-propagation-delay">传播延迟 Propagation Delay</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-25.png" /></p>
<p>传播延迟（Propagation Delay, <span class="math inline">\(t_{PD}\)</span>）：从 <strong>有效输入</strong>（由 <span class="math inline">\(V_{IL}\)</span> 和 <span class="math inline">\(V_{IH}\)</span> 确定） 到 <strong>有效输出</strong>（由 <span class="math inline">\(V_{OL}\)</span> 和 <span class="math inline">\(V_{OH}\)</span> 确定）的时间上界。</p>
<p>元件的 <span class="math inline">\(t_{PD}\)</span> 在出厂时就确定了，我们可以通过每个元件的 <span class="math inline">\(t_{PD}\)</span> 计算出整个系统的 <span class="math inline">\(t_{PD}\)</span>。</p>
<p>有趣的是，当我们想减少某个 MOSFET 的传播延迟，可以尝试降低它的电阻，也就是增加它的宽度；但增加宽度的同时也会增加栅极的电容。</p>
<h3 id="污染延迟-contamination-delay">污染延迟 Contamination Delay</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-26.png" /></p>
<p>污染延迟（Contamination Delay, <span class="math inline">\(t_{CD}\)</span>）：从 <strong>无效输入</strong> 到 <strong>无效输出</strong> 的时间下界。制造商有时也会将污染延迟称为最小传播延迟（Minimun Propagatio Delay）</p>
<p>通常我们会忽略 <span class="math inline">\(t_{CD}\)</span>，并假设当输入变得无效之后，输出就立即变得无效。</p>
<h3 id="时序规则总结">时序规则总结</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-27.png" /></p>
<h3 id="简单的例子">简单的例子</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-28.png" /></p>
<h3 id="lenient-combinational-device">Lenient Combinational Device</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-29.png" /></p>
<p>Lenient Combination Device：当有 <strong>任意</strong> 足够确定输出的有效输入时，输出至少在 <span class="math inline">\(t_{PD}\)</span> 内是有效的。也就是说，输出不会受到某些输入变化的影响。</p>
<p>比如上图所示，对于一个 CMOS 与非门，只要当 A 为 1 时，不管 B 怎么变化，输出 Z 都一直是有效的 0。</p>
<p>大部分使用 CMOS 实现的逻辑门都是天然宽松（lenient）的。</p>
<h1 id="组合逻辑-combinational-logic">组合逻辑 Combinational Logic</h1>
<h2 id="描述组合逻辑">描述组合逻辑</h2>
<ol type="1">
<li><strong>真值表</strong>：一种简洁的描述组合系统功能的方法。真值表需要 <span class="math inline">\(2^N\)</span> 行来描述具有 N 个输入的系统</li>
<li><strong>布尔表达式</strong>：用 AND（乘法）、OR（加法）、取反（上划线）来表示布尔代数的表达式。可以与真值表相互转换，通常用 <em>乘积和</em>（sum-of-products）的方法将真值表转换为布尔表达式（即将每个输出为 1 的行加起来，如下图所示）</li>
</ol>
<h2 id="组合逻辑电路的设计">组合逻辑电路的设计</h2>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-31.png" /></p>
<h3 id="基本模块">基本模块</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-32.png" /></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-35.png" /></p>
<h3 id="直接综合所有模块">直接综合所有模块</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-33.png" /></p>
<p>看起来整个电路的 <span class="math inline">\(t_{PD}\)</span> 为三个门之和，但实际上并不是这样，因为多个输入的 ANDs 和 ORs 并没有那么简单</p>
<h3 id="多个输入的-ands-和-ors">多个输入的 ANDs 和 ORs</h3>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-34.png" /></p>
<p>通常来讲，对于 N 个输入的系统，链式结构的 <span class="math inline">\(t_{PD}\)</span> 是 <span class="math inline">\(N - 1\)</span> 个模块的和，而树状结构则是 <span class="math inline">\(log_2(N)\)</span> 。但如上图所示，假如 D 的输入比其几个输入晚来，链式结构的 <span class="math inline">\(t_{PD}\)</span> 则会更优。因此要具体情况具体分析。</p>
<h2 id="使用相反逻辑门">使用相反逻辑门</h2>
<p>由于 CMOS 实现的逻辑门是天然相反的，因此为了追求更好的性能，我们通常不用 AND 和 OR，而用 NAND 和 NOR。</p>
<ol type="1">
<li>NAND 和 NOR 可以用一个 CMOS 门（包含一个上拉电路和一个下拉电路）实现，但是 AND 和 OR 需要两个 CMOS 门（比如 NAND + INVERTER）。</li>
<li>NAND 和 NOR 不满足结合律，一次我们不能像之前一样构建多输入的 NANDs 和 NORs</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-35.png" /></p>
<h3 id="input-nand-是通用门">2-INPUT NAND 是通用门</h3>
<p>可以用只 NAND 或者 NOR 达到 AND、OR、INVERTER 的效果</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-36.png" /></p>
<h3 id="德摩根定律-demorgans-law">德摩根定律 Demorgan's Law</h3>
<p><span class="math display">\[
\overline A + \overline B = \overline {A \cdot B}
\\
\overline A \cdot \overline B = \overline {A+B}
\]</span></p>
<ol type="1">
<li>通过德摩根定律，可以实现 AND-NOR、NAND-OR 之间的转换，同时可以看到通过 CMOS 实现的相反逻辑门虽然面积更大，但拥有更低的 <span class="math inline">\(t_{PD}\)</span> 。</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-37.png" /></p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-39.jpg" alt="Course-ComputationStructure-39" /><figcaption aria-hidden="true">Course-ComputationStructure-39</figcaption>
</figure>
<blockquote>
<p>注意上图中 NAND-NAND 和 NOR-NOR 达成的效果是一样的，但是 NAND-NAND 中的 A 信号连接了两个门（4 个 MOSFET 电路），而 NOR-NOR 中的 A 信号只连接了 INVERTER 中的 2 个 MOSFET 电路，A 的电容负载更小。如果在 A 还需要连接更多的电路的情况下，这就显得很重要。</p>
</blockquote>
<ol start="2" type="1">
<li>通过德摩根定律，可以构造更多输入的 NAND 和 NOR</li>
</ol>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Course-ComputationStructure-38.png" alt="Course-ComputationStructure-38" /><figcaption aria-hidden="true">Course-ComputationStructure-38</figcaption>
</figure>
<h2 id="逻辑简化">逻辑简化</h2>
<h3 id="使用布尔代数进行逻辑简化">使用布尔代数进行逻辑简化</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<tbody>
<tr class="odd">
<td>或</td>
<td><span class="math inline">\(a+1=1 \\ a+0=a \\ a+a=a\)</span></td>
</tr>
<tr class="even">
<td>与</td>
<td><span class="math inline">\(a1=a \\ a0=0 \\ aa=a\)</span></td>
</tr>
<tr class="odd">
<td>交换律</td>
<td><span class="math inline">\(a+b=b+a \\ ab=ba\)</span></td>
</tr>
<tr class="even">
<td>结合律</td>
<td><span class="math inline">\((a+b)+c=a+(b+c) \\ (ab)c=a(bc)\)</span></td>
</tr>
<tr class="odd">
<td>分配律</td>
<td>$a(b+c)=ab+ac \ a+bc=(a+b)(a+c) $</td>
</tr>
<tr class="even">
<td>互补律</td>
<td><span class="math inline">\(a+\overline a=1 \\ a \overline a = 0\)</span></td>
</tr>
<tr class="odd">
<td>吸收律</td>
<td><span class="math inline">\(a+ab=a \\ a+\overline ab=a+b \\ a(a+b)=a \\ a(\overline a+b)=ab\)</span></td>
</tr>
<tr class="even">
<td>消除律</td>
<td><span class="math inline">\(ab+\overline a b = b \\ (a+b)(\overline a+b)=b\)</span></td>
</tr>
<tr class="odd">
<td>德摩根定律</td>
<td><span class="math inline">\(\overline a + \overline b = \overline{ab} \\ \overline a \overline b = \overline {a + b}\)</span></td>
</tr>
</tbody>
</table>
<p>例子： <span class="math display">\[
Y = \overline C \overline B A + CB \overline A + CBA + \overline CBA
\\
Y = \overline C \overline B A + CB + \overline C BA
\\
Y = \overline C A + CB
\]</span></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/hais-notebook/2021/03/20/DataBase/</url>
    <content><![CDATA[<p>什么是数据库、Node.js 连接数据库、SQL、范式、表设计、缓存字段、事务、存储引擎</p>
<span id="more"></span>
<h1 id="startup">Startup</h1>
<h2 id="什么是数据库">什么是数据库</h2>
<h3 id="数据库-database">数据库 Database</h3>
<blockquote>
<p>将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合称为数据库</p>
</blockquote>
<p>根据数据保存的格式不同，数据库一般被分为：</p>
<ul>
<li>关系型数据库</li>
<li>面向对象数据库、XML 数据库、键值存储系统（Redis）、层次数据库</li>
</ul>
<h3 id="数据库管理系统-dbms">数据库管理系统 DBMS</h3>
<blockquote>
<p>用来管理数据库的系统被称为数据库管理系统</p>
</blockquote>
<ul>
<li>比如 MySQL、PostgreSQL、SQL Server、DB2、Oracle</li>
</ul>
<p>DBMS 大概结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">数据库（硬盘/内存中存数据的地方）</span><br><span class="line">           ↑ 读/写</span><br><span class="line">Server 服务端（数据提供者）</span><br><span class="line"> 请求的数据 ↓ ↑ SQL语句 </span><br><span class="line">Client 客户端（数据使用者）</span><br></pre></td></tr></table></figure>
<p>我们使用的 MySQL 命令，就是一个客户端，MySQL 背后其实还有一个 Server 在 24 小时不间断运行着</p>
<h2 id="创建数据库">创建数据库</h2>
<p><a href="https://dev.mysql.com/downloads/mysql/">下载 MySQL</a>、<a href="https://dev.mysql.com/downloads/workbench">下载 MySQL WorkBench</a></p>
<p>使用 Docker <a href="/hais-notebook/2021/03/14/Docker/" title="Docker">Docker</a></p>
<h2 id="用-node.js-连接数据库">用 Node.js 连接数据库</h2>
<p>可以使用 <a href="https://github.com/mysqljs/mysql">mysqljs 库</a></p>
<p>可以使用 Sequelize.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.<span class="title function_">connect</span>()</span><br><span class="line"></span><br><span class="line">connection.<span class="title function_">query</span>(<span class="string">&quot;CREATE DATABASE IF NOT EXISTS harvey DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;&quot;</span>, <span class="keyword">function</span> (<span class="params">error, results, fields</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建数据库&quot;</span>, results)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.<span class="title function_">query</span>(<span class="string">&quot;USE harvey;&quot;</span>)</span><br><span class="line"></span><br><span class="line">connection.<span class="title function_">query</span>(<span class="string">`CREATE TABLE IF NOT EXISTS user(</span></span><br><span class="line"><span class="string">  name text,</span></span><br><span class="line"><span class="string">  age int</span></span><br><span class="line"><span class="string">);`</span>, <span class="keyword">function</span> (<span class="params">error, results, fields</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建表&quot;</span>, results)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>
<h1 id="references">References</h1>
<h2 id="常见的-sql-命令">常见的 SQL 命令</h2>
<h3 id="操作-databasetable">操作 database/table</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> harvey <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"><span class="comment">-- （MySQL 才需要使用 utf8mb4，并且在后面写 COLLATE）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line"><span class="keyword">DROP</span> database_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line">use lzblog;</span><br></pre></td></tr></table></figure>
<h3 id="操作记录">操作记录</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (name, age, `password`) <span class="keyword">VALUES</span> (<span class="string">&#x27;harvey&#x27;</span>, <span class="number">20</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;harvey&#x27;</span></span><br><span class="line"><span class="comment">-- 一般采用软删除</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> state<span class="operator">=</span><span class="string">&#x27;0&#x27;</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;harvey&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> state<span class="operator">&lt;&gt;</span><span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">24</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;harvey&#x27;</span></span><br><span class="line"><span class="comment">-- You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;harvey&#x27;</span> <span class="keyword">AND</span> `password`<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;harvey&#x27;</span> <span class="keyword">OR</span> `password`<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name LIKCE <span class="string">&#x27;%ve%&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>增：<code>INSERT INTO user (name, age) VALUES ('harvey', 20);</code></li>
<li>删：<code>DELETE FROM user WHERE name='harvey';</code></li>
<li>改：<code>UPDATE user SET age=24 WHERE name='harvey';</code></li>
<li>查：<code>SELECT * FROM user LIMIT 10;</code></li>
</ul>
<h4 id="用-join-将表连接起来">用 JOIN 将表连接起来</h4>
<p>有时候我们需要拆表、建立关联表等，这时候怎样将数据连起来查询呢？使用 JOIN。</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="JOIN" /><figcaption aria-hidden="true">JOIN</figcaption>
</figure>
<h5 id="inner-join-join">INNER JOIN (JOIN)</h5>
<p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，但是只显示 columnA、columnB 两列中有交集的部分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA<span class="operator">=</span>table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-inner.html">这里</a></p>
<h5 id="left-join-left-outer-join">LEFT JOIN (LEFT OUTER JOIN)</h5>
<p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证左边的表（table1，或者说 columnA）数据显示完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA<span class="operator">=</span>table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-left.html">这里</a></p>
<h5 id="right-join-right-outer-join">RIGHT JOIN (RIGHT OUTER JOIN)</h5>
<p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证右边的表（table2，或者说 columnB）数据显示完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA<span class="operator">=</span>table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-right.html">这里</a></p>
<h5 id="full-join-full-outer-join">FULL JOIN (FULL OUTER JOIN)</h5>
<blockquote>
<p>MySQL 中不支持 FULL OUTER JOIN</p>
</blockquote>
<p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证两边的数据都完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA<span class="operator">=</span>table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-full.html">这里</a></p>
<h2 id="mysql-的数据类型">MySQL 的数据类型</h2>
<p>五大类：数字、字符串、时间和日期、JSON（5.7.8 以上）、其他特殊类型</p>
<h3 id="数字类型">数字类型</h3>
<ul>
<li><p>bit、tinyint、bool/boolean、smallint、mediumint、int、bigint、decimal、float、double</p></li>
<li><p>serial：一个自增长的非负大整数（BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE）</p></li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/numeric-type-syntax.html">官方文档</a></p>
<h3 id="字符串类型">字符串类型</h3>
<ul>
<li>char(100)、varchar(100)、binary(1024)、varbinary(1024)、blob、text、enum('v1','v2')、set('v1','v2')</li>
</ul>
<p>varchar 长度可变，可以节省空间</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/string-type-syntax.html">官方文档</a></p>
<h3 id="时间和日期">时间和日期</h3>
<ul>
<li>date、time、datetime、timestamp、year</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-type-syntax.html">官方文档</a></p>
<p>一般传给前端需要转换为 ISO 8601 格式</p>
<h1 id="concepts">Concepts</h1>
<h2 id="关系型数据库的范式">关系型数据库的范式</h2>
<h3 id="第一范式-1nf">第一范式 1NF</h3>
<blockquote>
<p><strong>字段不可再分</strong>。</p>
</blockquote>
<p>比如我们需要存储体检者的双眼视力，那么左右眼视力应该分别存在两个字段中。</p>
<h3 id="第二范式-2nf">第二范式 2NF</h3>
<blockquote>
<p>在第一范式的基础上，要有 <strong>键</strong>（键可由多个字段组合）。 所有字段分别 <strong>完全依赖</strong> 于键。 如果键是多个字段的组合，则 <strong>不允许部分依赖</strong> 于该键。</p>
</blockquote>
<blockquote>
<p>依赖关系：给出键，就能确定唯一字段的值。</p>
</blockquote>
<p>比如给出“学号”，就能唯一确定“姓名”，反之则不行，则称“姓名”依赖于“学号”。</p>
<p>比如有一个表中有“学号”“姓名”“课名”“分数”，分数依赖于“学号+课名”，因此将“学号+课名”作为键，但字段“姓名”不依赖于“课名”却依赖于“学号”（“姓名”部分依赖于“学号+课名”）这就不满足第二范式。</p>
<h3 id="第三范式-3nf">第三范式 3NF</h3>
<blockquote>
<p>一个表里面不能有两层依赖。</p>
</blockquote>
<p>比如一个表中有“学号”“姓名”“系名”“系主任”，“姓名”依赖于“学号”，而“系主任”依赖于“系名”，这就不满足第三范式。</p>
<h3 id="bc范式">BC范式</h3>
<blockquote>
<p>键中的属性也不存在间接依赖。</p>
</blockquote>
<h2 id="数据库设计经验">数据库设计经验</h2>
<blockquote>
<p>高内聚、低耦合。</p>
</blockquote>
<h3 id="高内聚">高内聚</h3>
<p>把相关的字段放到一起，不相关的字段分开建表。</p>
<p>如果两个字段能单独建表，那就单独建表。</p>
<h3 id="低耦合">低耦合</h3>
<p>如果两个表中有弱关系，采取低耦合</p>
<h4 id="一对一">一对一</h4>
<p>假设一个学生只能加入一个班级，一个班级里面只能有一个学生。</p>
<ul>
<li><p>可以把班级放在学生表里面： 学生表：学生 id、学生姓名、班级 id 班级表：班级 id、班级名称</p></li>
<li><p>也可以单独建立关联表： 学生表：学生 id、学生姓名 关联表：学生 id、班级 id 班级表：班级 id、班级名称</p></li>
</ul>
<h4 id="一对多">一对多</h4>
<p>假设一个作者可以写多本数。</p>
<p>若 DBMS 支持数组，可以存两个 id 到一个字段：作者 id、姓名、书（书的 id 数组）</p>
<p>但一般推荐单独建立关系表：</p>
<p>作者表：id、姓名 关联表：作者 id、书 id 书表：id、书名</p>
<h4 id="多对多">多对多</h4>
<p>假设一个学生可以加入多个班级，一个班级也可以有多个学生。</p>
<p>仍然推荐建立关联表：</p>
<p>学生表：学生 id、学生姓名 关联表：学生 id、班级 id、有效期 班级表：班级 id、班级名称</p>
<h4 id="什么时候建立关联表">什么时候建立关联表</h4>
<p>当关联自身存在属性时，比如上表的有效期。或者管理多对多这种比较复杂的关系的时候也推荐建立关联表。</p>
<h1 id="tricks">Tricks</h1>
<h2 id="缓存字段">缓存字段</h2>
<p>一个例子：一个 blog 包含多个 comments，如何获取博客的评论数？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> comments <span class="keyword">WHERE</span> blog_id<span class="operator">=</span><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>这样会比较慢，可以在 blog 表上加一个 comment_count 字段，每次添加 comment 就 +1，删除就 -1</p>
<h2 id="事务-transaction">事务 Transaction</h2>
<p>在上述例子的解决办法中有个问题，用户的评论操作产生了两件事：1. comments 表新增记录；2. blog 表的 comment_count 字段 +1。</p>
<p>这样不能保证两边的数据同步，因为有可能其中一步失败了，这就需要用到事务。如果其中有一条语句失败了，则全部不执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">语句<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>可以看<a href="https://www.runoob.com/mysql/mysql-transaction.html">这个教程</a></p>
<h2 id="mysql-存储引擎">MySQL 存储引擎</h2>
<p>可以通过 <code>show engines</code> 查看 MySQL 支持的存储引擎。</p>
<ul>
<li>InnoDB，默认，一般认为是事务性数据库的首选</li>
<li>MyISAM，拥有较高的插入、查询速度，但不支持事务</li>
<li>Memory，内存中快速访问数据</li>
<li>Archive，只支持 insert 和 select</li>
</ul>
<h2 id="索引">索引</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name(length))</span><br></pre></td></tr></table></figure>
<p>可以看<a href="https://www.runoob.com/sql/sql-create-index.html">这个教程</a></p>
<p>索引可以提高查询数据的效率，但更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。</p>
<p>因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/hais-notebook/2021/03/14/Docker/</url>
    <content><![CDATA[<p>数据库的基本知识以及用 Docker 来安装数据库。</p>
<span id="more"></span>
<h1 id="用-docker-来安装数据库">用 Docker 来安装数据库</h1>
<h2 id="安装-docker">安装 Docker</h2>
<ul>
<li>进入 <a href="https://hub.docker.com/">Docker Hub 官方网站</a> 注册并下载</li>
<li>确保 <code>docker --version</code> 返回版本号</li>
<li>在 Docker Engine 中设置国内镜像，<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html">可以点这里查看教程</a> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="docker-安装-mysql">Docker 安装 MySQL</h2>
<ul>
<li>进入 Docker 上面 <a href="https://hub.docker.com/_/mysql">MySQL 的主页</a></li>
<li>运行命令创建容器： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="comment"># -d 表示守护进程形式，不会随意关掉</span></span><br><span class="line"><span class="comment"># -p 用来设置端口映射 本机端口号:虚拟机端口号</span></span><br><span class="line">docker run --name mysql-demo1 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:latest</span><br></pre></td></tr></table></figure></li>
</ul>
<p>常见的 docker 命令：</p>
<ul>
<li><code>docker run</code> 启动新容器</li>
<li><code>docker ps -a</code> 查看所有的容器（Containers）</li>
<li><code>docker kill &lt;id|name&gt;</code> 关闭对应的容器</li>
<li><code>docker restart &lt;id|name&gt;</code> 重启关闭的容器</li>
<li><code>docker rm &lt;id|name&gt;</code> 删除对应的容器</li>
<li><code>docker container prune</code> 删除无用的容器，以节省空间</li>
</ul>
<p>注意：用 docker 运行的容器，默认不会持久化，容器被删掉，数据也就没了</p>
<h2 id="docker-连接-mysql">Docker 连接 MySQL</h2>
<ol type="1">
<li>进入 Docker 容器，相当于一个 Linux 虚拟机： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-demo1 bash</span><br></pre></td></tr></table></figure></li>
<li>使用 MySQL 命令进入数据库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -u root：以 ROOT 用户进入</span></span><br><span class="line"><span class="comment"># -p 直接回车，然后输入密码</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li>
<li>使用 SQL 语句操作 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看有哪些数据库</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"># 进入其中一个数据库</span><br><span class="line">use <span class="operator">&lt;</span>数据库名称<span class="operator">&gt;</span>;</span><br><span class="line"># 看有哪些表</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"># 查看表内容</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名称<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Git &amp; GitHub</title>
    <url>/hais-notebook/2020/01/29/Git/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="git-本地仓库">Git 本地仓库</h1>
<h2 id="六行配置">六行配置</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name [username] </span><br><span class="line">git config --global user.email [useremail@example.com]</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
<h2 id="命令">命令</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git init</code></td>
<td>创建 <code>.git</code> 目录，容纳代码快照</td>
</tr>
<tr class="even">
<td><code>git add</code></td>
<td>准备将文件提交进 git 目录（本地仓库），路径可以是绝对路径、相对路径、<code>.</code>（当前目录）和 <code>*</code></td>
</tr>
<tr class="odd">
<td><code>git status</code></td>
<td>查看目前的状态</td>
</tr>
<tr class="even">
<td><code>git commit</code></td>
<td>提交（实际上是复制到了.git目录）</td>
</tr>
<tr class="odd">
<td><code>git commit -m "version1"</code></td>
<td>查看更新时间</td>
</tr>
<tr class="even">
<td><code>git commit -v（--verbose）</code></td>
<td>推荐，提交理由写得更详细</td>
</tr>
<tr class="odd">
<td><code>git reset --hard xxxxxx（提交号的前六位）</code></td>
<td>这个操作会使没有 commit 过的变动消失</td>
</tr>
<tr class="even">
<td><code>git log</code></td>
<td>查看历史记录</td>
</tr>
<tr class="odd">
<td><code>git reflog</code></td>
<td>查看包括 reset 的历史记录</td>
</tr>
<tr class="even">
<td><code>git branch xxx</code></td>
<td>基于当前的commit创建一份新的分支</td>
</tr>
<tr class="odd">
<td><code>git branch</code></td>
<td>查看所有分支和当前分支</td>
</tr>
<tr class="even">
<td><code>git branch -d xxx</code></td>
<td>删除分支</td>
</tr>
<tr class="odd">
<td><code>git checkout xxx</code></td>
<td>切换分支，当前未提交的文件如果与另一个分支不冲突，切换分支的操作就不会产生影响，如果冲突，可以用git stash或合并冲突</td>
</tr>
<tr class="even">
<td><code>git merge xxx</code></td>
<td>合并分支，先到达想要保留的分支再使用</td>
</tr>
<tr class="odd">
<td><code>git rm --chached xxx</code></td>
<td>将已经被 add 的文件从缓存中删除</td>
</tr>
</tbody>
</table>
<p><code>.gitignore</code> 文件中可以输路径来忽略不想提交的文件，比如 <code>node_modules</code> <code>DS_Store</code> <code>.idea</code> <code>.vscode</code></p>
<h1 id="git-远程仓库">Git 远程仓库</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个私钥和公钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C [useremail@example.com]</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传一个本地仓库</span></span><br><span class="line">git remote add origin [git@github.com:Hyuain/git-demo-1.git]</span><br><span class="line">git push -u origin master <span class="comment"># 一个新的分支需要写 -u 和后面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git：创建一个新目录，与 xxx 同名</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git yyy：创建一个新目录，命名为 yyy</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git .：不会新建目录，使用当前目录容纳代码和 .git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="comment"># git stash：把文件藏起来</span></span><br><span class="line"><span class="comment"># git stash pop：再把文件取出来</span></span><br></pre></td></tr></table></figure>
<h2 id="高级操作">高级操作</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ga=&quot;git add&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias gc=&quot;git commit -v&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias gl=&quot;git pull&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias gp=&quot;git push&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias gco=&quot;git checkout&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias gst=&quot;git status -sb&quot;&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">code ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后加上</span></span><br><span class="line"><span class="built_in">alias</span> glog=<span class="string">&quot;git log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit -- | less&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="踩坑记录">踩坑记录</h1>
<h2 id="git-log-中文乱码">git log 中文乱码</h2>
<p>输入以下命令即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
<h2 id="git-push-clone-报错">git push / clone 报错</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<h3 id="方法-1">方法 1</h3>
<p>防火墙添加 22 端口入站策略配置为允许，有时候不能解决问题。</p>
<h3 id="方法-2">方法 2</h3>
<ol type="1">
<li>在 <code>~/.ssh</code> 存放密钥（<code>id_rsa</code> 和 <code>id_rsa.pub</code>）的文件夹，新建 <code>config</code>，内容如下：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User XXX@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>刷新 <code>config</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;XXX&quot;</span></span><br><span class="line">git config --global user.email XXX@xx.com</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>有时候还是不能解决问题</p>
<h3 id="方法-3">方法 3</h3>
<ol type="1">
<li>修改 hosts 文件，也可以进入 <a href="https://www.ipaddress.com/">IPAddress</a> 查询这域名的 IP 地址。</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>刷新 DNS 缓存</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></table></figure>
<h1 id="github-加速">GitHub 加速</h1>
<h2 id="推荐---通过-ssh-时">推荐 - 通过 <code>SSH</code> 时</h2>
<p><code>SSH</code> 的clone方式也是大家使用的最多的方式，但 <code>SSH</code> 一般情况是不走 <code>http</code>、<code>https</code> 的代理的，在终端执行 <code>export https_proxy=xxx</code>，甚至将代理软件设置为全局代理也无法令 <code>SSH</code> 通过代理。这里介绍如何使<code>SSH clone</code>时走代理： 把下面这段写进 <code>~/.ssh/config</code> 文件（因为用到私玥认证所以带了 <code>IdentityFile</code> 选项）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux &amp; WSL 配置</span></span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand /usr/bin/nc -x 127.0.0.1:7890 %h %p</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GitBash 的配置</span></span><br><span class="line"> Host github.com</span><br><span class="line">     User git</span><br><span class="line">     ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br><span class="line">     IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>这里 <code>127.0.0.1:7890</code> 是一个 <code>http</code> 代理，这样便能令 <code>SSH</code> clone GitHub 时通过代理，达到加速的目的。</p>
<p>这种设置方法依赖Linux命令<a href="https://linux.die.net/man/1/nc"><code>nc</code></a>和 <a href="https://linux.die.net/man/5/ssh_config"><code>ssh config</code></a> <code>ProxyCommand</code>。</p>
<blockquote>
<ul>
<li>使用时可能会有的报错：<code>Bad owner or permissions on /Users/username/.ssh/config</code>，解决方法参考如下：</li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   https://github.com/ddollar/heroku-accounts/issues/15
&gt;
&gt;   https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey</code></pre>
<h2 id="通过-https-时">通过 <code>HTTPS</code> 时</h2>
<p>通过 <code>HTTPS</code> 形式的 clone 通过代理加速很简单，和普通的网页访问的加速并没有不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HTTPS_PROXY=socks5://127.0.0.1:1080</span><br><span class="line">git clone https://github.com/lightjiao/lightjiao.github.io.git</span><br></pre></td></tr></table></figure>
<p>另外，<code>Git</code> 本身有一个 <code>http.proxy/https.proxy</code> 的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>但 <code>HTTPS</code> clone的方式本身有一个缺点，每次与远端repo通讯时候都会要求填写用<code>Github</code>户名和密码，使用比较繁琐</p>
<h2 id="a-little-more-on-git-protocol">A Little More on Git Protocol</h2>
<p>By saying "Git Protocol", I mean a Git Server Protocal called "The Git Protocol". Its URI likes <code>git://server/project.git</code>. Note it starts with a <code>git://</code>, not <code>ssh://</code> or <code>http://</code> or something else.</p>
<p>It's not commonly used, so you can skip this. I write this mainly for completeness of Git proxy settings.</p>
<p>Git a has configration <code>core.gitProxy</code> dedicated for this protocol, its man reads:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core.gitProxy</span><br><span class="line"></span><br><span class="line">A &quot;proxy command&quot; to execute (as command host port) instead of establishing direct connection to the </span><br><span class="line">remote server when using the Git protocol for fetching. If the variable value is in the </span><br><span class="line">&quot;COMMAND for DOMAIN&quot; format, the command is applied only on hostnames ending with the specified </span><br><span class="line">domain string. This variable may be set multiple times and is matched in the given order; the first </span><br><span class="line">match wins.</span><br><span class="line"></span><br><span class="line">Can be overridden by the GIT_PROXY_COMMAND environment variable (which always applies universally, </span><br><span class="line">without the special &quot;for&quot; handling).</span><br></pre></td></tr></table></figure>
<p>You can set it by <code>git config</code>.</p>
<p>参考来源：</p>
<ul>
<li>https://www.zhihu.com/question/27159393/answer/145122287</li>
<li>https://gist.github.com/coin8086/7228b177221f6db913933021ac33bb92</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/hais-notebook/2020/02/02/HTML/</url>
    <content><![CDATA[<p>WWW、HTML，和一些常见重点的 HTML 标签。</p>
<span id="more"></span>
<h1 id="word-wide-web">Word Wide Web</h1>
<ul>
<li>互联网，基于IP之间通信，但是无法输入地址得到一个网页</li>
<li>WWW = URL + HTTP + HTML（李爵士发明的，基于互联网实现的，输入地址得到一个网页的网络）</li>
</ul>
<h1 id="html-历史">HTML 历史</h1>
<p>诞生于李爵士的一篇文章，最开始只有 18 个元素，这些元素如今还有 11 个健在，现在最新版的HTML大概有 110 个标签</p>
<h2 id="html-5">HTML 5</h2>
<ul>
<li>狭义HTML 5：最新版本 HTML 语言，多了 32 个新标签</li>
<li>广义HTML 5：包括 CSS3 等朋友们</li>
</ul>
<h3 id="html-5-技术集合">HTML 5 技术集合</h3>
<ul>
<li>新标签、新属性</li>
<li>新的通信技术：WebSockets、WebRTC</li>
<li>离线存储技术：LocalStorage、断网检测</li>
<li>多媒体技术：视频、音频</li>
<li>图像技术：Canvas、SVG、WebGL</li>
<li>Web增强技术：History API、全屏</li>
<li>设备相关技术：摄像头、触摸屏</li>
<li>新的样式技术：CSS3新的 Flex、Grid 的布局方式</li>
</ul>
<h1 id="html-起手式">HTML 起手式</h1>
<p>用 <code>Emmet</code> 所提供的速写法可以很快地写出你在写 <code>HTML</code> 所需要写的一个骨架。 你只需要在安装了插件的编辑器（某些编辑器默认具有此功能）中输入 <code>!</code> 再敲击 <code>Tab</code>，便可以很方便地输入以下内容。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 表示文档类型是 HTML 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> <span class="comment">&lt;!-- html 标签，可以在这里设置语言，比如 lang=&quot;zh-CN&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="comment">&lt;!-- 这里的东西不会显示到页面上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 文件的字符编码 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置视口大小为设备宽度（以兼容手机），并设置初始缩放为 1.0 并禁用缩放 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span> <span class="comment">&lt;!-- 让 IE 浏览器使用最新的内核 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="常用标签">常用标签</h1>
<ul>
<li>表示书/文章的层级
<ul>
<li>标题 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code></li>
<li>章节 <code>&lt;section&gt;</code></li>
<li>文章 <code>&lt;article&gt;</code></li>
<li>段落 <code>&lt;p&gt;</code></li>
<li>头部 <code>&lt;header&gt;</code></li>
<li>脚部 <code>&lt;footer&gt;</code></li>
<li>主要内容 <code>&lt;main&gt;</code></li>
<li>旁支内容 <code>&lt;aside&gt;</code></li>
<li>划分 <code>&lt;div&gt;</code></li>
</ul></li>
<li>内容标签
<ul>
<li>有序列表 <code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code></li>
<li>无序列表 <code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code></li>
<li>描述 <code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code> + <code>&lt;dd&gt;</code>，其中 <code>&lt;dt&gt;</code> 表示描述词，<code>&lt;dd&gt;</code> 表示描述的内容（ <code>Emmet</code> 速写: <code>dl+</code>）</li>
<li>保留空格的段落 <code>&lt;pre&gt;</code></li>
<li>分割线 <code>&lt;hr&gt;</code></li>
<li>换行 <code>&lt;br&gt;</code></li>
<li>定位符、超链接 <code>&lt;a&gt;</code></li>
<li>语气的强调 <code>&lt;em&gt;</code></li>
<li>本质的强调 <code>&lt;strong&gt;</code></li>
<li>代码 <code>&lt;code&gt;</code>，默认是内联元素，可以用 <code>&lt;pre&gt;</code> 包住 <code>&lt;code&gt;</code></li>
<li>引用 <code>&lt;quote&gt;</code></li>
<li>块级引用 <code>&lt;blockquote&gt;</code></li>
</ul></li>
<li>全局属性
<ul>
<li><code>class</code> 类</li>
<li><code>contenteditable</code> 用户可以直接编辑页面上的东西</li>
<li><code>hidden</code> 隐藏</li>
<li><code>id</code> 标记</li>
<li><code>style</code> 样式</li>
<li><code>tabindex</code> 控制 <code>Tab键</code> 激活元素的顺序，<code>tabindex=0</code> 是最后一个，<code>tabindex=-1</code> 代表永远不会访问</li>
<li><code>title</code> 鼠标悬浮显示的内容</li>
</ul></li>
</ul>
<div class="note warning"><p><strong>为什么会有默认样式？</strong> 因为 HTML 被发明的时候，还没有CSS <strong>怎么看默认样式？</strong> 开发者工具 -&gt; Elments -&gt; Styles -&gt; user agent stylesheet <strong>CSS Reset?</strong> <a href="https://dev.to/hankchizljaw/a-modern-css-reset-6p3">Andy Bell</a> <a href="https://meyerweb.com/eric/tools/css/reset/">Meyerweb</a> <a href="https://gist.github.com/FrankFang/df5e57a0799823ed89a960a642b3a1e2">Frank Fang</a></p>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http-server . -c-1 <span class="comment"># -c-1 表示不要缓存</span></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">parcel index.html</span><br></pre></td></tr></table></figure>
<h1 id="a-标签"><code>&lt;a&gt;</code> 标签</h1>
<h2 id="href-属性"><code>href</code> 属性</h2>
<ul>
<li>网址
<ul>
<li><code>http://google.com</code></li>
<li><code>https://google.com</code></li>
<li><code>//google.com</code> 无协议网址</li>
</ul></li>
<li>路径
<ul>
<li><code>/a/b/c</code> 绝对路径，但是是基于 <strong>HTTP 服务</strong> 开启的根目录，不是整个计算机的根目录</li>
<li><code>a/b/c</code> 相对路径，基于当前路径的目录</li>
<li><code>index.html</code> 当前目录的文件</li>
<li><code>./index.html</code> 当前目录的文件</li>
</ul></li>
<li><code>#id</code></li>
<li>伪协议
<ul>
<li><code>javascript:alert(1);</code>
<ul>
<li><code>javasrcript:;</code> 可以写一个什么都不做的a标签</li>
</ul></li>
<li><code>mailto:xxx@xxx.com</code> 会呼出邮件客户端</li>
<li><code>tel:1300000000</code> 会呼出拨号界面</li>
</ul></li>
</ul>
<h2 id="target-属性"><code>target</code> 属性</h2>
<ul>
<li>内置名字
<ul>
<li><code>_blank</code> 新标签</li>
<li><code>_top</code> 在最顶层打开（比如 <code>iframe</code> 的最外层页面）</li>
<li><code>_parent</code> 在父级窗口打开，没有 <code>_top</code> 那么高层</li>
<li><code>_self</code> 在当前页面打开（比如 <code>iframe</code> 的当前层）</li>
</ul></li>
<li>其他自定义的新窗口的名字（<code>window.name</code>）或者 <code>iframe</code> 的名字</li>
</ul>
<p>使用 rel=noopener 不打开新标签</p>
<h2 id="download-属性"><code>download</code> 属性</h2>
<p>下载而不是查看网页，但是大部分不支持</p>
<h1 id="iframe-标签"><code>&lt;iframe&gt;</code> 标签</h1>
<p>内嵌窗口，现在大都不用了</p>
<h1 id="table-标签"><code>&lt;table&gt;</code> 标签</h1>
<div class="note warning"><p>里面必须写<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>，否则浏览器也会自己加上，并且显示的顺序与实际写的这三个顺序无关，浏览器一定是按照<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>的顺序显示</p>
</div>
<p>相关的样式有：</p>
<ul>
<li><code>table-layout</code>
<ul>
<li><code>auto</code> 按照内容的多少来分配宽度权重</li>
<li><code>fixed</code> 等宽</li>
</ul></li>
<li><code>border-collapse: collapse</code> 表示两个单元格的边线合并</li>
<li><code>border-spacing</code> 两个单元格中间的空隙</li>
</ul>
<h1 id="img-标签"><code>&lt;img&gt;</code> 标签</h1>
<blockquote>
<p>发出一个GET请求，展示一张图片</p>
</blockquote>
<h2 id="src-属性"><code>src</code> 属性</h2>
<p>可以是相对路径，也可以是绝对路径</p>
<h2 id="alt-属性"><code>alt</code> 属性</h2>
<p>图片加载失败的时候显示的内容</p>
<h2 id="height-和-width-属性"><code>height</code> 和 <code>width</code> 属性</h2>
<p>若只写高度或宽度，图像比例保持不变</p>
<h2 id="事件">事件</h2>
<ul>
<li><code>onload</code>图片加载成功</li>
<li><code>onerror</code> 图片加载失败</li>
</ul>
<h2 id="响应式">响应式</h2>
<p><code>max-width: 100%</code></p>
<h1 id="form-标签"><code>&lt;form&gt;</code> 标签</h1>
<blockquote>
<p>发出一个 GET 或 POST 请求，然后刷新页面</p>
</blockquote>
<h2 id="action-属性"><code>action</code> 属性</h2>
<p>请求到哪个页面</p>
<h2 id="method-属性"><code>method</code> 属性</h2>
<p>是用 GET 还是 POST</p>
<h2 id="autocomplete-属性"><code>autocomplete</code> 属性</h2>
<p>为 <code>on</code> 则打开自动填充，下面的 <code>text</code> 要写 <code>name</code></p>
<h2 id="target-属性-1"><code>target</code> 属性</h2>
<p>把哪个页面（ 值可以为 <code>_blank</code> 等等）变成要请求到的那个页面（也就是说哪个页面需要刷新）</p>
<div class="note warning"><ul>
<li>一般不监听 <code>input</code> 的 <code>click</code> 事件</li>
<li><code>form</code> 里面的 <code>input</code> 要有 <code>name</code></li>
<li>一个 form 必须要有一个 <code>type="submit"</code>，如果 <code>button</code> 不写 <code>type</code>，默认 <code>submit</code></li>
</ul>
</div>
<div class="note warning"><p><strong><code>&lt;input type="submit"&gt;</code> 和 <code>&lt;button type="submit"&gt;</code> 的区别？</strong> <code>input</code> 里面不能再有标签（但是文字可以用 <code>value=""</code> 进行更改） <code>button</code> 里面可以有任何东西（包括图片等其他标签）</p>
</div>
<h1 id="input-标签"><code>&lt;input&gt;</code> 标签</h1>
<h2 id="type-属性"><code>type</code> 属性</h2>
<ul>
<li><code>text</code></li>
<li><code>color</code></li>
<li><code>password</code></li>
<li><code>radio</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>checkbox</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>file</code> 加上 <code>multiple</code> 属性可以同时选多个文件</li>
<li><code>hidden</code></li>
<li><code>tel</code></li>
<li><code>email</code></li>
<li><code>search</code></li>
</ul>
<h2 id="事件-1">事件</h2>
<ul>
<li><code>onchange</code></li>
<li><code>onfocus</code></li>
<li><code>onblur</code></li>
</ul>
<h1 id="textarea-标签"><code>&lt;textarea&gt;</code> 标签</h1>
<p><code>style="resize: none"</code> 让右下角不能拖动</p>
<h1 id="select-标签"><code>&lt;select&gt;</code> 标签</h1>
<p><code>&lt;option value="1"&gt;星期一&lt;/option&gt;</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Internet Security</title>
    <url>/hais-notebook/2023/01/18/InternetSecurity/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="web-安全概述">Web 安全概述</h1>
<h2 id="web-应用">Web 应用</h2>
<ul>
<li>由动态脚本、编译过的代码等组合而成</li>
<li>通常架设在 Web 服务器上，用户在 Web 浏览器上发送请求</li>
<li>这些请求使用 HTTP 协议，由 Web 应用和企业后台数据库及其他动态内容通信</li>
</ul>
<h2 id="web-应用三层架构">Web 应用三层架构</h2>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Web-Application.png" alt="Web 应用三层架构" /><figcaption aria-hidden="true">Web 应用三层架构</figcaption>
</figure>
<h2 id="wasc-的定义">WASC 的定义</h2>
<blockquote>
<p>WASC（Web Application Security Consortium）是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，负责为 WWW 指定广为接受的应用安全标准</p>
</blockquote>
<p>WASC 将应用安全威胁分为六大类：</p>
<ol type="1">
<li>Authentication（验证）</li>
<li>Authorization（授权）</li>
<li>Client-Side Attacks（客户侧攻击）</li>
<li>Command Execution（命令执行）</li>
<li>Information Disclosure（信息暴露）</li>
<li>Logical Attacks（逻辑性攻击）</li>
</ol>
<h2 id="owasp-的定义">OWASP 的定义</h2>
<blockquote>
<p>OWASP（Open Web Application Security Project）致力于发现和解决不安全 Web 应用的根本原因</p>
</blockquote>
<ol type="1">
<li>Injection（注入）</li>
<li>Broken Authentication（失效的身份认证）</li>
<li>Sensitive Data Exposure（敏感信息泄露）</li>
<li>XXE, XML External Entities（XML 外部实体）</li>
<li>Broken Access Control（失效的访问控制）</li>
<li>Security Misconfiguration（安全配置错误）</li>
<li>XSS, Cross-Site Scripting（跨站脚本）</li>
<li>Insecure Deserialization（不安全的反序列化）</li>
<li>Using Components with Known Vulnerabilities（使用含有已知漏洞的组件）</li>
<li>Insufficient Logging &amp; Monitoring（不足的日志记录和监控）</li>
</ol>
<h1 id="验证机制安全">验证机制安全</h1>
<h2 id="什么是验证机制">什么是验证机制</h2>
<ul>
<li>验证机制是 Web 应用中最简单的一种安全机制。一般来说，应用程序 <strong>必须用户提交的用户名和密码，判断是否允许登录</strong></li>
<li>验证机制是应用程序防御恶意攻击的 <strong>核心机制</strong>，处于安全防御的最前沿，如果缺乏安全有效的验证机制，其他核心安全机制（会话管理和访问控制）都无法实施</li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Login-Process.webp" alt="典型的用户登陆流程" /><figcaption aria-hidden="true">典型的用户登陆流程</figcaption>
</figure>
<p>有这样几种常用的验证技术：</p>
<ul>
<li>基于 HTML 表单的验证</li>
<li>多元机制</li>
<li>客户端 SSL 证书</li>
</ul>
<h2 id="验证机制存在的安全隐患">验证机制存在的安全隐患</h2>
<h3 id="弱密码">弱密码</h3>
<p>许多 Web 应用程序没有或很少对用户密码强度进行控制：</p>
<ul>
<li>非常短或空白密码</li>
<li>以常用字典词汇为密码</li>
<li>密码与用户名完全相同</li>
<li>长时间使用默认密码</li>
</ul>
<h3 id="暴力破解">暴力破解</h3>
<p>登陆功能的公开性会诱使攻击者视图猜测用户名和密码，有诸如 Burp Suite 等工具提供了一些常用的字典</p>
<p>为了防止暴力破解，可以使用验证码，而验证码也需要注意几个问题：</p>
<ul>
<li>验证码是否真实有效</li>
<li>验证码的复杂度</li>
<li>应对当前诸如 OCR、打码等技术</li>
</ul>
<p>也可以设置 Cookie 和会话检测，增加失败计数器，当然 Cookie 在客户端可以随意修改</p>
<p>此外现在常用双因子认证（你知道的 + 你拥有的）</p>
<h3 id="忘记密码">忘记密码</h3>
<p>包括问题的答案、邮箱、手机验证码用明文或简单的 MD5 加密等</p>
<h3 id="多阶登录机制">多阶登录机制</h3>
<p>多次验证检查可能会提高登录机制的安全性，但在这个过程中可能也存在更多的执行缺陷：</p>
<ul>
<li>可能会认为到达第三阶段的用户已经通过了第一二阶段</li>
<li>可能认为每个阶段用户的身份不会变化</li>
<li>有些问题的细节或答案没有保存在服务器上，而是放在隐藏的 HTML 字段中</li>
</ul>
<h1 id="会话管理">会话管理</h1>
<h2 id="什么是会话管理">什么是会话管理</h2>
<ul>
<li>会话管理在用户通过请求提交他们的证书后，<strong>持续</strong> 向应用程序保证用户身份的真实性</li>
<li>由于会话管理机制发挥关键作用，且比较难以发现其漏洞，因此成为针对应用程序的恶意攻击的主要目标，攻击者若能破坏应用程序的会话管理，就能轻易避开验证机制</li>
</ul>
<h2 id="会话管理的安全隐患">会话管理的安全隐患</h2>
<h3 id="会话令牌生成漏洞">会话令牌生成漏洞</h3>
<p>通过简单的用户名、电子邮件经过简单的编码、加密生成的，不安全</p>
<h4 id="令牌可预测">令牌可预测</h4>
<p>令牌有一定的模式和规则、时间依赖</p>
<h4 id="随机数强度不足">随机数强度不足</h4>
<p>计算机中的数据极少完全随机，一般通过软件使用各种技巧生成伪随机数</p>
<h3 id="会话传输漏洞">会话传输漏洞</h3>
<p>尽可能缩短一个会话的寿命可以降低攻击者截获、猜测或滥用有效会话的风险</p>
<h4 id="会话终止攻击">会话终止攻击</h4>
<p>有一些应用程序没有有效的会话终止功能，他的有效期非常长</p>
<p>有些时候，退出功能并不能帮助服务器终止会话，比如只是简单地删除客户端的 Cookie，我们需要让服务端的会话失效</p>
<h4 id="会话劫持攻击">会话劫持攻击</h4>
<p>攻击者通过网络嗅探、XSS 攻击等方式截获令牌</p>
<h2 id="会话管理漏洞的防御">会话管理漏洞的防御</h2>
<ul>
<li><strong>令牌传输过程</strong>：令牌只能通过 HTTPS 传送，让浏览器不能通过 HTTP 传送令牌</li>
<li><strong>增加软硬会话过期</strong>
<ul>
<li>软会话过期：一定时间没有交互之后，Session 失效</li>
<li>应会话过期：经过一定时间之后，不管用户做什么，会话都会过期</li>
</ul></li>
<li><strong>提供完善的注销功能</strong></li>
</ul>
<h1 id="sql-注入攻击">SQL 注入攻击</h1>
<p>Web 程序经常会建立用户提交数据的 SQL 语句，但如果建立 SQL 语句的方法不安全，则容易造成 SQL 注入漏洞</p>
<h2 id="sql-注入危害">SQL 注入危害</h2>
<ul>
<li><strong>探知数据库的具体结构</strong>，为进一步攻击做准备</li>
<li><strong>泄露数据</strong>，尤其是机密信息、账户信息等</li>
<li><strong>获得更高权限</strong>，来修改数据甚至是内部结构</li>
</ul>
<h2 id="sql-注入防御">SQL 注入防御</h2>
<ul>
<li><strong>参数化查询</strong>：最根本性的防御
<ul>
<li>指定查询结构，用户输入预留占位符</li>
<li>指定占位符的内容</li>
</ul></li>
</ul>
<h1 id="xss-跨站脚本攻击">XSS 跨站脚本攻击</h1>
<p>攻击者通常通过注入 HTML 或 JS 脚本发动攻击，攻击成功后，攻击者可以得到私密网页内容和 Cookie 等</p>
<h2 id="xss-攻击危害">XSS 攻击危害</h2>
<ul>
<li><strong>盗号</strong></li>
<li><strong>控制数据</strong>，读取、篡改、添加、删除敏感数据</li>
<li><strong>非法转账</strong></li>
<li><strong>网站挂马</strong></li>
<li><strong>控制肉鸡</strong></li>
</ul>
<h2 id="xss-攻击分类">XSS 攻击分类</h2>
<h3 id="反射式-xss-攻击">反射式 XSS 攻击</h3>
<p>又称非永久性 XSS，是目前最流行的 XSS 攻击</p>
<p>出现在服务器直接使用客户端提交的数据，比如 URL 数据、HTML 表单等，并且没有对数据进行无害化处理，这些数据中藏着一些可执行脚本，最常见的方式就是恶意连接，其中包含了 XSS 攻击脚本</p>
<h3 id="存储式-xss-攻击">存储式 XSS 攻击</h3>
<p>又称永久性 XSS，危害更大</p>
<p>攻击者将脚本上传到 Web 服务器上，使得所有访问该页面的用户都面临信息泄露的可能</p>
<p>多发生在个人信息字段、文档或上传的文件及其他数据的名称、提交给应用程序管理员的反馈或问题、向其他用户传送的信息、在用户之间共享的上传文件内容</p>
<h3 id="基于-dom-的-xss-攻击">基于 DOM 的 XSS 攻击</h3>
<p>基于 DOM 的 XSS 攻击仅仅通过 JavaScript 执行，常发生在应用程序每次返回相同的静态 HTML，而客户端 JavaScript 动态生成信息，并不会跟服务端交互获取的时候</p>
<h2 id="xss-攻击载荷">XSS 攻击载荷</h2>
<ul>
<li><strong>会话令牌</strong>：XSS 攻击最普遍的方式，截取受害者的会话令牌，劫持他的会话</li>
<li><strong>虚拟置换</strong>：向 Web 应用程序页面注入恶意数据（修改页面），没有修改保存在服务器上保存的内容，而是通过程序处理来显示置换</li>
<li><strong>注入木马</strong>：比如突然弹出一个对话框（木马登录表单），诱导你输入用户密码</li>
</ul>
<h2 id="xss-防御措施">XSS 防御措施</h2>
<ul>
<li><strong>输入验证</strong>
<ul>
<li>数据不是太长</li>
<li>数据仅包含合法字符</li>
<li>数据与正则表达式匹配</li>
<li>对不同的数据类型（比如账号、邮箱等）设置不同的规则</li>
</ul></li>
<li><strong>输出编码</strong>
<ul>
<li>对数据进行 HTML 编码，使用 HTML 实体代替字面量字符，净化可能的恶意字符</li>
</ul></li>
</ul>
<h1 id="csrf-跨站请求伪造">CSRF 跨站请求伪造</h1>
<p>典型的流程如下：</p>
<ol type="1">
<li>受害者登录 <code>a.com</code>，并且保留了登录凭证（Cookie）</li>
<li>攻击者诱使受害者访问 <code>hack.com</code></li>
<li><code>hack.com</code> 向 <code>a.com</code> 发送请求：<code>a.com/act=xx</code> 浏览器默认会携带上 <code>a.com</code> 的 <code>Cookie</code></li>
<li><code>a.com</code> 收到请求后，确认是受害者的凭证，误认为是受害者自己发送的请求</li>
<li><code>a.com</code> 以受害者的名义执行了 <code>act=x</code></li>
</ol>
<h2 id="几种常见的攻击类型">几种常见的攻击类型</h2>
<h3 id="get-类型的-csrf">GET 类型的 CSRF</h3>
<p>这个类型非常简单，一般只需要一个 HTTP 请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withraw?amount=10000&amp;for=hacker&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在受害者访问有这个 img 的页面之后，浏览器会自动向 <code>http://bank.example/withraw?amount=10000&amp;for=hacker</code> 发送请求</p>
<h3 id="post-类型的-csrf">POST 类型的 CSRF</h3>
<p>这类攻击通常是使用一个自动提交的表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="链接类型的-csrf">链接类型的 CSRF</h3>
<p>需要用户点击链接才会触发：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://bank.example/withraw?amount=10000&amp;for=hacker&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="csrf-的特点">CSRF 的特点</h2>
<ul>
<li>攻击一般发起在 <strong>第三方网站</strong>，而不是被攻击的网站（通常是 <strong>跨域</strong> 的），因此被攻击的网站无法防止攻击的发生</li>
<li>攻击者利用受害者的登陆凭证，而不是直接盗取数据</li>
<li>攻击者仅仅是 <strong>利用</strong> 受害者的登录凭证，而 <strong>不能获取</strong> 到这个凭证</li>
<li>跨站请求可以用各种方式：图片、超链接、CORS、Form 表单等，部分请求可以直接嵌入第三方论坛、文章中，难以进行追踪</li>
<li>通常是跨域的，但有时候也可以在 <strong>本域</strong> 进行，比如在论坛和评论区可以发图和连接，这种攻击更加危险</li>
</ul>
<h2 id="csrf-防御措施">CSRF 防御措施</h2>
<p>针对 CSRF 通常是跨域请求，并且攻击者只是冒用、而无法真正获得 Cookie 的特点，可以采取以下策略：</p>
<ul>
<li><strong>阻止不明外域的访问</strong>
<ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul></li>
<li><strong>提交时要求附加本域才能获得的信息</strong>
<ul>
<li>CSRF Token</li>
<li>双重 Cookie 验证</li>
</ul></li>
</ul>
<h3 id="同源检测">同源检测</h3>
<p>可以通过 <strong>Origin Header</strong> 和 <strong>Referer Header</strong> 来判断请求是否来自外域</p>
<p>对于 Origin 有两个问题：</p>
<ul>
<li>IE 11 不会在 CORS 请求上添加 Origin 标头</li>
<li>302 重定向之后，Origin 不再包含在重定向之后的请求中</li>
</ul>
<p>对于 Referer 也有问题：</p>
<ul>
<li>每个浏览器对于 Referer 的实现可能有差别，不能保证浏览器自身没有安全漏洞</li>
<li>攻击请求可能隐藏 Referer</li>
</ul>
<p>当 Origin 和 Referer 都不存在的时候，建议直接阻止访问</p>
<p>，同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这有时候也有问题，比如搜索引擎来的请求也会被当做疑似 CSRF 攻击，并且安全性并不是很高</p>
<h3 id="csrf-token">CSRF Token</h3>
<ol type="1">
<li><strong>将 CSRF Token 输出到页面中</strong>，用户打开页面时，需要给用户生成一个 Token，可以将这个 Token 保存在 Session 中，同时给页面上所有的 a 标签 和 form 标签后面加入这个 Token</li>
<li><strong>页面提交的请求携带这个 Token</strong></li>
<li><strong>服务器验证 Token 是否正确</strong></li>
</ol>
<h3 id="分布式校验">分布式校验</h3>
<p>使用一种计算出来的结果而不是随机生成的字符串作为 Token，这样在校验的时候就无需读取存储的 Token，只需要再计算一次即可</p>
<h3 id="双重-cookie-验证">双重 Cookie 验证</h3>
<p>因为攻击者实际上无法知道 Cookie 里面的内容，所以只需要让 AJAX 和表单请求中携带一个 Cookie 中的值，后端接口验证 Cookie 中的字段与请求参数中的字段是否相同，这样可以减小后端服务器 Session 存储的压力</p>
<p>但是也有一些问题：</p>
<ol type="1">
<li>如果用户访问 <code>www.a.com</code>，后端域名为 <code>api.a.com</code>，那么在 <code>www.a.com</code> 下就拿不到 <code>api.a.com</code> 的 Cookie</li>
<li>于是这个认证必须种在 <code>a.com</code> 下</li>
<li>于是任意子域名都可以修改 <code>a.com</code> 下的 Cookie</li>
<li>如果某个子域名存在漏洞被 XSS 攻击，那么攻击者就可以修改 <code>a.com</code> 下的 Cookie</li>
<li>攻击者就可以使用自己配置的 Cookie，对用户在 <code>www.a.com</code> 下发起 CSRF 攻击</li>
</ol>
<h3 id="samesite-cookie">Samesite Cookie</h3>
<p>Google 起草了一份草案来改进 HTTP 协议，就是为 <code>Set-Cookie</code> 响应头增加 <code>Samesite</code> 属性，表明这个 Cookie 是个 <strong>同站 Cookie</strong></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 实现部分 API</title>
    <url>/hais-notebook/2020/02/23/JS-SourceCode/</url>
    <content><![CDATA[<p>实现一些常见的 API。</p>
<span id="more"></span>
<h1 id="array">Array</h1>
<h2 id="map">map</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot read property &quot;map&quot; of null or undefined&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callback) !== <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27;is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 草案中提到要先转换为对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> T = thisArg</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 右移 0 位，可以把前面的空位用 0 填充，实际上是为了保证 len 为数字且为整数，因为位运算会丢弃小数</span></span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Array</span>(len)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k]</span><br><span class="line">      A[k] = callback.<span class="title function_">call</span>(T, kValue, k, O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reduce">reduce</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span>(<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot read property &quot;reduce&quot; of null or undefined&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callback) !== <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27;is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k]</span><br><span class="line">        k++</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Each element of array is empty&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callback.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[k], k, O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="push">push</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myPush</span> = <span class="keyword">function</span>(<span class="params">...items</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> argCount = items.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="comment">// 2 ** 53 - 1 是 JS 能表示的最大整数</span></span><br><span class="line">  <span class="keyword">if</span> (len + argCount &gt; <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The number of array is over the max value restricted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; argCount; i++) &#123;</span><br><span class="line">    O[len + i] = items[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newLength = len + argCount</span><br><span class="line">  O.<span class="property">length</span> = newLength</span><br><span class="line">  <span class="keyword">return</span> newLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pop">pop</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myPop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  len--</span><br><span class="line">  <span class="keyword">let</span> value = O[len]</span><br><span class="line">  <span class="keyword">delete</span> O[len]</span><br><span class="line">  O.<span class="property">length</span> = len</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filter">filter</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot read property &quot;filter&quot; of null or undefined&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callback) !== <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27;is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(thisArg)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i]</span><br><span class="line">      <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="splice">splice</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sliceDeleteElements</span> = (<span class="params">array, startIndex, deleteCount, deleteArray</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      deleteArray[i] = array[index]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">movePostElements</span> = (<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果增加与删除一样多，就不动</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.<span class="property">length</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果删除比新增多，就左移</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; addElements.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i</span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除因为挪动而空出来的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.<span class="property">length</span> - deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果删除比新增少，就右移</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; addElements.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i</span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.<span class="property">length</span> - deleteCount)</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">computeStartIndex</span> = (<span class="params">startIndex, len</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len : startIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">computeDeleteCount</span> = (<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认 startIndex 及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) <span class="keyword">return</span> len - startIndex</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) <span class="keyword">return</span> len - startIndex</span><br><span class="line">  <span class="keyword">return</span> deleteCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mySplice</span> = <span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="variable language_">arguments</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> deleteArray = <span class="keyword">new</span> <span class="title class_">Array</span>(deleteCount)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数清洗，如果用户传来非法值怎么办</span></span><br><span class="line">  startIndex = <span class="title function_">computeStartIndex</span>(startIndex, len)</span><br><span class="line">  deleteCount = <span class="title function_">computeDeleteCount</span>(startIndex, len, deleteCount, argumentsLen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 seal 对象和 frozen 对象</span></span><br><span class="line">  <span class="comment">// 密封对象不可扩展，不能添加、删除方法和属性，但可以修改属性值</span></span><br><span class="line">  <span class="comment">// 冻结对象还不能修改属性值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(array) &amp;&amp; deleteCount !== addElements.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;the object is a sealed object&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.<span class="property">length</span> &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;the object is a frozen object&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  <span class="title function_">sliceDeleteElements</span>(array, startIndex, deleteCount, deleteArray)</span><br><span class="line">  <span class="comment">// 移动原来的数组中的元素</span></span><br><span class="line">  <span class="title function_">movePostElements</span>(array, startIndex, len, deleteCount, addElements)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i]</span><br><span class="line">  &#125;</span><br><span class="line">  array.<span class="property">length</span> = len - deleteCount + addElements.<span class="property">length</span></span><br><span class="line">  <span class="keyword">return</span> deleteArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sort">sort</h2>
<p>在 V8 引擎中 - n &lt;= 10 时，采用插入排序 - n &gt; 10 时，采用三路快速排序 - 10 &lt; n &lt;= 1000，采用中位数作为哨兵元素 - n &gt; 1000，每隔 200~215 个元素选出一个元素，放到一个新数组，然后对他排序，找到中间位置的数，以此作为中位数</p>
<h3 id="插入排序及其优化">插入排序及其优化</h3>
<p>原来的插入排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">insertSort</span> = (<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt; &#123;</span><br><span class="line">  end = end || arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; arr[j]; j--) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">      arr[j - <span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用变量覆盖的方式替代交换元素：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/3/16e3124af5479387?imageslim" /></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">insertSort</span> = (<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt; &#123;</span><br><span class="line">  end = end || arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找哨兵元素">寻找哨兵元素</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getPivotIndex</span> = (<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> tempArr = []</span><br><span class="line">  <span class="comment">// 递增量在 200~215 之间</span></span><br><span class="line">  <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>)</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">from</span> += <span class="number">1</span></span><br><span class="line">  to -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">    tempArr[j] = [i, a[i]]</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">  tempArr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">comparefn</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> tempArr[tempArr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完成快排">完成快排</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_sort</span> = (<span class="params">a, b, c</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [a, b, c]</span><br><span class="line">  <span class="title function_">innsetSort</span>(arr, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = (<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 为了确保 pivot 不是最值，将他和 from to 一起排序</span></span><br><span class="line">  [a[<span class="keyword">from</span>], a[pivotIndex], a[to - <span class="number">1</span>]] = <span class="title function_">_sort</span>(a[<span class="keyword">from</span>], a[pivotIndex], a[to - <span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> pivot = a[pivotIndex]</span><br><span class="line">  <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> highStart = to - <span class="number">1</span></span><br><span class="line">  a[pivotIndex] = a[lowEnd]</span><br><span class="line">  a[lowEnd] = pivot</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="promise">Promise</h1>
<h2 id="原版-promise-的基本用法">原版 Promise 的基本用法</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;FULFILLED&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="第一步创建-class-mypromise">第一步：创建 class MyPromise</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">handle</span>) &#123; <span class="comment">// handle 即为 (resolve, reject) =&gt; &#123;...&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyPromise must accept a function as parameter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步处理-mypromise-的状态和值">第二步：处理 <code>MyPromise</code> 的状态和值</h2>
<p>原版 Promise 对象存在三种状态：<code>Pending</code> <code>Fulfilled</code> <code>Rejected</code></p>
<div class="note warning"><p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Reject</code>，并且之后不能再变化</p>
</div>
<p><code>resolve</code> 会将 Promise 对象的状态变为 <code>FulFilled</code>，而 <code>reject</code> 则会将其变为 <code>Pending</code></p>
<p>而原版 Promise 的值说的是状态改变时传递给回调函数的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyPromise must accept a function as parameter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 执行 handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 resolve</span></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 reject</span></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三步实现-then-方法">第三步：实现 <code>then</code> 方法</h2>
<p><code>then</code> 方法支持链式调用，可以用两个数组来实现回调队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyPromise must accept a function as parameter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_fulfilledQueues</span> = []</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rejectedQueues</span> = []</span><br><span class="line">    <span class="comment">// 执行 handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 resolve</span></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 reject</span></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 then</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;_value, _status&#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 成功时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> <span class="title function_">fulfilled</span> = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">onFulfilledNext</span>(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="title function_">onFulfilled</span>(value)</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">              res.<span class="title function_">then</span>(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title function_">onFulfilledNext</span>(next)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="title function_">onRejectedNext</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_fulfilledQueues</span>.<span class="title function_">push</span>(onFulfilled)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_rejectedQueues</span>.<span class="title function_">push</span>(onRejected)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">onFulfilled</span>(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">          <span class="title function_">onRejected</span>(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="call-apply-bind">call apply bind</h1>
<h2 id="模拟实现的思路">模拟实现的思路</h2>
<p>我们有一个对象和一个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">call</span>(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果我们把 <code>bar</code> 变成 <code>foo</code> 的一个属性，那么就可以不使用 <code>call</code> 了，<code>this</code> 会被隐式地传递过去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">bar</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以借鉴这样的思路，我们先将函数加到对象的属性上，调用之后再删除掉即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.<span class="property">fn</span> = bar</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.<span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.<span class="property">fn</span></span><br></pre></td></tr></table></figure>
<h2 id="开始实现">开始实现</h2>
<h3 id="第一步传递-this">第一步：传递 this</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mayCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  context.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步传递-arguments">第二步：传递 arguments</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步解决其他问题">第三步：解决其他问题</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// call 可能传入原始类型，bug 是 falsy 都会变成 window</span></span><br><span class="line">  context = context ? <span class="title class_">Object</span>(context) : <span class="variable language_">window</span>  </span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 处理函数的返回值</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="comment">// 这里不需要区分有没有 args，因为如果没有传值，他的值将会是空数组 []</span></span><br><span class="line">  <span class="comment">// 你仍然可以使用 ...[] 来展开</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照同样的思路我们也可以模拟 apply：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">  context = context ? <span class="title class_">Object</span>(context) : <span class="variable language_">window</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意这里要区分的原因是，如果没有传入 args，那么他的值就是 undefined</span></span><br><span class="line">  <span class="comment">// 你无法对 undefined 进行展开，而且他的报错是：</span></span><br><span class="line">  <span class="comment">// VM8558:1 Uncaught TypeError: context.fn is not iterable (cannot read property Symbol(Symbol.iterator))</span></span><br><span class="line">  <span class="comment">// 而不是 undefined is not iterable</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用 ES3 的写法来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context = context ? <span class="title class_">Object</span>(context) : <span class="variable language_">window</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  <span class="comment">// eval 表示把里面的字符串当做 JS 代码来执行</span></span><br><span class="line">  <span class="comment">// 这句话相当于执行 context.fn( arguments[1], arguments[2], ...)</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context, arr</span>) &#123;</span><br><span class="line">  context = context ? <span class="title class_">Object</span>(context) : <span class="variable language_">window</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      args.<span class="title function_">push</span>(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bind">bind</h2>
<h3 id="一个简单实现">一个简单实现</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span> <span class="comment">// 存下这个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(context, args.<span class="title function_">concat</span>(newArgs)) <span class="comment">// 支持柯里化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析">源码分析</h3>
<p>源于 MDN 上提供的 polyfill</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property">proptotype</span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为 arguments 是伪数组，他没有 slice 方法</span></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="variable language_">this</span>,</span><br><span class="line">        fNOP = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">        fBound = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 这是考虑到了要使用 new 来调用 bind 的返回值的情况</span></span><br><span class="line">          <span class="comment">// 如果使用 new 调用，new 具有最高优先级，函数的 this 由 new 确定，而不是 bind</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP</span><br><span class="line">                 ? <span class="variable language_">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">          <span class="comment">// 柯里化</span></span><br><span class="line">                 aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下面这两句相当于 fBound.prototype = Object.create(this.prototype)，是比较古老的写法</span></span><br><span class="line">    <span class="comment">// 是为了让 this instanceof fNOP 变得有意义</span></span><br><span class="line">    <span class="comment">// 这样，如果使用 new 运算符</span></span><br><span class="line">    <span class="comment">// 那么 fBound 中的 this instanceof fBound === true</span></span><br><span class="line">    <span class="comment">// 同时也有 this instanceof fNOP === true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="new">new</h1>
<p>在 <code>new</code> 的时候，做了这样几件事情：</p>
<ol type="1">
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>构造函数.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fun, ...args</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fun.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    <span class="comment">// let newObj = &#123;&#125;</span></span><br><span class="line">    <span class="comment">// newObj.__proto__ = fun.prototype</span></span><br><span class="line">    <span class="keyword">const</span> result = fun.<span class="title function_">apply</span>(newObj, args)</span><br><span class="line">    <span class="comment">// 原版的 new 中，如果构造函数返回一个对象，则 new 也返回一个对象；如果构造函数返回一个简单类型，则 new 返回刚刚创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Java</title>
    <url>/hais-notebook/2023/02/09/Java/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="concepts">Concepts</h1>
<h2 id="object-oriented">Object Oriented</h2>
<ul>
<li><strong>Encapsulation</strong>: a class contains data and behaviors, and can hide some</li>
<li><strong>Abstraction</strong>
<ul>
<li>Abstract away implementation details</li>
<li>Isolate the impact of changes made to the code</li>
</ul></li>
<li><strong>Inheritance</strong>: It weakens encapsulation.</li>
<li><strong>Polymorphism</strong>: Any object instantiated by any child class can be handled in the same way</li>
<li><strong>Coupling and Cohesion</strong>: <em>Loose coupled, highly cohesive</em>
<ul>
<li><strong>Coupling</strong> (dependency): The degree to which one class knows about another class.</li>
<li><strong>Cohesion</strong>: The degree to which a class has a single, well-focused purpose.</li>
</ul></li>
<li><strong>Interface/Implementation Paradigm</strong>
<ul>
<li>An object should <strong>reveal only the interfaces</strong> that other objects must have to interact with it.</li>
<li>Clients of the class will not be affected by implementation change.</li>
</ul></li>
</ul>
<h2 id="uml-class-diagrams">UML Class Diagrams</h2>
<p><a href="https://www.youtube.com/watch?v=UI6lqHOVHic">UML Class Diagram Tutorial Video</a></p>
<p><a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/;WWWSESSIONID=011FBA1C6F02E5074E7D3E435507A547.www1">UML Class Diagram Tutorial</a></p>
<h3 id="attributes">Attributes</h3>
<ul>
<li>Data containing values that describe each instance of that class</li>
<li>Also called fields, variables, properties.</li>
</ul>
<h3 id="methods">Methods</h3>
<ul>
<li>Specify behavioral feature of a class.</li>
<li>Also called operations or functions.</li>
</ul>
<h3 id="visibility">Visibility</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- private</span><br><span class="line">+ public</span><br><span class="line"># protected</span><br><span class="line">~ package/default</span><br></pre></td></tr></table></figure>
<h3 id="relationship">Relationship</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/ClassRelationship.jpg" alt="Class Relationship" /><figcaption aria-hidden="true">Class Relationship</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDInheritance.jpg" alt="Inheritance" /><figcaption aria-hidden="true">Inheritance</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDAssociation.jpg" alt="Association" /><figcaption aria-hidden="true">Association</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDAggregation.jpg" alt="Aggregation" /><figcaption aria-hidden="true">Aggregation</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDComposition.jpg" alt="Composition" /><figcaption aria-hidden="true">Composition</figcaption>
</figure>
<h3 id="example">Example</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDExample1.jpg" alt="Class Diagram Example" /><figcaption aria-hidden="true">Class Diagram Example</figcaption>
</figure>
<h2 id="solid-principle">SOLID Principle</h2>
<ul>
<li>SRP: Single Responsibility Principle</li>
<li>OCP: Open/Close Principle</li>
<li>LSP: Liskov Substitution Principle</li>
<li>IPS: Interface Segregation Principle</li>
<li>DIP: Dependency Inversion Principle</li>
</ul>
<h3 id="srp-single-responsibility-principle">SRP: Single Responsibility Principle</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Animal</span><br><span class="line">- perfiomWalk()</span><br><span class="line">- performSwim()</span><br><span class="line">- performSleep()</span><br></pre></td></tr></table></figure>
<h3 id="ocp-openclose-principle">OCP: Open/Close Principle</h3>
<ul>
<li>Software entities (classes, modules, functions, etc.) should be:
<ul>
<li>Open for extension</li>
<li>Close for modification</li>
</ul></li>
<li>Be able to extend a class's behavior without modifying it.</li>
</ul>
<h3 id="lsp-liskov-substitution-principle">LSP: Liskov Substitution Principle</h3>
<p>If we substitute a super class object reference with an object of <em>any</em> of its subclasses, the program should not break.</p>
<p>If a superclass can do something, a subclass <strong>MUST</strong> also be able to do it.</p>
<h3 id="ips-interface-segregation-principle">IPS: Interface Segregation Principle</h3>
<p>No code should be forced to depend on methods it does not use.</p>
<p>Splits large interfaces into smaller and more specific ones.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Large interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Zookeeper</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">washAnimal</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">feedAnimal</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">petAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split into ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalCleaner</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">washAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalFeeder</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">feedAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalPetter</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">petAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalCarer</span> <span class="keyword">implements</span> <span class="title class_">AnimalCleaner</span>, AnimalFeeder &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalLover</span> <span class="keyword">implements</span> <span class="title class_">AnimalPetter</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dip-dependency-inversion-principle">DIP: Dependency Inversion Principle</h3>
<p>Depend upon abstractions. Do not depend upon concrete classes.</p>
<h2 id="convention-over-configuration-principle">Convention-Over-Configuration Principle</h2>
<p>The convention represents the most-used way to configure the app for a specific purpose.</p>
<p>Only need to change those places where your app needs more particular configuration.</p>
<p>Write less code for configuration.</p>
<h1 id="startup">Startup</h1>
<h2 id="extension-pack-for-java-for-vscode">Extension Pack for Java for VSCode</h2>
<ol type="1">
<li>Install the <code>Extension Pack for Java</code></li>
<li>Refresh VSCode: Press <code>Ctrl+Shift+P</code> and input <code>Reload Window</code></li>
<li>Clean the Java workspace when there are problems: Press <code>Ctrl+Shift+P</code> and input <code>Java: Clean Java Language Server Workspace</code></li>
</ol>
<h2 id="creating-and-running-java-programs">Creating and Running Java programs</h2>
<p>Create Java source file <code>TestCircle.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestCircle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCircle</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compile the Java source file into bytecode:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac TestCircle.java</span><br></pre></td></tr></table></figure>
<p>Execute the Java program:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java TestCircle</span><br></pre></td></tr></table></figure>
<p>To generate Setter and Getter methods in VSCode, in a Java source file, right-click and select <code>Source Action...</code>. And then select <code>Generate Getters and Setters</code>. The way to generate constructors is similar.</p>
<h1 id="oo-design-in-java">OO Design in Java</h1>
<h2 id="encapsulation">Encapsulation</h2>
<ul>
<li>Access Modifier
<ul>
<li>The keyword <code>private</code> signifies that a method or variable can be accessed only within the declaring object.</li>
<li>All/most attributes should be declared as private.</li>
</ul></li>
<li>Getters and Setters</li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<ul>
<li><strong>Is-a Relationship</strong>: A subclass can do anything that the superclass can do.
<ul>
<li><strong>Generalization</strong>: A subclass is a type of superclass (a dog <strong>is-a</strong> mammal)</li>
</ul></li>
</ul>
<h3 id="method-overriding">Method Overriding</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// Not mandatory but considered as best practice for coding</span></span><br><span class="line">  <span class="comment">// Because it will let comiler to check wether Animal has sound or not</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interface-and-abstract-class">Interface and Abstract Class</h3>
<ul>
<li>An <strong>interface</strong> can provide <strong>NO implementation</strong> at all.
<ul>
<li>A class can inherit from only one parent class, but it can implement many interfaces.</li>
</ul></li>
<li>An <strong>abstract class</strong> can provide some implementation.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Nameable</span> &#123;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String aName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mammal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateHeat</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Mammal</span> <span class="keyword">implements</span> <span class="title class_">Nameable</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span> <span class="params">(String aName)</span> &#123;</span><br><span class="line">    name = aName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">D</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Mammal</span> <span class="variable">M</span> <span class="operator">=</span> D;</span><br><span class="line"><span class="type">Nameable</span> <span class="variable">N</span> <span class="operator">=</span> D;</span><br></pre></td></tr></table></figure>
<h2 id="composition">Composition</h2>
<ul>
<li><strong>Has-a Relationship</strong>: A dog <strong>has a</strong> head.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Walkable &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="type">Mammal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mammal</span>();</span><br><span class="line">  <span class="type">Walkable</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walkable</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performWalk</span><span class="params">()</span> &#123;</span><br><span class="line">    w.walk();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performEat</span><span class="params">()</span> &#123;</span><br><span class="line">    m.eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inverting-of-control-ioc">Inverting of Control (IoC)</h2>
<ul>
<li><strong>DIP</strong>: high-level modules should <strong>not</strong> depend on low-level modules.</li>
<li><strong>Both</strong> should depend on abstractions.</li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/java-before-ioc.jpg" alt="High-level module depends on low level module" /><figcaption aria-hidden="true">High-level module depends on low level module</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/java-ioc.jpg" alt="Inverting of Control" /><figcaption aria-hidden="true">Inverting of Control</figcaption>
</figure>
<p>Create 2 interfaces: to fetch the data and export the data.</p>
<ul>
<li>All low-level modules must implements these interfaces</li>
<li>High-level module (Balance Sheet Module) needs to rely on interfaces</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFetchData</span> &#123;</span><br><span class="line">  List&lt;Object[]&gt; fetchData();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IExportData</span> &#123;</span><br><span class="line">  File <span class="title function_">exportData</span><span class="params">(List&lt;Object[]&gt; listData)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalanceSheet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">IExportData</span> <span class="variable">exportDataObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">IFetchData</span> <span class="variable">fetchDataObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">generateBalanceSheet</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Object[]&gt; dataList = fetchDataObj.fetchData();</span><br><span class="line">    <span class="keyword">return</span> exportDataObj.exportData(dataList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dependency-injection-di">Dependency Injection (DI)</h3>
<ul>
<li>DI is one way to implement IoC.</li>
<li>Decouples your class's construction from the construction of its dependencies.
<ul>
<li>Invert the object creation process from your module to other code or entity.</li>
<li>Inject the object from outside.</li>
</ul></li>
</ul>
<h4 id="constructor-injection">Constructor Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalanceSheet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IExportData exportDataObj;</span><br><span class="line">  <span class="keyword">private</span> IFetchData fetchDataObj;</span><br><span class="line">  </span><br><span class="line">  BalanceSheet(IFetchData fetchData, IExportData exportData) &#123;</span><br><span class="line">    <span class="built_in">this</span>.fetchDataObj = fetchData;</span><br><span class="line">    <span class="built_in">this</span>.exportDataObj = exportData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setter-injection">Setter Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalanceSheet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IExportData exportDataObj;</span><br><span class="line">  <span class="keyword">private</span> IFetchData fetchDataObj;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExportDataObj</span><span class="params">(IExportData exportDataObj)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.exportDataObj = exportDataObj;</span><br><span class="line">    <span class="built_in">this</span>.fetchDataObj = fetchDataObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ioc-containers">IoC Containers</h3>
<ul>
<li>A container takes care of creating, configuring, and managing objects.</li>
<li>You just need to do configuration, and the container will take care of object instantiation and dependency management with ease.</li>
<li>Java IoC Containers: Spring, Google Guice and Dagger.</li>
</ul>
<h3 id="factory-pattern">Factory Pattern</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalanceSheet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IFetchData fetchDataObj;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureFetchData</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fetchDataObj = FetchDataFactory.getFetchData(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FetchDataFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IFetchData <span class="title function_">getFetchData</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="type">IFetchData</span> <span class="variable">fetchData</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;FROM_DB&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">      fetchData = <span class="keyword">new</span> <span class="title class_">FetchDatabase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;FROM_WS&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">      fetchData = <span class="keyword">new</span> <span class="title class_">FetchWebService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="maven">Maven</h1>
<p>Maven is a tool for building and managing your Java-based projects.</p>
<h2 id="project-structure">Project Structure</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">  |--main</span><br><span class="line">  |  `-- java</span><br><span class="line">  |    `-- com</span><br><span class="line">  |      `-- example</span><br><span class="line">  |        `-- App.java</span><br><span class="line">  `-- test</span><br><span class="line">    `-- java</span><br><span class="line">      `-- com</span><br><span class="line">        `-- example</span><br><span class="line">          `-- AppTest.java</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>src/main/java</strong>: The source code.</li>
<li><strong>src/main/resources</strong>: The resources such as configuration files and property files.</li>
<li><strong>src/test/resources</strong>: The test resources such as configuration files and property files.</li>
<li><strong>pom.xml:</strong> <strong>Project Object Model</strong>. The project's information and dependencies.
<ul>
<li><strong>groupId</strong>: identifies the group or organization that the dependency belongs to.</li>
<li><strong>artifactId</strong>: the id of the artifact within the group.</li>
<li><strong>version</strong>: the version of the dependency that the project requires.</li>
<li><strong>scope</strong>: the scope of the dependency (whether it is required for compilation, test, runtime, etc.)</li>
</ul></li>
<li><strong>target</strong>: The compiled code and other files generated during the build process.</li>
</ul>
<h2 id="create-a-maven-project">Create a Maven Project</h2>
<h3 id="use-vscode-extension">Use VSCode Extension</h3>
<p>Step 1:</p>
<p>In VSCode, press <code>Ctrl+Shift+P</code>. Search for Java, Select <code>Java: Create Java Project</code>.</p>
<p>Alternatively, you may click <code>+</code> under the <strong>Java Project Panel</strong>.</p>
<p>Step 2: Choose <code>Maven</code>.</p>
<p>Step 3: Select <code>maven-archetype-quickstart</code></p>
<h3 id="use-command">Use Command</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.example \</span><br><span class="line">-DartifactId=Demo2 \</span><br><span class="line">-DarchetkypeArtifactId=maven-archetype-quickstart \</span><br><span class="line">-DinteractiveMode=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="maven-lifecycle">Maven Lifecycle</h2>
<p>3 build-in build lifecycles:</p>
<ul>
<li><strong>Default</strong>: handles project deployment.</li>
<li><strong>Clean</strong>: handles project cleaning.</li>
<li><strong>Site</strong>: handles the creation of project's web site.</li>
</ul>
<p>These are some phases in the default lifecycle:</p>
<ul>
<li><strong>validate</strong></li>
<li><strong>compile</strong></li>
<li><strong>test</strong>: unit test</li>
<li><strong>package</strong></li>
<li><strong>verify</strong>: integration test</li>
<li><strong>install</strong>: install the package into local repository</li>
<li><strong>deploy</strong></li>
</ul>
<h2 id="goals">Goals</h2>
<ul>
<li>A specific task (finer than a build phase) which contributes to the building and managing of a project.</li>
<li>Each goal is bound to one or more phases.
<ul>
<li>Corresponds to a specific action that needs to be performed</li>
<li>E.g. compiling code, running tests, and packaging the code.</li>
</ul></li>
<li>One or more plugins can be bounded to the goal.</li>
</ul>
<h2 id="plugins">Plugins</h2>
<ul>
<li>Perform tasks in specific goal(s).
<ul>
<li>E.g. automate common build tasks, such as compiling code, running tests, and packaging the code.</li>
</ul></li>
<li>Can be bound to one or more goals.</li>
</ul>
<h2 id="commands">Commands</h2>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/maven-phase-goal-plugin.jpg" alt="Maven Phases, goals and Plugins" /><figcaption aria-hidden="true">Maven Phases, goals and Plugins</figcaption>
</figure>
<p>A Maven command may be written in 2 forms:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn [phase]</span><br><span class="line">mvn [plugin]:[goal]</span><br></pre></td></tr></table></figure>
<p>E.g.:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn compile            <span class="comment"># execute default lifecycle till compile phase</span></span><br><span class="line">mvn compiler:compile   <span class="comment"># only excute compiler plugin to comile</span></span><br><span class="line"></span><br><span class="line">mvn <span class="built_in">test</span></span><br><span class="line">mvn surefire:<span class="built_in">test</span>      <span class="comment"># only excute surefire plugin to test</span></span><br><span class="line"></span><br><span class="line">mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure>
<h2 id="jar-java-archive-file">JAR (Java Archive) File</h2>
<p>A package file format used to aggregate many Java class files and associated metadata and resources into one file for distribution.</p>
<h1 id="spring-boot">Spring Boot</h1>
<h2 id="simple-demo-with-rest-api">Simple Demo With Rest API</h2>
<h3 id="spring-initializr">Spring Initializr</h3>
<ul>
<li><p><a href="https://start.spring.io/">Spring Initializr</a> helps you initialize spring boot project.</p></li>
<li><p>Choose Spring Web, Spring Data JPA and PostgreSQL Driver.</p></li>
<li><p>Use IntelliJ to open the project.</p></li>
<li><p>Since we have not installed database, comment out <code>spring-boot-starter-data-jpa</code> in <code>pom.xml</code>, and then run the project.</p></li>
<li><p>Open browser and go to localhost:8080</p></li>
</ul>
<h3 id="simple-api">Simple API</h3>
<p>In <code>DemoApplication.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/xx&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> List.of(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="student-class">Student Class</h3>
<ul>
<li><p>Right click <code>com.example.demo</code> folder, click new package to create a <code>com.example.demo.student</code> package.</p></li>
<li><p>Create a <code>Student</code> class inside the package.</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> LocalDate dob;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Use Ctrl+Insert to generate construtors, getters, setters, toString quickly</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Long id, String name, String email, LocalDate dob, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.dob = dob;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String email, LocalDate dob, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.dob = dob;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalDate <span class="title function_">getDob</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDob</span><span class="params">(LocalDate dob)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dob = dob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, dob=&quot;</span> + dob +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And then go to <code>DemoApplication</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/xx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> List.of(</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Student</span>(</span><br><span class="line">					<span class="number">1L</span>,</span><br><span class="line">					<span class="string">&quot;Mariam&quot;</span>,</span><br><span class="line">					<span class="string">&quot;Mariam.jamal@gmail.com&quot;</span>,</span><br><span class="line">					LocalDate.of(<span class="number">2000</span>, Month.JANUARY, <span class="number">5</span>),</span><br><span class="line">					<span class="number">21</span></span><br><span class="line">			)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="api-layer">API Layer</h3>
<p>Create <code>StudentController</code> class inside student package, and remove relative code from <code>DemoApplication</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;api/v1/student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(</span><br><span class="line">                        <span class="number">1L</span>,</span><br><span class="line">                        <span class="string">&quot;Mariam&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Mariam.jamal@gmail.com&quot;</span>,</span><br><span class="line">                        LocalDate.of(<span class="number">2000</span>, Month.JANUARY, <span class="number">5</span>),</span><br><span class="line">                        <span class="number">21</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="business-layer-and-dependency-injection">Business Layer and Dependency Injection</h3>
<p>Create a <code>StudentService</code> class inside student package, and modify <code>StudentController</code> like below:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StudentService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component or @Service tells the class should be instantiated (It is a bean)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(</span><br><span class="line">                        <span class="number">1L</span>,</span><br><span class="line">                        <span class="string">&quot;Mariam&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Mariam.jamal@gmail.com&quot;</span>,</span><br><span class="line">                        LocalDate.of(<span class="number">2000</span>, Month.JANUARY, <span class="number">5</span>),</span><br><span class="line">                        <span class="number">21</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StudentController.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;api/v1/student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired annotation tells inject StudentService automatically</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentController</span><span class="params">(StudentService studentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.studentService = studentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.getStudents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Use dependency injection to inject <code>StudentService</code> into <code>StudentController</code>.</p>
<h3 id="create-database-and-properties-file">Create Database and Properties File</h3>
<p>Modify the <code>application.properties</code> file (Sometimes <code>username</code> and <code>password</code> are also needed.):</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:postgresql://localhost:5432/student</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string"></span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">create-drop</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.PostgreSQLDialect</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.format_sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>Install PostgreSQL. (Sometimes you need to turn on postgresql service in windows task manager.)</p>
<p>Enter psql using <code>psql</code> command or SQL Shell (psql). Use <code>\l</code> to see existed databases.</p>
<p>Then, create student database:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE student;</span><br></pre></td></tr></table></figure>
<p>Use <code>\du</code> to see list of roles.</p>
<p>Then, grant privileges:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> &quot;student&quot; <span class="keyword">TO</span> [username];</span><br></pre></td></tr></table></figure>
<p>Then, connect to student database:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\c student</span><br></pre></td></tr></table></figure>
<p>Use <code>\d</code> to see tables in student database.</p>
<p>Uncomment <code>spring-boot-starter-data-jpa</code> in <code>pom.xml</code></p>
<h3 id="jpa">JPA</h3>
<p>Modify <code>Student</code> class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@SequenceGenerator(</span></span><br><span class="line"><span class="meta">            name = &quot;student_sequence&quot;,</span></span><br><span class="line"><span class="meta">            sequenceName = &quot;student_sequence&quot;,</span></span><br><span class="line"><span class="meta">            allocationSize = 1</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@GeneratedValue(</span></span><br><span class="line"><span class="meta">            strategy = GenerationType.SEQUENCE,</span></span><br><span class="line"><span class="meta">            generator = &quot;student_sequence&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jpa-repository">JPA Repository</h3>
<p>Create a <code>StudentRepository</code> interface inside student package:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaRepository&lt;Type, ID Type&gt;</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Inject into <code>StudentService</code> class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StudentRepository studentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentService</span><span class="params">(StudentRepository studentRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.studentRepository = studentRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="saving-student">Saving Student</h3>
<p>Create a <code>StudentConfig</code> class inside student package:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CommandLineRunner <span class="title function_">commandLineRunner</span><span class="params">(StudentRepository repository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">mariam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(</span><br><span class="line">                    <span class="number">1L</span>,</span><br><span class="line">                    <span class="string">&quot;Mariam&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Mariam.jamal@gmail.com&quot;</span>,</span><br><span class="line">                    LocalDate.of(<span class="number">2000</span>, Month.JANUARY, <span class="number">5</span>),</span><br><span class="line">                    <span class="number">21</span></span><br><span class="line">            );</span><br><span class="line">            <span class="type">Student</span> <span class="variable">alex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(</span><br><span class="line">                    <span class="number">2L</span>,</span><br><span class="line">                    <span class="string">&quot;Alex&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Alex@gmail.com&quot;</span>,</span><br><span class="line">                    LocalDate.of(<span class="number">2004</span>, Month.JANUARY, <span class="number">5</span>),</span><br><span class="line">                    <span class="number">21</span></span><br><span class="line">            );</span><br><span class="line">            repository.saveAll(</span><br><span class="line">                    List.of(mariam, alex)</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Restart the server, and 2 students above will be saved in student database, and can be seen using <code>\d</code>.</p>
<h3 id="transient">Transient</h3>
<p>Add <code>@Transient</code> notation to <code>age</code>, since age can be calculated.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Period.between(<span class="built_in">this</span>.dob, LocalDate.now()).getYears();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Restart the server, and age will no longer be a column in the table.</p>
<h3 id="add-student">Add Student</h3>
<p>Use <code>@PostMapping</code> in <code>StudentController</code>.</p>
<p><code>@RequestBody</code> can map request body to class.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNewStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;</span><br><span class="line">    studentService.addNewStudent(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Click the network icon to generate http-client for testing:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">###</span><br><span class="line">POST http://localhost:8080/api/v1/student</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Bilal&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;bilal.ahmed@gmail.com&quot;,</span><br><span class="line">  &quot;dob&quot;: &quot;1995-12-17&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Complete <code>addNewStudent</code> method in <code>StudentService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    Optional&lt;Student&gt; studentOptional = studentRepository.findStudentByEmail(student.getEmail());</span><br><span class="line">    <span class="keyword">if</span> (studentOptional.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;email taken&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    studentRepository.save(student);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And <code>findStudentByEmail</code> method in <code>StudentRepository</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Query can be omitted</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT s FROM Student s WHERE s.email = ?1&quot;)</span></span><br><span class="line">Optional&lt;Student&gt; <span class="title function_">findStudentByEmail</span><span class="params">(String email)</span>;</span><br></pre></td></tr></table></figure>
<p>Modify <code>application.properties</code> to send error message to front end:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.error.include-message</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>
<h3 id="delete-student">Delete Student</h3>
<p>Use <code>@DeleteMapping</code> in <code>StudentController</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(path = &quot;&#123;studentId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@PathVariable(&quot;studentId&quot;)</span> Long studentId)</span> &#123;</span><br><span class="line">    studentService.deleteStudent(studentId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Complete <code>StudentService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteStudent</span><span class="params">(Long studentId)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> studentRepository.existsById(studentId);</span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;student with id &quot;</span> + studentId + <span class="string">&quot;does not exists&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    studentRepository.deleteById(studentId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update-student">Update Student</h3>
<p>Use <code>@PutMapping</code> in <code>StudentController</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(path = &quot;&#123;studentId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStudent</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable(&quot;studentId&quot;)</span> Long studentId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(required = false)</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(required = false)</span> String email</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    studentService.updateStudent(studentId, name, email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Complete <code>updateStudent</code> in <code>StudentService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStudent</span><span class="params">(Long studentId, String name, String email)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentRepository.findById(studentId)</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;student with id &quot;</span> + studentId + <span class="string">&quot; dose not exist&quot;</span></span><br><span class="line">            ));</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span> &amp;&amp; !Objects.equals(student.getName(), name)) &#123;</span><br><span class="line">        student.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (email != <span class="literal">null</span> &amp;&amp; email.length() &gt; <span class="number">0</span> &amp;&amp; !Objects.equals(student.getEmail(), email)) &#123;</span><br><span class="line">        Optional&lt;Student&gt; studentOptional = studentRepository.findStudentByEmail(email);</span><br><span class="line">        <span class="keyword">if</span> (studentOptional.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;email taken&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        student.setEmail(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="packaging">Packaging</h3>
<p>Stop the servers, open Maven panel, and run <code>clean</code>. It will delete the <code>target</code> folder.</p>
<p>Then run <code>install</code>, get the <code>target folder</code>. There is a <code>demo-0.0.1-SNAPSHOT.jar</code> file in this folder.</p>
<p>Open the terminal:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> target</span><br><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>Now the application is running.</p>
<p>And we can change the port by adding <code>--server.port=8081</code> at the end.</p>
<h2 id="generate-a-spring-boot-project">Generate a Spring Boot Project</h2>
<p><a href="https://start.spring.io/">Spring Initializr</a> configured into your Maven project</p>
<ul>
<li>The Spring app main class</li>
<li>The Spring Boot POM parent</li>
<li>The dependencies</li>
<li>The Spring Boot Maven plugin</li>
<li>The properties file</li>
</ul>
<h2 id="dependency-starter">Dependency Starter</h2>
<p>A dependency starter is a group of dependencies you add to configure your app for a specific purpose.</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/dependency-starter.jpg" alt="Dependency Starter" /><figcaption aria-hidden="true">Dependency Starter</figcaption>
</figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="the-spring-ecosystem">The Spring Ecosystem</h2>
<ul>
<li>Spring Core</li>
<li>Spring Model-View-Controller (MVC): Web application development.</li>
<li>Spring Data Access: Connect to SQL databases.</li>
<li>Spring Testing</li>
</ul>
<h2 id="springbootapplication"><span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span></h2>
<p>Enables</p>
<ul>
<li><strong><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></strong>: Automatically configure your Spring application based on the jar dependencies that you have added. (e.g., Configure database connection based on specified dependency)</li>
<li><strong><span class="citation" data-cites="ComponentScan">@ComponentScan</span></strong>: Enable scan <strong><span class="citation" data-cites="Component">@Component</span></strong>.</li>
<li><span class="citation" data-cites="*">@*</span>*Configuration**: Allow register extra beens in the context or import additional configuration classes.</li>
</ul>
<h2 id="spring-context">Spring Context</h2>
<p>The place in the app's memory where we add the object instances we want Spring to manage.</p>
<h3 id="bean"><span class="citation" data-cites="Bean">@Bean</span></h3>
<p>A bean is an object that is instantiated, assembled, and managed by a Spring IoC container.</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SpringContext.jpg" alt="Spring Context" /><figcaption aria-hidden="true">Spring Context</figcaption>
</figure>
<h3 id="configuration"><span class="citation" data-cites="Configuration">@Configuration</span></h3>
<p>Configuration class is a special class to instruct Spring to do specific actions.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  Parrot <span class="title function_">parrot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parrot</span>();</span><br><span class="line">    p.setName(<span class="string">&quot;Koko&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="component"><span class="citation" data-cites="Component">@Component</span></h3>
<p>Mark it as a component. Spring creates an instance of the class and adds that instance to its context.</p>
<h2 id="dependency-injection-di-in-spring">Dependency Injection (DI) in Spring</h2>
<h3 id="autowired"><span class="citation" data-cites="Autowired">@Autowired</span></h3>
<p>Defines the object that needs the dependency.</p>
<p>If there is a SMSService which implements MessageService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="field-based-injection">Field-Based Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MessageService messageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constructor-based-injection">Constructor-Based Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setter-based-injection">Setter-Based Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageService messageService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageService</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="qualifier"><span class="citation" data-cites="Qualifier">@Qualifier</span></h3>
<p>If there are multiple beans, we need use <span class="citation" data-cites="Qualifier">@Qualifier</span> to tell Spring which one is correct.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;SMSService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;EmailService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="field-base-injection">Field-Base Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier(&quot;SMSService&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> MessageService messageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constructor-based-injection-1">Constructor-Based Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(<span class="meta">@Qualifier(&quot;SMSService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setter-based-injection-1">Setter-Based Injection</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageService messageService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="meta">@Qualifier(&quot;SMSService&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageService</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="primary"><span class="citation" data-cites="Primary">@Primary</span></h3>
<p>We can also use <span class="citation" data-cites="Primary">@Primary</span> to indicate the default one.</p>
<h2 id="web-service">Web Service</h2>
<h3 id="controller"><span class="citation" data-cites="Controller">@Controller</span></h3>
<h3 id="restcontroller"><span class="citation" data-cites="RestController">@RestController</span></h3>
<p>Instruct Spring that all the controller's actions are REST endpoints.</p>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/hais-notebook/2020/01/29/JavaScript/</url>
    <content><![CDATA[<ul>
<li>JavaScript 有 8 种数据类型，3 种变量声明的方式</li>
<li>JavaScript 的数组不是典型的数组，而是一个对象；<strong>元素的数据类型可以不同，内存不一定连续，是通过字符串下标（而不是数字下标）获取元素</strong>。</li>
</ul>
<span id="more"></span>
<h1 id="startup">Startup</h1>
<h2 id="history">History</h2>
<p>1994 年，网景公司（当时叫 Mosaic Communications）发布了一款名为 <strong>Mosaic Netscape</strong> 的网页浏览器，在四个月内，这款浏览器就占据了四分之三的浏览器市场，并成为 1990 年代互联网的主要浏览器。</p>
<blockquote>
<p>因为世界最早流行的图形接口网页浏览器 <strong>NCSA Mosaic</strong> 是美国国家超级电脑应用中心（NCSA）与 1993 年发布的，网景公司为了避免版权纠纷，将浏览器改名为 <strong>Netscape Navigator</strong>，而公司则改名为 <strong>Netscape Communications</strong>。</p>
</blockquote>
<p>这款浏览器发布之后，网景意识到，<strong>光有静态的页面是不行的，需一种网页脚本语言，使得浏览器可以与网页互动。</strong></p>
<p>1995 年，昇阳（Sun）正式向市场推出 Java，网景公司看到 Java 的前景，决定与之结盟，并在浏览器中支持 Java，但如果直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂。</p>
<p>同年，网景招募了布兰登（Brendan Eich），授意其开发一款 <strong>“未来的脚本语言”</strong> ，这种语言需要：“看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手。”——这个决定就排除了 Perl、Python、Tcl 或 Scheme 这些选项，同时也促成了 JavaScript 的诞生。</p>
<p>由于对 Java 不感兴趣，布兰登只用了十天时间就设计出了这款语言的原型，并命名为 <strong>Mocha</strong>，后续又改名为 <strong>LiveScript</strong>，但在 1995 年 12 月，公司为了蹭 Java 的热度，改名为 <strong>JavaScript</strong>。而事实上，JavaScript 和 Java 关系并不大。</p>
<blockquote>
<p>总的来说，布兰登的设计思路是这样的：</p>
<ol type="1">
<li>借鉴 C 的基本语法；</li>
<li>借鉴 Java 的数据类型和内存管理；</li>
<li>借鉴 Scheme，将函数提升到“第一等公民”（first class）的地位；</li>
<li>借鉴 Self，使用基于原型（prototype）的继承机制。</li>
</ol>
</blockquote>
<p>由于 JavaScript 在浏览器上的大获成功，微软（Microsoft）在后续推出的 IE 3 上也使用了 <strong>JScript</strong> ——这与 JavaScript 是类似、但不同标准的语言。于是当年市场上出现了两者对峙的情况，网页设计者通常会在主页放上“用 Netscape可达到最佳效果 ”或“用 IE 可达到最佳效果”的标志。</p>
<p>1996 年 11 月，网景正式向 <strong>欧洲计算机制造商协会（ECMA）</strong> 提交语言标准；1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。自然 JavaScript 也成为了 ECMAScript 最著名的实现之一。</p>
<p>由于只有短短十天的设计时间，而且世界上之前没有出现过结合了函数式编程和对象编程的语言，以及发展的迅速导致没有时间调整设计，JavaScript 成功成为了有着众多设计缺陷的语言，在这里不做细谈。</p>
<p>2001 年，微软发布 Windows XP，并捆绑了 IE 6。由于 Windows XP 迅速爆火以及长期的垄断，IE 6 也随之占据非常高的市场份额。前文已经说过，IE 6 对 JavaScript 支持并不好，同时 IE 6 对 CSS 标准的支持也不尽完善，导致前端技术的发展进入了漫长的蛰伏期。</p>
<p>2004 年，谷歌（Google）发布爆款应用 Gmail。这款应用在刚推出时，容量就比起其他受欢迎的电子邮箱服务如雅虎和微软的 Hotmail 多出过百倍，成为市场爆品，同时也让众多开发者看到了页面交互的巨大前景和可能性。</p>
<p>2005 年，Jesse 将谷歌用到的技术命名为 AJAX。</p>
<p>2006 年，至今为止最为长寿的 JavaScript 库—— jQuery，发布。</p>
<p>2008 年，谷歌发布 Chrome 浏览器；同年，Chrome 的使用率上升至 1%。其使用高性能 JavaScript 引擎 V8。</p>
<p>2009 年，Ryan 基于 V8 写了 Node.js。</p>
<p>2010 年，Isaac 基于 Node.js 写了 npm。</p>
<p>2010 年，TJ 受 Sinatra 启发，写了 Express.js。赶上了这几波顺风车的 JavaScript 迅速发展，并将触手伸向了后端。自此，JavaScript 也能胜任后端的一些工作了。</p>
<p>2012 年，Chrome 全球占有率达到 33%，超越 IE 跃居首位。</p>
<p>2015 年 12 月，Chrome 中国占有率达到 37%，超越 IE。</p>
<h1 id="basic-syntax">Basic Syntax</h1>
<h2 id="表达式">表达式</h2>
<ul>
<li>表达式一般都有值，语句可能有也可能没有</li>
<li>语句一般会改变环境（声明、赋值），逗号表示语句没完</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>          <span class="comment">// 值为 3</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)      <span class="comment">// 值为函数的返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>    <span class="comment">// 值为函数本身</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) <span class="comment">// 值为函数的返回值：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p><code>retrun</code> 后面不能接回车，否则相当于返回 <code>undefined</code></p>
</div>
<h3 id="标识符">标识符</h3>
<p>在 JavaScript 中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。（有时候也可以用其他的 Unicode 字符，比如中文，比如 Emoji）</p>
<h3 id="代码块-block">代码块 block</h3>
<p>简单来说就是把代码用大括号包在一起</p>
<h3 id="for">for</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 5 5 5 5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<h3 id="label">label</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">a</span>:<span class="number">1</span> &#125; <span class="comment">// a 是一个 label，值是 1</span></span><br></pre></td></tr></table></figure>
<h2 id="值">值</h2>
<h3 id="字符存储">字符存储</h3>
<ul>
<li>如何存数字？十进制转二进制，用十六进制（HEX）表示二进制</li>
<li>如何存字符？转换为数字，48 号表示 0，65 号表示 A，97 号表示 a</li>
<li>如何表示汉字（GB、GBK）？0000~FFFF，16 位，2 字节</li>
<li>Unicode 已收录 13 万字符（大于 16 位），全世界通用，以后还会继续扩充；缺点：两个字节不够用了，至少要三个字节</li>
<li>UTF-8：通过变长的存法，减小容量</li>
</ul>
<h3 id="种数据类型">8 种数据类型</h3>
<blockquote>
<p>5 基 2 空 1 对象</p>
</blockquote>
<h4 id="number">Number</h4>
<blockquote>
<p>64 位浮点数组成</p>
</blockquote>
<h5 id="特殊值">特殊值</h5>
<p><code>0</code> <code>+0</code> <code>-0</code></p>
<p><code>Infinity</code> <code>+Infinity</code> (1/0) <code>-Infinity</code> (1/-0)</p>
<p><code>NaN</code>（0/0，但他还是一个数字，NaN 不等于 NaN）</p>
<h5 id="范围和精度">范围和精度</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Number-Range.png" alt="JSNumber的存储" /><figcaption aria-hidden="true">JSNumber的存储</figcaption>
</figure>
<p>范围：</p>
<ul>
<li>能准确表示的范围在 <code>Number.MAX_SAFE_INTEGER</code> 与 <code>Number.MIN_SAFE_INTEGER</code> 之间（- 2^53 + 1 ~ 2^53 - 1）</li>
<li>事实上能存储 <code>Number.MAX_VALUE</code> ~ <code>Number.MIN_VALUE</code> 的值（±1.7976931348623157 * 10^308），但由于只有 64 bit，所以有些值实际上是近似数</li>
</ul>
<p>精度：大概是 15 个十进制有效数字</p>
<h5 id="number-new-number"><code>Number()</code> &amp; <code>new Number()</code></h5>
<ul>
<li><code>Number(value)</code> 会将 <code>value</code> 转换为 Number 类型
<ul>
<li>几乎等价于 <code>+value</code>，除了对 Symbol 的处理有所不同</li>
<li>对于对象，会按照 <code>[@@toPrimitive]()</code> <code>valueOf</code> <code>toString()</code> 的顺序调用</li>
</ul></li>
<li><code>new Number()</code> 会创建一个 <code>Number</code> 对象，而不是属于基本类型 Number 的值，<code>new Number(42) !== 42</code> 但 <code>new Number(42) == 42</code></li>
<li>一般不使用 <code>new Number()</code></li>
</ul>
<h5 id="number.parsefloat-number.parseint-parsefloat-parseint"><code>Number.parseFloat()</code> &amp; <code>Number.parseInt()</code> &amp; <code>parseFloat()</code> &amp; <code>parseInt()</code></h5>
<ul>
<li><code>parseFloat === Number.parseFloat</code></li>
<li><code>parseInt === Number.parseInt</code></li>
<li><code>parseFloat()</code> 会将字符串转换为浮点数
<ul>
<li>如果不是字符串，会先被强制转换为字符串</li>
<li>字符串开头的空格会被忽略</li>
</ul></li>
<li><code>parseInt()</code> 将字符串转换为整数
<ul>
<li>接受两个参数，第二个参数是进制</li>
<li>其他与 <code>parseFloat</code> 相同</li>
</ul></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;December 17, 1995 03:24:00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面展示 Number parseInt parseFloat 和 + 的类型转换</span></span><br><span class="line"><span class="comment">// 如果其他没有写出来的，则表示与 Number 结果相同</span></span><br><span class="line"><span class="comment">// 如果 parseFloat 没有写出来，表示与 parseInt 相同</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>)                   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>)                 <span class="comment">// NaN, String(true) === &#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>)                  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>)                <span class="comment">// NaN, String(false) === &#x27;false&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)                   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>)                 <span class="comment">// NaN, String(null) === &#x27;null&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)              <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">undefined</span>)            <span class="comment">// NaN, String(undefined) === &#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;)                     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;&#125;)                   <span class="comment">// NaN, String(&#123;&#125;) === &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(object1)                <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">parseInt</span>(object1)              <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(date1)                  <span class="comment">// 819199440000</span></span><br><span class="line"><span class="built_in">parseInt</span>(date1)                <span class="comment">// NaN, String(date1) === &#x27;Sun Dec 17 1995 03:24:00 GMT+0800 (中国标准时间)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">12345678901234567890n</span>)  <span class="comment">// 12345678901234567000</span></span><br><span class="line">+<span class="number">12345678901234567890n</span>         <span class="comment">// Cannot convert a BigInt value to a number</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">12345678901234567890n</span>)<span class="comment">// 12345678901234567000, String(12345678901234567890n) === &#x27;12345678901234567890&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="title class_">Symbol</span>())               <span class="comment">// Cannot convert a Symbol value to a number</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">Symbol</span>())             <span class="comment">// Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;37.12&quot;</span>)                <span class="comment">// 37.12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;37.12&quot;</span>)              <span class="comment">// 37</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;37.12&quot;</span>)            <span class="comment">// 37.12</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;3122d&quot;</span>)                <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3122d&quot;</span>)              <span class="comment">// 3122</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;d3122&quot;</span>)                <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;37.12.12&quot;</span>)             <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;37.12.12&quot;</span>)           <span class="comment">// 37</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;37.12.12&quot;</span>)         <span class="comment">// 37.12</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;0x11&quot;</span>)                 <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;0b11&quot;</span>)                 <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0b11&quot;</span>)               <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;0o11&quot;</span>)                 <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0o11&quot;</span>)               <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)                     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>)                   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;      &quot;</span>)               <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;      &quot;</span>)             <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h5 id="number.isnan-isnan"><code>Number.isNaN()</code> &amp; <code>isNaN()</code></h5>
<ul>
<li><code>Number.isNaN</code> 更加健壮，他不会进行类型转换，他只对 <code>NaN</code> 返回 <code>true</code>，与 <code>x !== x</code> 等价</li>
<li>全局 <code>isNaN</code> 会先将值转换为 Number 类型，对所有转换为 Number 为 <code>NaN</code> 的，也会返回 <code>true</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;i&#x27;m a string&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>)      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;)             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>)           <span class="comment">// false, Number(true) === 1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>)           <span class="comment">// false, Number(null) === 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37.12&quot;</span>)        <span class="comment">// false, Number(&quot;37.12&quot;) === 37.12</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;3122d&quot;</span>)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>)             <span class="comment">// false, Number(&quot;&quot;) === 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;      &quot;</span>)       <span class="comment">// false, Number(&quot;      &quot;) === 0</span></span><br></pre></td></tr></table></figure>
<h4 id="string">String</h4>
<blockquote>
<p>每个字符两个字节（阉割版 UTF-8，两个字符定长）</p>
</blockquote>
<h5 id="写法">写法</h5>
<p>单引号、双引号、反引号，引号不是字符串的一部分</p>
<h5 id="转义">转义</h5>
<p><code>\r</code> 表示回车， <code>\uFFFF</code> 表示对应的 Unicode 字符， <code>\xFF</code> 表示前256个 Unicode 字符</p>
<h5 id="字符串的属性">字符串的属性</h5>
<p>字符串本来不应该有属性，只有对象才有属性，见下面的解释</p>
<ul>
<li>长度： <code>s.length</code></li>
<li>下标： <code>s[0]</code></li>
<li>base64 转码： <code>window.btoa</code> 编码， <code>window.atob</code> 反编码</li>
</ul>
<h5 id="string-new-string"><code>String()</code> &amp; <code>new String()</code></h5>
<ul>
<li><code>String()</code> 得到的是一个字符串基本类型</li>
<li><code>new String()</code> 得到的是一个对象</li>
<li>会发生强制类型转换，值得注意的是：
<ul>
<li><code>undefined</code> <code>null</code> 都会被转换成那几个英文字母</li>
<li>对于对象或其他非空的基本类型，会按照 <code>[@@toPrimitive]()</code> <code>toString()</code> <code>valueOf</code> 的顺序调用</li>
</ul></li>
</ul>
<h5 id="string-基本类型与-string-对象">String 基本类型与 String 对象</h5>
<blockquote>
<p>Boolean 和 Number 有同样的问题，都有基本类型和对象的区别</p>
</blockquote>
<ul>
<li>String 基本类型可以通过字面量（单双引号）或者 <code>String()</code> 的返回值得到</li>
<li>String 对象可以通过 <code>new String()</code> 获得，但通常不怎么使用</li>
<li>JavaScript 会自动检查访问基本类型 String 属性、或者在基本类型上调用方法的地方，并自动将其包裹成一个对象，访问对象上的属性或方法</li>
<li>他们在传给 <code>eval()</code> 的时候表现也有所不同：String 基本类型会被当成 JavaScript 源码，而 String 对象会被当做一个对象</li>
</ul>
<h4 id="boolean">Boolean</h4>
<blockquote>
<p>否定运算、相等运算、比较运算可以得到 bool 值</p>
</blockquote>
<div class="note warning"><p><strong>6 个 falsy 值</strong></p>
<p><code>undefined</code> <code>null</code> <code>0</code> <code>NaN</code> <code>''</code> <code>document.all</code></p>
</div>
<h4 id="symbol">Symbol</h4>
<blockquote>
<p>每个 Symbol 都不一样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Symbol</span>(<span class="number">123</span>) <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<h4 id="bigint">BigInt</h4>
<blockquote>
<p>BigInt 可以准确表示任何大小的整数值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the &quot;n&quot; at the end means it&#x27;s a BigInt</span></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure>
<h4 id="undefined">undefined</h4>
<p>如果声明了没有赋值，默认是 <code>undefined</code></p>
<p>如果函数没有写 <code>return</code>，默认是 <code>undefined</code></p>
<h4 id="null">Null</h4>
<p>习惯上把非对象空值写成 undefined，对象空值写成 null；</p>
<p>null 通常表示即该处不应该有值，undefined 通常表示"缺少值"，就是此处应该有一个值，但是还没有定义。</p>
<h4 id="object">Object</h4>
<div class="note warning"><p>数组、函数、日期都是 Object，不是单独的数据类型，但是使用 <code>typeof</code> 的时候，可以分辨出 function</p>
</div>
<h3 id="数据类型检测">数据类型检测</h3>
<h4 id="typeof-instanceof-tostring-的比较"><code>typeof</code> <code>instanceof</code> <code>toString</code> 的比较</h4>
<table>
<tr>
<td colspan="2">
类型
</td>
<td>
举例
</td>
<td colspan="2">
typeof
</td>
<td colspan="2">
instanceof
</td>
<td colspan="2">
Object.prototype.toString.call()
</td>
</tr>
<tr>
<td rowspan="5">
基本类型
</td>
<td>
Number
</td>
<td>
1
</td>
<td>
number
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object Number]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
String
</td>
<td>
'hello'
</td>
<td>
string
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object String]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Boolean
</td>
<td>
true
</td>
<td>
boolean
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object Boolean]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Symbol
</td>
<td>
Symbol()
</td>
<td>
symbol
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object Symbol]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
BigInt
</td>
<td>
12345678n
</td>
<td>
bigint
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object BigInt]
</td>
<td>
√
</td>
</tr>
<tr>
<td rowspan="4">
new 基本类型
</td>
<td>
new Number()
</td>
<td>
new Number(1)
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Number]**
</td>
<td>
√
</td>
</tr>
<tr>
<td>
new String()
</td>
<td>
new String('hello')
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object String]**
</td>
<td>
√
</td>
</tr>
<tr>
<td>
new Boolean()
</td>
<td>
new Boolean('false')
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Boolean]**
</td>
<td>
√
</td>
</tr>
<tr>
<td>
new BigInt()
</td>
<td colspan="7">
BigInt is not a constructor
</td>
</tr>
<tr>
<td rowspan="2">
空值
</td>
<td>
null
</td>
<td>
null
</td>
<td>
object
</td>
<td>
×
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object Null]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
undefined
</td>
<td>
undefined
</td>
<td>
undefined
</td>
<td>
√
</td>
<td>
false*
</td>
<td>
○
</td>
<td>
[object Undefined]
</td>
<td>
√
</td>
</tr>
<tr>
<td rowspan="6">
对象类型
</td>
<td>
普通对象
</td>
<td>
{a: '1', b: '2'}
</td>
<td>
object
</td>
<td>
√
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Object]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Array
</td>
<td>
[1, 2, 3]
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Array]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Function
</td>
<td>
function() {}
</td>
<td>
function
</td>
<td>
√
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Function]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Error
</td>
<td>
new Error()
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Error]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
Date
</td>
<td>
new Date()
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object Date]
</td>
<td>
√
</td>
</tr>
<tr>
<td>
RegExp
</td>
<td>
new RegExp()
</td>
<td>
object
</td>
<td>
○
</td>
<td>
true
</td>
<td>
√
</td>
<td>
[object RegExp]
</td>
<td>
√
</td>
</tr>
</table>
<p>*尽管我们直接使用 <code>1 instanceof Number</code> 会出现错误，但是我们可以自定义 <code>instanceof</code> 方法，让他可以判断基本类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimitiveNumber</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> instance === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">PrimitiveNumber</span> <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p>**基本类型与用 <code>new Constructor</code> 构造的用对象包裹的基本类型实际上是不一样的，特别是在 <code>Boolean</code> 上，这点需要注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boolean = <span class="literal">false</span></span><br><span class="line">!!boolean <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newBoolean = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line">!!newBoolean <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="自己实现一个-instanceof">自己实现一个 <code>instanceof</code></h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left) <span class="comment">// 相当于 left.__proto__</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="object.is-和"><code>Object.is</code> 和 <code>===</code></h4>
<p><code>Object.is</code> 修复了 <code>===</code> 的一些失误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">is</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// 修复 +0 和 -0 相等的问题</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 修复 NaN 和 NaN 不相等的问题</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="种变量声明的方式">3 种变量声明的方式</h3>
<h4 id="var">var</h4>
<ul>
<li>过时的，不好的</li>
<li>函数作用域</li>
<li>可以重复声明</li>
<li>可以先使用再声明</li>
<li>全局声明的 <code>var</code> 变量会变成 <code>window</code> 的属性</li>
</ul>
<h4 id="let">let</h4>
<ul>
<li>新的，更合理的</li>
<li>遵循块作用域</li>
<li>不能重复声明</li>
<li>可以赋值，也可以不赋值</li>
<li>必须先声明再使用</li>
<li>全局声明的 <code>let</code> 变量不会再变成 <code>window</code> 的属性</li>
<li><code>let</code> 配合 <code>for</code> 循环有奇效</li>
</ul>
<h4 id="const">const</h4>
<p>跟 <code>let</code> 几乎一样，但声明时必须赋值，且不能再更改</p>
<div class="note warning"><p>变量声明指定值的时候同时也指定了类型，但是 <strong>值和类型都可以随意变化</strong></p>
</div>
<h3 id="toprimitive-valueof-tostring"><code>toPrimitive</code> &amp; <code>valueOf</code> &amp; <code>toString</code></h3>
<table>
<tr>
<td colspan="2">
类型
</td>
<td>
举例
</td>
<td>
@<span class="citation" data-cites="toPrimitive">@toPrimitive</span>
</td>
<td>
valueOf
</td>
<td>
toString
</td>
</tr>
<tr>
<td rowspan="5">
基本类型
</td>
<td>
Number
</td>
<td>
1
</td>
<td>
-
</td>
<td>
返回数字基本类型
</td>
<td>
<p>
可以接受一个参数，表示进制
</p>
<p>
注意数字基本类型发生强制类型转换时（比如 <code>$&#123;someNumber&#125;</code>），并不会调用 Number.prototype.toString()，所以覆盖这个方法并不会影响到此种情况的类型转换结果
</p>
</td>
</tr>
<tr>
<td>
String
</td>
<td>
'hello'
</td>
<td>
-
</td>
<td>
返回字符串基本类型
</td>
<td>
与 valueOf 实现完全相同
</td>
</tr>
<tr>
<td>
Boolean
</td>
<td>
true
</td>
<td>
-
</td>
<td>
返回布尔基本类型
</td>
<td>
返回字符串 "true" "false"
</td>
</tr>
<tr>
<td>
Symbol
</td>
<td>
Symbol()
</td>
<td>
*1
</td>
<td>
与 toPrimitive 效果相同
</td>
<td>
*2
</td>
</tr>
<tr>
<td>
BigInt
</td>
<td>
12345678n
</td>
<td>
-
</td>
<td>
返回 BigInt 基本类型
</td>
<td>
返回一个去掉 n 的字符串
</td>
</tr>
<tr>
<td rowspan="6">
对象类型
</td>
<td>
普通对象
</td>
<td>
{a: '1', b: '2'}
</td>
<td>
默认没有，可以自己定义
</td>
<td>
对象自己，这是无意义的，因为 valueOf() 一般是用来转换成基本类型的，因此需要自己定义 valueOf
</td>
<td>
根据 this 返回 "[object Type]"
</td>
</tr>
<tr>
<td>
Array
</td>
<td>
[1, 2, 3]
</td>
<td>
-
</td>
<td>
-
</td>
<td>
调用 Array.prototype.join
</td>
</tr>
<tr>
<td>
Function
</td>
<td>
function() {}
</td>
<td>
-
</td>
<td>
-
</td>
<td>
根据 this 返回函数字符串
</td>
</tr>
<tr>
<td>
Error
</td>
<td>
new Error()
</td>
<td>
-
</td>
<td>
-
</td>
<td>
返回错误信息
</td>
</tr>
<tr>
<td>
Date
</td>
<td>
new Date()
</td>
<td>
*3
</td>
<td>
与 Date.prototype.getTime 效果相同
</td>
<td>
返回日期字符串
</td>
</tr>
<tr>
<td>
RegExp
</td>
<td>
new RegExp()
</td>
<td>
-
</td>
<td>
-
</td>
<td>
*4
</td>
</tr>
</table>
<p>*1. <code>Symbol.prototype[@@toPrimitive]</code> 会返回一个 Symbol 基本类型，其中的 <code>hint</code> 参数并没有被用到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&quot;example&quot;</span>)</span><br><span class="line">sym === sym[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>*2. <code>Symbol.prototype.toString</code> 需要提供一个 <code>this</code>，这个 <code>this</code> 应该是一个 Symbol 基本类型或 Symbol 对象。如果不提供正确的 <code>this</code>，它将会抛错，因为 <code>Symbol.prototype[@@toPrimitive]</code> 方法只会返回一个 Symbol 基本类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// Expected output: &quot;Symbol(desc)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="property">iterator</span>.<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// Expected output: &quot;Symbol(Symbol.iterator)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// Expected output: &quot;Symbol(foo)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(Symbol(&#x27;foo&#x27;) + &#x27;bar&#x27;);</span></span><br><span class="line"><span class="comment">// Expected output: Error: Can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure>
<p>*3. <code>Date.prototype[@@toPrimitive]</code> 会根据参数返回时间戳或者字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Depending on timezone, your results will vary</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;20 December 2019 14:48&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](<span class="string">&#x27;string&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;Fri Dec 20 2019 14:48:00 GMT+0800 (中国标准时间)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](<span class="string">&#x27;number&#x27;</span>));</span><br><span class="line"><span class="comment">// 1576824480000</span></span><br></pre></td></tr></table></figure>
<p>*4. <code>RegExp.prototype.toString</code> 会返回类似 <code>/source/flag</code> 的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;a+b+c&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;/a+b+c/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;a+b+c&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// &quot;/a+b+c/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;g&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// &quot;/bar/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// &quot;/\n/g&quot; (if your browser supports escaping)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>).<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// &quot;/\n/g&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<h4 id="number-1">Number</h4>
<ul>
<li>余数 <code>-x % 7</code> 为 <code>-(x % 7)</code></li>
<li>指数 <code>x ** 3</code></li>
<li>自增 <code>a++</code> 表达式的值是 <code>a</code> 加之前的值， <code>++a</code> 表达式的值是 <code>a</code> 加之后的值</li>
<li>求值运算符 <code>+</code>，附属运算符 <code>-</code></li>
</ul>
<h4 id="string-1">String</h4>
<ul>
<li>连接运算 <code>+</code></li>
</ul>
<div class="note warning"><p><code>number + string</code>，变成字符串</p>
<p><code>string - number</code>，变成数字</p>
</div>
<h3 id="比较运算符">比较运算符</h3>
<h4 id="section">==</h4>
<ul>
<li>模糊相等，发生自动类型转换，别用两个等于</li>
<li>JavaScript 三位一体</li>
</ul>
<h4 id="section-1">===</h4>
<p>全等，基本类型看值是否相等，对象看地址是否相等</p>
<ul>
<li><code>[] !== []</code></li>
<li><code>&#123;&#125; !== &#123;&#125;</code></li>
<li><code>NaN !== NaN</code></li>
</ul>
<h3 id="布尔运算符">布尔运算符</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span> &amp;&amp; <span class="variable language_">console</span>.<span class="property">log</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 防止 console.log 报错（防御性编程）</span></span><br><span class="line">a = a || <span class="number">100</span> <span class="comment">// 但是五个 falsy 值都会让 a 为假，因此有 bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用函数来赋初值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">n = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="短路逻辑">短路逻辑</h4>
<h5 id="section-2">&amp;&amp;</h5>
<p>如果前面是 <strong>真的</strong>，就执行后面的（若前面是假的，表达式的值为前面；若前面是真的，表达式的值为后面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">f1</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;f1 存在&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span> &amp;&amp; <span class="variable language_">console</span>.<span class="property">log</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 因为 IE 没有 console.log，所以可以这样写防止出错</span></span><br></pre></td></tr></table></figure>
<h5 id="section-3">||</h5>
<p>如果前面是 <strong>假的</strong>，就执行后面的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a || <span class="number">100</span> <span class="comment">// 可以用于设置保底值</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制运算符">二进制运算符</h3>
<h4 id="或与">或与</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> | <span class="number">0b1010</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 1111</span></span><br><span class="line">(<span class="number">0b1111</span> &amp; <span class="number">0b1010</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>
<h4 id="否">否</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(~<span class="number">0b0101</span>).<span class="title function_">toString</span>(<span class="number">2</span>)         <span class="comment">// -110 (-6)</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> (<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>然后进行位运算（比如这里的按位取反）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> (-<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这里其实是使用的二进制补码，最高位表示 -2^32，次高位表示 +2^31，当 32 位全为 1 时，表示 - 1，可以通过“按位取反再加一”的方式快速获取他的相反数（在这里就是 6）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 按位取反</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span> <span class="comment">// +1，得到 6</span></span><br></pre></td></tr></table></figure>
<p>执行按位操作后，结果将转换回 64 位 JavaScript 数，也就是 <code>-110</code></p>
<p>另外一个有趣的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(~-<span class="number">0b0101</span>).<span class="title function_">toString</span>(<span class="number">2</span>)  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>先获得其 32 位表达（因为有符号，因此要按位取反再加一得到补码）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> (-<span class="number">0101</span>)</span><br></pre></td></tr></table></figure>
<p>再进行否运算：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br></pre></td></tr></table></figure>
<h4 id="异或">异或</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> ^ <span class="number">0b1010</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>按位取反可以用 <code>^1111</code>，有多少位就有多少个 <code>1</code></p>
</div>
<h4 id="左移和右移">左移和右移</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt; <span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">(<span class="number">0b0010</span> &lt;&lt; <span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h4 id="头部补零的右移运算符">头部补零的右移运算符</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt;&gt; <span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="使用运算符判断奇偶">使用运算符判断奇偶</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">偶数 &amp; <span class="number">1</span> === <span class="number">0</span></span><br><span class="line">奇数 &amp; <span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-来取整">使用 <code>~</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> <code>|</code> 来取整</h4>
<blockquote>
<p>位运算不支持小数，会自动抹去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~ <span class="number">6.83</span> <span class="comment">// 6</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> | <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt;&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-来交换-a-b-的值">使用 <code>^</code> 来交换 <code>a</code> <code>b</code> 的值</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版语法</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
<h3 id="其他运算符">其他运算符</h3>
<h4 id="点运算符">点运算符</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 属性值</span><br></pre></td></tr></table></figure>
<h4 id="void-运算符">void 运算符</h4>
<blockquote>
<p>求表达式的值或执行语句，然后 <code>void</code> 的值总为 <code>undefined</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 表达式或语句</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止假动作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;example.com&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;hi&#x27;); return false;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(console.log(&#x27;hi&#x27;))&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="逗号运算符">逗号运算符</h4>
<blockquote>
<p>表示取后面的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// a 为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = x =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>); <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = x =&gt; (<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>), x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 跟上面是一样的，先执行 console.log，再让 return 为x + 1</span></span><br></pre></td></tr></table></figure>
<h3 id="优先级">优先级</h3>
<p>圆括号的优先级最高</p>
<h2 id="es6">ES6</h2>
<p>作用域、箭头函数、默认参数、展开运算符、模板字符串、解构赋值、import export、class、for of、Generator、新的数据类型（Symbol、Map、Set）</p>
<h2 id="generator">Generator</h2>
<h3 id="function">function*</h3>
<p>生成器是一个带星号的“函数”（其实他并不是真正的函数），可以通过 <code>yield</code> 关键字暂停执行和恢复执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: function, done: false &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: 3, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>调用 <code>gen()</code> 之后，程序会阻塞住，不会执行任何语句</li>
<li>调用 <code>g.next()</code> 之后，程序会继续执行，直到遇到 <code>yield</code></li>
<li><code>next</code> 方法会返回一个对象，有 <code>value</code> 和 <code>done</code> 属性，<code>value</code> 为 当前 <code>yield</code> 后面的结果，<code>done</code> 表示是否执行完，遇到 <code>return</code> 后，<code>done</code> 变为 <code>true</code></li>
</ol>
<h3 id="yield">yield*</h3>
<p><code>yield*</code> 可以实现生成器的套娃：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">gen2</span>()</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会按 1 2 3 4 的顺序执行</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器的实现机制协程">生成器的实现机制：协程</h3>
<p>一个线程可以存在多个协程，协程不受操作系统的管理，而是被具体的应用程序代码所控制，因此没有进程的上下文切换的开销，性能高。</p>
<p>一个线程一次只能执行一个协程，可以通过 <code>yield</code> 暂停当前协程，并将 JS 线程的控制权转移给另一个协程。</p>
<h3 id="generator-与异步">Generator 与异步</h3>
<h4 id="thunk-函数">thunk 函数</h4>
<p>thunk 函数即偏函数，核心是接受一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能，相当于一群函数的抽象和封装</p>
<h4 id="generator-与异步-1">Generator 与异步</h4>
<h5 id="thunk">thunk</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">readFileThunk</span> = (<span class="params">filename</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;001.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;002.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data2.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>()</span><br><span class="line"><span class="comment">// value 值即为 thunk 生成的定制化函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="title function_">value</span>(<span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到上一次的结果，调用 next，将结果作为参数传入</span></span><br><span class="line">  g.<span class="title function_">next</span>(data1).<span class="title function_">value</span>(<span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将上面的代码进行封装，减少嵌套</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params">err, data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.<span class="title function_">next</span>(data)</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">done</span>) <span class="keyword">return</span></span><br><span class="line">    res.<span class="title function_">value</span>(next)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">run</span>(g)</span><br></pre></td></tr></table></figure>
<h5 id="promise">Promise</h5>
<p>也可以用 Promise 来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">readFilePromise</span> = (<span class="params">filename</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;001.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data1.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;002.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data2.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGenPromise</span>(<span class="params">gem ,data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gen.<span class="title function_">next</span>(data).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getGenPromise</span>(g).<span class="title function_">then</span>(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getGenPromise</span>(g, data1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getGenPromise</span>(g, data2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="object-1">Object</h1>
<h2 id="创建对象">创建对象</h2>
<p>对象有以下这样几种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的简便声明</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;harvey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象的标准写法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;harvey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对象也可以作为参数直接传入函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;harvey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这里我们需要注意以下几个细节：</p>
<ul>
<li>键名是字符串，不是标识符，可以是任意字符</li>
<li>引号可以省略，省略之后就只能写标识符或者以数字开头</li>
<li><strong>就算引号省略了，键名也还是字符串</strong>（不一定，键名也可能是函数、日期、正则等）</li>
<li>奇怪的属性名： <code>1e2</code> 会变成 <code>'100'</code>， <code>.234</code> 会变成 <code>'0.234'</code>， <code>0xFF</code> 会变成 <code>'255'</code></li>
<li>变量也可以作为属性名，比如：<code>let obj = &#123; [p1]: 'harvey' &#125;</code>，这样就会用 <code>p1</code> 里面的值了，<strong>中括号里面的东西都会先求值</strong></li>
</ul>
<h2 id="对象的属性">对象的属性</h2>
<h3 id="隐藏的属性">隐藏的属性</h3>
<ul>
<li><p><strong>每一个</strong> 对象都有一个隐藏属性 <code>__proto__</code>，这个属性存着 <strong>一个对象的地址</strong>，这个对象包含了这类对象（普通对象、数组、函数等）的 <strong>共有属性</strong></p></li>
<li><p><code>__proto__</code> 里面存的实际上就是 <strong>原型的地址</strong></p></li>
<li><p>因此，<strong>每一个对象都有原型</strong></p></li>
<li><p>比如 <code>obj = &#123;&#125;</code>，他的原型的地址就存储在 <code>obj.__proto__</code> 中，而<code>obj.__proto__</code> 也是一个对象，因此他也有原型，但我们规定，他的原型值为 <code>null</code></p></li>
</ul>
<h3 id="属性的删除">属性的删除</h3>
<p>有以下两种删除对象属性的方法：</p>
<ol type="1">
<li><code>obj.name = undefined</code>，这样做只会删除属性的值，不会把属性完全删除</li>
<li><code>delete obj.name</code>，同时删除属性名和属性值，或者用 <code>delete obj['name']</code> 也是可以的</li>
</ol>
<p>删除完成后可以对删除的结果进行检查：</p>
<ol type="1">
<li><code>'name' in obj</code>，检查 <code>'name'</code> 是不是 <code>obj</code> 的属性名，如果是用上面的第一种方法删除，检查的结果将是 <code>true</code>；如果是第二种方法删除，则会返回 <code>false</code>；注意属性名有引号（因为属性名实际上是字符串）</li>
<li><code>'name' in obj &amp;&amp; obj.name === undefined</code>，检查是否含有属性名且值为 <code>undefined</code>，如果是上面第一种方法删除，则会返回 <code>true</code></li>
</ol>
<h3 id="属性的查看">属性的查看</h3>
<ul>
<li><code>Object.keys(obj)</code>，查看 <code>obj</code> 的 <strong>自身</strong> 属性名</li>
<li><code>Object.values(obj)</code>，查看 <code>obj</code> 的 <strong>自身</strong> 属性值</li>
<li><code>Object.entries(obj)</code>，返回结果包含两个数组，第一个数组是 <code>obj</code> 的 <strong>自身</strong> 属性名，第二个数组是 <code>obj</code> 的 <strong>自身</strong> 属性值</li>
<li><code>console.dir(obj)</code>，查看 <code>obj</code> 的 <strong>自身属性 + 共有属性</strong></li>
<li><code>in</code>，查看是不是 <strong>自身属性 + 共有属性</strong> （相当于所有属性）</li>
<li><code>obj.hasOwnProperty('toString')</code>，查看 <code>'toString'</code> 是不是 <code>'obj'</code> <strong>自身的</strong> 属性</li>
</ul>
<div class="note warning"><p><code>obj.name</code> 等价于 <code>obj['name']</code>，不等价于 <code>obj[name]</code></p>
</div>
<h3 id="添加或修改属性">添加或修改属性</h3>
<p>直接赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;harvey&#x27;</span></span><br><span class="line">obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;harvey&#x27;</span></span><br><span class="line">obj[<span class="string">&#x27;na&#x27;</span> + <span class="string">&#x27;me&#x27;</span>] = <span class="string">&#x27;harvey&#x27;</span> <span class="comment">// 因为属性名本质是字符串，上面三句话实际上是一样的</span></span><br></pre></td></tr></table></figure>
<p>批量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, &#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span>, <span class="attr">p3</span>: <span class="number">3</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>但是，不能直接修改共有属性（原型上的属性）：比如，不能通过 <code>obj.toString</code> 来修改原型上的 <code>'toString'</code>，这样只会为 <code>obj</code> 增添一个本身的 <code>'toString'</code> 属性，而不会修改原型，除非这样写代码（但是这是不推荐的）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型的属性</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">toString</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> =</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(common)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">person.<span class="property">__proto__</span> = common <span class="comment">// 原型链增加一个环节</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的原型">对象的原型</h2>
<div class="note warning"><p>所有的函数自带 prototype（箭头函数没有 prototype）</p>
<p>prototype 中自带 constructor</p>
<p>constructor 里面的东西就是函数的内容</p>
</div>
<h3 id="new-x">new X()</h3>
<ol type="1">
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>X.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现一个类似 new 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">X</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a + <span class="number">1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">b</span> = b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title function_">X</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NEW</span>(<span class="params">fun, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fun.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="comment">// 相当于</span></span><br><span class="line">  <span class="comment">// let newObj = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// newObj.__proto__ = fun.prototype</span></span><br><span class="line">  <span class="keyword">const</span> result = fun.<span class="title function_">apply</span>(newObj, args)</span><br><span class="line">  <span class="comment">// 原版的 new 中，如果构造函数返回一个对象，则 new 也返回一个对象；如果构造函数返回一个简单类型，则 new 返回刚刚创建的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = <span class="title function_">NEW</span>(X, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-x">构造函数 <code>X</code></h3>
<ul>
<li><code>X</code> 自身用于添加新对象的<strong>自身的属性</strong></li>
<li><code>X.prototype</code> 负责保存对象的<strong>共用属性</strong></li>
</ul>
<p>一般来讲有这样的代码规范：</p>
<ul>
<li>所有构造函数首字母大写，被构造出来的对象首字母小写</li>
<li><code>new</code> 后面的函数使用名词；其他的函数一般用动词开头</li>
</ul>
<h3 id="如何确定一个对象的原型">如何确定一个对象的原型？</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(对象) === 对象.<span class="property">__proto__</span> === 其构造函数.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型与对象的分类">数据类型与对象的分类</h3>
<blockquote>
<p>数据类型是 JavaScript 数据的类型，一共有 8 种；</p>
<p>对象的分类则有无数种，常见的有 Array、Function、Date、RegExp 等</p>
</blockquote>
<p>我们常见的有这几种类型的对象：</p>
<ul>
<li>数组对象
<ul>
<li>自身属性：<code>'0'</code> <code>'1'</code> <code>'2'</code> <code>'length'</code></li>
<li>共有属性：<code>'push'</code> <code>'pop'</code> <code>'shift'</code> <code>'unshift'</code> <code>'join'</code></li>
</ul></li>
<li>函数对象
<ul>
<li>自身属性：<code>'name'</code> <code>'length'</code></li>
<li>共有属性：<code>'call'</code> <code>'apply'</code> <code>'bind'</code></li>
</ul></li>
</ul>
<h2 id="valueof-tostring">valueOf &amp; toString</h2>
<h2 id="其他问题">其他问题</h2>
<blockquote>
<p><strong>Q: window 是谁构造出来的？</strong></p>
<p>A: <code>Window</code>，可以通过 constructor 属性看出构造者</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Object 是谁构造的？</strong></p>
<p>A: window.Function，所有的函数都是 window.Function 构造的</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Function 是谁构造的？</strong></p>
<p>A: window.Function，所有的函数都是 window.Function 构造的，浏览器构造了 Function，然后指定它的构造者是自己</p>
</blockquote>
<h1 id="array">Array</h1>
<h2 id="获得新数组">获得新数组</h2>
<h3 id="将类数组转化为数组">将类数组转化为数组</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>
<h3 id="新建数组">新建数组</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的简便定义</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的标准写法</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者只传入一个参数，表示数组的长度</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="转化为数组">转化为数组</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以&#x27;,&#x27;分隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;1,2,3&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有间隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;123&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象转换</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转化为字符串</span></span><br><span class="line"><span class="keyword">let</span> str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>数组对象除了 <code>__proto__</code> 之外，还包括 <strong>索引</strong> 和 <strong>长度（<code>length</code>）</strong> 这两个自身属性。</p>
<div class="note warning"><p><strong>伪数组</strong>：伪数组的原型链中没有数组的原型</p>
<p>比如 <code>let divList = document.querySelector('div')</code> 将得到一个伪数组；一个普通的对象只是加上 <code>length</code> 属性，也将得到一个伪数组。</p>
<p>通常我们需要把它转化为数组来使用</p>
<p><code>let divArray = Array.from(divList)</code></p>
</div>
<h3 id="合并数组">合并数组</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr1.<span class="title function_">concat</span>(arr2) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h3 id="截取数组">截取数组</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.<span class="title function_">slice</span>(<span class="number">2</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h3 id="复制数组">复制数组</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.<span class="title function_">slice</span>(<span class="number">0</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];  <span class="keyword">delete</span> arr[<span class="string">&#x27;0&#x27;</span>]</span><br><span class="line"><span class="comment">// arr 为 [ empty, &#x27;b&#x27;, &#x27;c&#x27;]，如果3个都是 empty，称为稀疏数组，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改 length 也可以删除数组的元素，不推荐</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">shift</span>()</span><br><span class="line"><span class="comment">// 删除最开始的元素，并返回他，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">pop</span>()</span><br><span class="line"><span class="comment">// 删除最后一个元素，并返回他，arr 被修改</span></span><br><span class="line"> </span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，并返回删除的部分，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，增加 &#x27;x&#x27; 和 &#x27;y&#x27;</span></span><br><span class="line"><span class="comment">// 并返回删除的部分，arr 被修改</span></span><br></pre></td></tr></table></figure>
<h2 id="查找元素">查找元素</h2>
<h3 id="遍历元素">遍历元素</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`$(index) : $(item)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两种基本没有区别</span></span><br><span class="line"><span class="comment">// 但 for 关键字有 continue 和 break，forEach 没有</span></span><br><span class="line"><span class="comment">// for 是块级作用域，forEach 是函数作用域</span></span><br></pre></td></tr></table></figure>
<h3 id="查找单个元素">查找单个元素</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">indexOf</span>(item) <span class="comment">// 有就会返回 index，没有就会返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>) </span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素</span></span><br><span class="line">arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素对应的索引</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>索引越界</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[arr.<span class="property">length</span>] === <span class="literal">undefined</span></span><br><span class="line">a[-<span class="number">1</span>] === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
</div>
<h2 id="增加元素">增加元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>()</span><br><span class="line"><span class="comment">// 在尾部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">unshift</span>()</span><br><span class="line"><span class="comment">// 在头部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">8</span>, <span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment">// 增加 &#x27;x&#x27; 和 &#x27;y&#x27;，并返回删除的部分（[]），arr 被修改</span></span><br></pre></td></tr></table></figure>
<h2 id="修改元素">修改元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reverse</span>() <span class="comment">// arr 被修改</span></span><br><span class="line">arr.<span class="title function_">sort</span>() <span class="comment">// arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>( <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( a &gt; b ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a === b ) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回 1，a 在 b 之后</span></span><br><span class="line"><span class="comment">// 返回 0，不变</span></span><br><span class="line"><span class="comment">// 返回 -1，b 在 a 之后</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">score</span> - b.<span class="property">score</span>) <span class="comment">// 按 score 从小到大排序</span></span><br></pre></td></tr></table></figure>
<h2 id="数组变换">数组变换</h2>
<p>得到新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map： n 变 n</span></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter：n 变少</span></span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce：n 变 1</span></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item, <span class="number">0</span>)</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result.<span class="title function_">concat</span>(item * item), [])</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span></span><br><span class="line">  result.<span class="title function_">concat</span>(item % <span class="number">2</span> === <span class="number">1</span> ? [] : item), [])</span><br></pre></td></tr></table></figure>
<h1 id="function-1">Function</h1>
<h2 id="定义一个函数">定义一个函数</h2>
<h3 id="具名函数">具名函数</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(形参) &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数">匿名函数</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">function</span>(<span class="params">形参</span>) &#123; 函数体 &#125; <span class="comment">// 右边的部分也叫函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">形参</span>)&#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 如果函数的声明是在 = 右边</span></span><br><span class="line"><span class="comment">// fn 的作用域只能在 = 右边</span></span><br><span class="line"><span class="comment">// 别的地方可以用 fn 这个名字</span></span><br></pre></td></tr></table></figure>
<h3 id="使用构造函数">使用构造函数</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Function</span>()</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数">箭头函数</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入参数 =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> 语句</span><br><span class="line">&#125;</span><br><span class="line">x =&gt; (&#123; <span class="attr">name</span>: <span class="string">&#x27;...&#x27;</span> &#125;) <span class="comment">// 如果要返回对象，就要加圆括号</span></span><br></pre></td></tr></table></figure>
<h3 id="函数提升">函数提升</h3>
<p>函数可以先使用再声明，因为 function 会跑到最前面</p>
<p>但是 <code>let fn = function()&#123;&#125;</code> 不是函数提升，他不能先使用再声明，因为这句话是赋值，右边的匿名函数不会提升</p>
<h2 id="作用域">作用域</h2>
<ul>
<li><strong>全局变量与局部变量</strong>：在 <strong>顶级作用域</strong> 声明的变量是全局变量（比如 window 上的变量是全局变量）；其他的都是局部变量</li>
<li><strong>就近原则</strong>：如果有多个作用域有同名变量 <code>a</code>，那么查找 <code>a</code> 的声明时，就向上取最近的作用域</li>
<li><strong>作用域的确定与函数的执行无关（JavaScript 的作用域为静态作用域），但变量的值在函数执行的时候才能确定</strong></li>
</ul>
<h3 id="闭包">闭包</h3>
<blockquote>
<p>函数用到了外部的变量，则函数+这个变量=闭包，作用域遵循就近原则</p>
</blockquote>
<p>闭包的作用：隐藏局部变量，暴露操作函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">createAdd</span>()</span><br><span class="line"><span class="title function_">add</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">add</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>闭包的缺点：容易内存泄露。注意，虽然闭包并不会造成内存泄露，真实原因是 JS 引擎的实现有问题。</p>
<h2 id="参数">参数</h2>
<h3 id="参数传递">参数传递</h3>
<p>复制内存图中 stack 里面的东西（简单类型复制值，对象复制地址）</p>
<h3 id="形参">形参</h3>
<p>实际上就是变量声明： <code>var x = arguments[0]</code></p>
<div class="note warning"><p>形参可多可少</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="variable language_">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值">返回值</h2>
<ul>
<li>每个函数都有返回值，默认是 <code>undefined</code></li>
<li>只有函数才有返回值</li>
</ul>
<h2 id="调用栈">调用栈</h2>
<ul>
<li>JS 在调用函数之前，需要把函数的环境 push 到一个数组（调用栈）里面，等函数执行完之后把环境 pop 出来，然后 return 到之前的环境中</li>
<li>递归很容易把栈压满：爆栈</li>
<li>调用栈最长有多少？Chrome 12578；Firefox 26773；Node 12536</li>
</ul>
<h2 id="this-和-arguments">this 和 arguments</h2>
<blockquote>
<p>关于 this 更多的内容可以看看这篇文章—— <a href="https://hais-teatime.com/post/2019-12-24-this/">再看 this</a>。</p>
</blockquote>
<h3 id="arguments">arguments</h3>
<p>调用函数即传入 arguments， arguments 是包含传入参数的伪数组</p>
<h3 id="this">this</h3>
<ul>
<li><code>this</code> 的存在是为了解决函数获取一个对象的引用的问题</li>
<li>如果不给任何的条件， <code>this</code> 为 <code>window</code></li>
<li>如果想要指定 <code>this</code>，要用 <code>fn.call(xxx, 1, 2, 3)</code> 传入 <code>this</code> 和 <code>arguments</code>（如果传入的 <code>this</code> 不是对象，将会默认封装成对象，除非加上 <code>'use strict'</code>，JS的糟粕）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this: &#x27;</span> + <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="number">1</span>) <span class="comment">// &#x27;this: 1&#x27;</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &#x27;this: undefined&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="两种调用函数的方法">两种调用函数的方法</h4>
<h5 id="隐式传递">隐式传递</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.<span class="title function_">sayHi</span>()</span><br><span class="line"><span class="comment">// 会自动地把 person 传到函数里，作为 this</span></span><br></pre></td></tr></table></figure>
<h5 id="显式传递">显式传递</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.<span class="property">sayHi</span>.<span class="title function_">call</span>(person)</span><br><span class="line"><span class="comment">// 手动把 person 传到函数里，作为 this</span></span><br><span class="line"><span class="comment">// apply 跟 call 的区别就是后面要加中括号（参数传的是数组）</span></span><br></pre></td></tr></table></figure>
<h4 id="绑定-this">绑定 this</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">p1, p2</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, p1, p2) &#125;</span><br><span class="line"><span class="keyword">let</span> f3 = f1.<span class="title function_">bind</span>( &#123;<span class="attr">name</span>:<span class="string">&#x27;hai&#x27;</span>&#125;, <span class="string">&#x27;hi&#x27;</span> )</span><br><span class="line"><span class="title function_">f3</span>()  <span class="comment">// 等价于 f1.call( &#123;name:&#x27;hai&#x27;&#125;, &#x27;hi&#x27; )</span></span><br><span class="line">      <span class="comment">// 相当于让 f3 的 this 和 arguments 永远等于这个</span></span><br></pre></td></tr></table></figure>
<h4 id="箭头函数-1">箭头函数</h4>
<p>没有 <code>arguments</code> 和 <code>this</code>，里面的 <code>this</code> 就是外面的 <code>this</code>，就算加 <code>call</code> 也没有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// window</span></span><br><span class="line">fn.<span class="title function_">call</span>( &#123;<span class="attr">name</span>:<span class="string">&#x27;hai&#x27;</span>&#125; ) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<h2 id="立即执行函数">立即执行函数</h2>
<p>只想要一个局部变量，而不想要一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="regexp">/-/</span><span class="number">1</span>*/! <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">var</span> a = <span class="number">2</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(a) &#125; ()</span><br><span class="line"><span class="comment">// 声明了一个全局函数，立即调用</span></span><br></pre></td></tr></table></figure>
<h1 id="javascript-world">JavaScript World</h1>
<h2 id="开机">开机</h2>
<h3 id="固件">固件</h3>
<ul>
<li>固件是固定在主板上的存储设备，里面有开机程序</li>
<li>开机程序会将文件里的 OS 加载到内存里运行</li>
</ul>
<h3 id="操作系统以-linux-为例">操作系统（以 Linux 为例）</h3>
<ul>
<li>首先加载操作系统内核</li>
<li>然后启动初始化进程，编号为 1，每个进程都有 PID</li>
<li>启动系统服务：文件、安全、联网</li>
<li>等待用户登录：输入密码登录 / ssh 登录</li>
<li>登录后，运行 shell，用户就可以和操作系统对话了</li>
<li>bash 是一种 shell，图形化界面可认为是一种 shell</li>
</ul>
<h2 id="打开浏览器">打开浏览器</h2>
<h3 id="chrome.exe">chrome.exe</h3>
<ul>
<li>运行 chrome.exe 文件</li>
<li>开启 chrome 进程，作为主进程</li>
<li>主进程会开启一些辅助进程，如网络服务、GPU 加速</li>
<li>每新建一个标签，就有可能开启一个子进程</li>
</ul>
<h3 id="浏览器的功能">浏览器的功能</h3>
<ul>
<li>发起请求、下载 HTML、解析 HTML、下载 CSS、解析 CSS、渲染界面、下载 JS、解析 JS、执行 JS</li>
<li>功能模块：用户界面、渲染引擎、JS 引擎、存储等，这些功能模块属于不同的线程
<ul>
<li>JS 通过<strong>跨线程通信</strong>，使渲染引擎重新渲染</li>
<li>JS 是单线程的</li>
<li>DOM 操作慢：跨线程通信慢</li>
</ul></li>
</ul>
<h3 id="javascript-引擎">JavaScript 引擎</h3>
<ul>
<li>浏览器用的什么 JS 引擎？
<ul>
<li>Chrome 用的是 V8 引擎，C++ 编写</li>
<li>网景用的是 SpiderMonkey，后被 Firefox 使用，C++</li>
<li>Safari 用的是 JavaScriptCore</li>
<li>IE 用的是 Chakra（JScript 9）</li>
<li>Edge 用的是 Chakra (JavaScript)</li>
<li>Node.js 用的是 V8 引擎</li>
</ul></li>
<li>主要功能
<ul>
<li>编译：把 JS 代码翻译为机器能执行的字节码或机器码</li>
<li>优化：改写代码，使其更加高效</li>
<li>执行：执行上面的字节码或机器码</li>
<li>垃圾回收：把 JS 用完的内存回收，方便之后再次使用</li>
</ul></li>
</ul>
<h3 id="运行-javascript-代码">运行 JavaScript 代码</h3>
<ul>
<li>准备工作
<ul>
<li>提供 API： window、document、setTimeout（这些功能成为运行环境 runtime env）</li>
</ul></li>
<li>内存图
<ul>
<li><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/RAM-Graph.png" title="fig:" alt="内存图" /></li>
<li>红色区域（存放数据，但不会存变量名）
<ul>
<li>Stack 栈：每个数据顺序存放，非对象都存在 Stack</li>
<li>Heap 堆：每个数据随机存放，对象都存在 Heap（数组、函数）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="堆内存与栈内存">堆内存与栈内存</h3>
<p>JS 的内存空间分为</p>
<ul>
<li>栈（Stack）：存放简单类型，LIFO</li>
<li>堆（Heap）：存放引用类型，是一种经过排序的树形结构，每个节点都有一个值，通常说的堆是指二叉堆，存取随意</li>
<li>池（一般也被归类为栈中）：存放常量，故又称常量池</li>
</ul>
<h4 id="堆与栈的优缺点">堆与栈的优缺点</h4>
<ul>
<li>栈内存系统效率高，因为堆内存需要分配空间和地址，还要把地址存在栈内存中，因此效率低</li>
<li>引用类型变量大小不确定，如果放到栈内存中就无法轻易改变自己的大小，同时也浪费空间</li>
</ul>
<p>闭包中的变量保存在堆内存中，而不是栈内存中，因此函数调用之后闭包仍然能够引用到函数内的变量</p>
<h4 id="闭包与堆内存">闭包与堆内存</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">A</span>()</span><br></pre></td></tr></table></figure>
<p>函数 A 弹出调用栈之后，函数 A 中的变量这个时候是存储在堆上的，现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上</p>
<h3 id="v8-执行一段代码的过程">V8 执行一段代码的过程</h3>
<ol type="1">
<li>首先通过词法分析和语法分析生成 <strong>AST</strong></li>
<li><strong>解释器</strong> 将 AST 转换为字节码</li>
<li>由 <strong>解释器</strong> 逐行执行字节码，遇到热点代码启动 <strong>编译器</strong> 进行编译，生成对应的机器码，优化执行效率</li>
</ol>
<h4 id="生成-ast">生成 AST</h4>
<h5 id="词法分析">词法分析</h5>
<p>主要是把一行行代码分解成一个个 token：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;harvey&#x27;</span></span><br></pre></td></tr></table></figure>
<p>会把句子拆分成四个部分（四个 token）：关键字 let、变量名 name、赋值 =、字符串 'harvey'</p>
<h5 id="语法分析">语法分析</h5>
<p>将生成的这些 token 数据，根据一定的语法规则转化为 AST，之后会生成执行上下文。 babel 实际上就是将 ES6 代码解析生成 ES6 的 AST，然后再转换为 ES5 的 AST，然后再转换为 ES5 的代码。</p>
<h5 id="生成字节码">生成字节码</h5>
<p>生成 AST 之后，直接通过 V8 解释器（Ignition） 生成字节码，但是字节码并不能让机器直接运行——之所以不直接转化为机器码，是因为机器码空间占用太大了。</p>
<p>字节码比机器码轻量很多，是介于 AST 和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。</p>
<h4 id="执行代码">执行代码</h4>
<p>热点代码：在执行字节码的过程中，如果有一段代码反复出现，则记为 <strong>热点代码</strong>（HotSpot），这段代码会被编译成机器码保存起来。在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码。</p>
<p>JS 实际上并不是一门完全的解释型语言，因为字节码不仅配合了 <strong>解释器</strong>，还要配合 <strong>编译器</strong>。编译器和解释器的根本区别在于前者会编译生成二进制文件而后者不会。</p>
<h2 id="javascript-world-1">JavaScript World</h2>
<div class="note warning"><p><strong>JS 公式：<code>对象.__proto__ === 其构造函数.prototype</code></strong></p>
<p><strong>根公理：<code>Object.prototype</code> 是所有对象的（直接或间接）原型</strong></p>
<p><strong>函数公理：所有函数都是由 <code>Function</code> 构造的</strong></p>
</div>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-1.png" alt="JSWorld-1" /> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-2.png" alt="JSWorld-2" /> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-3.png" alt="JSWorld-3" /> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-4.png" alt="JSWorld-4" /></p>
<h1 id="dom">DOM</h1>
<h2 id="获取节点">获取节点</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">id</span> <span class="comment">// 或者直接 id</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;idxxx&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&gt;span:nth-child(2)&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.red&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="获取特定的元素">获取特定的元素</h3>
<ul>
<li>获取 html： <code>document.documentElement</code></li>
<li>获取 head： <code>document.head</code></li>
<li>获取 body： <code>document.body</code></li>
<li>获取 window： <code>window</code></li>
<li>获取所有元素： <code>document.all</code>，第 6 个 <code>falsy</code> 值，别的浏览器为了不使用为了 IE 设计的代码（这个是 IE 发明的）</li>
</ul>
<h3 id="获取的元素的原型">获取的元素的原型</h3>
<p>div 的原型链：</p>
<p><code>HTMLDivElement.prototype</code> → <code>HTMLElement.prototype</code> → <code>Elment.prototype</code> → <code>Node.prototype</code> → <code>EventTarget.prototype</code> → <code>Object.prototype</code></p>
<h3 id="节点node和元素element的区别">节点（Node）和元素（Element）的区别</h3>
<p>使用 x.nodeType 可以得到一个数字：</p>
<ul>
<li>1 表示 Element（也叫 Tag ）</li>
<li>3 表示 Text</li>
<li>8 表示 Comment</li>
<li>9 表示 Document</li>
<li>11 表示 Document Fragment</li>
</ul>
<h3 id="获取附近的元素">获取附近的元素</h3>
<ul>
<li>查爸爸： <code>div.parentNode</code> 或者 <code>div.parentElement</code></li>
<li>查子代： <code>div.childNodes</code> 或者 <code>div.children</code>，推荐使用后者，因为前者包括了文本节点，比如空格，两者都会实时变化</li>
<li>查兄弟姐妹： <code>div.parentNode.childNodes</code> 或者 <code>div.parentNode.children</code>，然后再排除自己</li>
<li>查看老大： <code>div.firstChild</code></li>
<li>查看老幺： <code>div.lastChild</code></li>
<li>查看上一个哥哥： <code>div.previousSibling</code>（有可能查到文本节点，可以用 <code>div.previousElementSibling</code>）</li>
<li>查看下一个弟弟： <code>div.nextSibling</code>（有可能查到文本节点，可以用 <code>div.nextElementSibling</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历一个 div 里面所有的元素</span></span><br><span class="line">travel = <span class="function">(<span class="params">node, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(node)</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">children</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">travel</span>(node.<span class="property">children</span>[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">travel</span>(div1, <span class="function">(<span class="params">node</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(node))</span><br></pre></td></tr></table></figure>
<h2 id="创建节点">创建节点</h2>
<h3 id="创建一个标签">创建一个标签</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建一个文本节点">创建一个文本节点</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">text = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="在标签里面插入文本">在标签里面插入文本</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div1.<span class="title function_">appendChild</span>(text1)</span><br><span class="line">div1.<span class="property">innerText</span> = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">div1.<span class="property">textContent</span> = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line"><span class="comment">//但是不能用</span></span><br><span class="line">div.<span class="title function_">appendChild</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="插入到页面中">插入到页面中</h3>
<ul>
<li><code>document.body.appendChild(div)</code> 或者 <code>已经在页面中的元素.appendChild(div)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有 div#test1 和 div#test2</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">test1.<span class="title function_">appendChild</span>(div)</span><br><span class="line">test2.<span class="title function_">appendChild</span>(div)</span><br><span class="line"><span class="comment">// div 最终只会出现在 test2 里面</span></span><br></pre></td></tr></table></figure>
<ul>
<li>让两个地方都有： <code>let div2 = div1.cloneNode(true)</code>，如果后面为 <code>true</code> 则使用深拷贝，所有的后代也会被拷贝</li>
</ul>
<h2 id="删除节点">删除节点</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(div)</span><br><span class="line">div.<span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>如果一个 Node 被移除了页面（DOM）树，它还可以再被放回去，它暂存在了内存里面，如果想删除，<code>div = null</code>，一会儿会自动回收</p>
</div>
<h2 id="编辑节点">编辑节点</h2>
<h3 id="编辑属性">编辑属性</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">className</span> = <span class="string">&#x27;red blue&#x27;</span><span class="comment">// 会覆盖掉之前的 class，要用 div.className += &#x27; red&#x27;</span></span><br><span class="line"></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span> = <span class="string">&#x27;color: blue&#x27;</span></span><br><span class="line"><span class="comment">// 会覆盖掉之前的 style，一般就写 style 的一部分</span></span><br><span class="line"><span class="comment">// 比如 div.style.color = &#x27;blue&#x27;，注意大小写问题：div.style.backgroundColor</span></span><br><span class="line"></span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-x&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">getAtrribute</span>(<span class="string">&#x27;data-x&#x27;</span>) <span class="comment">// 强加的，这样写也行</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>如果用 <code>a.href</code> 获取属性，然后是相对路径的话，他会把域名一起弄下来</p>
<p>如果用 <code>a.href.getAttribute('href')</code> 只获取属性里面写了的部分</p>
</div>
<h3 id="编辑事件">编辑事件</h3>
<ul>
<li><code>div.onclick</code> 默认为 <code>null</code>，如果改成 <code>fn</code>，那么在点击的时候就会调用 <code>fn.call(div, event)</code>，<code>event</code> 包含了点击事件的所有信息，比如坐标</li>
<li><code>div.addEventListener</code></li>
</ul>
<h3 id="编辑内容">编辑内容</h3>
<h4 id="编辑文本内容">编辑文本内容</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.<span class="property">innerText</span> = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">test.<span class="property">textContent</span> = <span class="string">&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改-html-内容">修改 HTML 内容</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 里面的字符不能超过两万个</span></span><br></pre></td></tr></table></figure>
<h4 id="修改标签">修改标签</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 先清空</span></span><br><span class="line">test.<span class="title function_">appendChild</span>(div) <span class="comment">//再加内容</span></span><br></pre></td></tr></table></figure>
<h3 id="跨线程">跨线程</h3>
<p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.start</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.end</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">test.<span class="property">clientWidth</span> <span class="comment">// 如果没有这句话，上下两句话就会合并，这句话会触发重新渲染</span></span><br><span class="line">test.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="属性同步">属性同步</h4>
<ul>
<li>标准属性，会自动同步，比如 <code>id</code> <code>className</code> <code>title</code></li>
<li><code>data-*</code> 属性，也会自动同步</li>
<li>非标准属性，不会同步到页面里，只会停留在JS 线程中，而不会自动同步到页面上</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Property-1.png" alt="JSProperty-1" /> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Property-2.png" alt="JSProperty-2" /></p>
<div class="note warning"><p>自定义属性最好以 <code>data-</code> 为前缀</p>
</div>
<h4 id="property-和-attribute">Property 和 Attribute</h4>
<ul>
<li>Property 是 JS 线程中 div1 的所有属性</li>
<li>Attribute 是 渲染引擎中 div1 对应标签的属性</li>
<li>大部分时候，同名的 Property 和 Attribute 值相等</li>
<li>如果不是标准属性，那么他们俩只会在一开始的时候相等</li>
<li>但注意 Attribute 只支持字符串，而 Property 支持字符串、布尔等类型</li>
</ul>
<h1 id="asynchronous">Asynchronous</h1>
<h2 id="ajax">AJAX</h2>
<blockquote>
<p>AJAX 即 Asynchronous JavaScript and XML（异步的 JavaScript 与 XML 技术），其实就是一套综合了多项技术的浏览器端网页开发技术。Google 在它多个著名的交互应用程序中使用了这套技术，如 Google 讨论组、Google 地图、Google 搜索建议、Gmail 等，这使得人们看到了前端领域新的可能性。</p>
<p>传统的 Web 应用允许用户端填写表单（form），当提交表单时就向网页服务器发送一个请求；服务器接收并处理传来的表单，然后送回一个<strong>新的网页</strong>。</p>
<p>但这个做法浪费了许多带宽，因为在前后两个页面中的大部分 HTML 码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>与此不同，AJAX 应用可以仅向服务器发送并取回必须的数据，并在客户端采用 JavaScript 处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p>
</blockquote>
<p>简单来讲：</p>
<ol type="1">
<li>AJAX 是浏览器上的功能，浏览器可以使用 AJAX 发请求、收响应；</li>
<li>浏览器在 <code>window</code> 上面加了一个 <code>XMLHttpRequest</code>，方便开发者通过 JS 来发请求、收响应，这是一个构造函数</li>
</ol>
<h3 id="加载-css-js-html-xml">加载 CSS / JS / HTML / XML</h3>
<p>如果想要使用 <code>XMLHttpRequest</code> 让浏览器来帮我们加载 CSS / JS / HTML / XML，一共需要进行四步：</p>
<ol type="1">
<li>创建 <code>XMLHttpResquest</code> 对象</li>
<li>调用他的 <code>open()</code> 方法</li>
<li>使用 <code>onreadystatechange</code> 监听他的成功和失败事件</li>
<li>调用他的 <code>send()</code> 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/&#123;url&#125;&#x27;</span>)</span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; request.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line">request.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>
<p>HTTP 里面可以装 HTML / CSS / JS / XML 等，但得知道怎么解析他们：</p>
<ul>
<li>拿到 CSS 之后生成 <code>&lt;style&gt;</code> 标签</li>
<li>拿到 JS 之后生成 <code>&lt;script&gt;</code> 标签</li>
<li>拿到 HTML 之后使用 <code>innerHTML</code> 和 DOM API，可以新建一个 <code>div</code></li>
<li>拿到 XML 之后的 <code>request.responseXML</code> 实际上已经是一个 DOM 节点了</li>
</ul>
<h3 id="json">JSON</h3>
<blockquote>
<p>JavaScript Object Natation，JSON 不是对象，而是一种标记语言（就像 HTML、XML、Markdown），用来展示数据，<a href="http://json.org/json-zh.html">JSON 中文官网</a></p>
</blockquote>
<h4 id="json-的数据类型">JSON 的数据类型</h4>
<ul>
<li>string（但是只支持双引号）</li>
<li>number（支持科学计数法）</li>
<li>bool</li>
<li>null</li>
<li>object</li>
<li>array</li>
</ul>
<div class="note warning"><p>JSON 中，不支持函数和变量</p>
</div>
<h4 id="json.parse">JSON.parse()</h4>
<blockquote>
<p>反序列化</p>
</blockquote>
<ul>
<li>将符合 JSON 语法的字符串转换为 JS 对应类型的数据</li>
<li>JSON 字符串 ⇒ JS 数据</li>
<li>由于 JSON 只有六种类型，所以转换出的数据也只有六种</li>
<li>如果不符合 JSON 语法，则会抛出 Error，一般用 try catch 捕获错误，比如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	object = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">`&#123;&#x27;name&#x27;:&#x27;harvey&#x27;&#125;`</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错了，错误详情是：&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">	object = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;no name&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object)</span><br></pre></td></tr></table></figure>
<h4 id="json.stringify">JSON.stringify()</h4>
<blockquote>
<p>序列化</p>
</blockquote>
<ul>
<li>是 JSON.parse 的逆运算</li>
<li>JS 数据 ⇒ JSON 字符串</li>
<li>由于 JS 的数据类型比 JSON 多，所以不一定能够成功</li>
<li>如果失败，则会抛出一个 Error 对象</li>
</ul>
<h2 id="异步">异步</h2>
<h3 id="异步与同步">异步与同步</h3>
<ul>
<li><strong>同步</strong>： <strong>能直接拿到结果，不拿到结果就不离开</strong>，就像医院挂号一样，可能需要花上几分钟，但是 <strong>拿到号之后才会离开窗口</strong></li>
<li><strong>异步</strong>： <strong>不能直接拿到结果</strong>，比如在餐厅门口等位，拿到号之后我们可以去逛街，那什么时候真正吃上饭呢？我们可以：
<ul>
<li>每 10 分钟去餐厅问一下（<strong>轮询</strong>）</li>
<li>也可以扫码用微信接收通知（<strong>回调</strong>）</li>
</ul></li>
</ul>
<p>AJAX 举例：当 <code>request.send()</code> 之后，并不能直接得到 <code>response</code>，必须要等待 <code>readyState</code> 变成 <code>4</code> 之后，浏览器回头调用 <code>request.onreadystatechange</code> 函数</p>
<h3 id="回调callback">回调（callback）</h3>
<ul>
<li>写给自己的函数，不是回调</li>
<li>写给别人用的函数，放在一个地方，让他来调用，就是回调</li>
<li><code>request.onreadystatechange</code>，是写给浏览器调用的，意思是让浏览器回头调一下这个函数</li>
</ul>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f2</span>(f1)</span><br><span class="line"><span class="comment">// 我调用了 f2，因此 f2 不是回调</span></span><br><span class="line"><span class="comment">// 我把 f1 传给了 f2</span></span><br><span class="line"><span class="comment">// 我没有调用，而是 f2 调用了 f1</span></span><br><span class="line"><span class="comment">// 所以 f1 是回调</span></span><br></pre></td></tr></table></figure>
<h3 id="异步与回调">异步与回调</h3>
<h4 id="关联">关联</h4>
<p>异步任务需要在得到结果时通知 JS 来拿结果，怎么通知呢？</p>
<ol type="1">
<li>可以让 JS 留一个函数地址（电话号码）给浏览器</li>
<li>异步任务完成之后，浏览器调用该函数的地址（拨打电话）</li>
<li>同时 <strong>把结果作为参数</strong> 传给该函数（电话里说可以来吃了）</li>
</ol>
<p>这个函数是我写给浏览器调用的，所以是回调函数</p>
<h4 id="区别">区别</h4>
<p>异步任务需要用回调函数来通知结果</p>
<ul>
<li>但异步也可以用 <strong>轮询</strong></li>
<li>回调也不一定用在异步里面，比如 <code>array.forEach( n ⇒ console.log(n) )</code>，这就是 <strong>同步回调</strong></li>
</ul>
<h3 id="异步函数">异步函数</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">MDN Async Function</a></p>
<p>如果一个函数的返回值处于以下这三个内部，即为异步函数：</p>
<ul>
<li><code>setTimeout</code></li>
<li>AJAX（即 <code>XMLHttpRequest</code>）</li>
<li><code>AddEventListener</code></li>
</ul>
<p>也可以设置同步的 AJAX，<code>request.open("get", "/5.json", false)</code>，但是这样会使页面在请求期间卡住</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 摇骰子()&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">6</span>) + <span class="number">1</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是按上面这样写，将拿不到 1 ~ 6 的随机数，而是 undefined</span></span><br><span class="line"><span class="keyword">const</span> n = 摇骰子()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调来拿到异步的结果</span></span><br><span class="line"><span class="keyword">function</span> 摇骰子(fn)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">6</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">x</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) &#125;</span><br><span class="line">摇骰子(f1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化代码，因为 f1 只用了一次</span></span><br><span class="line"><span class="keyword">function</span> 摇骰子(fn)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">6</span>) +<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">摇骰子(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以再简化为</span></span><br><span class="line">摇骰子(<span class="variable language_">console</span>.<span class="property">log</span>) <span class="comment">// 但是如果参数个数不一致就不能这样简化</span></span><br></pre></td></tr></table></figure>
<p>可以再看一下下面这道题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array) <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 正确的写法，i 和 arr 可以省略</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">paseInt</span>(item)</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 最开始的写法相当于</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">paseInt</span>(item, i, arr)</span><br><span class="line">    <span class="comment">// parseInt(&#x27;1&#x27;, 0, arr)，0 为无效参数，忽略</span></span><br><span class="line">    <span class="comment">// parseInt(&#x27;2&#x27;, 1, arr)，相当于把 &#x27;2&#x27; 作为 1 进制来进行解析 =&gt; NaN</span></span><br><span class="line">    <span class="comment">// parseInt(&#x27;3&#x27;, 2, arr)，相当于把 &#x27;3&#x27; 作为 2 进制来进行解析 =&gt; NaN</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="promise-1">Promise</h3>
<blockquote>
<p>如果异步任务有两个结果：成功或失败，怎么做？</p>
</blockquote>
<p>方法一：回调接受两个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>); <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>方法二：使用两个回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/1.json&#x27;</span>, <span class="function"><span class="params">data</span>=&gt;</span>&#123;&#125;, <span class="function"><span class="params">error</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/1.json&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function">()=&gt;</span>&#123;&#125;, <span class="attr">fail</span>: <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是这两个方法都有问题：</p>
<ol type="1">
<li>不规范，名称五花八门，有人用 <code>success + error</code>，有人用 <code>success + fail</code>，有人用 <code>done + fail</code></li>
<li>容易出现回调地狱，代码看不懂</li>
<li>很难进行错误处理</li>
</ol>
<h4 id="回调地狱">回调地狱</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getUser</span>( <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">getGroups</span>( user, <span class="function"><span class="params">groups</span> =&gt;</span> &#123;</span><br><span class="line">    groups.<span class="title function_">forEach</span>( <span class="function">(<span class="params">g</span>) =&gt;</span> &#123;</span><br><span class="line">      g.<span class="title function_">filter</span>( <span class="function"><span class="params">x</span> =&gt;</span> x.<span class="property">owenerId</span> === user.<span class="property">id</span>)</span><br><span class="line">        .<span class="title function_">forEach</span>( <span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="promise-2">Promise</h4>
<h5 id="基本用法">基本用法</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;success, fail&#125; = options</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">  request.<span class="title function_">open</span>(method, url)</span><br><span class="line">  request.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.<span class="property">status</span> &lt; <span class="number">400</span>) &#123;</span><br><span class="line">       success.<span class="title function_">call</span>(<span class="literal">null</span>, request.<span class="property">response</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span> &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">        fail.<span class="title function_">call</span>(<span class="literal">null</span>, request, request.<span class="property">status</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.<span class="title function_">send</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/xxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">success</span>(<span class="params">response</span>)&#123;&#125;, <span class="attr">fail</span>:<span class="function">(<span class="params">request, status</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;)  <span class="comment">// 左边是 function 的缩写，右边是箭头函数</span></span><br></pre></td></tr></table></figure>
<p>↑ 上面是普通的写法，↓ 下面是 Promise 的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="comment">// return new Promise((resolve, reject)=&gt;&#123;..&#125;)</span></span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    request.<span class="title function_">open</span>(method, url)</span><br><span class="line">    request.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(request.<span class="property">status</span> &lt; <span class="number">400</span>) &#123;</span><br><span class="line">          resolve.<span class="title function_">call</span>(<span class="literal">null</span>, request.<span class="property">response</span>)  <span class="comment">// 成功调用 resolve(result)，他再回调用第一个函数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span> &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">          reject.<span class="title function_">call</span>(<span class="literal">null</span>, request)  <span class="comment">// 失败调用 reject(error)，他再会调用第二个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.<span class="title function_">send</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/xxx&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;&#125;, <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;&#125; )   <span class="comment">// Promise 的回调（成功/失败）只能接受一个参数</span></span><br></pre></td></tr></table></figure>
<h5 id="promise-是如何解决回调地狱的">Promise 是如何解决回调地狱的</h5>
<p>回调地狱：</p>
<ol type="1">
<li>多层嵌套</li>
<li>无法方便地进行错误处理</li>
</ol>
<p>解决办法：</p>
<ol type="1">
<li>回调函数延迟绑定，回调函数是通过后面的 then 方法传入的</li>
<li>返回值穿透，根据 then 中回调函数的传入值创建不同类型的 Promise，再把返回的 Promise 穿透到外层，以供后续使用。以上两点实现了链式调用，解决多层嵌套问题</li>
<li>错误冒泡，前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了</li>
</ol>
<h5 id="promise.all">Promise.all()</h5>
<ul>
<li>如果传入的参数是一个空的可迭代对象，比如空数组，则返回一个已完成（already resolved）状态的 Promise。</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。</li>
<li>其它情况下返回一个处理中（pending）的Promise。</li>
</ul>
<p>返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。（如果都成功，则成功；有一个失败，则失败）</p>
<p>返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values); <span class="comment">// [3, 1337, &quot;foo&quot;] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="promise.race">Promise.race()</h5>
<p>可以传入多个 promise，谁快，Promise.race() 就会跟谁一样，如果传的迭代是空的，则返回的 promise 将永远等待。</p>
<h1 id="canvas">Canvas</h1>
<h2 id="什么是-canvas">什么是 Canvas</h2>
<blockquote>
<p><code>&lt;canvas&gt;</code> 是 HTML 5 新增的元素，可用于通过使用 JavaScript 的脚本来绘制图形。例如，他可以用于绘制图形、制作照片、创建动画，甚至可以进行实时视频处理和渲染</p>
</blockquote>
<p>简单来说，<code>&lt;canvas&gt;</code> 提供了一块画布，在上面可以使用 JavaScript 动态渲染图像</p>
<h3 id="canvas-与-svg">Canvas 与 SVG</h3>
<blockquote>
<p>SVG（Scalable Vector Graphics）是基于 XML，用于描述二维矢量图形的一种图片格式，由 W3C 指定，是一个开放标准</p>
</blockquote>
<p>Canvas 在绘制结束之后不能被保存到内存中，每次都需要重新绘制，是实时绘制的；svg 则在绘制完之后会被保存在内存中，当需要修改这个对象信息的时候，直接修改就可以了</p>
<table>
<thead>
<tr class="header">
<th>Canvas</th>
<th>SVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>依赖分辨率（位图）</td>
<td>不依赖分辨率（矢量图）</td>
</tr>
<tr class="even">
<td>单个 HTML 元素</td>
<td>每个图形都是一个 DOM 元素</td>
</tr>
<tr class="odd">
<td>只能通过脚本语言绘制</td>
<td>CSS、脚本语言都可以用来绘制</td>
</tr>
<tr class="even">
<td>不支持事件处理程序</td>
<td>支持事件处理程序</td>
</tr>
<tr class="odd">
<td>弱的文本渲染恩能够力</td>
<td>最适合带有大型渲染区域的应用程序，比如谷歌地图</td>
</tr>
<tr class="even">
<td>图面较小，对象数量较大时（&gt;10k）性能最佳</td>
<td>对象数量较小（&lt;10k）、图面更大时性能更佳</td>
</tr>
</tbody>
</table>
<h2 id="canvas-的应用场景">Canvas 的应用场景</h2>
<ol type="1">
<li><strong>绘制图表</strong>，比如 EChats 之类的数据可视化库都是使用 Canvas 实现的</li>
<li><strong>小游戏</strong>，基本上所有的 HTML 5 游戏都是基于 Canvas 开发的，因为不需要借助其他任何插件</li>
<li><strong>活动页面</strong>，比如转转轮、刮奖</li>
<li><strong>特效、背景</strong></li>
</ol>
<h2 id="canvas-api">Canvas API</h2>
<h3 id="设置宽高">设置宽高</h3>
<p>可以通过 HTML 或 JS 来设置，不能通过 CSS 设置，这会导致不可预料的缩放</p>
<h3 id="获取-canvas-对象">获取 Canvas 对象</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.<span class="title function_">getContext</span>(contextType, contextAttributes)</span><br></pre></td></tr></table></figure>
<p><code>contextType</code> 是上下文类型，有这样几种：</p>
<ul>
<li><code>2d</code>：代表一个二维渲染上下文</li>
<li><code>webgl</code> 或 <code>experimental-webgl</code>：代表一个三维渲染上下文</li>
<li><code>webgl2</code> 或 <code>experimental-webgl2</code>：代表一个三维渲染上下文，并且只能在浏览器中实现 WebGL 版本 2（OpenGL ES 3.0）</li>
</ul>
<h3 id="绘制路径">绘制路径</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fill()</code></td>
<td>填充路径</td>
</tr>
<tr class="even">
<td><code>stroke()</code></td>
<td>描边</td>
</tr>
<tr class="odd">
<td><code>arc()</code></td>
<td>创建圆弧</td>
</tr>
<tr class="even">
<td><code>rect()</code></td>
<td>创建矩形</td>
</tr>
<tr class="odd">
<td><code>fillRect()</code></td>
<td>绘制矩形路径区域</td>
</tr>
<tr class="even">
<td><code>strokeRect()</code></td>
<td>绘制矩形路径描边</td>
</tr>
<tr class="odd">
<td><code>clearRect()</code></td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
<tr class="even">
<td><code>arcTo()</code></td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr class="odd">
<td><code>beginPath()</code></td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr class="even">
<td><code>moveTo()</code></td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr class="odd">
<td><code>lineTo()</code></td>
<td>添加一个新点，然后画布中创建从该点到最后指定点的线条</td>
</tr>
<tr class="even">
<td><code>closePath()</code></td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr class="odd">
<td><code>clip()</code></td>
<td>从原始画布剪切任意形状和尺寸的区域</td>
</tr>
<tr class="even">
<td><code>quadraticCurveTo()</code></td>
<td>创建二次方贝塞尔曲线</td>
</tr>
<tr class="odd">
<td><code>bezierCurveTo()</code></td>
<td>创建三次方贝塞尔曲线</td>
</tr>
<tr class="even">
<td><code>isPointInPath()</code></td>
<td>如果指定的点位于当前路径中，则返回 true，否则返回 false</td>
</tr>
</tbody>
</table>
<h4 id="绘制曲线">绘制曲线</h4>
<h5 id="arc">arc()</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="title function_">arc</span>(x, y, sAngle, eAangle, counterCloseWise)</span><br></pre></td></tr></table></figure>
<p><code>x</code> 和 <code>y</code> 指定了圆心坐标，<code>sAngle</code> 和 <code>eAngle</code> 分别为起始角和结束角，<code>counterCloseWise</code> 设置为 <code>true</code> 表示逆时针绘制</p>
<h4 id="绘制直线">绘制直线</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">moveTo</span>(x, y) <span class="comment">// 把路径移动到画布中的指定点，不创建线条</span></span><br><span class="line"><span class="title function_">lineTo</span>(x, y) <span class="comment">// 添加一个新点，然后在画布中创建从该点到最后指定点的线条</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>如果没有 <code>moveTo</code>，那么第一次 <code>lineTo</code> 就视为 <code>moveTo</code></p>
</div>
<p>可以给绘制的直线添加样式：</p>
<table>
<thead>
<tr class="header">
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>lineCap</code></td>
<td>设置或返回线条的结束端点样式</td>
</tr>
<tr class="even">
<td><code>lineJoin</code></td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr class="odd">
<td><code>lineWidth</code></td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr class="even">
<td><code>miterLimit</code></td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody>
</table>
<h4 id="绘制矩形">绘制矩形</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fillRect</span>(x, y, width, height) <span class="comment">// 绘制一个实心矩形</span></span><br><span class="line"><span class="title function_">strokeRect</span>(x, y, width, height) <span class="comment">// 绘制一个空心矩形</span></span><br></pre></td></tr></table></figure>
<h4 id="颜色样式和阴影">颜色、样式和阴影</h4>
<p>创建路径之后，可以设置样式属性，再使用 <code>fill()</code> 和 <code>stroke()</code> 进行填充或描边</p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr class="even">
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr class="odd">
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr class="even">
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr class="odd">
<td>shadowOffsetX</td>
<td>设置或返回阴影距形状的水平距离</td>
</tr>
<tr class="even">
<td>shadowOffsetY</td>
<td>设置或返回阴影距形状的垂直距离</td>
</tr>
</tbody>
</table>
<h4 id="设置渐变">设置渐变</h4>
<p>有这样几个方法可以设置渐变：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr class="even">
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr class="odd">
<td>createRadialGradient()</td>
<td>环形的渐变（用在画布内容上）</td>
</tr>
<tr class="even">
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody>
</table>
<p>主要使用到下面这个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> grd = context.<span class="title function_">createLinerGradient</span>(x0, y0, x1, y1)</span><br><span class="line">grd.<span class="title function_">addColorStop</span>(stop, color) <span class="comment">// stop 是介于 0.0 ~ 1.0 之间的值</span></span><br></pre></td></tr></table></figure>
<h4 id="图形转换">图形转换</h4>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr class="even">
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr class="odd">
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr class="even">
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr class="odd">
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵，然后运行 transform()</td>
</tr>
</tbody>
</table>
<p>注意旋转实际上是对画布旋转，旋转之后所有的都会旋转</p>
<h4 id="图形绘制">图形绘制</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">drawImage</span>(img, sx, sy, swidth, sheight, x, y, width, height)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>img</code>：规定要使用的图像、画布或视频</li>
<li><code>sx</code>：可选。开始剪切的 x 坐标位置</li>
<li><code>sy</code>：可选。开始剪切的 y 坐标位置</li>
<li><code>swidth</code>：可选。被剪切图像的宽度</li>
<li><code>sheight</code>：可选。被剪切图像的高度</li>
<li><code>x</code>：在画布上放置图像的 x 坐标位置</li>
<li><code>y</code>：在画布上放置图像的 y 坐标位置</li>
<li><code>width</code>：可选。要使用的图像的宽度（伸展或缩小图像）</li>
<li><code>height</code>：可选。要使用的图像的高度（伸展或缩小图像）</li>
</ul>
<h1 id="extra-topics">Extra Topics</h1>
<h2 id="promise-3">Promise</h2>
<h3 id="promise-如何消灭回调地狱">Promise 如何消灭回调地狱</h3>
<p>回调地狱：</p>
<ol type="1">
<li>多层嵌套</li>
<li>无法方便地进行错误处理</li>
</ol>
<p>解决办法：</p>
<ol type="1">
<li>回调函数延迟绑定，回调函数是通过后面的 then 方法传入的</li>
<li>返回值穿透，根据 then 中回调函数的传入值创建不同类型的 Promise，再把返回的 Promise 穿透到外层，以供后续使用。以上两点实现了链式调用，解决多层嵌套问题</li>
<li>错误冒泡，前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了</li>
</ol>
<h3 id="promise-怎样实现链式调用的">Promise 怎样实现链式调用的</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="comment">// 缓存当前 Promise 实例</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  self.<span class="property">value</span> = <span class="literal">null</span></span><br><span class="line">  self.<span class="property">error</span> = <span class="literal">null</span></span><br><span class="line">  self.<span class="property">status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">  <span class="comment">// 回调函数有可能是个数组</span></span><br><span class="line">  self.<span class="property">onFulfilledCallbacks</span> = []</span><br><span class="line">  self.<span class="property">onRejectedCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">      self.<span class="property">value</span> = value</span><br><span class="line">      self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(self.<span class="property">value</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reject</span> = error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">      self.<span class="property">error</span> = error</span><br><span class="line">      self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(self.<span class="property">error</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> bridgePromise</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="comment">// 拆解这个 promise，直到返回值不为 promise 为止</span></span><br><span class="line">      <span class="keyword">if</span> (x.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        x.<span class="title function_">then</span>(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolvePromise</span>(bridgePromise, y, resolve, reject)</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise =  <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 要拿到 then 中回调返回的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(value)</span><br><span class="line">          <span class="title function_">resolvePromise</span>(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="title function_">onRejected</span>(error))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(self.<span class="property">value</span>)</span><br><span class="line">          <span class="title function_">resolvePromise</span>(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(self.<span class="property">error</span>)</span><br><span class="line">          <span class="title function_">resolvePromise</span>(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些例子">一些例子</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success1&#x27;</span>)&#125;, <span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error1&#x27;</span>)&#125; )</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success2&#x27;</span>)&#125;, <span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error2&#x27;</span>)&#125; )</span><br><span class="line"><span class="comment">// error1 -&gt; success2</span></span><br></pre></td></tr></table></figure>
<h2 id="前端路由">前端路由</h2>
<blockquote>
<p>路由就是根据不同的 URL 来展示不同的内容或页面</p>
</blockquote>
<p>用户每次提交表单就要重新刷新页面 -&gt; 催生了 AJAX；</p>
<p>用户在多页面之间跳转体验很差 -&gt; 催生了单页应用（SPA, Single-Page Application）</p>
<p>单页应用页面本身的 URL 没有变化，导致其无法记住用户的操作，对 SEO 也不友好 -&gt; 催生了前端路由</p>
<blockquote>
<p>前端路由就是在 <strong>保证只有一个 HTML 页面</strong>，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个 <strong>特殊的 URL</strong></p>
<p>在刷新、前进、后退和 SEO 时均通过这个特殊的 URL 来实现</p>
<p>并且改变 URL 时不向服务器发送请求</p>
</blockquote>
<h3 id="hash-与-history">Hash 与 History</h3>
<h4 id="hash">Hash</h4>
<p>由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 <code>hashchange</code> 事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。</p>
<p>基本 API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;string&#x27;</span> <span class="comment">// 用于设置 hash 值</span></span><br><span class="line"><span class="keyword">let</span> hash = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> <span class="comment">// 获取当前 hash 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 hash 变化，点击浏览器的前进后退会触发：</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newURL = event.<span class="property">newURL</span> <span class="comment">// hash 改变后的新 URL</span></span><br><span class="line">  <span class="keyword">let</span> oldURL = event.<span class="property">oldURL</span> <span class="comment">// hash 改变前的旧 URL</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以简写成</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">onhashchange</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="实现一个路由对象">实现一个路由对象</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hashRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 存储不同的 hash 值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">// 通过 hashchange 来监听 hash 变化</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="variable language_">this</span>.<span class="property">load</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册每个视图（注册每个 hash 值对应的回调函数）</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">hash, callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[hash] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册首页的回调（没有 hash 值时默认为首页）</span></span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;index&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理视图未找到的情况</span></span><br><span class="line">  <span class="title function_">registerNotFound</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理异常情况</span></span><br><span class="line">  <span class="title function_">registerError</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> handler</span><br><span class="line">      <span class="comment">// 没有 hash 默认首页</span></span><br><span class="line">    <span class="keyword">if</span> (!hash) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>.<span class="property">index</span></span><br><span class="line">      <span class="comment">// 没找到对应的 hash 值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">routers</span>.<span class="title function_">hasOwnProperty</span>(hash)) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">      <span class="comment">// 其他普通情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[hash]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行注册的回调函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handler.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span><br><span class="line">      (<span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再这样使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page1&quot;</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page2&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page3&quot;</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page4&quot;</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page5&quot;</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">HashRouter</span>()</span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册首页回调函数</span></span><br><span class="line">router.<span class="title function_">registerIndex</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是首页&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册其他视图回调函数</span></span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page1&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page1&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page2&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page3&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page3&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page4&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出一个异常&#x27;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册未找到对应 hash 值时的回调</span></span><br><span class="line">router.<span class="title function_">regierNotFound</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面未找到&#x27;</span>)</span><br><span class="line"><span class="comment">// 注册出现异常时的回调</span></span><br><span class="line">router.<span class="title function_">registerError</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面异常，错误信息：&lt;br&gt;&#x27;</span> + e.<span class="property">message</span>)</span><br><span class="line"><span class="comment">// 加载视图</span></span><br><span class="line">router.<span class="title function_">load</span>()</span><br></pre></td></tr></table></figure>
<h4 id="history-1">History</h4>
<p>在 HTML5 之前，浏览器就已经有了 history 对象，但早期的只有 <code>go</code> <code>forward</code> <code>back</code> 这些方法，用于多页面之间的跳转，HTML 5 中新加入了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>() <span class="comment">// 添加新的状态到历史状态栈</span></span><br><span class="line">history.<span class="title function_">replaceState</span>() <span class="comment">// 用新的状态代替当前状态</span></span><br><span class="line">history.<span class="property">state</span> <span class="comment">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure>
<p>与 hash 不同，history 的改变并不会触发任何事件，所以我们无法直接监听 history 的改变而做出相应的改变。</p>
<p>而对于单页应用的 history 模式而言，URL 的改变只有可能是以下四种情况：</p>
<ol type="1">
<li>点击浏览器的而前进或后退按钮</li>
<li>点击 a 标签</li>
<li>在 JS 代码中触发 <code>history.pushState</code> 函数</li>
<li>在 JS 代码中触发 <code>history.replaceState</code> 函数</li>
</ol>
<h5 id="实现一个路由对象-1">实现一个路由对象</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HistoryRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 存储不同 path 值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">listenPopState</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">listenLink</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听 popstate 事件，处理前进和后退时应该如何调用</span></span><br><span class="line">  <span class="title function_">listenPopState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> state = e.<span class="property">state</span> || &#123;&#125;</span><br><span class="line">      <span class="keyword">let</span> path = state.<span class="property">path</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听 a 标签，阻止他的默认事件，并且调用 pushState 方法</span></span><br><span class="line">  <span class="title function_">listenLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = e.<span class="property">target</span></span><br><span class="line">      <span class="keyword">if</span> ((dom.<span class="property">tagName</span>.<span class="property">toLowerCase</span> === <span class="string">&#x27;a&#x27;</span>) &amp;&amp; dom.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>)) &#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">assign</span>(dom.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次进入页面时调用</span></span><br><span class="line">  <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = location.<span class="property">pathname</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">register</span>(<span class="params">path, callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;/&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">registerNotFound</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">registerError</span>(<span class="params">callback = <span class="keyword">function</span>() &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 pushState</span></span><br><span class="line">  <span class="title function_">assign</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">pushState</span>(&#123;path&#125;, <span class="literal">null</span>, path)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 replaceState</span></span><br><span class="line">  <span class="title function_">replace</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">replaceState</span>(&#123;path&#125;, <span class="literal">null</span>, path)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dealPathHandler</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">routers</span>.<span class="title function_">hasOwnProperty</span>(path)) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[path]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handler.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span><br><span class="line">      (<span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的使用方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page1&quot;</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page2&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page3&quot;</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page4&quot;</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page5&quot;</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">HashRouter</span>()</span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册首页回调函数</span></span><br><span class="line">router.<span class="title function_">registerIndex</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是首页&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册其他视图回调函数</span></span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page1&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page1&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page2&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page3&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是 page3&#x27;</span>)</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page4&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出一个异常&#x27;</span>)&#125;)</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> router.<span class="title function_">assign</span>(<span class="string">&#x27;/page2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册未找到对应 path 值时的回调</span></span><br><span class="line">router.<span class="title function_">regierNotFound</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面未找到&#x27;</span>)</span><br><span class="line"><span class="comment">// 注册出现异常时的回调</span></span><br><span class="line">router.<span class="title function_">registerError</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面异常，错误信息：&lt;br&gt;&#x27;</span> + e.<span class="property">message</span>)</span><br><span class="line"><span class="comment">// 加载视图</span></span><br><span class="line">router.<span class="title function_">load</span>()</span><br></pre></td></tr></table></figure>
<h3 id="各自的优缺点及使用场景">各自的优缺点及使用场景</h3>
<h4 id="为什么-history-模式需要服务器端配合">为什么 history 模式需要服务器端配合？</h4>
<p>我们通过 history 来修改 URL 后，页面不会刷新；如果我们手动刷新页面，或者通过 URL 直接进入应用时，服务端是无法识别这个 URL 的——因为我们其实只有一个 html 文件</p>
<p>因此，如果要使用 history 模式，就需要在服务端增加一个覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应返回单页应用的 html 文件</p>
<h4 id="各自的优缺点">各自的优缺点</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th>hash</th>
<th>history</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>观赏性</td>
<td>丑</td>
<td>美</td>
</tr>
<tr class="even">
<td>兼容性</td>
<td>&gt;IE8</td>
<td>&gt;IE10</td>
</tr>
<tr class="odd">
<td>其他</td>
<td>锚点功能失效，相同 hash 值不触发动作</td>
<td>需要服务端配合，相同 path 值也可以通过 pushState 触发动作</td>
</tr>
</tbody>
</table>
<h2 id="函数防抖与函数节流">函数防抖与函数节流</h2>
<h3 id="函数防抖">函数防抖</h3>
<p>等了一段时间，没有新的人上车了再发车：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, delay = <span class="number">300</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数节流">函数节流</h3>
<p>冷却时间：指定时间间隔内只会执行一次任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, interval = <span class="number">300</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span></span><br><span class="line">    canRun = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      canRun = <span class="literal">true</span></span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何用正则实现-trim">如何用正则实现 <code>trim()</code></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">trim</span> = (<span class="params">string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> string.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象和数组的深拷贝">对象和数组的深拷贝</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">b</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">d</span>: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接赋值">直接赋值</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = obj1</span><br></pre></td></tr></table></figure>
<p>当改变 <code>obj1</code> 的时候，<code>obj2</code> 会跟着改变，这是直接赋值，不属于深/浅克隆</p>
<h3 id="浅克隆">浅克隆</h3>
<blockquote>
<p>只克隆第一层</p>
</blockquote>
<h4 id="手动实现">手动实现</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj.<span class="title function_">hasOwnProperty</span>(key)) <span class="keyword">continue</span> <span class="comment">// 这里也可以用 break，因为到这一步基本就已经到原型的属性了，可以直接跳出循环</span></span><br><span class="line">  obj2[key] = obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="object.assign">Object.assign</h4>
<p>他拷贝的是对象属性的引用，而不是对象本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure>
<h4 id="展开运算符">展开运算符</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj &#125;</span><br></pre></td></tr></table></figure>
<h4 id="concat">concat</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">concat</span>()</span><br></pre></td></tr></table></figure>
<h4 id="slice">slice</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>()</span><br></pre></td></tr></table></figure>
<h3 id="深克隆">深克隆</h3>
<blockquote>
<p>每一层都克隆</p>
</blockquote>
<h4 id="简易版的深拷贝">简易版的深拷贝</h4>
<p>最最最简单的深拷贝可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>
<p>但是在有些时候是会出现问题的：</p>
<ol type="1">
<li>循环引用</li>
<li>无法处理 RegExp、Date、Set、Map、Function 等</li>
</ol>
<p>也可以用 <code>lodash</code> 之类的库，当然也可以手写一个简易版的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决循环引用问题">解决循环引用问题</h4>
<p>思路：创建一个 Map，将已经拷贝过的对象记录下来，如果发现已经拷贝过，就直接返回他</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">target</span>) =&gt; (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target, map = <span class="keyword">new</span> weakMap()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(target, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop], map)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 Map，那么 map 的 key 将会与 map 形成强引用，如果强引用一直存在，那么对象将无法被回收；</p>
<p>使用 WeakMap 可以构造一种弱引用（一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收），WeakMap 的 Key 必须是对象，而值可以是任意的。</p>
<h4 id="拷贝特殊对象">拷贝特殊对象</h4>
<h5 id="可继续遍历">可继续遍历</h5>
<p>比如 Map、Set、Array、Object、Arguments：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="property">call</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">target</span>) =&gt; (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) <span class="keyword">return</span> target</span><br><span class="line">  <span class="keyword">let</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">let</span> cloneTarget</span><br><span class="line">  <span class="keyword">if</span> (!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不可遍历对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) <span class="keyword">return</span> target</span><br><span class="line">  map.<span class="title function_">set</span>(target, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;[object Map]&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">set</span>(<span class="title function_">deepClone</span>(key), <span class="title function_">deepClone</span>(item))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;[object Set]&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      target.<span class="title function_">add</span>(<span class="title function_">deepClone</span>(item))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 Object 和 Array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不可遍历">不可遍历</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regExpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleRegExp</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;source, flags&#125; = target</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params">source, flags</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要区分处理箭头函数和普通函数，因为普通函数是 Function 的实例，而箭头函数不是任何类的实例</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleFunc</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 箭头函数返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!func.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> func</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)(?=&#125;)/m</span></span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s*&#123;)/</span></span><br><span class="line">  <span class="keyword">const</span> funcString = func.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">const</span> param = paramReg.<span class="title function_">exec</span>(funcString)</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.<span class="title function_">exec</span>(funcString)</span><br><span class="line">  <span class="keyword">if</span> (!body) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].<span class="title function_">slice</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(...param, body[<span class="number">0</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(body[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleNotTraverse</span> = (<span class="params">target, tag</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> constructor = target.<span class="property">constructor</span></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">boolTag</span>:</span><br><span class="line">      <span class="comment">// 因为用 new Boolean 创造出来的对象有问题</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">numberTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">stringTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">errorTag</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">dateTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">target</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">regExpTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleRegExp</span>(target)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">funcTag</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleFunc</span>(target)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码">完整代码</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getType</span> = target =&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target).<span class="title function_">match</span>(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = target =&gt; (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">&#x27;map&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;set&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;array&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;object&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;arguments&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleRegExp</span> = target =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;source,flags&#125; = target</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params">source, flags</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleFunc</span> = func =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!func.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> func</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)(?=&#125;)/m</span></span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span></span><br><span class="line">  <span class="keyword">const</span> funcString = func.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">const</span> param = paramReg.<span class="title function_">exec</span>(funcString)</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.<span class="title function_">exec</span>(funcString)</span><br><span class="line">  <span class="keyword">if</span> (!body) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(...paramArr, body[<span class="number">0</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(body[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleNotTraverse</span> = (<span class="params">target, type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> constructor = target.<span class="property">constructor</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;symbol&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;error&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;date&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">target</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;regexp&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleRegExp</span>(target)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;function&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleFunc</span>(target)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">let</span> cloneTarget</span><br><span class="line">  <span class="keyword">if</span> (!canTraverse[type]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handleNotTraverse</span>(target, type)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) <span class="keyword">return</span> target</span><br><span class="line">  map.<span class="title function_">set</span>(target, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;map&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">set</span>(<span class="title function_">deepClone</span>(key, map), <span class="title function_">deepClone</span>(item, map))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;set&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">add</span>(<span class="title function_">deepClone</span>(item, map))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop], map)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于堆栈内存和闭包">关于堆栈内存和闭包</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">a[b]= <span class="string">&#x27;Harvey&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;Zhang&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b]) <span class="comment">// =&gt; &#x27;Zhang&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">    c = <span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">a[b] = <span class="string">&#x27;Harvey&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;Zhang&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b]) <span class="comment">// =&gt; &#x27;Harvey&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = &#123; <span class="attr">n</span>: <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">    c = &#123; <span class="attr">m</span>: <span class="string">&#x27;2&#x27;</span> &#125;</span><br><span class="line">a[b] = <span class="string">&#x27;Harvey&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;Zhang&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b]) <span class="comment">// =&gt; &#x27;Zhang&#x27;</span></span><br><span class="line"><span class="comment">// 所有的引用类型存的时候都会被转换成字符串，而 object 转换成字符串的结果都是 &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>堆：存储引用类型值的空间；</p>
<p>栈：存储基本类型值和执行代码的环境；浏览器加载页面就会形成栈内存，当执行函数的时候，都会形成一个新的执行上下文（Execution Context Stack），压入栈中执行</p>
</div>
<p>闭包的作用 1：保存——保存私有变量，不被销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(i *= <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">2</span>) <span class="comment">// =&gt; var test = AAAFFF111</span></span><br><span class="line"><span class="title function_">test</span>(<span class="number">5</span>) <span class="comment">// =&gt; &#x27;4&#x27; </span></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：地址 AAAFFF111</span><br><span class="line">│ 作为函数，存储代码（字符串）</span><br><span class="line">│ 作为对象，存储键值对（prototype、length、name ...）</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 1，不销毁，因为 i 被占着</span><br><span class="line">│ i = 2</span><br><span class="line">│ return AAAFFF111</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">    ↑</span><br><span class="line">    | 上级作用域</span><br><span class="line">    |</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 2，执行完之后销毁</span><br><span class="line">│ alert(i *= 2)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<p>闭包的作用 2：保护——修改自己的私有变量，不会影响外面的东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>,</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a</span>) &#123; <span class="comment">// 全局 A = AAAFFF000</span></span><br><span class="line">  A = <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(a + b++)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(a++)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>(<span class="number">1</span>) <span class="comment">// =&gt; &#x27;1&#x27;, a = 2</span></span><br><span class="line"><span class="title function_">A</span>(<span class="number">2</span>) <span class="comment">// =&gt; &#x27;4&#x27;, b = 3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ Global Object</span><br><span class="line">| a = 0</span><br><span class="line">| b = 0</span><br><span class="line">| A = AAAFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">│ `A = function(b) &#123; alert(a + b++) &#125;; alert(a++)`</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ `alert(a + b++)`</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(1) ECStack，因为 BBBFFF000 被全局 A 占用了，所以不销毁</span><br><span class="line">│ a = 1</span><br><span class="line">| A = BBBFFF000</span><br><span class="line">| alert(a++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(2) ECStack，没有被占用的，所以销毁</span><br><span class="line">│ b = 2</span><br><span class="line">| alert(a + b++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<h2 id="面向对象">面向对象</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>() <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>() <span class="comment">// Foo() 作为普通函数执行，改变了全局的 getName() 为 1，返回 this（为 window）</span></span><br><span class="line"><span class="title function_">getName</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>() <span class="comment">// 前面是无参数 new（优先级18），后面是成员访问（优先级19），先执行成员访问，获取 Foo.getName()，为 2，再 new（相当于普通函数执行）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>() <span class="comment">// 前面是有参数 new（优先级19），后面是成员访问（优先级19），先 new（创建实例），getName 是原型上的 getName，3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>() <span class="comment">// 先 new（创建实例 xxx），变为 new xxx.getName()，再算成员访问（原型上的方法），为 3，再 new</span></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">| 代码字符串</span><br><span class="line">| getName: fun -&gt; 2</span><br><span class="line">| prototype: BBBFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ constructor: Foo</span><br><span class="line">| getName: func -&gt; 3</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 变量提升阶段</span><br><span class="line">| Foo = AAAFFF000，声明并定义</span><br><span class="line">│ getName = func -&gt; 5，var 声明，之后在 function 赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 代码执行阶段</span><br><span class="line">| getName = func -&gt; 4，在 var 处赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<h2 id="parseurl-函数">parseUrl 函数</h2>
<p>可以用 <code>new URL</code> API 或者创建一个 <code>&lt;a&gt;</code> 标签的，并获取他的属性：</p>
<p>new URL 在 IE 上兼容性不是很好，但是 Node 也支持这个 API。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">parseUrl</span> = source =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(source)</span><br><span class="line">  <span class="keyword">const</span> query = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> params = url.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/^\?/</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  params.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> param = item.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    query[param[<span class="number">0</span>]] = param[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">protocol</span>: url.<span class="property">protocol</span>.<span class="title function_">replace</span>(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">host</span>: url.<span class="property">host</span>,</span><br><span class="line">    <span class="attr">path</span>: url.<span class="property">pathname</span>,</span><br><span class="line">    <span class="attr">query</span>: query,</span><br><span class="line">    <span class="attr">hash</span>: url.<span class="property">hash</span>.<span class="title function_">replace</span>(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseUrl</span>(<span class="string">&quot;http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">parseUrl</span> = source =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  a.<span class="property">href</span> = source</span><br><span class="line">  <span class="comment">// 下面的内容是一样的</span></span><br><span class="line">  <span class="keyword">const</span> query = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> params = a.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/^\?/</span>,<span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">  params.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> param = item.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    query[param[<span class="number">0</span>]] = param[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">protocol</span>: a.<span class="property">protocol</span>.<span class="title function_">replace</span>(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">host</span>: a.<span class="property">host</span>,</span><br><span class="line">    <span class="attr">path</span>: a.<span class="property">pathname</span>,</span><br><span class="line">    <span class="attr">query</span>: query,</span><br><span class="line">    <span class="attr">hash</span>: a.<span class="property">hash</span>.<span class="title function_">replace</span>(<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseUrl</span>(<span class="string">&quot;http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="eventloop">EventLoop</h2>
<h3 id="浏览器中的-eventloop">浏览器中的 EventLoop</h3>
<p>浏览器中的 EventLoop 有 2 个阶段：<strong>宏任务</strong> 和 <strong>微任务</strong></p>
<ol type="1">
<li>第一个 <strong>宏任务</strong>：整段脚本。执行过程中的 <strong>同步代码</strong> 直接执行，<strong>宏任务</strong> 进入宏任务队列，<strong>微任务</strong> 进入微任务队列</li>
<li>当前 <strong>宏任务</strong> 执行完出队，检查 <strong>微任务</strong> 队列，若有则依次执行，直至微任务队列为空</li>
<li>执行浏览器 <strong>UI 线程</strong> 的渲染工作</li>
<li>检查是否有 <strong>Web worker</strong> 任务，有则执行</li>
<li>执行队首新的 <strong>宏任务</strong>，回到 2 循环至宏任务队列为空</li>
</ol>
<h4 id="一些例子-1">一些例子</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>() <span class="comment">// -&gt; 执行 async2 并等待返回结果</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>) <span class="comment">// 6 -&gt; 有的浏览器会先执行 then 的，而不是按入栈出栈的先后顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>) <span class="comment">// 7</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="node.js-中的-eventloop">Node.js 中的 EventLoop</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="三大关键阶段">三大关键阶段</h4>
<ol type="1">
<li><p><strong>timer</strong>：执行定时器回调阶段，检查定时器（<code>setTimeout</code> <code>setInterval</code>），如果到了时间就执行回调。</p></li>
<li><p><strong>poll</strong>：轮询阶段，当文件 I/O、网络 I/O 等一步操作执行完之后，通过 <code>data</code> <code>connect</code> 等事件来通知 JS 主线程，使得时间循环到达 poll 阶段：</p>
<ul>
<li>如果当前已经存在定时器，且定时器到时间了，拿出来执行，eventLoop 回到 timer 阶段</li>
<li>如果没有定时器，就去看回调函数队列
<ul>
<li>如果队列不为空，拿出队列中的方法依次执行</li>
<li>如果队列为空，检查是否有 <code>setImmediate</code>
<ul>
<li>有则前往 check 阶段</li>
<li>没有则继续等待，等待 callback 加入队列，加入后会立即执行；一定时间后自动进入 check 阶段</li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>check</strong>：直接执行 <code>setImmediate</code></p>
<ul>
<li><p><code>setTimeout</code> -&gt; timers</p></li>
<li><p><code>setImmediate</code> -&gt; check</p></li>
<li><p><code>nextTick</code> -&gt; 当前阶段的后面</p></li>
<li><p><code>promise.then</code> -&gt; 看他是通过什么实现的，如果是用 <code>nextTick</code> 实现的，就当 <code>nextTick</code> 看，当 <code>resolve</code> 的时候放在当前阶段的后面</p></li>
</ul></li>
</ol>
<h4 id="一些例子-2">一些例子</h4>
<p>注意：有可能先执行 JS 代码，也有可能先开启 EventLoop，因为进程开启都需要时间。</p>
<p>比如当执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(fn, <span class="number">100</span>)</span><br><span class="line"><span class="title function_">setImmediate</span>(fn2)</span><br></pre></td></tr></table></figure>
<p><strong><code>fn</code> 放到一个 timers 的一个数组中</strong></p>
<p>V</p>
<p><strong>进入 poll 阶段进行等待，同时看时间</strong></p>
<p>V</p>
<p><strong>进入 check 阶段</strong> 允许在 poll 阶段空闲的时候立即执行一些函数，主要是 <code>setImmediate()</code> 里面的， 比如如果有 <code>setImmediate(fn2)</code>，则在 poll 中就不等了，直接进入 check，在 check 中执行 <code>fn2</code></p>
<p>V</p>
<p><strong>进入 timers 阶段，执行 <code>fn</code></strong> 如果因为之前有 <code>setImmediate()</code> 导致提前进入了下一个循环，而此时 <code>setTimeout</code> 的计时还没到，则此时不执行 <code>fn</code></p>
<p>而有种情况比较特殊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">setImmediate</span>(fn2)</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>如果 EventLoop 开启得很快，则此时 timers 中没有 <code>fn</code>；</p></li>
<li><p>如果 EventLoop 开启得慢，则此时 timers 中有 <code>fn</code>，而如果此时 timers 中有 <code>fn</code>，而且计时已经结束，就马上执行了 <code>fn</code> 再往下走</p></li>
</ul>
<p>也就是说因为 EventLoop 有时候开启得快，有时候开启得慢，所以如果一开始就执行上面两句代码，他们的执行先后是不确定的！</p>
<h2 id="js-垃圾回收">JS 垃圾回收</h2>
<h3 id="内存的生命周期">内存的生命周期</h3>
<p>JS 环境中的内存声明周期由以下三部分组成：</p>
<ol type="1">
<li>内存分配：当我们声明变量、函数、对象的时候，系统会自动分配内存</li>
<li>内存使用：使用变量、函数等</li>
<li>内存回收</li>
</ol>
<h3 id="垃圾回收">垃圾回收</h3>
<h4 id="什么是垃圾">什么是垃圾</h4>
<ul>
<li>没有被引用的，所谓引用就是一个对象拥有访问另一个对象的权限（隐式或显式）</li>
<li>引用的几个对象互相组成环</li>
</ul>
<h4 id="垃圾回收算法">垃圾回收算法</h4>
<h5 id="引用计数法">引用计数法</h5>
<p>每次生成一个新东西，就将被引用的对象的计数 +1，每次删除一个东西，就将被引用的对象计数 -1 但是若出现循环引用，则无法回收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">div.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 div 引用了事件处理函数，事件处理函数也引用了 div，因为 div 可以在事件处理函数中被访问到。</p>
<h5 id="标记清除法">标记清除法</h5>
<ol type="1">
<li>标记所有变量</li>
<li>从根部清除所有能触及的对象的标记</li>
<li>删除掉还有标记的变量</li>
</ol>
<p>解决除了循环引用的问题，因为循环引用的对象无法从全局对象出发再获取到他们的引用。</p>
<h3 id="内存泄漏">内存泄漏</h3>
<p>经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏</p>
<h4 id="常见的内存泄露">常见的内存泄露</h4>
<h5 id="意外的全局变量">意外的全局变量</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  bar1 = <span class="string">&#x27;some text&#x27;</span> <span class="comment">// 实际上声明了全局变量 window.bar1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bar2</span> = <span class="string">&#x27;some text&#x27;</span> <span class="comment">// 全局变量 window.bar2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="被遗忘的计时器和回调函数">被遗忘的计时器和回调函数</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = <span class="title function_">loadData</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;renderer&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(renderer) &#123;</span><br><span class="line">    renderer.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(serverData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>如果后续移除了 renderer，那么其实计时器已经没用了，但是没有回收计时器的话，计时器仍然后效，他依赖的 serverData 也依然有效</p>
<h5 id="dom-引用">DOM 引用</h5>
<p>前端除了 JS 进程以外，还有 DOM 进程：</p>
<ul>
<li>只使用 <code>div.remove</code> 只是将 <code>div</code> 从页面中删掉，但在内存中还在</li>
<li>只使用 <code>div = null</code>，而没有 <code>remove</code> 的话，<code>div</code> 还在 DOM 中，他就不会被回收</li>
</ul>
<p>此外还有一些特殊情况，比如如果我们引用了一个表格中的 td 元素，一旦在 DOM 中删除了整个表格，我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素。但是事实上，这个 td 元素是整个表格的一个子元素，并保留对于其父元素的引用。这就会导致对于整个表格，都无法进行内存回收。</p>
<h2 id="与后端进行数据交互的方法">与后端进行数据交互的方法</h2>
<h3 id="form-表单">Form 表单</h3>
<ul>
<li>只支持 GET 和 POST 类型</li>
<li>有问无答</li>
<li>提交后页面会刷新，用户体验不佳</li>
</ul>
<h3 id="ajax-1">AJAX</h3>
<ul>
<li>支持多种请求方法</li>
<li>XMLHttpRequest</li>
<li>Fetch</li>
<li>POST 请求编码方式
<ul>
<li>multipart/formData</li>
</ul></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以用</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// 也可以直接将 Form 表单的 DOM 对象直接放进去</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>($form)</span><br></pre></td></tr></table></figure>
<h3 id="websocket">WebSocket</h3>
<ul>
<li>服务器可以主动发起请求</li>
</ul>
<h2 id="时间">时间</h2>
<ul>
<li>ISO 8601</li>
<li>Moment.js</li>
<li>Day.js</li>
</ul>
<h2 id="代码题">代码题</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">a.<span class="property">x</span> = a = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码执行分为两步： 1. 确定 a 是什么；2. 执行（从右向左）</span></span><br><span class="line"><span class="comment">// 执行到 a.x 的时候，a 还是原来的地址，但是他右边的 a 已经是新的地址了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/hais-notebook/2022/05/29/Linux/</url>
    <content><![CDATA[<p>参考文章 <a href="https://juejin.cn/post/6917096816118857736">1</a>、B 站教程等。</p>
<span id="more"></span>
<h1 id="linux-发行版">Linux 发行版</h1>
<h2 id="linux-历史">Linux 历史</h2>
<ul>
<li>1983 年，Richard Stallman 发起 GNU 计划，他同时也是 smalltack 语言的发明者（被公认的第二个面向对象语言），他还编写了 Emacs。</li>
<li>1991 年，Linus Torvalds 开始开发 Linux 内核。</li>
<li>1996 年，确定企鹅为 Linux 的吉祥物。</li>
</ul>
<h2 id="linux-发行版的主要起源">Linux 发行版的主要起源</h2>
<p>Linux 有众多发行版，但其实有两条主线，<strong>debian</strong> 系列和 <strong>redhat</strong> 系列。</p>
<ul>
<li>Debian 计划是一个致力于创建自有操作系统的合作组织，他的特点是稳定、安全。Ubuntu 就是基于 Debian 改进的。</li>
<li>RedHat 是一家商业公司，现在对个人提供一些<em>红帽认证</em>之类的证书。现在的 Centos 占据了大部分服务器市场。</li>
</ul>
<h2 id="典型版本">典型版本</h2>
<ul>
<li>Ubuntu：基于 Debian 系统的 unstable 分支修改的，界面漂亮，包管理软件是 apt-get。</li>
<li>Centos：是 RHEL 源码再编译的产物，在包管理和稳定性上，与红帽企业版差别不大。</li>
<li>ArchLinux：采用滚动升级的模式发行，他的软件和理念通常都是最新的，定制化非常强。</li>
<li>Gentoo：下载的是软件的源代码，然后在本地进行编译安装，比较底层。</li>
<li>LFS：Linux From Scratch，有非常详细的安装文档，教你怎么编译内核，编译引导程序等。</li>
<li>Kali：非常专业的发行版，包含了常见的破解、渗透、攻击工具。</li>
</ul>
<h1 id="path">PATH</h1>
<p>Linux 上一些目录里的文件，是可以被默认找到的，这些目录的集合，就叫做 PATH。PATH 也是一个环境变量，我们可以额通过命令查看 PATH：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span></span><br></pre></td></tr></table></figure>
<h1 id="linux-一切皆文件">Linux 一切皆文件</h1>
<p>在 Linux 中，对命令、文档、设备、目录、套接字的操作都是一致的。开发驱动程序中使用的一些函数，其实和读写文件没什么两样。</p>
<h2 id="当前路径pwd">当前路径：<code>pwd</code></h2>
<blockquote>
<p>pwd: print working directory</p>
</blockquote>
<div class="note warning"><p>在执行一些危险命令时，时常确认当前目录是是个好习惯。</p>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># /root</span></span><br></pre></td></tr></table></figure>
<p>当默认使用 root 登录之后，就会停留在 <code>/root</code> 目录中，Linux 中的目录层次，是通过 <code>/</code> 进行划分的。</p>
<h2 id="文件系统的用户标准">文件系统的用户标准</h2>
<blockquote>
<p>FHS: Filesystem Hierarchy Standard</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>第一层</th>
<th>第二层</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/bin</code></td>
<td></td>
<td>目录 <code>/usr/bin</code> 的软链接</td>
</tr>
<tr class="even">
<td><code>/sbin</code></td>
<td></td>
<td>目录 <code>/usr/sbin</code> 的软链接</td>
</tr>
<tr class="odd">
<td><code>/lib</code></td>
<td></td>
<td>目录 <code>/usr/lib</code> 的软链接</td>
</tr>
<tr class="even">
<td><code>/usr</code></td>
<td><code>/bin</code></td>
<td>存放一些常用的命令</td>
</tr>
<tr class="odd">
<td><code>/usr</code></td>
<td><code>/sbin</code></td>
<td>存放一些管理员常用的命令</td>
</tr>
<tr class="even">
<td><code>/usr</code></td>
<td><code>/lib</code></td>
<td>存放一些动态库和模块文件</td>
</tr>
<tr class="odd">
<td><code>/sys</code></td>
<td></td>
<td>内核中的数据结构的可视化接口</td>
</tr>
<tr class="even">
<td><code>/proc</code></td>
<td></td>
<td>内存映像</td>
</tr>
<tr class="odd">
<td><code>/run</code></td>
<td></td>
<td>内存映像</td>
</tr>
<tr class="even">
<td><code>/boot</code></td>
<td></td>
<td>存放引导程序，内核相关文件</td>
</tr>
<tr class="odd">
<td><code>/dev</code></td>
<td></td>
<td>存放一些设备文件，比如光盘</td>
</tr>
<tr class="even">
<td><code>/etc</code></td>
<td></td>
<td>存放一些全局的、应用配置文件。比如如果安装了 php、nginx，他们的配置文件就放在这下面的某个文件夹里面</td>
</tr>
<tr class="odd">
<td><code>/var</code></td>
<td></td>
<td>同 <code>/var/run</code>，存放系统运行时需要的文件，比如 mysql 的 pid 等</td>
</tr>
<tr class="even">
<td><code>/tmp</code></td>
<td></td>
<td>非常特殊的临时文件夹，断电丢失，所有用户都有写入权限，通常用来做文件交换用</td>
</tr>
<tr class="odd">
<td><code>/home</code></td>
<td><code>/*</code></td>
<td>用户目录。我们可以在里面做任何操作，可以存放一些自己的资料、测试用的数据资料等</td>
</tr>
<tr class="even">
<td><code>/root</code></td>
<td></td>
<td>root 用户的 home</td>
</tr>
</tbody>
</table>
<h2 id="查看文件列表ls">查看文件列表：<code>ls</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls 可以接受路径参数，不用跳转到那里去就能输出相关信息</span></span><br><span class="line"><span class="built_in">ls</span> /</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code> <code>--all</code></td>
<td>列出所有的文件，包括隐藏文件</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>列出文件的详细信息</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>根据修改时间排序</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>根据 ctime 排序显示</td>
</tr>
<tr class="odd">
<td><code>-C</code> <code>--color</code></td>
<td>显示彩色</td>
</tr>
</tbody>
</table>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx   1 root root         7 Apr 20 18:39 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   3 root root      4096 Apr 20 18:54 boot</span><br><span class="line">drwxr-xr-x  18 root root      3880 May 29 16:48 dev</span><br><span class="line">drwxr-xr-x  88 root root      4096 May 23 17:14 etc</span><br><span class="line">drwxr-xr-x   3 root root      4096 May 23 17:03 home</span><br><span class="line">lrwxrwxrwx   1 root root         7 Apr 20 18:39 lib -&gt; usr/lib</span><br></pre></td></tr></table></figure>
<ul>
<li>第一列：第一个字母是文件类型，后面表示文件权限</li>
<li>第二列：普通文件表示链接数，目录表示是子文件数</li>
<li>第三列：所属用户</li>
<li>第四列：所属组</li>
<li>第五列：大小</li>
<li>第六列：最后修改时间</li>
<li>最后一列：软链接或文件名</li>
</ul>
<h3 id="隐藏文件">隐藏文件</h3>
<p>直接在 <code>/root</code> 目录里执行 <code>ls -al</code> 可以看到更多的东西，这些额外的东西就是隐藏文件，他们都是以 <code>.</code> 开头，并且以配置文件居多。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">drwx------  5 root root 4096 May 29 16:55  .</span><br><span class="line">drwxr-xr-x 18 root root 4096 May 23 16:52  ..</span><br><span class="line">-rw-------  1 root root 1196 May 29 19:45  .bash_history</span><br><span class="line">-rw-r--r--  1 root root 3106 Dec  5  2019  .bashrc</span><br></pre></td></tr></table></figure>
<p>并且还有两个特殊的目录—— <code>.</code> 和 <code>..</code>。前者表示当前目录，后者表示上层目录。</p>
<p>也可以使用 <code>ll</code>，他相当于 <code>ls -al</code>。</p>
<h2 id="切换目录cd">切换目录：<code>cd</code></h2>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>../</code></td>
<td>上层目录</td>
</tr>
<tr class="even">
<td><code>./</code></td>
<td>当前目录</td>
</tr>
<tr class="odd">
<td><code>~</code></td>
<td>当前的用户目录</td>
</tr>
<tr class="even">
<td><code>-</code></td>
<td>可以在最近的两次目录中来回切换</td>
</tr>
</tbody>
</table>
<h2 id="创建目录mkdir">创建目录：<code>mkdir</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p a1/b2/c3/d4/e5/f6/&#123;g7,g8,g9,g10&#125;</span><br></pre></td></tr></table></figure>
<p><code>-p</code> 可以让我们一次性创建多层目录，<code>&#123;&#125;</code> 可以一次性创建多个目录</p>
<h2 id="文件操作touch-rm-cp-mv">文件操作：<code>touch</code> <code>rm</code> <code>cp</code> <code>mv</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">touch</span> long.txt</span><br><span class="line"><span class="built_in">touch</span> haha.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line"><span class="built_in">cp</span> haha.txt xixi.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line"><span class="built_in">mv</span> long.txt short.txt</span><br><span class="line"><span class="built_in">mv</span> haha.txt a1/</span><br><span class="line"><span class="built_in">mv</span> xixi.txt a1/b2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> short.txt</span><br><span class="line"><span class="built_in">rm</span> -rvf a1/</span><br></pre></td></tr></table></figure>
<h3 id="复制文件cp">复制文件：<code>cp</code></h3>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-r</code></td>
<td>递归复制</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>强制复制，直接覆盖不给提示</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>覆盖时给提示</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示详细步骤</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>把文件属性也复制过去</td>
</tr>
<tr class="even">
<td><code>-a</code></td>
<td>把档案所有特性一起复制</td>
</tr>
</tbody>
</table>
<h2 id="删除文件rm">删除文件：<code>rm</code></h2>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-r</code></td>
<td>递归删除</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>强制删除，不给提示</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>删除时给提示</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示详细步骤</td>
</tr>
</tbody>
</table>
<h2 id="移动文件mv">移动文件：<code>mv</code></h2>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-f</code></td>
<td>直接覆盖，不给提示</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>覆盖时给提示</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示详细步骤</td>
</tr>
<tr class="even">
<td><code>-b</code></td>
<td>覆盖前先备份</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>文件较新的时候才覆盖</td>
</tr>
</tbody>
</table>
<h1 id="操作文件">操作文件</h1>
<p><code>ll</code> 结果的第一列的第一个字母，表示了 Linux 文件类型：</p>
<table>
<thead>
<tr class="header">
<th>字母</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-</code></td>
<td>普通文件</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>目录文件</td>
</tr>
<tr class="odd">
<td><code>l</code></td>
<td>链接文件，比如快捷方式</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>套接字文件</td>
</tr>
<tr class="odd">
<td><code>c</code></td>
<td>字符设备文件，比如 <code>/dev/ 中的很多文件</code></td>
</tr>
<tr class="even">
<td><code>b</code></td>
<td>块设备文件，比如一块磁盘</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>管道文件</td>
</tr>
</tbody>
</table>
<p>Linux 上文件可以没有后缀，他的后缀其实没有什么实际的意义，我们可以通过 <code>file</code> 命令查看文件的具体类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file /etc</span><br><span class="line"><span class="comment"># /etc: directory</span></span><br><span class="line">file /etc/group</span><br><span class="line"><span class="comment"># /etc/group: ASCII text</span></span><br></pre></td></tr></table></figure>
<h2 id="创建一个文件">创建一个文件</h2>
<h3 id="生成数字序列seq">生成数字序列：<code>seq</code></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 10 20 &gt;&gt; spring</span><br></pre></td></tr></table></figure>
<p><code>&gt;</code> 是将前面命令的输出重定向到其他地方；<code>&gt;&gt;</code> 类似，并且是在原来文件的基础上追加内容</p>
<h3 id="查看内容cat">查看内容：<code>cat</code></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n spring</span><br><span class="line"><span class="comment"># 1	10</span></span><br><span class="line"><span class="comment"># 2	11</span></span><br><span class="line"><span class="comment"># 3	12</span></span><br><span class="line"><span class="comment"># 4	13</span></span><br><span class="line"><span class="comment"># 5	14</span></span><br><span class="line"><span class="comment"># 6	15</span></span><br><span class="line"><span class="comment"># 7	16</span></span><br><span class="line"><span class="comment"># 8	17</span></span><br><span class="line"><span class="comment"># 9	18</span></span><br><span class="line"><span class="comment"># 10	19</span></span><br><span class="line"><span class="comment"># 11	20</span></span><br></pre></td></tr></table></figure>
<p><code>-n</code> 会显示行号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并 a 文件和 b 文件到 c 文件</span></span><br><span class="line"><span class="built_in">cat</span> a b &gt;&gt; c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 a 文件内容作为输入，使用管道处理</span></span><br><span class="line"><span class="built_in">cat</span> a | cmd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入内容到指定文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; index.html &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h3 id="平和地查看内容less-head-tail">平和地查看内容：<code>less</code> <code>head</code> <code>tail</code></h3>
<p>如果文件非常大，使用 <code>cat</code> 就会在终端上疯狂输出，这时候我们可以使用另外的方案。</p>
<h4 id="less"><code>less</code></h4>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-n</code></td>
<td>显示行号</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>显示百分比</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>常用快捷键</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/</code></td>
<td>向下搜索</td>
</tr>
<tr class="even">
<td><code>?</code></td>
<td>向上搜索</td>
</tr>
<tr class="odd">
<td><code>n</code></td>
<td>重复上一个搜索</td>
</tr>
<tr class="even">
<td><code>N</code></td>
<td>反向重复上一个搜索</td>
</tr>
<tr class="odd">
<td><code>&lt;space&gt;</code></td>
<td>向后翻页</td>
</tr>
<tr class="even">
<td><code>b</code></td>
<td>向前翻页</td>
</tr>
<tr class="odd">
<td><code>j</code></td>
<td>向下一行</td>
</tr>
<tr class="even">
<td><code>k</code></td>
<td>向上一行</td>
</tr>
<tr class="odd">
<td><code>g</code></td>
<td>去开头</td>
</tr>
<tr class="even">
<td><code>G</code></td>
<td>去结尾</td>
</tr>
<tr class="odd">
<td><code>q</code></td>
<td>退出</td>
</tr>
</tbody>
</table>
<h4 id="head-tail"><code>head</code> <code>tail</code></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示头三行</span></span><br><span class="line"><span class="built_in">head</span> -n 3 spring</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾三行</span></span><br><span class="line"><span class="built_in">tail</span> -n 3 spring</span><br></pre></td></tr></table></figure>
<p><code>tail -f</code> 表示循环读取，可以用来在控制终端实时监控文件变化，来查看一些滚动日志，可以配合 <code>grep</code> 命令达到过滤效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 滚动查看系统日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/messages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滚动查看包含 info 字样的日志信息</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/messages | grep info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滚动监控到重新创建的文件，比如一些按天滚动的</span></span><br><span class="line"><span class="built_in">tail</span> -F</span><br></pre></td></tr></table></figure>
<h3 id="查找文件find">查找文件：<code>find</code></h3>
<table>
<thead>
<tr class="header">
<th>常用参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-name</code></td>
<td>文件名，可以使用通配符</td>
</tr>
<tr class="even">
<td><code>-size</code></td>
<td>根据大小搜索</td>
</tr>
<tr class="odd">
<td><code>-type</code></td>
<td>根据文件类型搜索 f d l s p b c</td>
</tr>
<tr class="even">
<td><code>-perm</code></td>
<td>根据文件权限搜索</td>
</tr>
<tr class="odd">
<td><code>-mtime</code></td>
<td>修改时间，天</td>
</tr>
<tr class="even">
<td><code>-mmin</code></td>
<td>修改时间，分</td>
</tr>
<tr class="odd">
<td><code>-user</code></td>
<td>属于某个用户</td>
</tr>
<tr class="even">
<td><code>-group</code></td>
<td>属于某个组</td>
</tr>
<tr class="odd">
<td><code>-exec</code></td>
<td>执行命令，建议使用 xargs 替代</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局找 decorator 文件</span></span><br><span class="line">find / -name decorator.py -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除当前目录中的所有 class 文件</span></span><br><span class="line">find . | grep .class$ | xargs <span class="built_in">rm</span> -rvf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 /root 下一天前访问的文件</span></span><br><span class="line">find /root -atime 1 -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找十分钟内更新过的文件</span></span><br><span class="line">find /root -cmin -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找输入 root 用户的文件</span></span><br><span class="line">find /root -user root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找大于 1MB 的文件，进行清理</span></span><br><span class="line"></span><br><span class="line">find /root -size +1024k -<span class="built_in">type</span> f | xargs <span class="built_in">rm</span> -f</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>FAQs</title>
    <url>/hais-notebook/2022/03/12/Memo-FAQs/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="css">CSS</h1>
<h2 id="滚动条的宽度">滚动条的宽度</h2>
<p>滚动条的宽度在 14 ~ 19px 之间，根据操作系统不同</p>
<h2 id="回溯机制">回溯机制</h2>
<h2 id="flex-的常见属性">flex 的常见属性</h2>
<h2 id="页面导入样式时link-和-import-有什么区别">页面导入样式时，<code>link</code> 和 <code>@import</code> 有什么区别</h2>
<table>
<thead>
<tr class="header">
<th>link</th>
<th><span class="citation" data-cites="import">@import</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HTML 标签，除了 CSS 之外还可以定义 RSS 等</td>
<td>CSS 提供的</td>
</tr>
<tr class="even">
<td>加载页面时同时加载</td>
<td>页面加载完之后再加载</td>
</tr>
<tr class="odd">
<td>没有兼容性问题</td>
<td>不兼容 IE 5 以下</td>
</tr>
<tr class="even">
<td>可以通过 DOM 动态引入</td>
<td>不能动态引入</td>
</tr>
</tbody>
</table>
<h2 id="移动端响应式方案">移动端响应式方案</h2>
<ol type="1">
<li><span class="citation" data-cites="media">@media</span></li>
<li>PC 固定布局，移动端 rem</li>
<li>flex</li>
<li>vh/vw</li>
</ol>
<h2 id="css-选择器优先级">CSS 选择器优先级</h2>
<ol type="1">
<li>越具体优先级越高</li>
<li>写在后面的覆盖写在前面的</li>
<li><code>important!</code> 最高，但是少用</li>
</ol>
<h2 id="清除浮动">清除浮动</h2>
<h1 id="dom">DOM</h1>
<h2 id="事件委托">事件委托</h2>
<p>父级通过 <code>target</code> 来判断是谁上面发生的事件，并作出不同的响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了 li&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bindEvent</span> = (<span class="params">element, eventType, selector, fn</span>) =&gt; &#123;</span><br><span class="line">  element.<span class="title function_">addEventListener</span>(eventType, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> el = e.<span class="property">target</span></span><br><span class="line">    <span class="keyword">while</span> (!el.<span class="title function_">matches</span>(selector)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (el === element) &#123;</span><br><span class="line">        el = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      el = el.<span class="property">parentNode</span></span><br><span class="line">    &#125;</span><br><span class="line">    el &amp;&amp; fn.<span class="title function_">call</span>(el, e)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用-mouse-事件写一个可拖拽的-div">用 mouse 事件写一个可拖拽的 div</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dragging = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> position = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  dragging = <span class="literal">true</span></span><br><span class="line">  position = [e.<span class="property">clientX</span>, e.<span class="property">clientY</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragging) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> x = e.<span class="property">clientX</span></span><br><span class="line">  <span class="keyword">const</span> y = e.<span class="property">clientY</span></span><br><span class="line">  <span class="keyword">const</span> deltaX = x - position[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> deltaY = y - position[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> left = <span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">left</span> || <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> top = <span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">top</span> || <span class="number">0</span>)</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">left</span> = left + deltaX + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  div.<span class="property">style</span>.<span class="property">top</span> = top + deltaY + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  position = [x, y]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  dragging = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="http">HTTP</h1>
<h2 id="pwa">PWA</h2>
<h2 id="get-和-post-的区别">GET 和 POST 的区别</h2>
<ul>
<li>GET 不安全，POST 不安全（其实都不安全）</li>
<li>GET 是有长度限制的，POST 没有长度限制（但一般 GET 的长度不超过 1 KB，POST 上限 4M ~ 20M 左右）</li>
<li>GET 参数在 URL 中，POST 消息在消息体中</li>
<li>GET 只需要一个报文，POST 需要两个以上（因为有消息体）</li>
<li>GET 幂等，POST 不幂等</li>
<li>语义不同，GET 是为了获取数据，POST 是为了提交数据</li>
</ul>
<h2 id="nslookup">nslookup</h2>
<p>直接使用可以查询到域名的 A 记录。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup hais-teatime.com</span><br></pre></td></tr></table></figure>
<h2 id="域名">域名</h2>
<p>比如对于 www.baidu.com</p>
<ul>
<li>顶级域名：com</li>
<li>：baidu.com</li>
<li>三级域名：www.baidu.com</li>
</ul>
<p>三级域名跟二级域名可以没关系，有可能都不是属于一家公司，注意辨别。</p>
<h1 id="jquery">jQuery</h1>
<h2 id="制作-tab">制作 Tab</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$tabBar.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $li = $(e.<span class="property">currentTarget</span>)</span><br><span class="line">  $li</span><br><span class="line">    .<span class="title function_">addClass</span>(<span class="string">&#x27;selected&#x27;</span>)</span><br><span class="line">    .<span class="title function_">siblings</span>()</span><br><span class="line">    .<span class="title function_">removeClass</span>(<span class="string">&#x27;selected&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> index = $li.<span class="title function_">index</span>()</span><br><span class="line">  $tabContent</span><br><span class="line">    .<span class="title function_">children</span>()</span><br><span class="line">    .<span class="title function_">eq</span>(index)</span><br><span class="line">    .<span class="title function_">addClass</span>(<span class="string">&#x27;active&#x27;</span>) <span class="comment">// 一定不要用.css 和.show，样式和行为分离</span></span><br><span class="line">    .<span class="title function_">siblings</span>()</span><br><span class="line">    .<span class="title function_">removeClass</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$tabBar.<span class="title function_">children</span>().<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;click&#x27;</span>)  <span class="comment">// 默认触发第一个</span></span><br></pre></td></tr></table></figure>
<h1 id="vue">Vue</h1>
<h2 id="组件间通信">组件间通信</h2>
<ol type="1">
<li>父子组件：<code>$emit</code> 和 <code>$on</code></li>
<li>爷孙组件、兄弟组件：eventBus</li>
<li>Vuex</li>
</ol>
<h2 id="渲染过程">渲染过程</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的同步渲染过程</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> child = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">div.<span class="title function_">appendChild</span>(child) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 1</span></span><br><span class="line">body.<span class="title function_">appendChild</span>(div) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">outerHTML</span>)</span><br></pre></td></tr></table></figure>
<p>不能让 A —更新—&gt; B 的同时 B —更新—&gt; A</p>
<h1 id="react">React</h1>
<h2 id="组件间通信-1">组件间通信</h2>
<ol type="1">
<li>父子组件：通过 props 直接传参（onChange、onClick）</li>
<li>爷孙组件：传两次 props</li>
<li>任意组件：Redux</li>
</ol>
<h2 id="dom-diff">DOM Diff</h2>
<h3 id="reconciliation">Reconciliation</h3>
<p>Reconciliation 直译为协调，即 React 的渲染机制，他有以下几步：</p>
<ol type="1">
<li>props 或 state 改变</li>
<li>render 函数返回不同的元素树（虚拟 DOM）</li>
<li>新旧 DOM 对比（vDOM Diff）</li>
<li>针对差异的地方进行更新</li>
<li>渲染为真实的 DOM 树</li>
</ol>
<h3 id="dom-diff-原理">DOM Diff 原理</h3>
<h4 id="设计思想">设计思想</h4>
<ol type="1">
<li>永远只比较同层的节点，不会跨层级比较</li>
<li>不同的两个节点产生不同的树（两个类型不同的节点直接用新的全部替代旧的，包括其后代）</li>
<li>通过 key 判断哪些元素是相同的（比如列表如果没有 key，从头部插入元素会导致列表全部更新），因此 key 需要在列表中保持唯一（不需要全局唯一）</li>
</ol>
<h4 id="比较流程">比较流程</h4>
<ul>
<li>若元素类型不相同：直接用新的树替换掉原来的树</li>
<li>若元素类型相同：
<ul>
<li>若都是 DOM 节点：更新 DOM 属性，比如 <code>style</code>、<code>title</code> 等，再向下递归找</li>
<li>若都是组件节点：组件实例保持不变，更新 Props</li>
</ul></li>
</ul>
<h3 id="如何减少-diff-过程">如何减少 Diff 过程</h3>
<blockquote>
<p>利用 <code>shouldComponentUpdate</code></p>
</blockquote>
<p>默认的 <code>shouldComponentUpdate</code> 会在 props 或 state 发生变化的时候返回 true，表示组件会重新渲染，然后调用 render 函数，进行 vDOM Diff；相对的，我们也可以通过控制它的返回值来控制是否发生 vDOM Diff</p>
<h3 id="浅比较与深比较">浅比较与深比较</h3>
<ul>
<li>类组件的 <code>shouldComponentUpdate</code> 中可以对 props 和 state 进行浅比较（使用 <code>pureComponent</code> API，比较一层 key 和 value，类似于浅拷贝），也可以进行深比较（递归）</li>
<li>函数组件使用 <code>memo</code> 方法可以进行肩比较，但是只比较了 props：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>)</span><br></pre></td></tr></table></figure>
<h3 id="immutable-数据结构">immutable 数据结构</h3>
<p>immutable 的意义：浅比较缺点很明显，深比较有时候又比较浪费性能</p>
<p>简单来说：</p>
<ol type="1">
<li><strong>节省性能</strong>：immutable 内部采用多叉树结构，如果它里面有节点被改变，那么则更新 <strong>这个节点</strong> 和他有关的所有 <strong>上级节点</strong></li>
<li><strong>返回一个新的引用</strong>，即使是浅比较也能感知到数据的变化</li>
</ol>
<h4 id="一些-immutable-api">一些 immutable API</h4>
<h5 id="fromjs">fromJS</h5>
<p>将 JS 对象转换为 immutable 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">&#x27;immutable&#x27;</span></span><br><span class="line"><span class="keyword">const</span> immutableState = <span class="title function_">fromJS</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="tojs">toJS</h5>
<p>将 immutable 对象转换为 JS 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsObj = immutableState.<span class="title function_">toJS</span>()</span><br></pre></td></tr></table></figure>
<h5 id="getgetin">get/getIn</h5>
<p>用来获取 immutable 对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.<span class="property">a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.<span class="property">a</span>.<span class="property">b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.<span class="title function_">getIn</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 传入一个数组</span></span><br></pre></td></tr></table></figure>
<h5 id="set">set</h5>
<p>用来给 immutable 对象的属性赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="merge">merge</h5>
<p>新旧数据对比，旧数据中不存在的属性直接添加，存在的属性用新数据覆盖</p>
<h1 id="webpack">Webpack</h1>
<p><a href="zhuanlan.zhihu.com/p/44438844">更多问题可以查看这篇知乎专栏</a></p>
<h2 id="提高构建速度">提高构建速度</h2>
<ul>
<li>happypack 使用多线程打包</li>
<li>dllplugin</li>
</ul>
<h2 id="webpack-文件过大">webpack 文件过大</h2>
<ul>
<li>提取通用模块文件</li>
<li>压缩 JS、CSS、图片</li>
<li>按需加载</li>
</ul>
<h2 id="import-alias">import alias</h2>
<h3 id="在-js-或-ts-中使用">在 JS 或 TS 中使用 <code>@</code></h3>
<p>可以直接使用</p>
<h3 id="在-css-或-scss-中使用">在 CSS 或 SCSS 中使用 <code>@</code></h3>
<p>需要使用 <code>~@</code>，但是 webstorm 中会报错，需要点开 <code>settings</code>-<code>webpack</code>，在路径中找到 <code>node_modules\@vue\cli-service\webpack.config.js</code></p>
<h1 id="数据结构">数据结构</h1>
<h2 id="哈希表">哈希表</h2>
<p>按照一定的规则（有很多种不同的规则，可以按实际情况选择）去存储数据，这样找数据的时候就会很快了。 有时候会出现冲突（不同的数据根据规则计算应该放到同样的地方），这个时候需要解决冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length = <span class="number">1000</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">slots</span> = <span class="title class_">Array</span>(length) <span class="comment">// slots 就是哈希表的这个数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算出要存的位置，这里的方法是：将这个字符串的每一位的 ASCII 码算出来，再把每一位的加起来，再%哈希表的总长度</span></span><br><span class="line">  <span class="title function_">hash</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="comment">// 将字符串解构为一个个的数组</span></span><br><span class="line">    <span class="keyword">let</span> value =[...v.<span class="title function_">toString</span>()].<span class="title function_">map</span>(<span class="function"><span class="params">char</span> =&gt;</span> char.<span class="title function_">charCodeAt</span>(<span class="number">0</span>)).<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item)</span><br><span class="line">    <span class="keyword">return</span> value%<span class="variable language_">this</span>.<span class="property">slots</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存数据，因为 hash 值可能相同，所以用 push</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="variable language_">this</span>.<span class="title function_">hash</span>(value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">slots</span>[key]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">slots</span>[key].<span class="title function_">includes</span>((value))) <span class="variable language_">this</span>.<span class="property">slots</span>[key].<span class="property">push</span>[value]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">slots</span>[key] = [value]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删数据</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="variable language_">this</span>.<span class="title function_">hash</span>(value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">slots</span>[key] &amp;&amp; <span class="variable language_">this</span>.<span class="property">slots</span>[key].<span class="title function_">includes</span>(value)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">slots</span>[key] = <span class="variable language_">this</span>.<span class="property">slots</span>[key].<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v !== value)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">search</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="variable language_">this</span>.<span class="title function_">hash</span>(value)</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">slots</span>[key] &amp;&amp; <span class="variable language_">this</span>.<span class="property">slots</span>[key].<span class="title function_">includes</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">slots</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图">图</h2>
<p>顶点：vertex 边：edge</p>
<p>可以这样表示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[V1, V2, V4], [V0, V2, V3], [V0, V1], [V1], [V0]]</span><br></pre></td></tr></table></figure>
<p>每一个数组表示对应的顶点与那些点相邻</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vCount</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertexCount</span> = vCount <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacencyList</span> = [...<span class="title class_">Array</span>(vCount)].<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> []) <span class="comment">// 相邻顶点的列表，得到类似于数组 [[], [], [], []]</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">verticesStatus</span> = [...<span class="title class_">Array</span>(vCount)].<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="literal">false</span>) <span class="comment">// 记录点是不是找过了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacencyList</span>[v1].<span class="title function_">push</span>(v2)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacencyList</span>[v2].<span class="title function_">push</span>(v1)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">showGraph</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacencyList</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">adjVertices, v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;v&#125;</span> -&gt; <span class="subst">$&#123;adjVertices.toString()&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resetStatus</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">verticesStatus</span> = [...<span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">vertexCount</span>)].<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 深度优先搜索</span></span><br><span class="line">  <span class="title function_">dfs</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">verticesStatus</span>[v] = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`访问到：<span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// Array.isArray 判断传递进来的是否是一个 Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">adjacencyList</span>[v])) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">adjacencyList</span>[v].<span class="title function_">forEach</span>(<span class="function"><span class="params">adjVertex</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">verticesStatus</span>[adjVertex]) <span class="variable language_">this</span>.<span class="title function_">dfs</span>(adjVertex)      </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 广度优先搜索</span></span><br><span class="line">  <span class="title function_">bfs</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    queue.<span class="title function_">push</span>(v)</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = queue.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">verticesStatus</span>[v]) <span class="keyword">continue</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">verticesStatus</span>[v] = <span class="literal">true</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`访问到 <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">adjacencyList</span>[v].<span class="title function_">forEach</span>(<span class="function"><span class="params">adjVertex</span> =&gt;</span> &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(adjVertex)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="架构">架构</h1>
<h2 id="新建一个项目">新建一个项目</h2>
<ol type="1">
<li><p>创建仓库</p></li>
<li><p>声明 LICENCE <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/free_software_licenses.png" /></p></li>
<li><p>要用什么第三方的东西？ npm</p></li>
<li><p>在 webstorm 里面搜 VCS</p></li>
</ol>
<h2 id="单元测试">单元测试</h2>
<ul>
<li>BDD（Behavior-Driven Development）：行为驱动开发，用自然语言描述需求</li>
<li>TDD（Test-Driven Development）：测试驱动开发，目的是为了让测试通过</li>
<li>Assert：断言</li>
</ul>
<h2 id="持续集成">持续集成</h2>
<ul>
<li>持续测试</li>
<li>持续交付</li>
<li>持续部署</li>
</ul>
<h1 id="mysql">MySQL</h1>
<h2 id="nodejs-client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-client">nodejs Client does not support authentication protocol requested by server; consider upgrading MySQL client</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="redis">Redis</h1>
<ul>
<li>web server 常用的缓存数据库，数据放在内存中</li>
<li>相比于 mysql，访问速度快；但是成本更高，数据量更小</li>
<li>解决：将 web server 和 redis 拆分成两个服务，不会占用 web server 的内存，可以跨进程访问</li>
<li>为何用 redis 来存 session？session 访问频繁，对性能要求高；不用考虑断电数据丢失的问题；session 数据量不会太大</li>
</ul>
<h1 id="其他">其他</h1>
<h2 id="发展趋势">发展趋势</h2>
<h3 id="最重要的">最重要的</h3>
<ul>
<li>React Hooks</li>
<li>ES6</li>
<li>TypeScript</li>
<li>Flutter</li>
</ul>
<h3 id="值得一学的">值得一学的</h3>
<ul>
<li>Graph QL</li>
<li>PWA</li>
<li>WebAssembly</li>
<li>WebGL 3D</li>
<li>《计算的本质》</li>
</ul>
<h3 id="需要了解的">需要了解的</h3>
<h4 id="html-5">HTML 5</h4>
<ul>
<li>语义化标签</li>
<li>音视频处理</li>
<li>canvas / webGL</li>
<li>history API</li>
<li>requestAnimationFrame</li>
<li>地理位置</li>
<li>web socket</li>
</ul>
<h4 id="css-3">CSS 3</h4>
<ul>
<li>常规</li>
<li>动画</li>
<li>盒子模型</li>
<li>响应式布局</li>
</ul>
<h4 id="javascript">JavaScript</h4>
<ul>
<li>ES 3/5/6/7/8/9</li>
<li>DOM</li>
<li>BOM</li>
<li>设计模式</li>
<li>底层原理
<ul>
<li>堆栈内存</li>
<li>闭包作用域 AO/VO/GO/EC/ESTACK</li>
<li>面向对象 OOP</li>
<li>This</li>
<li>EventLoop</li>
<li>浏览器渲染原理</li>
<li>回流重绘</li>
</ul></li>
</ul>
<h4 id="网络通信层">网络通信层</h4>
<ul>
<li>AJAX / Fetch / axios</li>
<li>HTTP 1.0/2.0</li>
<li>TCP</li>
<li>跨域处理方案</li>
<li>性能优化</li>
</ul>
<h4 id="hybrid-app-小程序">Hybrid / APP / 小程序</h4>
<ul>
<li>Hybrid</li>
<li>uni-app</li>
<li>RN</li>
<li>Flutter</li>
<li>MPVUE</li>
<li>Weex</li>
<li>PWA</li>
</ul>
<h4 id="工程化">工程化</h4>
<ul>
<li>webpack</li>
<li>git</li>
<li>linux / nginx</li>
</ul>
]]></content>
      <categories>
        <category>Memo</category>
      </categories>
  </entry>
  <entry>
    <title>Networking</title>
    <url>/hais-notebook/2023/01/18/Networking/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="协议栈">协议栈</h1>
<ul>
<li>应用层：FTP、DNS、HTTP</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP</li>
<li>链路层：DOCSIS</li>
<li>物理层：与双绞铜线、同轴电缆、光纤等相关</li>
</ul>
<h1 id="应用层">应用层</h1>
<h2 id="http">HTTP</h2>
<blockquote>
<p>Web 的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP）</p>
</blockquote>
<h3 id="http-概述">HTTP 概述</h3>
<h4 id="http-历史">HTTP 历史</h4>
<ul>
<li>HTTP 0.9：1991，只有 GET、只能传HTML，没有 CSS、JS，每个HTTP请求都是短连接</li>
<li>HTTP 1.0：1996，有了 POST、HEAD……</li>
<li>HTTP 1.1：1997，目前为止最常用的版本</li>
<li>HTTP 2.0：2015，HTTP 1.1 的扩展，于2015年5月提出</li>
<li>HTTP 3.0：QUIC 协议（一种传输层协议，TCP的效率比较低，QUIC 为了减小 TCP 的延迟和带宽开销）</li>
</ul>
<h3 id="http-协议结构和通讯原理">HTTP 协议结构和通讯原理</h3>
<h4 id="http-协议特点">HTTP 协议特点</h4>
<ul>
<li><strong>支持客户/服务器模式</strong></li>
<li><strong>简单快速</strong>
<ul>
<li>客户向服务器请求服务时，只需要传送请求方法和路径</li>
<li>GET、HEAD、POST</li>
<li>HTTP服务器程序规模小，因此通信速度块</li>
</ul></li>
<li><strong>灵活</strong>
<ul>
<li>允许传输任意类型的数据对象</li>
<li>正在传输的类型由 Content-Type 加以标记</li>
</ul></li>
<li><strong>无连接</strong>
<ul>
<li>无连接的含义是限制 <strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接——keep alive 功能使得连接（TCP）不断开，有规定的超时时间</li>
<li>采用这种方式可以节省传输时间</li>
</ul></li>
<li><strong>无状态</strong>
<ul>
<li>协议对事务的处理能力 <strong>没有记忆能力</strong>，每个请求都是 <strong>独立的</strong></li>
<li>如果后续处理需要前面的信息，则必须重传，导致每次连接的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul></li>
</ul>
<h4 id="uri-和-url">URI 和 URL</h4>
<blockquote>
<p>问题：我们在浏览器的 Web 地址应该叫 URL 还是 URI？ - URI：可以分为 URL 和 URN，或同时具备 locators 和 names 特性的一个东西 - URN 像一个人的名字，URL 像一个人的地址；URN 确定了东西的身份，URL 提供了找到它的方式（提供了访问机制，比如说协议）</p>
</blockquote>
<p>URL 实际上是 URI 的一个子集，除识别资源外还提供定位资源的方法。</p>
<p>下面是一个 URI 的组成：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               path</span><br><span class="line">        ┌───────────────┴───────────────┐┌───┴────┐</span><br><span class="line">  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port                  query         fragment</span><br><span class="line"></span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure>
<p>举一个我们常见的 URL（URI） 的例子：</p>
<p>https://zh.wikipedia.org/w/index.php?title=Special:随机页面#5</p>
<ol type="1">
<li><code>https</code>：协议</li>
<li><code>zh.wikipedia.org</code>：域名</li>
<li><code>/w/index.php</code>：路径（不同的页面）</li>
<li><code>?title=Special:随机页面</code>：查询参数（相同页面，不同内容）</li>
<li><code>#5</code>：锚点（相同页面，相同内容，不同位置）</li>
<li>其中若不写端口号，则表示使用 https 对应的默认端口号 443</li>
</ol>
<h4 id="http-报文结构">HTTP 报文结构</h4>
<h5 id="请求报文">请求报文</h5>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">【请求行】POST（请求方法） /webTours/login.pl（请求 URI） HTTP/1.1（HTTP 协议及版本）</span><br><span class="line">【请求头】用键值对来传递参数，包括 Host、Accept、Content-Type 等</span><br><span class="line"></span><br><span class="line">【请求体】</span><br></pre></td></tr></table></figure>
<p>可以用 curl 构造请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X -POST <span class="comment"># 设置请求动词</span></span><br><span class="line">curl -H <span class="string">&#x27;Accept: text/html&#x27;</span> <span class="comment"># -H 也可以写成 --header</span></span><br><span class="line">curl -H <span class="string">&#x27;Content-Type: text/plain;charset=utf-8&#x27;</span> -d <span class="string">&#x27;请求体内容&#x27;</span> <span class="comment"># -d 也可以写成 --data</span></span><br></pre></td></tr></table></figure>
<p>可以用 Node.js 读取请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.<span class="property">method</span></span><br><span class="line">request.<span class="property">url</span> <span class="comment">// 路径，带参数</span></span><br><span class="line">request.<span class="property">path</span> <span class="comment">// 纯路径</span></span><br><span class="line">request.<span class="property">query</span> <span class="comment">// 只有查询参数</span></span><br><span class="line">request.<span class="property">headers</span>[<span class="string">&#x27;Accept&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h5 id="响应报文">响应报文</h5>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">【响应行】HTTP/1.1（报文协议及版本） 200 Ok（状态码及状态描述）</span><br><span class="line">【响应头】</span><br><span class="line"></span><br><span class="line">【响应体】</span><br></pre></td></tr></table></figure>
<p>可以用 Node.js 设置响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.<span class="property">statusCode</span> = <span class="number">200</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;内容&#x27;</span>) <span class="comment">// 内容可以追加</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>注意 <code>path</code> 都是以 <code>/</code> 开头的</p>
</div>
<h4 id="http-报文头">HTTP 报文头</h4>
<ul>
<li><strong>Accept</strong>：浏览器端可以接收的媒体类型
<ul>
<li><strong>Accept: text/html</strong>，代表浏览器可以接收服务器回发的类型为 text/html 类型的数据，如果服务器无法返回此类型，应该返回一个 406 错误（Non Acceptable）</li>
<li><strong>Accept: <em>/</em></strong>，代表浏览器可以处理所有类型</li>
<li>可以设置优先级（权重值q，取0~1.000）</li>
</ul></li>
<li><strong>Accept-Encoding</strong>：浏览器申明自己接收的编码（压缩）方法（gzip、deflate）</li>
<li><strong>Accept-Language</strong>：浏览器申明自己接收的语言
<ul>
<li><strong>Accept-Language</strong>: zh-cn,zh;q=0.7,en-us,en;q=0.3</li>
</ul></li>
<li><strong>Connection</strong>
<ul>
<li><strong>Connection: keep-alive</strong>，TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>
<li><strong>Connection: close</strong>，一个 Request 完成后，TCP 连接关闭</li>
</ul></li>
<li><strong>Host</strong>：指定被请求资源的 Internet 主机和端口号，通常从 URL 中提取出来</li>
<li><strong>Referer</strong>：一般会带上此字段，告诉服务器是从哪个页面链接过来的</li>
<li><strong>User-Agent</strong>：告诉 HTTP 服务器，客户端使用的操作系统和浏览器名称和版本</li>
<li><strong>Content-Type</strong>：说明了报文体对象的媒体类型 <strong>text/html</strong>：HTML <strong>text/plain</strong>：纯文本 <strong>text/xml</strong>：XML <strong>image/gif</strong>：GIF图像 <strong>image/jpeg</strong>：JPG图像 <strong>image/png</strong>：PNG图像 <strong>application/xhtml+xml</strong>：XHTML <strong>application/xml</strong>：XML <strong>application/atom+xml</strong>：Atom XML <strong>application/json</strong>：JSON <strong>application/pdf</strong>：PDF <strong>application/msword</strong>：WORD <strong>application/octet-stream</strong>：二进制数据流 <strong>application/x-www-form-urlencoded</strong>：表单提交</li>
</ul>
<h4 id="http-请求方法">HTTP 请求方法</h4>
<ul>
<li><strong>GET</strong>：请求访问已被 URI 识别的资源
<ul>
<li>提交的内容是 URL 的一部分，长度限制、安全性</li>
</ul></li>
<li><strong>POST</strong>：与 GET 功能类似，一般用来传输实体的主体，主要目的是提交数据，不是获取响应主体的内容</li>
<li><strong>PUT</strong>：与 POST 最大的不同是，PUT 是幂等（不管重复多少次操作，都是实现相同的结果）的，POST 是不幂等的，因此一般创建对象用 POST，更新对象用 PUT，但是 PUT 没有验证机制，有安全性问题，所以一般还是用 POST</li>
<li><strong>HEAD</strong>：类似于GET，只不过返回的响应中没有具体的内容，用于获取报头（测试超链接的有效性）</li>
<li><strong>DELETE</strong>：请求删除资源，与 PUT 相反，并且没有验证机制，因此现在一般不用</li>
<li><strong>OPTIONS</strong>：用来查询针对请求 URI 指定的资源支持的方法
<ul>
<li>服务器返回一个<code>Allow: GET, HEAD, POST</code>等等</li>
</ul></li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断，但容易受到 XST 攻击，一般不用</li>
<li><strong>CONNECT</strong>：开启客户端与所请求资源之间的双向沟通的通道，可以用来创建隧道，一般用于 HTTP 代理</li>
</ul>
<h4 id="http-状态码">HTTP 状态码</h4>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-StatusCode.png" alt="HTTP状态码" /><figcaption aria-hidden="true">HTTP状态码</figcaption>
</figure>
<ul>
<li><strong>200 Ok</strong>，请求已成功，并且所希望的响应头或数据体已经随此响应返回</li>
<li><strong>202 Accepted</strong>，已接收，但处理未完成</li>
<li><strong>206 Partial Content</strong>，部分内容，处理器成功处理了部分 GET 请求——断点续传</li>
<li><strong>301 Moved Permanently</strong>，永久移动，请求的资源已被永久移动到新的 URI，以后任何新的请求都应使用新的 URI 代替</li>
<li><strong>302 Found</strong>，临时移动，客户端应继续使用原有 URI</li>
<li><strong>400 Bad Request</strong>，客户端请求的语法错误，服务器无法理解</li>
<li><strong>401 Unauthorized</strong>，请求要求用户的身份验证</li>
<li><strong>403 Forbidden</strong>，服务器理解客户端的请求，但是拒绝执行此请求</li>
<li><strong>404 Not Found</strong>，服务器无法根据请求找到资源（网页）</li>
<li><strong>500 Internal Server Error</strong>，服务器内部错误，无法完成请求</li>
<li><strong>502 Bad Gateway</strong>，充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
</ul>
<h4 id="http-状态管理cookie-和-session">HTTP 状态管理：Cookie 和 Session</h4>
<h5 id="cookie">Cookie</h5>
<p>W3C 推行的一种机制，客户端请求服务器，如果服务器需要记录该用户的状态，就向客户端浏览器颁发一个Cookie， 客户端浏览器会把Cookie保存起来，浏览器再请求的时候，就会把请求的网址连同Cookie一同提交给服务器</p>
<h5 id="session">Session</h5>
<p>另一种记录客户状态的机制，服务器把客户端信息以某种形式记录在服务器上 客户端可以以 Cookie、URL 重写或隐藏表单的形式保存 Session ID</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Session-Cookie.png" alt="Session与Cookie" /><figcaption aria-hidden="true">Session与Cookie</figcaption>
</figure>
<h5 id="cookie-和-session">Cookie 和 Session</h5>
<ul>
<li>有效期不同
<ul>
<li>Cookie 的有效时间久，或者可以设置到永远</li>
<li>Session 的有效期
<ul>
<li>超时自动失效，通常不长</li>
<li>程序调用 <code>HttpSession.invalidate()</code> 主动失效（退出、注销等操作）</li>
<li>服务器进程被终止</li>
</ul></li>
<li>存放位置不同，Cookie 在客户端，Session 在服务器端</li>
<li>安全性（隐私策略）不同，用户可以更改 Cookie</li>
<li>对服务器压力不同</li>
</ul></li>
</ul>
<h3 id="http-协议的特性">HTTP 协议的特性</h3>
<h4 id="http-协议中的编码和解码">HTTP 协议中的编码和解码</h4>
<blockquote>
<p>码 = 字符集+编码</p>
</blockquote>
<h5 id="编码规范">编码规范</h5>
<ul>
<li>字库表：里面存储了所有的字符</li>
<li>字符集：字符对应的二进制地址的集合</li>
<li>编码方式：一套编码规范可以有多种不同的编码方式（比如 UTF-8，对应的编码规范是 Unicode），一种算法来节约空间</li>
</ul>
<p>常见的编码规范：</p>
<ul>
<li>ASCII 码：7 位码，128 个字符，1 个字节</li>
<li>GBK：汉字内码扩展规范，2 个字节</li>
<li>ISO-8859-1：加了希腊语等，把其他所有的当做 ISO-8859-1 来解都没问题，没有中文，8 位码，1 个字节</li>
<li>Unicode：包含全世界所有的字符，最多 4 个字节</li>
</ul>
<h5 id="乱码">乱码</h5>
<p>乱码的由来：解码过程、编码过程都可能导致乱码</p>
<h5 id="url-的编码与解码">URL 的编码与解码</h5>
<p>URL 是采用 ASCII 字符集进行编码的</p>
<p><code>%</code> 编码规范：</p>
<ul>
<li>对 URL 中属于 ASCII 字符集的非保留字不做编码</li>
<li>对 URL 中的保留字需要取其 ASCII 内码，然后加上%的前缀对该字符进行编码</li>
<li>对 URL 中非 ASCII 字符需要取其 Unicode 内码，然后加上 <code>%</code> 的前缀对该字符进行编码</li>
</ul>
<blockquote>
<p>Fiddler</p>
</blockquote>
<h4 id="http-协议的基本认证">HTTP 协议的基本认证</h4>
<h5 id="常见的认证方式">常见的认证方式</h5>
<h5 id="basic">BASIC</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/BASIC.png" alt="BASIC" /><figcaption aria-hidden="true">BASIC</figcaption>
</figure>
<p>不便捷灵活，且不安全（Base64实际上就是明文传输）</p>
<h5 id="digest">DIGEST</h5>
<p>同样采用质询 / 响应方式，但不会明文传输密码</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/DIGEST.png" alt="DIGEST" /><figcaption aria-hidden="true">DIGEST</figcaption>
</figure>
<p>默认使用md5加密： 客户端发送响应摘要 = MD5(HA1:nonce:HA2) 其中，HA1 = MD5(username:realm:password), HA2 = MD5(method:digestURI) 虽然以前认为是不可逆的加密，但是仍然存在字典攻击、用户被冒充等风险</p>
<h5 id="ssl-客户端">SSL 客户端</h5>
<p>凭借客户端证书认证</p>
<h5 id="formbase">FormBase</h5>
<p>不是在 HTTP 协议中定义的，是使用 Web 应用各自实现的基于表单的认证，通过 Cookie 和 Session 来保持用户登录状态</p>
<h4 id="http-中的长连接和短链接">HTTP 中的长连接和短链接</h4>
<p>长连接又称持续连接（persistent connection），短连接又称非持续连接（non-persistent connection）</p>
<p>HTTP 中的长连接和短链接本质上是 TCP 的长连接和短链接 - HTTP/1.0 中，默认是短链接，每遇到一个外部资源就建立一个对话（创建一个 TCP 连接） - HTTP/1.1 起，默认是长连接（多个请求共用一个 TCP 连接）</p>
<h4 id="中介代理与中介网关">中介代理与中介网关</h4>
<h5 id="中介代理">中介代理</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Proxy.png" alt="中介代理" /><figcaption aria-hidden="true">中介代理</figcaption>
</figure>
<p>代理的作用：抓包、匿名访问、过滤器</p>
<h5 id="中介网关">中介网关</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Getway.png" alt="中介网关" /><figcaption aria-hidden="true">中介网关</figcaption>
</figure>
<p>扮演协议转换器的角色： - (HTTP/) 服务器端网关，通过 HTTP 协议与客户端对话，通过其他协议与服务器通信 - (/HTTP) 客户端网关，通过其他协议与客户端对话，通过 HTTP 协议与服务器通信</p>
<p>常见网关类型： - HTTP/*：服务器端 Web 网关 - HTTP/HTTPS：服务器端安全网关 - HTTPS/HTTP：客户端安全加速网关（SSL 卸载） - 资源网关</p>
<h4 id="http-缓存">HTTP 缓存</h4>
<p>缓存的内容：CSS、JS、图片等更新频率不大的静态资源文件</p>
<h5 id="http-缓存头部字段">HTTP 缓存头部字段</h5>
<h6 id="cache-control">Cache-Control</h6>
<blockquote>
<p>请求/响应头，缓存控制字段</p>
</blockquote>
<ul>
<li>no-store：所有内容都不缓存</li>
<li>no-cache：缓存，但浏览器会请求服务器判断资源是否更新</li>
<li>max-age=x：请求缓存后 x 秒不再发起请求</li>
<li>s-maxage=x：类似，但只对 CDN 缓存有效</li>
<li>public：客户端和代理服务器（CDN）都可以缓存</li>
<li>private：只有客户端可以缓存</li>
</ul>
<h6 id="其他头部字段">其他头部字段</h6>
<p>响应头，服务器返回：</p>
<ul>
<li><strong>Expires</strong>：代表资源过期时间，是 HTTP/1.0 的属性，比 HTTP/1.1 的 <strong>Cache-Control:max-age=x</strong> 优先级低</li>
<li><strong>Last-Modified</strong>：资源最新修改时间</li>
<li><strong>Etag</strong>：缓存资源标识</li>
</ul>
<p>请求头，服务器提供：</p>
<ul>
<li><strong>if-Modified-Since</strong>：资源最新修改时间，与 <strong>Last-Modified</strong> 是一对，他们会进行对比</li>
<li><strong>if-None-Match</strong>：缓存资源标识，与 <strong>Etag</strong> 是一对（其实就是上次服务器给的 Etag），他们会进行对比</li>
</ul>
<h5 id="http-缓存工作方式">HTTP 缓存工作方式</h5>
<h6 id="场景一让服务器与浏览器约定一个文件过期时间-expires">场景一：让服务器与浏览器约定一个文件过期时间 Expires</h6>
<p>服务器给浏览器一个 Expires，后续请求浏览器会对比当前 <strong>本地时间</strong> 是否已经大于 Expires，超过过期时间再请求。</p>
<p>问题：即使超过过期时间之后，文件可能仍然没有变化</p>
<h6 id="场景二约定-expires-的基础上再通过文件的最新修改时间进行对比-last-modified-与-if-modified-since">场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since</h6>
<p>服务器给浏览器 Expires 和 Last-Modified，后续若超过 Expires 后，浏览器请求时会带上 if-Modified-Since，服务器进行对比，如果文件未修改，就返回 304 Not Modified，让浏览器使用缓存</p>
<p>问题：浏览器可以随意修改本地时间，而且 Last-Modified 只能精确到秒</p>
<h6 id="场景三在上面的基础上加上-etagif-none-match再使用-max-age">场景三：在上面的基础上加上 Etag/If-None-Match，再使用 max-age</h6>
<p>max-age 使用的是 <strong>相对时间</strong>，因此浏览器不能通过修改本地时间的方式来影响缓存，优先级高于 Expires； Etag 优先级也高于 Last-Modified，因为文件只要修改过，Etag 就会发生变化</p>
<p>至此其实 Last-Modified 和 Expires 其实已经没什么用了，但很多时候还是会加上</p>
<p>问题：max-age 或者 Expires 未过期的情况下，若改动文件，应该怎样让浏览器知道？</p>
<h5 id="缓存改进方案">缓存改进方案</h5>
<h6 id="md5hash-缓存">md5/hash 缓存</h6>
<p>不缓存 html，为静态文件添加 MD5 或者 hash 标识，比如将静态资源的文件名改为 <code>f-hash1.js</code>，若文件修改了，文件名也会改变为 <code>f-hash2.js</code></p>
<h6 id="cdn-缓存">CDN 缓存</h6>
<blockquote>
<p>CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p>
</blockquote>
<p>CDN 的作用： 1. 减少源站压力 2. 解决跨区域访问问题</p>
<p>CDN缓存的工作方式： 1. 第一次请求，CDN 和 浏览器同时缓存 2. 浏览器缓存过期后，找 CDN 进行对比，CDN 看自己的过期没有，若自己没过期，就给发给浏览器</p>
<h5 id="浏览器操作对-http-缓存的影响">浏览器操作对 HTTP 缓存的影响</h5>
<table>
<thead>
<tr class="header">
<th>用户操作</th>
<th>Expires/Cache-Control</th>
<th>Last-Modified/Etag</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>地址栏回车</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr class="even">
<td>页面链接跳转</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr class="odd">
<td>新开窗口</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr class="even">
<td>前进、后退</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr class="odd">
<td>F5 刷新</td>
<td><em>无效</em></td>
<td>有效</td>
</tr>
<tr class="even">
<td>Ctrl+F5 刷新</td>
<td><em>无效</em></td>
<td><em>无效</em></td>
</tr>
</tbody>
</table>
<h3 id="http-内容协商机制">HTTP 内容协商机制</h3>
<blockquote>
<p>指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以相应资源的语言、字符集、编码方式等作为判断的基准</p>
</blockquote>
<h4 id="内容协商的方式">内容协商的方式</h4>
<ul>
<li><strong>客户端驱动</strong>：客户端发起请求，服务器发送可选项列表，客户端做出选择后再发送第二次请求</li>
<li><strong>服务器驱动</strong>：服务器检查客户端的请求头部集并决定提供哪个版本的页面
<ul>
<li>客户端发送：Accept、Accept-Language、Accept-Charset、Accept-Encoding
<ul>
<li><code>Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0</code></li>
</ul></li>
<li>服务器返回：Content-Type、Content-Language、Content-Type、Content-Encoding</li>
</ul></li>
<li><strong>透明协商</strong>：某个中间设备（通常是缓存代理）代表客户端进行协商</li>
</ul>
<h3 id="http-断点续传和多线程下载">HTTP 断点续传和多线程下载</h3>
<p>主要是通过请求头中的 <strong>Range</strong> 和响应头中的 <strong>Content-Range</strong> 实现的，并且若使用断点续传模式返回的状态码都是 206 Partial Content</p>
<h4 id="range">Range</h4>
<p>用于请求头中，指定第一个字节的位置和最后一个字节的位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Range:(unit=first byte pos)-[last byte pos]</span><br><span class="line">Range:bytes=0-499</span><br><span class="line">Range:bytes=-500</span><br><span class="line">Range:bytes=500-</span><br><span class="line">Range:bytes=500-600,601-999</span><br></pre></td></tr></table></figure>
<h4 id="content-range">Content-Range</h4>
<p>用于响应头中，返回当前接受的范围和文件总大小：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Range:bytes(unit first byte pos)-[last byte pos]/[entity length]</span><br></pre></td></tr></table></figure>
<h3 id="https">HTTPS</h3>
<h4 id="数字证书">数字证书</h4>
<h5 id="对称加密与非对称加密">对称加密与非对称加密</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Encryption.png" alt="对称加密" /><figcaption aria-hidden="true">对称加密</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/AsymEncryption.png" alt="非对称加密" /><figcaption aria-hidden="true">非对称加密</figcaption>
</figure>
<p>对称加密效率高，但在密钥分发时存在安全隐患，容易被截获；非对称加密安全性高，但性能低下；因此我们可以先用非对称加密传输对称加密的密钥，之后再用对称加密来传输数据</p>
<h5 id="数字签名与数字证书">数字签名与数字证书</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-1.png" alt="数字签名" /><figcaption aria-hidden="true">数字签名</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-2.png" alt="数字签名" /><figcaption aria-hidden="true">数字签名</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-1.png" alt="数字证书" /><figcaption aria-hidden="true">数字证书</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-2.png" alt="数字证书" /><figcaption aria-hidden="true">数字证书</figcaption>
</figure>
<h4 id="https-协议概述">HTTPS 协议概述</h4>
<blockquote>
<p>HTTPS 可以认为是 HTTP + TLS，TLS 是传输层加密协议，他的前身是 SSL 协议</p>
</blockquote>
<p>可以认为 TLS 建立在传输层和应用层之间（会话层），目前常用的版本有 TLS/1.0、1.1、1.2、1.3 和 SSL/3.0，但是 SSL/3.0 可能会存在 ‎POODLE 攻击，TSL/1.0 也存在一些漏洞</p>
<p>HTTPS 功能： - <strong>内容加密</strong>（非对称加密协商密钥 + 对称加密传输数据） - <strong>数据完整性</strong>（数字签名） - <strong>身份认证</strong>（数字证书）</p>
<h4 id="https-使用成本">HTTPS 使用成本</h4>
<ul>
<li>证书费用以及更新维护</li>
<li>降低用户的访问速度</li>
<li>消耗 CPU 资源</li>
</ul>
<p>HTTPS 对性能的影响：</p>
<ul>
<li>协议交互所增加的网络往返时延（Round-Trip Time）
<ul>
<li>有可能用户访问 HTTP，服务器需要返回 302 使其跳转到 HTTPS</li>
<li>TLS 完全握手阶段 1 和 2，以及与 CA 服务器进行连接与验证</li>
</ul></li>
<li>加解密相关的计算耗时
<ul>
<li>浏览器计算耗时</li>
<li>服务端计算耗时</li>
</ul></li>
</ul>
<div class="note warning"><p>HTTPS 并不能解决所有的劫持问题</p>
</div>
<h3 id="基于-http-的功能追加协议">基于 HTTP 的功能追加协议</h3>
<h4 id="http-协议的瓶颈">HTTP 协议的瓶颈</h4>
<ul>
<li>单路连接、请求低效，一条连接上只可发送 <strong>一个</strong> 请求，并且严格先入先出（非关键资源阻塞问题）</li>
<li>请求只能 <strong>从客户端开始</strong>，客户端不可以接受除了响应以外的指令，没办法让服务器一更新，客户端就立即更新</li>
<li>头部冗余，请求/响应头部 <strong>不经压缩</strong> 就发送</li>
<li>每次相互发送 <strong>相同的头部</strong> 造成浪费</li>
<li>不强制使用加密</li>
</ul>
<h4 id="websocket">WebSocket</h4>
<blockquote>
<p>是为了解决 HTTP 长连接问题而做出的改良协议，与 HTTP 协议有交集</p>
</blockquote>
<p>HTTP 的生命周期是由 Request/Response 确定的，一个 Request 与 一个 Response 对应，且 Response 是被动的。</p>
<p>WebSocket 是持久化协议，</p>
<p>一个典型的 WebSocket 握手：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==   浏览器随机生成的 Base64</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat  用来区分同一个 URL 下不同的服务所需要的协议 </span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>
<p>传统的轮询方式：</p>
<ul>
<li>AJAX 轮询：浏览器每隔几秒发一次请求，询问服务器有没有新消息</li>
<li>长轮询（Long Poll）：采取阻塞的方式，客户端发起连接，如果没有消息，服务器就一直不返回，直到有消息再返回</li>
</ul>
<blockquote>
<p>传统方式问题：太占用资源了，AJAX 轮询需要很高的处理速度，长轮询则需要能容纳很高的并发数</p>
</blockquote>
<p>WebSocket：</p>
<ul>
<li>一次连接，长期有效，服务器有消息的时候再推送（回调）</li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebSocket.png" alt="WebSocket" /><figcaption aria-hidden="true">WebSocket</figcaption>
</figure>
<p>WebSocket 的主要特点：</p>
<ul>
<li>真正的 <strong>全双工方式</strong>，允许服务器向客户端主动推送数据</li>
<li>减少 <strong>通信量</strong></li>
</ul>
<h4 id="spdy">SPDY</h4>
<blockquote>
<p>是谷歌开发的基于 TCP 的应用层协议，为了降低网络延迟，优化用户体验，也是对 HTTP 协议的增强</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SPDY.png" alt="SPDY" /><figcaption aria-hidden="true">SPDY</figcaption>
</figure>
<p>SPDY 的改进：</p>
<ul>
<li>多路复用、请求优化，允许多个请求共用一个 TCP 连接，并且可以设置优先级（避免非关键资源阻塞）</li>
<li>支持服务器推送技术，主要是资源类的推送（比如若浏览器请求了 <code>style.css</code>，服务器就主动再预推送一个 <code>style.js</code>），跟 WebSocket 不同</li>
<li>压缩了 HTTP 头</li>
<li>强制使用 SSL 传输协议</li>
</ul>
<h4 id="http2.0">HTTP/2.0</h4>
<blockquote>
<p>可以理解为 SPDY 的升级版，基本目标之一是减少传送单一 Web 页面时的并行 TCP 连接，减少需要服务器需要打开与维护的套接字数量。并且要求仔细设计相关机制避免队首（Head Of Line, HOL）阻塞。</p>
</blockquote>
<h5 id="二进制分帧">二进制分帧</h5>
<blockquote>
<p>HTTP/2.0 性能增强的核心，解决 HOL 阻塞。</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Binary-Framing.png" alt="二进制分帧" /><figcaption aria-hidden="true">二进制分帧</figcaption>
</figure>
<p>在二进制分帧层上，会将原来传输的信息分成更小的帧，并且采用二进制编码；HTTP/2.0 的通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，每个数据流都以消息的形式发送，这些消息由一个或多个帧组成，帧可以乱序发送，最后会根据每个帧上面的流标识符重新组装。</p>
<h5 id="首部压缩">首部压缩</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Header-Compression.png" alt="首部压缩" /><figcaption aria-hidden="true">首部压缩</figcaption>
</figure>
<p>使用 <strong>首部表</strong> 来跟踪和存储键值对，相同的数据不再通过每次响应和请求发送，通讯期间几乎不会改变 <strong>通用的键值对</strong>，每次只会发送新增或改变的部分头部，首部表在整个连接中有效，会不断更新</p>
<h5 id="多路复用">多路复用</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Multiplex.png" alt="多路复用" /><figcaption aria-hidden="true">多路复用</figcaption>
</figure>
<p>所有通信都在一个 TCP 连接上完成，将 HTTP 协议通信的基本单位缩小为帧，让多个数据流共用一个连接，提高利用率</p>
<p>单链接多资源的优势：</p>
<ul>
<li>可以 <strong>减少服务器连接压力</strong>，内存占用少了，连接吞吐量大了</li>
<li>由于 TCP 连接减少而使 <strong>网络拥塞状况</strong> 得以改观</li>
<li>慢启动时间减少，<strong>拥塞</strong> 和 <strong>丢包</strong> 恢复速度更快</li>
</ul>
<h5 id="并行双向字节流">并行双向字节流</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-1.png" alt="并行双向字节流" /><figcaption aria-hidden="true">并行双向字节流</figcaption>
</figure>
<ul>
<li>并行交错地发送请求，请求之间互不影响</li>
<li>并行交错地发送响应，响应之间互不影响</li>
<li>只使用一个连接即可并行发送多个请求和响应</li>
<li>消除不必要的延迟，减少页面加载的时间</li>
</ul>
<h5 id="请求优先级">请求优先级</h5>
<ul>
<li>可以为每个请求报文分配 1~256 的权重，数字较大说明拥有更高的优先级</li>
<li>可以通过指明相关报文段的 ID，说明报文段之间的关联性</li>
</ul>
<h5 id="服务器推送">服务器推送</h5>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-2.png" alt="服务器推送" /><figcaption aria-hidden="true">服务器推送</figcaption>
</figure>
<p>允许服务器为一个请求发送多个响应</p>
<h4 id="webdav">WebDAV</h4>
<blockquote>
<p>基于万维网的分布式创作和版本控制，用于管理 Web 服务器的文件</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebDAV.png" alt="WebDAV" /><figcaption aria-hidden="true">WebDAV</figcaption>
</figure>
<h4 id="quic-和-http3.0">QUIC 和 HTTP/3.0</h4>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-HTTP3.0.png" alt="QUIC和HTTP/3.0" /><figcaption aria-hidden="true">QUIC和HTTP/3.0</figcaption>
</figure>
<p>HTTP/2.0 的问题：</p>
<ul>
<li>由于 TCP 提供可靠的、按序的数据传输，他只会交付给应用层按序的数据，所以会有队首阻塞问题，必须要等上一个 HTTP 完整交付之后才能交付下一个</li>
<li>建立连接的握手延迟大，TCP 需要握手，对于短连接场景影响大</li>
</ul>
<p>QUIC 的特性：</p>
<ul>
<li><strong>面向连接和安全</strong>，所有的 QUIC 分组都是加密的。因为 QUIC 用于创建连接状态的握手和加密的握手，因此可以比 TCP + TLS 拥有更快的创建速度。 <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-1.png" alt="QUIC建立连接的过程" /></li>
<li><strong>没有队头阻塞的多路复用</strong> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Blocking.png" alt="TCP队头阻塞" /> <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-No-Blocking.png" alt="QUIC没有队头阻塞" /></li>
<li><strong>前向纠错</strong>，会多发一些冗余的包（校验包），虽然产生了多的包，但是减少了重传带来的损失 <img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-Error-Correcting.png" alt="前向纠错" /></li>
</ul>
<h2 id="电子邮件">电子邮件</h2>
<ul>
<li><p>因特网电子邮件系统总体由三个部分组成：<strong>用户代理（User Agent）、邮件服务器（Mail Server）、简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）</strong>。</p></li>
<li><p>每个接收方在邮件服务器上有一个 <strong>邮箱（Mailbox）</strong>。</p></li>
<li><p>发送方的用户代理传输到发送方的邮件服务器，然后被分发到接收方的邮箱中。</p></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A的代理 --SMTP/HTTP--&gt; A的邮件服务器 --SMTP--&gt; B的邮件服务器 --HTTP/IMAP--&gt; B的代理</span><br></pre></td></tr></table></figure>
<h3 id="推送报文smtp">推送报文（SMTP）</h3>
<ul>
<li>发送方的代理（手机、电脑等）可以通过 SMTP 向邮件服务器推送报文。</li>
<li>发送方的邮件服务器通过 SMTP 向接收方邮件服务器推送报文。</li>
<li>一般不使用中间邮件服务器，而是由 <strong>发送方邮件服务器</strong>（STMP Client） 与 <strong>接收方邮件服务器</strong>（STMP Server） 直接建立的 <strong>TCP</strong> 连接。</li>
<li>STMP Client 与 Server 在 25 端口建立 TCP 连接之后，可以发送命令：HELO、MAIL FROM、RCPT TO、DATA、QUIT。</li>
</ul>
<h4 id="邮件报文格式data">邮件报文格式（DATA）</h4>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">From: xxx@server.com</span><br><span class="line">To: yyy@another.com</span><br><span class="line">Subject: xxxxxx</span><br></pre></td></tr></table></figure>
<h3 id="获取报文">获取报文</h3>
<ul>
<li>IMAP</li>
<li>HTTP</li>
<li>POP3</li>
</ul>
<h2 id="dns">DNS</h2>
<blockquote>
<p>DNS (Domain Name System) 是：</p>
<ol type="1">
<li>一个由分层的 DNS 服务器（通常是运行 BIND (Berkeley Internet Name Domain) 的 UNIX 机器）实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议（使用 53 端口的 UDP）</li>
</ol>
</blockquote>
<p>DNS 的作用：</p>
<ul>
<li>进行主机名到 IP 的转换</li>
<li>主机别名（host aliasing）</li>
<li>邮件服务器别名（mail server aliasing）</li>
<li>负载分配（load distribution）</li>
</ul>
<h3 id="dns-的分布式设计">DNS 的分布式设计</h3>
<h4 id="分布式层次数据库">分布式、层次数据库</h4>
<ul>
<li><p><strong>根 DNS 服务器</strong>。全球有超过 1000 台根服务器实体，他们是 13 个不同的根服务器副本，由 12 个不同的组织管理。根服务器提供 TLD 服务器的 IP 地址。</p></li>
<li><p><strong>顶级域（Top-Level Domain, TLD）服务器</strong>。每个顶级域（com、org、edu 等）都有 TLD 服务器或服务器集群。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</p></li>
<li><p><strong>权威 DNS 服务器</strong>。多数大学和公司实现并维护他们自己的基本和辅助（备份）的权威 DNS 服务器。</p></li>
<li><p><strong>本地 DNS 服务器</strong>。严格来说并不属于 DNS 服务器层次结构，一般一个居民区的 ISP 或一个机构的 ISP 都有一台本地 DNS 服务器。</p></li>
</ul>
<h5 id="dns-服务器的交互">DNS 服务器的交互</h5>
<p>下图利用了 <strong>递归查询（recursive query）</strong>和 <strong>迭代查询（iterative query）</strong>。从 cis.poly.edu 到 dns.poly.edu 是递归查询，因为该查询以自己的名义请求，后续的 3 个查询是迭代查询。</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-DNS-1.jpg" alt="Networking-DNS-1" /><figcaption aria-hidden="true">Networking-DNS-1</figcaption>
</figure>
<p>而下图中的所有查询都是递归查询，我们通常遵循上图的查询模式：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-DNS-2.jpg" alt="Networking-DNS-2" /><figcaption aria-hidden="true">Networking-DNS-2</figcaption>
</figure>
<h4 id="dns-缓存">DNS 缓存</h4>
<p>事实上，因为缓存，只有很少部分 DNS 查询需要用到根服务器。</p>
<h3 id="dns-记录">DNS 记录</h3>
<ul>
<li>DNS 服务器存储了 <strong>资源记录（Resource Record, RR）</strong></li>
<li>资源记录是包括了下列字段的 4 元组：<code>(Name, Value, Type, TTL)</code>
<ul>
<li>TTL 是缓存时间</li>
<li>如果 Type = A，则 Name 是主机名， Value 是 IP 地址，比如 <code>(relay1.bar.foo.com, 145.37.93.126, A)</code></li>
<li>如果 Type = NS，则 Name 是域，Value 是权威 DNS 服务器的主机名，比如 <code>(foo.com, dns.foo.com, NS)</code></li>
<li>如果 Type = CNAME，则 Name 是主机别名，Value 是规范主机名，比如 <code>(foo.com, relay1.bar.foo.com, CNAME)</code></li>
<li>如果 Type = MX，则 Name 是主机别名，Value 是邮件服务器的规范主机名，比如 <code>(foo.com, mail.bar.foo.com, MX)</code>。通过使用 MX 记录，公司的邮件服务器可以和其他服务器使用相同的别名</li>
</ul></li>
</ul>
<h3 id="dns-报文">DNS 报文</h3>
<p>DNS 只有查询和回答报文，并且两种报文有相同的格式：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-DNS-3.jpg" alt="Networking-DNS-3" /><figcaption aria-hidden="true">Networking-DNS-3</figcaption>
</figure>
<p>可以使用 <code>nslookup</code> 直接向 DNS 服务器发送查询报文。</p>
<h2 id="视频流和内容分发网">视频流和内容分发网</h2>
<h3 id="http-流和-dash">HTTP 流和 DASH</h3>
<ul>
<li><strong>HTTP 流</strong>：视频只是一个普通的文件，每个文件有一个特定的 URL。接收到视频就进行播放，同时缓存该视频后面部分的帧。
<ul>
<li>缺陷：所有客户端接收到相同编码的视频</li>
</ul></li>
<li><strong>DASH (Dynamic Adaptive Stream over HTTP)</strong>：视频编码为几个不同的版本，客户动态地请求来自不同版本且长度为几秒的视频段数据块。每个视频版本存储在服务器中，HTTP 服务器有一个告示文件（manifest file），为每个版本提供一个 URL 和比特率。</li>
</ul>
<h3 id="内容分发网">内容分发网</h3>
<blockquote>
<p>内容分发网即 CDN (Content Distribution Network)</p>
</blockquote>
<ul>
<li>CDN 管理分布在多个地理位置的服务器，在他的服务器中存储各种 web 内容的副本，并且将每个用户请求定向到一个将提供最好用户体验的 CDN 位置</li>
<li>CDN 可以是专用 CDN（private CDN），也可以是第三方 CDN（third-party CDN）</li>
</ul>
<h1 id="运输层">运输层</h1>
<h2 id="多路复用与多路分解">多路复用与多路分解</h2>
<blockquote>
<p>运输层是怎样将网络层的报文段发送给应用层的不同进程的</p>
</blockquote>
<ul>
<li><p>一个进程拥有一个或多个 <strong>套接字（socket）</strong></p></li>
<li><p>运输层并没有直接将数据交付给进程，而是交给了某一个套接字</p></li>
<li><p><strong>多路分解（demultiplexing）</strong>：将运输层报文段中的数据交付给正确的套接字</p></li>
<li><p><strong>多路复用（multiplexing）</strong>：从不同套接字中收集数据块，并封装上首部信息从而生成报文段，然后发送给网络层</p></li>
<li><p>用于区分套接字的特殊字段就是端口号，下面是一个典型的运输层报文段的结构：</p></li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-Transport-1.jpg" alt="Networking-Transport-1" /><figcaption aria-hidden="true">Networking-Transport-1</figcaption>
</figure>
<h3 id="无连接和面向连接">无连接和面向连接</h3>
<ul>
<li>UDP 的套接字是由<strong>（目的 IP 地址，目的端口号）</strong>全面标识的，不同源但相同目的的报文段会被扔给同一个套接字。</li>
<li>TCP 的套接字是由 <strong>（源 IP 地址，源端口号，目的 IP 地址，目的端口号）</strong>标识的，因此不同源的报文段会被扔给不同的套接字。</li>
</ul>
<h2 id="udp">UDP</h2>
<h3 id="报文结构">报文结构</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-UDP-1.jpg" alt="Networking-UDP-1" /><figcaption aria-hidden="true">Networking-UDP-1</figcaption>
</figure>
<h3 id="udp-校验和checksum">UDP 校验和（checksum）</h3>
<ul>
<li><p>校验和：发送方将报文段中的 16 bit 字的和进行反码运算</p>
<ul>
<li>如果有溢出，需要进行反卷（即将溢出的高位与剩下的部分做加法运算）</li>
</ul></li>
<li><p>接收方将全部的 16 bit 字（包括校验和）加在一起，得到的结果应该是 <code>1111 1111 1111 1111</code>，如果其中有 0，则代表出现了问题</p></li>
<li><p>UDP 提供运输层的差错检测，在系统设计中被称为 <strong>端到端原则（end-end principle）</strong>。因为假定 IP 是可以运河在任何第二层协议之上的，UDP 相当于提供了一层保险，但注意 UDP 无法恢复差错。</p></li>
</ul>
<h2 id="可靠数据传输">可靠数据传输</h2>
<blockquote>
<p>在 <strong>不可靠的下层协议上</strong> 通过 <strong>可靠数据传输协议（reliable data transfer protocol）</strong> 为 <strong>上层实体</strong> 提供 <strong>可靠数据传输信道</strong>。</p>
</blockquote>
<h3 id="什么都不考虑rdt1.0">什么都不考虑：rdt1.0</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-1.jpg" alt="Networking-rdt-1" /><figcaption aria-hidden="true">Networking-rdt-1</figcaption>
</figure>
<h3 id="考虑比特差错rdt2.0">考虑比特差错：rdt2.0</h3>
<blockquote>
<p>校验和、序号、ACK、重传</p>
</blockquote>
<p>通常使用 <strong>自动重传请求（Automatic Repeat reQuest, ARQ）</strong>协议来解决这个问题，ARQ协议中还需要三种功能来处理比特差错： - 差错检测 - 接收方反馈（ACK、NAK） - 重传</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-2.jpg" alt="Networking-rdt-2" /><figcaption aria-hidden="true">Networking-rdt-2</figcaption>
</figure>
<p><strong>问题：无法解决 ACK 和 NAK 分组受损的情况。</strong></p>
<p>可以引入序号 0 和 1（因为还没有考虑到丢包的情况，这个 1 bit 的序号就够用了），来确认是正在重传之前的分组、还是发送了一个新的分组。</p>
<p>此外，引入序号之后，也可以用 ACK + 序号 来代替 NAK 了，如果发送方接收到 ACK + 之前的序号，说明当前的包没有被正确接收到，则需要重传当前的包。</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-3.jpg" alt="Networking-rdt-3" /><figcaption aria-hidden="true">Networking-rdt-3</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-4.jpg" alt="Networking-rdt-4" /><figcaption aria-hidden="true">Networking-rdt-4</figcaption>
</figure>
<h3 id="考虑比特差错和丢包rdt3.0">考虑比特差错和丢包：rdt3.0</h3>
<blockquote>
<p>定时器</p>
</blockquote>
<p>由于分组序号在 0 和 1 之间交替，因此又被称为 <strong>比特交替协议（alternating-bit protocol）</strong></p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-5.jpg" alt="Networking-rdt-5" /><figcaption aria-hidden="true">Networking-rdt-5</figcaption>
</figure>
<p><strong>问题：以上讨论的实际上都是停等（stop-and-wait）协议，发送方需要收到正确的 ACK 才能做出下一步行动，否则就会一直卡在等待状态。</strong></p>
<h3 id="考虑流水线数据传输">考虑流水线数据传输</h3>
<p>与停等相对应的就是流水线，分组可以看做被填充到一条流水线中，源源不断地发送过去。因此需要考虑到如下的影响：</p>
<ul>
<li><strong>增加序号范围</strong>。每个传送的分组必须有唯一序号，因为可能有多个在传输中的未确认报文</li>
<li><strong>可能需要缓存多个分组</strong>。</li>
<li><strong>考虑解决流水线上丢失、损坏、延时过大的问题</strong>。两种基本方法：<strong>GBN (Go-Back-N)</strong>，<strong>选择重传（Selective Repeat, SR）</strong>。</li>
</ul>
<h4 id="gbn">GBN</h4>
<blockquote>
<p>GBN 协议也常被称为 <strong>滑动窗口协议（sliding-window protocol）</strong></p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-6.jpg" alt="Networking-rdt-6" /><figcaption aria-hidden="true">Networking-rdt-6</figcaption>
</figure>
<ul>
<li>发送方
<ul>
<li>基序号 base：最早未确认分组的序号</li>
<li>窗口大小 N：当接收到应用层序号大于 base + N 的数据包时，拒绝发送此数据包</li>
<li>累计确认（cumulative acknowledgement）：发送方收到序号为 n 的 ACK 时，认为 n 及 n 以前的都已经被确认了</li>
<li>超时事件：超时后，发送方重传所有已发送但还未确认的分组</li>
</ul></li>
<li>接收方
<ul>
<li>丢弃所有失序分组，接收方不需要缓存任何失序分组（包括序号小于 base 的分组）</li>
</ul></li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-7.jpg" alt="Networking-rdt-7" /><figcaption aria-hidden="true">Networking-rdt-7</figcaption>
</figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-8.jpg" alt="Networking-rdt-8" /><figcaption aria-hidden="true">Networking-rdt-8</figcaption>
</figure>
<h4 id="sr">SR</h4>
<blockquote>
<p>选择重传</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-rdt-9.jpg" alt="Networking-rdt-9" /><figcaption aria-hidden="true">Networking-rdt-9</figcaption>
</figure>
<ul>
<li>发送方
<ul>
<li>与 GBN 一样有窗口大小，会拒绝上层超出当前窗口的包</li>
<li>逐个确认：每个分组有会单独维护自己的 ACK 状态，仅重传那些出错的分组</li>
<li>每个分组有自己的逻辑计时器</li>
</ul></li>
<li>接收方
<ul>
<li>缓存失序分组</li>
<li>仅将已收到的连续的分组发送给上层</li>
<li>接收到小于 base 的分组时，也会发送 ACK。因为如果接收方不确认该分组，发送方的窗口可能永远不能向前滑动（SR协议中，发送方和接收方的窗口并不总是一致）</li>
<li>窗口应小于序号空间大小的一半，因为如果窗口太大，会产生歧义而无法判断是旧分组重传还是新分组</li>
</ul></li>
</ul>
<h3 id="可靠数据传输机制总结">可靠数据传输机制总结</h3>
<table>
<thead>
<tr class="header">
<th>机制</th>
<th>用途和说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>校验和</td>
<td>检测比特错误</td>
</tr>
<tr class="even">
<td>定时器</td>
<td>超时重传，注意接收方可能收到一个分组的多个冗余副本</td>
</tr>
<tr class="odd">
<td>序号</td>
<td>检测出丢失副本和冗余副本</td>
</tr>
<tr class="even">
<td>确认</td>
<td>告诉发送方一个或多个分组已经收到，有逐个确认、累计确认等方式</td>
</tr>
<tr class="odd">
<td>否定确认</td>
<td>告诉发送方某个分组未被正确接收</td>
</tr>
<tr class="even">
<td>窗口、流水线</td>
<td>与停等相比，有更高的发送方利用率</td>
</tr>
</tbody>
</table>
<h2 id="tcp">TCP</h2>
<blockquote>
<p>TCP 面向连接、可靠、面向字节流；UDP 面向无连接</p>
</blockquote>
<ol type="1">
<li><strong>面向连接</strong>。TCP 需要三次握手建立连接，UDP 则不需要</li>
<li><strong>可靠</strong>。TCP <strong>有状态</strong>，会记录哪些数据发送了，哪些数据对方接受了，哪些数据丢失了，不允许差错；TCP <strong>可控制</strong>，会根据丢包的情况或者状态，调整自己的行为，比如控制速度或者重发</li>
<li>TCP 提供的是 <strong>全双工服务（full-duplex service）</strong>：建立连接后，A 的数据流向 B 的同时，B 也可以流向 A，A 既是发送方也是接收方</li>
<li><strong>面向字节流</strong>。UDP 的数据传输 <strong>是面向数据报</strong> 的，TCP 为了维护状态，将 IP 包变成了字节流。所谓 <strong>面向数据报</strong> 是指，应用层交给 UDP 多长的 <strong>报文</strong>，UDP 就照样发送，一次发送一个报文；而面向字节流是指，TCP 虽然一次接收应用层来的一个数据块（大小不等），但 TCP 把应用程序看成一连串无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就会把它划分得短一些再发送；如果应用程序一次只发送一个字节，TCP 也可以等待积累足够多的字节后再构成报文段发送出去。</li>
</ol>
<h3 id="报文结构-1">报文结构</h3>
<ul>
<li>TCP 报文可以看成 报文头 + 数据</li>
<li><strong>最大报文段长度（Maximum Segment Size）</strong>：TCP 发送一个大文件时，会将一个文件划分为长度为 MSS 的若干块；发送一个小数据块的时候，每个报文段长度将会远小于 MSS</li>
<li>下图是报文头的结构</li>
</ul>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header.png" alt="TCP报文头" /><figcaption aria-hidden="true">TCP报文头</figcaption>
</figure>
<h4 id="序列号">序列号</h4>
<blockquote>
<p>SN (Sequence Number)，长度为 4 Bytes</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-TCP-segment-2.jpg" alt="Networking-TCP-segment-2" /><figcaption aria-hidden="true">Networking-TCP-segment-2</figcaption>
</figure>
<ul>
<li>TCP 的序号是建立在字节流上面的，而不是报文段之上
<ul>
<li>假设发送一个文件有 500 000 Bytes，MSS 为 1000 Bytes</li>
<li>TCP 将会为每一个字节隐式地编号，假设数据流首字节编号为 0</li>
<li>TCP 将会为该数据流构造 500 个报文段，第一个报文序号为 0，第二个报文序号为 1000，第三个报文序号为 2000</li>
</ul></li>
</ul>
<h5 id="初始序列号">初始序列号</h5>
<p>即 Initial Sequence Number，在三次握手的过程中，双方会通过 SYN 报文来交换彼此的 ISN，ISN 会动态增长，每 4ms 就加 1，溢出则回到 0。动态增长的 ISN 增加了猜测 ISN 的难度</p>
<h4 id="确认号">确认号</h4>
<blockquote>
<p>ACK (Acknowledgement Number)，长度为 4 Bytes</p>
</blockquote>
<ul>
<li>告知对方下一个期望接收的序列号</li>
<li>小于 ACK 的所有字节已经全部接收到（累计确认）</li>
<li>TCP 并没有规定对失序到达的报文的处理，而是交给 TCP 编程人员去处理，实践中一般收方会缓存失序字节</li>
</ul>
<h4 id="标记位">标记位</h4>
<p>占用一个字节，常见的标记位有 SYN、ACK、FIN、RST、PSH。</p>
<ul>
<li>SYN：Synchronize，表示同步，用来开始请求</li>
<li>ACK：Acknowledge，表示确认</li>
<li>FIN：Finish，表示发送方准备断开连接</li>
<li>RST：Reset，用来强制断开连接</li>
<li>PSH：Push，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存</li>
</ul>
<h4 id="窗口大小">窗口大小</h4>
<p>占用两个字节，但实际上不够用，因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因此可以将窗口值扩大为原来的 2 ^ n 倍</p>
<h4 id="校验和">校验和</h4>
<p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃、等待重传</p>
<h4 id="可选项">可选项</h4>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header-Options.png" alt="可选项" /><figcaption aria-hidden="true">可选项</figcaption>
</figure>
<p>常用的可选项有： - Timestamp：TCP 时间戳 - MSS：TCP 允许的从对方接收的最大报文段 - SACK：选择确认选项 - Window Scale：窗口缩放</p>
<h5 id="timestamp">Timestamp</h5>
<p>Timestamp 一共占 10 个字节：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">kind(1 Byte) + length(1 Byte) + info(8 Bytes)</span><br></pre></td></tr></table></figure>
<p>其中 <code>kind=8</code> <code>length=10</code>，<code>info</code> 由 <code>timestamp</code> 和 <code>timestamp echo</code> 两部分构成，各占四个字节</p>
<p>TCP 的时间戳主要解决两个问题： - 计算往返时延（RTT, Round-Trip Time） - 防止序列号回绕</p>
<h6 id="计算-rtt">计算 RTT</h6>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Timestamp-RTT.png" alt="计算RTT" /><figcaption aria-hidden="true">计算RTT</figcaption>
</figure>
<h6 id="防止序列号回绕">防止序列号回绕</h6>
<p>因为序列号的长度是有限的，若超出容纳的范围，就会回到 0，时间戳使得两个序列号相同的报文也能得以区分</p>
<h3 id="超时重传">超时重传</h3>
<blockquote>
<p>在间隔一段时间没有等到这个数据包回复时，将会重传这个数据包</p>
</blockquote>
<h4 id="超时重传时间的计算">超时重传时间的计算</h4>
<h5 id="往返时间估计">往返时间估计</h5>
<blockquote>
<p>报文段的样本 RTT（SampleRTT）是指某段报文被发出到确认被收到之间的时间</p>
</blockquote>
<ul>
<li>TCP 仅为传输一次的报文段测量 SampleRTT，不会测量重传报文段的 SampleRTT</li>
<li>TCP 会维持一个 SampleRTT 的均值（称为 EstimatedRTT）</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EstimatedRTT = α * SampleRTT + (1 - α) * EstimatedRTT</span><br></pre></td></tr></table></figure>
<p>α 即为 <strong>平滑因子</strong>，建议值是 0.125</p>
<h5 id="测量-rtt-变化">测量 RTT 变化</h5>
<blockquote>
<p>RTT 变化定义为 DevRTT</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|</span><br></pre></td></tr></table></figure>
<p>β 的建议值是 0.25</p>
<h5 id="设置和管理超时时间">设置和管理超时时间</h5>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TimeoutInterval = µ * EstimatedRTT + ∂ * DevRTT </span><br></pre></td></tr></table></figure>
<p>µ 建议值取 1, ∂ 建议值取 4</p>
<h4 id="超时重传策略">超时重传策略</h4>
<p>下面是大多数 TCP 实现中做的一些修改，有的在协议中只是提供了一些建议。</p>
<h5 id="超时间隔加倍">超时间隔加倍</h5>
<blockquote>
<p>每次超时事件发生时，就将超时间隔设置为之前的两倍，而不是使用 EstimatedRTT 和 DevRTT 推算出来的值</p>
</blockquote>
<p>这种思路提供了一个简单的拥塞控制，防止重传导致的加重拥塞</p>
<h5 id="快速重传">快速重传</h5>
<ol type="1">
<li>如果接收方收到了比预期序号大的失序报文段，将立即发送一个冗余 ACK（再次确认之前的报文段已经到达）</li>
<li>接收方收到 3 个冗余 ACK 后，就执行快速重传（fast retransmit），即使该报文段没有超时，也进行重传</li>
</ol>
<h5 id="gbn-sr">GBN + SR</h5>
<ul>
<li>TCP 用了累计确认，看起来像 GBN</li>
<li>TCP 会缓存失序报文段，并不会重传所有未确认报文段，看起来像 SR</li>
<li>可以将 TCP 看做 GBN 和 SR 的混合体</li>
</ul>
<h3 id="流量控制">流量控制</h3>
<blockquote>
<p>流量控制（flow-control service）是一个速度匹配服务，协调发送方的发送速率与接收方的接收速率，消除发送方使接收方缓存溢出的可能性</p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-TCP-3.jpg" alt="Networking-TCP-3" /><figcaption aria-hidden="true">Networking-TCP-3</figcaption>
</figure>
<ul>
<li><strong>发送方</strong> 维护一个 <strong>接收窗口（receive window）</strong> 变量（即 <strong>rwnd</strong>）该变量指示了接收方剩余的缓存空间</li>
<li><strong>接收方</strong> 把当前 rwnd 值放入报文段的接收窗口字段中，通知 <strong>发送方</strong> 该连接的缓存中还有多少剩余空间</li>
<li>当 <strong>接收方</strong> 的 rwnd 为 0 时，<strong>发送方</strong> 继续发送只有一个字节数据的报文段。接收方会确认这些报文段，否则发送方将不会知道何时缓存开始清空</li>
<li>UDP 不提供流量控制，缓存溢出后报文段将会丢失</li>
</ul>
<h2 id="tcp-连接管理">TCP 连接管理</h2>
<h3 id="三次握手">三次握手</h3>
<blockquote>
<p>三次握手是需要确认双方的 <strong>发送能力</strong> 和 <strong>接收能力</strong></p>
</blockquote>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Handshake.png" alt="TCP三次握手" /><figcaption aria-hidden="true">TCP三次握手</figcaption>
</figure>
<blockquote>
<p><strong>三次握手的过程中可以携带数据吗？</strong></p>
<p>前两次不能，第三次可以，此时客户端已经处于 ESTABLISHED 状态，确认了服务器发送、接受信息的能力正常</p>
</blockquote>
<h3 id="四次挥手">四次挥手</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Wavehand.png" alt="TCP四次挥手" /><figcaption aria-hidden="true">TCP四次挥手</figcaption>
</figure>
<p>服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN。因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN。这就造成了四次挥手。</p>
<h3 id="syn-泛洪攻击与-cookie">SYN 泛洪攻击与 Cookie</h3>
<p>三次握手之前，在服务器状态从 CLOSED 变为 LISTEN 的时候，还在内部创建了两个队列：<strong>半连接队列</strong> 和 <strong>全连接队列</strong></p>
<h4 id="半连接队列">半连接队列</h4>
<p>又称 <strong>SYN 队列</strong>，当客户端发送 SYN 到服务端，服务端收到后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 <strong>半连接队列</strong></p>
<h4 id="全连接队列">全连接队列</h4>
<p>又称 <strong>ACCEPTED 队列</strong>，当客户端返回 ACK，服务端接收后，三次握手完成，连接等待被某个具体的应用取走，在被取走之前，会被推入 <strong>全连接队列</strong></p>
<h4 id="syn-泛洪攻击">SYN 泛洪攻击</h4>
<p>属于典型的 Dos/DDos 攻击，用客户端在短时间内伪造大量不存在的 IP 地址，疯狂发送 SYN 而不发送 ACK，不完成三次握手，使得服务器：</p>
<ol type="1">
<li>处理大量 SYN 包并返回 ACK，使得 <strong>半连接队列爆满</strong></li>
<li>由于是不存在的 IP，服务端长时间 <strong>收不到客户端的 ACK</strong>，就会疯狂重发数据，直到耗尽服务器资源</li>
</ol>
<h5 id="如何应对-syn-泛洪攻击">如何应对 SYN 泛洪攻击？</h5>
<ol type="1">
<li>增加半连接队列容量</li>
<li>减少 SYN + ACK 的重试次数</li>
<li>利用 SYN Cookie 技术，在服务端接收到 SYN 后不立即分配链接资源，而是根据 SYN 计算出一个 Cookie，连通第二次握手一同发给客户端，客户端回复 ACK 的时候带上 Cookie，服务端验证合法后才分配链接资源
<ul>
<li>TCP Fast Open：后续再进行三次握手时，客户端可以直接将之前缓存的 Cookie、SYN 和 HTTP 请求发送给服务端，如果合法就正常返回 <strong>SYN + ACK</strong>，同时可以给客户端发 <strong>HTTP 响应</strong></li>
</ul></li>
</ol>
<h3 id="拥塞控制">拥塞控制</h3>
<blockquote>
<p>在网络拥塞的情况下，分组重传会作为征兆出现，但并不能解决网络拥塞本身</p>
</blockquote>
<h4 id="拥塞控制原理">拥塞控制原理</h4>
<p>成因：网络中有很多主机，而物理链路的容量是有限的，网络会随着主机发送速率的增加而逐渐变得拥塞，就像堵车一样</p>
<p>代价：</p>
<ol type="1">
<li>即使在路由器缓存无限的情况下，分组的到达速率接近链路容量时，分组将经历巨大的排队时延</li>
<li>当路由器缓存有限时，发送方必须执行重传来补偿缓存溢出导致的丢失分组</li>
<li>当分组实际上并没有丢失，只是排队比较久时，发送方的提前的重传将占用额外的资源</li>
<li>当一个分组沿一条路径被丢弃时，每一个上游路由器之前做的所有努力都白费了</li>
</ol>
<p>控制方法：</p>
<ul>
<li>端到端的拥塞控制。网络层没有提供拥塞控制的方法，因此端系统需要通过网络行为（比如分组丢失与时延）来进行判断。TCP 采用这种方法，因为 IP 层不会反馈网络信息</li>
<li>网络辅助的拥塞控制。路由器会向发送方提供网络的拥塞状态。最新的 IP 和 TCP 也能选择性地实现网络辅助的拥塞控制</li>
</ul>
<h4 id="端到端的拥塞控制">端到端的拥塞控制</h4>
<h5 id="拥塞检测">拥塞检测</h5>
<p>出现丢包时，即可能出现了拥塞：</p>
<ul>
<li>超时</li>
<li>收到来自接收方的 3 个冗余 ACK</li>
</ul>
<h5 id="拥塞窗口">拥塞窗口</h5>
<p>除了接收窗口 rwnd 以外，发送端另外还需维护 <strong>拥塞窗口（congestion window）</strong> 变量（即 <strong>cwnd</strong>），限制其发送速率</p>
<p>发送方中未被确认的数据量不会超过 rwnd 与 cwnd 的最小值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">LastByteSent - LastByteAcked = min(rwnd, cwnd)</span><br></pre></td></tr></table></figure>
<p>通过调整 cwnd 就可以调整发送速率，通过用拥塞控制算法可以调整 cwnd</p>
<h5 id="拥塞控制算法">拥塞控制算法</h5>
<p>拥塞控制算法分为 <strong>慢启动、拥塞避免、快速恢复</strong> 三部分，其中前两个部分是 TCP 的强制部分，快速恢复是推荐部分</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Networking-TCP-4.jpg" alt="Networking-TCP-4" /><figcaption aria-hidden="true">Networking-TCP-4</figcaption>
</figure>
<h6 id="慢启动">慢启动</h6>
<blockquote>
<p>刚创建连接时，TCP 进入慢启动模式，并迅速适应可用的带宽数量</p>
</blockquote>
<ul>
<li>双方初始化自己 <strong>拥塞窗口（cwnd）</strong> 的大小，为 1 MSS</li>
<li>发送方发送出第 1 个报文段并等待确认，当报文段首次被确认时，cwnd 增加 1 MSS 变为 2 MSS</li>
<li>然后发出 2 个报文段，当他们都被确认时，cwnd 增加 2 MSS 变为 4 MSS</li>
<li>然后发出 4 个报文段，当他们都被确认时，cwnd 增加 4 MSS 变为 8 MSS……（每确认一个就增加 1 MSS）</li>
</ul>
<p>结束指数增长的条件：</p>
<ul>
<li>拥塞发生（丢包事件，包括超时和 3 个冗余 ACK）
<ul>
<li>TCP 发送方将 cwnd 设置为 1 并重新开始慢启动</li>
<li>同时，发送方还有一个 <strong>慢启动阈值（ssthresh）</strong> 的变量，设置为 cwnd / 2，即当检测到拥塞时将 ssthresh 设置为拥塞窗口值的一半</li>
</ul></li>
<li>当之后 cwnd 等于 ssthresh 时，结束慢启动并转移到 <strong>拥塞避免模式</strong></li>
</ul>
<h6 id="拥塞避免">拥塞避免</h6>
<ul>
<li>进入拥塞避免状态时，cwnd 值大约是上次遇到拥塞时的一半</li>
<li>此时每个 RTT 只将 cwnd 的值增加 1 MSS</li>
<li>当出现超时，与慢启动状态时相同，ssthresh 的值更新为 cwnd / 2，将 cwnd 重置为 1，然后迁移到 <strong>慢启动状态</strong></li>
<li>当出现 3 个冗余 ACK 时，网络继续发送报文段，将 cwnd 值减半（因为已收到的 3 个冗余 ACK，也要加上 3 个 MSS），将 ssthresh 更新为 cwnd 值的一半，进入 <strong>快速恢复状态</strong></li>
</ul>
<h6 id="快速恢复">快速恢复</h6>
<ul>
<li>每当收到冗余 ACK，cwnd 的值增加 1 MSS</li>
<li>最终，当对丢失报文段的一个 ACK 到达时，进入拥塞避免状态</li>
<li>当出现超时，与慢启动、拥塞避免相同，ssthresh 的值更新为 cwnd / 2，cwnd 重置为 1，然后迁移到 <strong>慢启动状态</strong></li>
</ul>
<h4 id="网络辅助拥塞控制">网络辅助拥塞控制</h4>
<h5 id="明确拥塞通告ecn">明确拥塞通告（ECN）</h5>
<blockquote>
<p>明确拥塞通告（Explicit Congestion Notification, ECN）是一种网络辅助的拥塞控制形式，涉及 TCP 和 IP</p>
</blockquote>
<ul>
<li>在网络层，位于 IP 的服务类型字段中有 2 bits 用于 ECN</li>
<li>当接收主机得到 ECN 拥塞指示时，发送给发送方的 ACK 包中的 ECE（明确拥塞通告回显）置为 1</li>
<li>发送方收到后会减半 cwnd，并在下一个报文段中对 CWR（拥塞窗口缩减）置为 1</li>
</ul>
<h5 id="基于时延的拥塞控制">基于时延的拥塞控制</h5>
<blockquote>
<p>在丢包之前主动检测拥塞</p>
</blockquote>
<h4 id="公平性">公平性</h4>
<blockquote>
<p>如果每条连接连接得到相同分量的链路带宽，则认为该拥塞控制机制是公平的</p>
</blockquote>
<ul>
<li>理想化条件下，TCP 是公平的，尽管 cwnd 不同</li>
<li>实践中，一般具有较小 RTT 的连接能够在链路空闲时更快抢到更多的可用带宽，因此拥有更高的吞吐量</li>
<li>由于 UDP 没有拥塞控制，所以 UDP 可以抢占大量资源而拒绝与 TCP 合作</li>
<li>此外可以给一个应用建立多条 TCP 连接以破坏公平性</li>
</ul>
<h2 id="其他性能优化">其他性能优化</h2>
<h3 id="nagle-算法">Nagle 算法</h3>
<blockquote>
<p>为了避免频繁发送小包而诞生</p>
</blockquote>
<ul>
<li>第一次发送数据的时候不用等待，即使是再小的包也马上发送</li>
<li>后面发送的包需要满足下面条件之一：
<ul>
<li>数据包大小达到最大子段大小（MSS, Max Segment Size）</li>
<li>之前所有包的 ACK 都已经接受到</li>
</ul></li>
</ul>
<h3 id="延迟确认">延迟确认</h3>
<blockquote>
<p>为了避免频繁回复小包而诞生</p>
</blockquote>
<p>TCP 要求延迟的时延必须小于 500ms，一般的操作系统都不会超过 200ms</p>
<p>一些场景收到之后会马上回复： - 收到了大于一个 frame 的报文，且需要调整窗口大小 - TCP 处于 quickack 模式（通过 <code>tcp_in_quickack_mode</code> 设置） - 发现了乱序包</p>
<h3 id="tcp-的-keep-alive">TCP 的 keep-alive</h3>
<p>由于 TCP 不是一个轮询的协议，他无法获知对端连接失效的情况（比如对端网络故障或宕机），<strong>keep-alive</strong> 则是用于探测对端的连接是否失效，但是因为探测的时间比较长，所以一般不怎么用</p>
<h1 id="网络层数据平面">网络层：数据平面</h1>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>NodeJS</title>
    <url>/hais-notebook/2020/03/09/NodeJS/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="一些有用的工具">一些有用的工具</h1>
<ul>
<li>commander：可以很方便地写出命令行，有多种语言的版本。</li>
<li>node-dev：文件更新时自动重启的 node，不宜在生产环境使用。</li>
<li>ts-node：让 node 支持直接运行 TypeScript 代码，不宜在生产环境使用。</li>
<li>ts-node-dev：node-dev + ts-node，不宜在生产环境使用。</li>
<li>注意用 ts 开发时，需要安装 <span class="citation" data-cites="types/node">@types/node</span></li>
<li>tsc --init 命令会自动创建 <code>tsconfig.json</code> 文件</li>
</ul>
<h1 id="node.js-简介">Node.js 简介</h1>
<h2 id="node.js-是什么">Node.js 是什么</h2>
<ul>
<li>不是 web 框架，不能把 Node.js 与 Flask 或 Spring 对比</li>
<li>不是编程语言，不能与 Python 或 PHP 对比</li>
<li>是一个平台，将多种技术组合起来，让 JavaScript 也能调用系统接口、开发后端应用
<ul>
<li>V8 引擎</li>
<li>libuv</li>
<li>C/C++ 实现的 c-ares、http-parser、OpenSSL、zlib 等</li>
</ul></li>
</ul>
<h2 id="node.js-技术架构">Node.js 技术架构</h2>
<h3 id="第三层node.js-api">第三层：Node.js API</h3>
<h3 id="第二层node.js-bindingscc-插件">第二层：Node.js bindings、C/C++ 插件</h3>
<h4 id="bindings">bindings</h4>
<p>沟通 Node.js 与 C/C++，比如 C/C++ 实现了 http-parsers 库，bindings 帮助我们调用这个库，比如将 C++ 编译成 .node，然后 JS require 他。</p>
<h4 id="cc-插件">C/C++ 插件</h4>
<p>自己写其他能力。</p>
<h3 id="第一层v8libuvc-aresopensslzlibhttp-parserzlib-等">第一层：V8、libuv、c-ares、OpenSSL、zlib、http-parser、zlib 等</h3>
<h4 id="libuv">libuv</h4>
<ul>
<li>每个操作系统上有不同的异步处理模块，比如 FreeBSD 上的 kqueue、Linux 上的 epoll、Windows 上的 IOCP</li>
<li>libuv 是一个跨平台的异步 I/O 库，他会根据系统选择合适的方案</li>
<li>可以用于 TCP/UDP/DNS/文件 等异步操作</li>
</ul>
<h3 id="v8">V8</h3>
<ul>
<li>将 JS 源代码变成本地代码（机器代码）执行</li>
<li>维护调用栈</li>
<li>内存管理</li>
<li>垃圾回收，重复利用无用的内存</li>
<li>实现 JS 的标准库</li>
</ul>
<p>注意：</p>
<ul>
<li>V8 不提供 DOM API，DOM API 是浏览器提供的</li>
<li>V8 是多线程的，比如垃圾回收为单独的线程，但执行 JS 是单线程的</li>
<li>可以开启两个线程来执行 JS，但这两个线程之间没什么关系</li>
<li>V8 自带 event loop，但 Node.js 基于 libuv 自己做了一个 event loop</li>
</ul>
<h4 id="event-loop">Event Loop</h4>
<ul>
<li>Event：包括内部事件（计时器到期了）、外部事件（文件可以读取了、socket 有内容了）</li>
<li>Loop：事件是有优先级的，处理顺序是有先后的，Node.js 要按顺序轮询每种事件，这种轮询往往都是循环的</li>
</ul>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">官方文档</a></p>
<p>重点阶段：</p>
<ul>
<li>timers 检查计时器</li>
<li>poll 轮询，大部分时间会停留在这个阶段，大部分事件将在 poll 得到处理，比如文件读取、网络请求</li>
<li>check 检查 setImmediate 回调</li>
</ul>
<blockquote>
<p>setTimout 与 setImmediate 谁先执行？ 不确定，大多数情况是 setImmediate 先执行，但有时刚进入的时候，会先执行 setTimout</p>
</blockquote>
<h1 id="文件模块">文件模块</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultDbPath = p.<span class="title function_">join</span>(__dirname, <span class="string">&quot;.todo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="title function_">read</span>(<span class="params">path = defaultDbPath</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.<span class="title function_">readFile</span>(path, &#123;</span><br><span class="line">        <span class="attr">flag</span>: <span class="string">&quot;a+&quot;</span></span><br><span class="line">      &#125;, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">write</span>(<span class="params">content = <span class="string">&quot;defaultContent&quot;</span>, path = defaultDbPath</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.<span class="title function_">writeFile</span>(path, content, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="http-模块">HTTP 模块</h1>
<p>一个最简单的服务器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IncomingMessage</span>, <span class="title class_">ServerResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request.method&quot;</span>, request.<span class="property">method</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request.url&quot;</span>, request.<span class="property">url</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request.headers&quot;</span>, request.<span class="property">headers</span>)</span><br><span class="line">  <span class="comment">// 监听 data 事件才能拿到 post 的请求体，用户每上传一点内容，就会触发一次 data 事件</span></span><br><span class="line">  <span class="keyword">const</span> array = []</span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    array.<span class="title function_">push</span>(chunk)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当流中没有数据了，会触发 end 事件</span></span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(array)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;body&quot;</span>, body.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 response</span></span><br><span class="line">    response.<span class="property">statusCode</span> = <span class="number">400</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&quot;x-harvey&quot;</span>, <span class="string">&quot;WOW&quot;</span>)</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&quot;1\n&quot;</span>)</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&quot;2\n&quot;</span>)</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&quot;request end&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>可以配合 <a href="https://nodejs.org/api/http.html#http_event_request">文档</a> 食用</p>
<h2 id="根据-url-返回不同的文件">根据 url 返回不同的文件</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IncomingMessage</span>, <span class="title class_">ServerResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> p <span class="keyword">from</span> <span class="string">&quot;path&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="keyword">const</span> publicDir = p.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;public&quot;</span>)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; method, url, headers &#125; = request</span><br><span class="line">  <span class="keyword">switch</span> (url) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;/index.html&quot;</span>:</span><br><span class="line">    fs.<span class="title function_">readFile</span>(p.<span class="title function_">resolve</span>(publicDir, <span class="string">&quot;index.html&quot;</span>), (<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">      response.<span class="title function_">end</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;/style.css&quot;</span>:</span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/css; charset=utf-8&quot;</span>)</span><br><span class="line">    fs.<span class="title function_">readFile</span>(p.<span class="title function_">resolve</span>(publicDir, <span class="string">&quot;style.css&quot;</span>), (<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">      response.<span class="title function_">end</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;/index.js&quot;</span>:</span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/javascript; charset=utf-8&quot;</span>)</span><br><span class="line">    fs.<span class="title function_">readFile</span>(p.<span class="title function_">resolve</span>(publicDir, <span class="string">&quot;index.js&quot;</span>), (<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">      response.<span class="title function_">end</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<h2 id="处理查询参数">处理查询参数</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; pathname, searchParams &#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(requestUrl, <span class="string">&quot;http://localhost:8888&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="匹配任意文件">匹配任意文件</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; method, <span class="attr">url</span>: requestUrl, headers &#125; = request</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(requestUrl, <span class="string">&quot;http://localhost:8888&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> filename = pathname.<span class="title function_">substr</span>(<span class="number">1</span>) || <span class="string">&quot;index.html&quot;</span></span><br><span class="line">  fs.<span class="title function_">readFile</span>(p.<span class="title function_">resolve</span>(publicDir, filename), <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.<span class="property">errno</span> === -<span class="number">4058</span>) &#123;</span><br><span class="line">        response.<span class="property">statusCode</span> = <span class="number">404</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.<span class="property">statusCode</span> = <span class="number">500</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">end</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    response.<span class="title function_">end</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="处理非-get-请求">处理非 get 请求</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (method !== <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">  response.<span class="property">statusCode</span> = <span class="number">405</span></span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">end</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加缓存">添加缓存</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">`public, max-age=<span class="subst">$&#123;cacheAge&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<h1 id="stream">Stream</h1>
<p>数据流叫 Stream，每次写的小数据叫 chunk，产生数据的一段叫 source，得到数据的一段叫 sink。</p>
<h2 id="nodejs-中的-stream">NodeJS 中的 Stream</h2>
<h3 id="用-stream-写文件">用 Stream 写文件</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> stream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&quot;./big_file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  stream.<span class="title function_">write</span>(<span class="string">`这是第 <span class="subst">$&#123;i&#125;</span> 行的内容，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\n`</span>)</span><br><span class="line">&#125;</span><br><span class="line">stream.<span class="title function_">end</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="不用-stream-读文件">不用 Stream 读文件</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&quot;./big_file.txt&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    response.<span class="title function_">end</span>(data)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到 Nodejs 进程的内存占用非常大。</p>
<h3 id="用-stream-读文件">用 Stream 读文件</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;./big_file.txt&quot;</span>)</span><br><span class="line">  stream.<span class="title function_">pipe</span>(response) <span class="comment">// response 也是 stream，文件 stream 和 response stream 通过管道连接</span></span><br><span class="line">  stream.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>使用 Stream，Nodejs 的内存占用会更低。</p>
<p>管道也可以通过这样来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream1 有数据就塞给 stream2</span></span><br><span class="line">stream1.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  stream2.<span class="title function_">write</span>(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// stream1 停了，就停掉 steam2</span></span><br><span class="line">stream1.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  stream2.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="stream-的原型链">Stream 的原型链</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s = fs.<span class="title function_">createReadStream</span>(path)</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">s -&gt; fs.ReadStream -&gt; stream.Readable -&gt; stream.Stream -&gt; event.EventEmitter -&gt; Object</span><br></pre></td></tr></table></figure>
<h3 id="支持的事件和方法">支持的事件和方法</h3>
<h4 id="stream.readable">stream.Readable</h4>
<ul>
<li><p>事件：data, end, error, close, readable, pause, resume ...</p></li>
<li><p>方法：</p>
<ul>
<li>pipe()</li>
<li>unpipe()</li>
<li>wrap()</li>
<li>destroy()</li>
<li>read()</li>
<li>unshift()</li>
<li>resume()</li>
<li>pause()</li>
<li>isPaused()</li>
<li>setEncoding()</li>
</ul></li>
</ul>
<h4 id="stream.writable">stream.Writable</h4>
<ul>
<li><p>事件：drain, finish, error, close, pipe, unpipe ...</p></li>
<li><p>方法：</p>
<ul>
<li>write()</li>
<li>destroy()</li>
<li>end()</li>
<li>cork()</li>
<li>uncork()</li>
<li>setDefaultEncoding()</li>
</ul></li>
</ul>
<h2 id="stream-的分类">Stream 的分类</h2>
<ul>
<li>Readable，可读，数据的生产者</li>
<li>Writable，可写，数据的消费者</li>
<li>Duplex，可读可写（双向，读和写的内容无关）</li>
<li>Transform，可读可写（变化，比如先把内容读出来，再写到别的地方）</li>
</ul>
<h3 id="readable-stream">Readable Stream</h3>
<ul>
<li>paused 静止态</li>
<li>flowing 流动态</li>
</ul>
<p>默认处于 paused；添加 data 事件监听，就会变成 flowing；删掉 data 事件监听就又变成 paused。 pause() 可以让他变为 paused，resume() 可以让他变为 flowing。</p>
<h3 id="writable-stream">Writable Stream</h3>
<ul>
<li>drain：writable.write(chunk) 将会返回一个 boolean，如果 boolean 为 false，这个 stream 堵车了，这个时候就需要等待。当 writable 监听到 drain 事件，表示不堵车了，可以继续传输数据。</li>
<li>finish：调用 stream.end() 方法，并且缓冲区的数据都已经传给底层系统后会触发。</li>
</ul>
<h3 id="transform-stream">Transform Stream</h3>
<p>NodeJS 内置了一些 Transform Stream，可以看这个使用 gzip 压缩的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&quot;zlib&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Transform</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> file = process.<span class="property">argv</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reportProgress = <span class="keyword">new</span> <span class="title class_">Transform</span>(&#123;</span><br><span class="line">  <span class="title function_">transform</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="comment">// 可以将 chunk push 进去</span></span><br><span class="line">    <span class="comment">// this.push(chunk)</span></span><br><span class="line">    <span class="comment">// 也可以把 chunk 给 callback</span></span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, chunk)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">createReadStream</span>(file)</span><br><span class="line">  .<span class="title function_">pipe</span>(crypto.<span class="title function_">createCipher</span>(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;123456&quot;</span>))</span><br><span class="line">  .<span class="title function_">pipe</span>(zlib.<span class="title function_">createGzip</span>())</span><br><span class="line">  <span class="comment">// 可以用 on 来进行监听并作出副作用（不会影响原来的数据）</span></span><br><span class="line">  <span class="comment">// .on(&quot;data&quot;, () =&gt; process.stdout.write(&quot;.&quot;))</span></span><br><span class="line">  <span class="comment">// 也可以插入一个 TransformStream</span></span><br><span class="line">  .<span class="title function_">pipe</span>(reportProgress)</span><br><span class="line">  .<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(file + <span class="string">&quot;.gz&quot;</span>))</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&quot;finish&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建一个-stream">创建一个 Stream</h2>
<h3 id="创建一个-writable-stream">创建一个 Writable Stream</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Writable</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> consumer = <span class="keyword">new</span> <span class="title class_">Writable</span>(&#123;</span><br><span class="line">  <span class="title function_">write</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="comment">// callback 调用这句必须要写，否则就会卡住</span></span><br><span class="line">    <span class="title function_">callback</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户的输入 stream -&gt; consumer</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">pipe</span>(consumer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写：</span></span><br><span class="line"><span class="comment">// process.stdin.on(&quot;data&quot;, (chunk) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   consumer.write(chunk)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<h3 id="创建一个-readable-stream">创建一个 Readable Stream</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Readable</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> producer = <span class="keyword">new</span> <span class="title class_">Readable</span>()</span><br><span class="line"></span><br><span class="line">producer.<span class="title function_">push</span>(<span class="string">&quot;HAHAHA&quot;</span>)</span><br><span class="line">producer.<span class="title function_">push</span>(<span class="string">&quot;XIXIXI&quot;</span>)</span><br><span class="line"><span class="comment">// push null 必须写，表示已经结束了</span></span><br><span class="line">producer.<span class="title function_">push</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">producer.<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="comment">// producer.on(&quot;data&quot;, (chunk) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   process.stdout.write(chunk)</span></span><br><span class="line"><span class="comment">//   console.log(&quot;WRITE&quot;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<p>上面的写法是先将所有的数据 push 进流里面，那么有没有办法让他边读边写呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Readable</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> producer = <span class="keyword">new</span> <span class="title class_">Readable</span>(&#123;</span><br><span class="line">  <span class="title function_">read</span>(<span class="params">size</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="variable language_">this</span>.<span class="property">currentCharCode</span>++))</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentCharCode</span> &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="comment">// push null 表示终止</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">producer.<span class="property">currentCharCode</span> = <span class="string">&quot;A&quot;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line"></span><br><span class="line">producer.<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>
<p>上述的代码就是在 <code>process.stdout</code> 要数据的时候（调用 <code>read</code> 的时候），<code>producer</code> 才往里面 push 一个字符。</p>
<h3 id="创建一个-duplex-stream">创建一个 Duplex Stream</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Duplex</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> duplex = <span class="keyword">new</span> <span class="title class_">Duplex</span>(&#123;</span><br><span class="line">  <span class="title function_">write</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="title function_">callback</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">read</span>(<span class="params">size</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="variable language_">this</span>.<span class="property">currentCharCode</span>++))</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentCharCode</span> &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">duplex.<span class="property">currentCharCode</span> = <span class="number">65</span></span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">pipe</span>(duplex).<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>
<p>简单来说就是把 Readable 和 Writable Stream 写在一起，就成了一个双向的 Stream，它既可写又可读，既可以消费信息、又可以生产信息。他的生产和消费过程彼此相互独立、互不影响。</p>
<h3 id="transform-stream-1">Transform Stream</h3>
<p>Transform 虽然也被称为“双向流”，但跟 Duplex 不同，他是先读数据，转换之后再写数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Transform</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;stream&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upperCaseTransformer = <span class="keyword">new</span> <span class="title class_">Transform</span>(&#123;</span><br><span class="line">  <span class="title function_">transform</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(chunk.<span class="title function_">toString</span>().<span class="title function_">toUpperCase</span>())</span><br><span class="line">    <span class="title function_">callback</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">pipe</span>(upperCaseTransformer).<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>
<h1 id="进程和线程">进程和线程</h1>
<h2 id="进程-process">进程 Process</h2>
<p><strong>进程</strong>是<strong>程序</strong>（比如 exe）的执行实例。<strong>程序</strong>在CPU上执行的活动叫做<strong>进程</strong>。</p>
<p>一个进程可以创建另一个进程（父进程与子进程）。</p>
<h3 id="多程序并发执行">多程序并发执行</h3>
<p>单核 CPU 在一个时刻，只能做一件事情，为了让用户在同一时刻可以做多件事，就需要在不同进程中快速切换。</p>
<p>也就是“多程序并发执行”——多个程序在宏观上并行，微观上串行。多个进程之间会出现抢资源（比如打印机就很明显）的现象。</p>
<h3 id="进程的两个状态">进程的两个状态</h3>
<p>进程有 <strong>非运行态</strong> 与 <strong>运行态</strong>。分派程序将 CPU 分配给非运行态的进程，进程从而进入运行态；过一段时间之后进程暂停，又进入非运行态。</p>
<h3 id="阻塞">阻塞</h3>
<p>在进程队列中等待执行的进程都处于 <strong>非运行态</strong>，一些进程(A)在等待 CPU 资源，一些进程(B)在等待 I/O 完成（比如文件读取）。如果这时候把 CPU 分配给 B 进程，B 进程并不会使用 CPU，而是继续等 I/O——我们把 B 称为 <strong>阻塞进程</strong>。为了避免资源的浪费，分派程序只会把 CPU 分配给 <strong>非阻塞进程</strong>。</p>
<h2 id="线程-thread">线程 Thread</h2>
<p>早期的面向进程设计的操作系统中，进程是程序的基本执行实体。现在的面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。</p>
<p>进程是执行的基本实体，也是资源分配的基本实体——这就导致进程的创建、切换、销毁太消耗 CPU 的时间了。因此引入线程，线程作为执行的基本实体，而进程作为资源分配的基本实体。</p>
<h3 id="概念">概念</h3>
<ul>
<li>CPU 调度和执行的最小单元</li>
<li>一个进程中可以有一个或多个线程</li>
<li>一个进程中的线程共享该进程的所有资源</li>
<li>进程的第一个线程叫做初始化线程</li>
<li>线程的调度可以由操作系统负责，也可以由用户自己负责</li>
</ul>
<h2 id="使用-nodejs-操作进程">使用 NodeJS 操作进程</h2>
<p>使用 <code>child_process</code> 模块可以创建子进程。 子进程的运行结果存在系统缓存之中（最大 200kb），等到子进程结束之后，主进程再用回调函数读取子进程的运行结果。</p>
<h3 id="exec">exec</h3>
<p><code>exec(command[, options][, callback])</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="comment">// exec 可以执行命令行命令，从而开启一个子进程，子进程如果有输出，会存在缓存之中，等子进程结束之后输出给 stdout</span></span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&quot;ls ../&quot;</span>, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error, stdout, stderr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面这段简单的代码表示使用 exec 可以执行命令行命令，使用命令行我们就可以开启一个子进程。</p>
<p>exec 也会返回一个包含流的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> streams = <span class="title function_">exec</span>(<span class="string">&quot;ls ../&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// streams.stdout 是一个流</span></span><br><span class="line">streams.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getData&quot;</span>, chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// stream.stderror 也是一个流</span></span><br><span class="line">streams.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getError&quot;</span>, chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此外，还可以用 <code>util.promisify</code> 将其包裹为一个 Promise，避免回调地狱：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promisifiedExec = util.<span class="title function_">promisify</span>(exec)</span><br><span class="line"></span><br><span class="line"><span class="title function_">promisifiedExec</span>(<span class="string">&quot;ls ../&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success&quot;</span>, data.<span class="property">stdout</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>注意！如果 <code>exec</code> 执行的命令行命令可以被用户指定，就会存在注入的风险，所以通常我们不使用 <code>exec</code>。</p>
<h3 id="execfile">execFile</h3>
<p><code>execFile(file[, args][, options][, callback])</code></p>
<p>跟 exec 用法基本相同，也可以以流的方式使用，但命令行参数需要用数组的形式传入，无法注入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; execFile &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="title function_">execFile</span>(<span class="string">&quot;ls&quot;</span>, [<span class="string">&quot;-la&quot;</span>, <span class="string">&quot;.&quot;</span>], <span class="function">(<span class="params">error, stdout</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(stdout)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="options">options</h4>
<p>options 可传可不传，他有一些比较重要的参数：</p>
<ul>
<li>cwd: 在哪个目录执行，默认是当前目录</li>
<li>env: 环境变量，默认是 process.env</li>
<li>maxBuffer: 用于暂存 stdout 和 stderr 的最大缓存区大小，默认 1024 * 1024 Byte</li>
<li>shell: 指定运行的 shell</li>
</ul>
<h3 id="spawn">spawn</h3>
<p>用法跟 execFile 基本一样，但没有回调函数，只能通过流事件来获取结果，也没有最大的缓存限制（因为是流，并没有暂存 stdout 和 stderr）。</p>
<p>一般用 spawn，不用 execFile，因为流比较方便，且不会占用太多内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> streams = <span class="title function_">spawn</span>(<span class="string">&quot;ls&quot;</span>, [<span class="string">&quot;-la&quot;</span>, <span class="string">&quot;.&quot;</span>])</span><br><span class="line"></span><br><span class="line">streams.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="fork">fork</h3>
<p>创建一个执行 Node 脚本的子进程，可以监听他的 message 事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** main.js */</span></span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实类似于 execFile(&quot;node&quot;, [&quot;./child.js&quot;])</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="title function_">fork</span>(<span class="string">&quot;./child.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程监听子进程传来的消息</span></span><br><span class="line">childProcess.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;父进程得到 message&quot;</span>, message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">childProcess.<span class="title function_">send</span>(&#123; <span class="attr">age</span>: <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** child.js */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is child.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程监听父进程传来的消息</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子进程得到 message&quot;</span>, message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  process.<span class="title function_">send</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;harvey&quot;</span> &#125;)</span><br><span class="line">  <span class="comment">// 如果没有这句话，node 会因为父子进程相互监听而无法退出</span></span><br><span class="line">  process.<span class="title function_">exit</span>()</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="使用-nodejs-操作线程">使用 NodeJS 操作线程</h2>
<p>操作线程需要使用 <code>new Worker</code>，而这个 API 非常新，在 v10.5.0 才加入，并且在 v11.7.0 之前使用都需要 <code>--experimental-worker</code> 来开启，因此用得会比较少，并且效率也不高。</p>
<blockquote>
<p>Workers (threads) are useful for performing CPU-intensive JavaScript operations. They do not help much with I/O-intensive work. The Node.js built-in asynchronous I/O operations are more efficient than Workers can be.</p>
</blockquote>
<p>具体内容可以参考 <a href="https://nodejs.org/api/worker_threads.html">官方文档</a></p>
<h1 id="express">Express</h1>
<h2 id="express-generator">Express Generator</h2>
<p>express 脚手架。</p>
<h2 id="use">use</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&quot;express&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)</span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&quot;first hi\n&quot;</span>)</span><br><span class="line">  <span class="comment">// 为了让他执行下一个 use，需要调用 next()，否则他不会执行下一个 use</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&quot;second hi\n&quot;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>express 就是这样通过一个个 <code>use</code> 的函数，最终到达结束程序。每一个函数可以读取 request、写入 response、调用 next()。</p>
<h2 id="中间件">中间件</h2>
<p><code>use</code> 的那些函数就被称为 <strong>中间件</strong>。 可以看一下 <code>express-generator</code> 为我们创建的 <code>app.js</code> 文件的其中一部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">logger</span>(<span class="string">&quot;dev&quot;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>())</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;public&quot;</span>)))</span><br></pre></td></tr></table></figure>
<p>Express 这样的编程模型的优点就是模块化：每个功能都能通过一个函数实现，然后通过 app.use 将函数们整合起来。如果这些函数放到不同的文件或者 npm 包里，就实现了模块化。</p>
<h2 id="路由">路由</h2>
<p>用 use 也可以很方便地实现路由：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">path</span> === <span class="string">&quot;/&quot;</span> &amp;&amp; request.<span class="property">method</span> === <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&quot;ROOT&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由此衍生除了一些 API 糖：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/xxx&quot;</span>, fn)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/xxx&quot;</span>, fn)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/xxx&quot;</span>, fn)</span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&quot;/xxx&quot;</span>).<span class="title function_">all</span>(f1).<span class="title function_">get</span>(f2).<span class="title function_">post</span>(f3)</span><br></pre></td></tr></table></figure>
<h2 id="错误处理">错误处理</h2>
<p><code>next()</code> 可以传入一个错误/字符串，就会进入错误处理函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    <span class="comment">// 传给 next 一个错误，就会直接进入 errorHandler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>(<span class="string">&quot;出错了！&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;如果没有错误，这里才会执行&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">error, request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">write</span>(error)</span><br><span class="line">  response.<span class="title function_">end</span>()</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="子应用与挂载点">子应用与挂载点</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> admin = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/admin&quot;</span>, admin) <span class="comment">// admin 是子应用，/admin 是 admin 的挂载点</span></span><br></pre></td></tr></table></figure>
<h2 id="express-apis">Express APIs</h2>
<h3 id="express.xxx">express.xxx</h3>
<ul>
<li><code>express.static()</code> 指定静态资源文件夹路径</li>
<li><code>express.json()</code> 解析 Content-Type 为 application/json（或类似）的内容</li>
<li><code>express.urlencoded()</code> 解析 Content-Type 为 application/x-www-form-urlencoded（或类似）的内容</li>
<li><code>express.text()</code> 解析 Content-Type 为 text/plain（或类似）的内容</li>
<li><code>express.raw()</code> 解析 Content-Type 为 application/octet-stream （或类似）的内容</li>
</ul>
<h3 id="app.xxx">app.xxx</h3>
<ul>
<li><code>app.set()</code> set 一个值，不过有一些特殊值，比如 <code>case sensitive routing</code> <code>env</code> <code>views</code> <code>view engine</code>，而且一般这些特殊值放在所有的中间件之前才会生效</li>
<li><code>app.get()</code> 可以获取到你 set 的东西</li>
<li><code>app.get()</code> <code>app.post()</code> <code>app.put()</code> <code>app.delete()</code> <code>app.patch()</code> <code>app.all()</code> 这些都是 <code>app.use()</code> 的 API 糖</li>
<li><code>app.locals</code> 设置一些局部变量，比如 <code>app.locals.title = "My Title"</code>，然后就可以在其他地方进行读取</li>
<li><code>app.mountpath</code> 挂载路径</li>
</ul>
<h3 id="request.xxx">request.xxx</h3>
<ul>
<li><code>request.app</code> 获取到全局的 app</li>
<li><code>request.get()</code> 获取请求头</li>
<li><code>request.param()</code> 获取某个参数</li>
<li><code>request.range()</code>
<ol type="1">
<li>用 HEAD 请求某个资源，如果资源支持分片下载，就可以得到类似于 <code>Accept-Ranges: bytes</code>（支持以字节为分片下载） 的响应头。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests">可以参阅这里</a></li>
<li>然后用请求头 <code>Range</code> 就可以设置分片下载</li>
<li><code>request.range</code> 则是用于解析 <code>Range</code> 这个请求头的</li>
</ol></li>
</ul>
<h3 id="response.xxx">response.xxx</h3>
<ul>
<li><code>response.app</code> 获取到全局的 app</li>
<li><code>response.headersSent</code> 是否已经发送响应头</li>
<li><code>response.set()</code> 设置响应头（覆盖之前的）</li>
<li><code>response.append()</code> 设置请求头（不覆盖之前的）</li>
<li><code>response.status()</code> 设置状态码</li>
<li><code>repoonse.cookie()</code> 设置 cookie</li>
<li><code>response.download()</code> 提供下载</li>
<li><code>response.format()</code> 根据请求的不同 <code>Accept</code> 值返回不同的类型</li>
<li><code>response.json()</code> 类似于 <code>JSON.stringify()</code></li>
<li><code>response.location()</code> 一般用于 301/302/307 跳转，设置响应头 <code>Location</code></li>
<li><code>response.redirect()</code> 相当于 <code>response.location()</code> + <code>response.status()</code></li>
<li><code>response.write()</code> 写入消息体（流式操作）</li>
<li><code>response.end()</code> 写入消息体（一次性），不能跟 <code>response.write</code> 同时使用</li>
</ul>
<h3 id="router.xxx">router.xxx</h3>
<p><code>router</code> 相当于一个小型的 <code>app</code>，是一个单独的用于路由的实例，需要这样声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">userRouter.<span class="title function_">get</span>(<span class="string">&quot;/:id&quot;</span>, <span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/users&quot;</span>, userRouter) <span class="comment">// 将 userRouter 挂载到 app 上</span></span><br></pre></td></tr></table></figure>
<p><code>router</code> 有这些 API，基本被 <code>app</code> 包含。</p>
<ul>
<li><code>router.all()</code></li>
<li><code>router.METHOD()</code></li>
<li><code>router.param()</code></li>
<li><code>router.route()</code></li>
<li><code>router.use()</code></li>
</ul>
<h1 id="koa">Koa</h1>
<h2 id="koa-与-express-的区别">Koa 与 Express 的区别</h2>
<ul>
<li>中间件模型不同：Koa 是 U 型，Express 是线型</li>
<li>语法特性不同，一般来说 NodeJS 7.6.0 之后才算完美支持 Koa</li>
<li>Koa 没有内置中间件</li>
</ul>
<h2 id="koa-的中间件模型u-型洋葱型">Koa 的中间件模型：U 型/洋葱型</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">请求 -&gt; f1 -&gt; f2 -&gt; f3 -&gt; ...</span><br><span class="line">                           ↓</span><br><span class="line">响应 &lt;- f1 &lt;- f2 &lt;- f3 &lt;- ...</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的中间件使用示例，按照注释的顺序运行，可以看到一个以 <code>await next()</code> 为轴的 U 型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 什么也不做</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="comment">// 5. 读取 X-Response-Time 中的时间，打印出来</span></span><br><span class="line">  <span class="keyword">const</span> time = ctx.<span class="property">response</span>.<span class="title function_">get</span>(<span class="string">&quot;X-Response-Time&quot;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 2. 记录开始时间</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="comment">// 4. 计算第三个中间件写 &quot;Hello World&quot; 的时间，并写入 X-Response-Time 响应头中</span></span><br><span class="line">  <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;X-Response-Time&quot;</span>, <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 3. body = &quot;Hello World&quot;</span></span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  <span class="comment">// 最后一个中间件可以不写 await next()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="await-next"><code>await next()</code></h3>
<p><code>next()</code> 表示进入下一个函数，并返回一个 Promise，当下一个函数执行完成之后，会将 Promise 置为成功，然后 await 继续执行剩下的代码</p>
<p>实际上相当于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="comment">// 中间件需要返回一个 Promise 对象，使用 async 的写法将会自动 return 一个 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start</span><br><span class="line">    ctx.<span class="title function_">set</span>(<span class="string">&quot;X-Response-Time&quot;</span>, <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span>)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="koa-apis">Koa APIs</h2>
<h3 id="app.xxx-1">app.xxx</h3>
<ul>
<li><code>app.env</code> 获取环境变量</li>
<li><code>app.listen()</code></li>
<li><code>app.use()</code> 插入中间件</li>
<li><code>app.on("error", fn)</code> 错误处理</li>
<li><code>app.emit()</code> 触发事件</li>
</ul>
<h3 id="ctx.xxx">ctx.xxx</h3>
<ul>
<li><code>ctx.req</code> NodeJS 封装的请求</li>
<li><code>ctx.request</code> Koa 封装的请求</li>
<li><code>ctx.res</code></li>
<li><code>ctx.response</code></li>
<li><code>ctx.state</code> 跨中间件分享数据</li>
<li><code>ctx.cookies.get</code> <code>ctx.cookies.set</code></li>
<li><code>ctx.throw</code></li>
<li><code>ctx.assert</code></li>
</ul>
<h4 id="request-和-response-委托">Request 和 Response 委托</h4>
<p><code>ctx</code> 是 Request 和 Response 的委托，比如写 <code>ctx.body =</code> 相当于写 <code>ctx.response.body =</code>。 如果要自己实现委托操作的话，可以这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(ctx, <span class="string">&quot;body&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">response</span>.<span class="property">body</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="ctx.request.xxx-ctx.response.xxx"><code>ctx.request.xxx</code> <code>ctx.response.xxx</code></h4>
<p>可以直接查看 <a href="https://koa.bootcss.com/">相关文档</a></p>
<h1 id="next">Next</h1>
<p>NodeJS WEB 框架之 Next。 Tip：如何保存密码？</p>
<ol type="1">
<li>存在环境变量中：用 <code>export xxx=</code> 设置环境变量，用 <code>process.env.xxx</code> 使用环境变量</li>
<li>或者参考 <a href="https://nextjs.org/docs/basic-features/environment-variables">这篇文章</a></li>
</ol>
<h2 id="开始一个-next.js-项目">开始一个 Next.js 项目</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app next-demo</span><br></pre></td></tr></table></figure>
<h2 id="next-的一些特性">Next 的一些特性</h2>
<h3 id="使用-link-快速导航">使用 Link 快速导航</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来这样写</span></span><br><span class="line">&lt;a href=<span class="string">&quot;xxx&quot;</span>&gt;点击跳转&lt;/a&gt;</span><br><span class="line"><span class="comment">// 现在这样写</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>页面不会刷新，用 AJAX 请求新页面的内容</li>
<li>不会请求重复的 HTML、CSS、JS</li>
<li>自动在页面插入新内容、删除旧内容</li>
<li>省去了很多请求和解析的过程、速度极快</li>
</ul>
<h3 id="同构代码">同构代码</h3>
<p>同一份代码，在浏览器和 Node 两端都执行了，比如在组件里面写一个 console.log，会发现 Node 控制台和 Chrome 中都会有 log。</p>
<p>但：</p>
<ul>
<li>不是所有的代码都会在两端运行，比如需要用户触发的操作，就不会在 Node 中运行</li>
<li>不是所有的 API 都能用，比如 <code>window</code> 就会报错，因为在 Node 中不存在</li>
</ul>
<h3 id="head"><code>&lt;Head&gt;</code></h3>
<p>可以用 <code>&lt;Head&gt;</code> 标签书写 <code>title</code> <code>meta:viewport</code> 等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以在 <code>pages/_app.js</code> 中进行全局配置：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyApp</span></span><br></pre></td></tr></table></figure>
<p>切换页面的时候 MyApp 不会被销毁，MyApp 里面的代码会重新执行，但是里面的状态会保留。</p>
<h3 id="style">Style</h3>
<p>在 <code>_app.js</code> 中还可以用 <code>import</code> 直接引入全局生效的 <code>global.css</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../styles/globals.css&#x27;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下都是相对路径引入，用配置指定根目录，可以参考 <a href="https://nextjs.org/docs/advanced-features/module-path-aliases">这篇文档</a></p>
<p>也可以在组件中书写局部的 <code>&lt;style&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">  h1 &#123; </span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="静态资源">静态资源</h3>
<p>官方推荐静态资源放在 public 中，但在这里面的资源不能加 hash。 因此不推荐这样用，可以另外新建 <code>asstes/images</code> 文件夹来存放图片静态资源。 但直接这样就需要自己配置 file-loader，也就是自定义 webpack 配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">webpack</span>: <span class="function">(<span class="params">config, options</span>) =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">module</span>.<span class="property">rules</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|jpeg|gif|svg)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;[name].[contenthash].[ext]&quot;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">          <span class="attr">publicPath</span>: <span class="string">&quot;_next/static&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <a href="https://github.com/twopluszero/next-images#readme">next-images 插件</a> 来引入图片</p>
<h2 id="next.js-api-模式">Next.js API 模式</h2>
<p>在 api 目录下创建文件 <code>v1/post.tsx</code></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiHandler</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span></span><br><span class="line"><span class="keyword">import</span> p <span class="keyword">from</span> <span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123; promises <span class="keyword">as</span> fsPromise &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span></span><br><span class="line"><span class="keyword">import</span> matter <span class="keyword">from</span> <span class="string">&quot;gray-matter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPosts</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> markdownDir = p.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&quot;markdown&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> fileNames = <span class="keyword">await</span> fsPromise.<span class="title function_">readdir</span>(markdownDir)</span><br><span class="line">  <span class="keyword">const</span> posts = fileNames.<span class="title function_">map</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = name.<span class="title function_">replace</span>(<span class="string">&quot;/.md$/&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> filePath = p.<span class="title function_">join</span>(markdownDir, name)</span><br><span class="line">    <span class="keyword">const</span> text = fs.<span class="title function_">readFileSync</span>(filePath, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: &#123; title, date &#125;, content &#125; = <span class="title function_">matter</span>(text)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      id, title, date,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> posts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里跟 express 和 koa 不同，没有将 next 直接暴露给我们，但是由于 next 基于 express，他其实也支持 express 类似的中间件，具体请查阅文档</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Posts</span>: <span class="title class_">NextApiHandler</span> = <span class="keyword">async</span> (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">getPosts</span>()</span><br><span class="line">  response.<span class="property">statusCode</span> = <span class="number">200</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">  response.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(posts))</span><br><span class="line">  response.<span class="title function_">end</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Posts</span></span><br></pre></td></tr></table></figure>
<p>可以试着访问 <code>/api/v1/posts</code>，这段代码只会运行在 node，不会运行在浏览器中</p>
<h2 id="next.js-三种渲染方式">Next.js 三种渲染方式</h2>
<h3 id="客户端渲染bsr">客户端渲染（BSR）</h3>
<p>在浏览器上执行的渲染（Browser Side Render），类似用 JS（Vue、React）去创建 HTML</p>
<p>缺点：</p>
<ul>
<li>白屏，而且在拿到响应之前都需要显示 loading 状态</li>
<li>SEO 不友好，搜索引擎拿不到具体的数据；搜索引擎也不会执行 JS，因此看到的 HTML 信息量极少</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/posts/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextPage</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCallback, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Post</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">date</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PostsIndex</span>: <span class="title class_">NextPage</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [posts, setPosts] = useState&lt;<span class="title class_">Post</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/v1/posts&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setPosts</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;clicked&quot;</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 静态内容 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>文章列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 动态内容 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        posts.map((item) =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PostsIndex</span></span><br></pre></td></tr></table></figure>
<p>实际上上述的静态内容是先由服务器渲染出来，然后再在浏览器上增加事件绑定的，可以看 <a href="https://zh-hans.reactjs.org/docs/react-dom-server.html#rendertostring">这篇文档</a>：</p>
<p>服务端调用 <code>ReactDOMServer.renderToString(element)</code>，将 React 元素渲染为初始 HTML。 再在前端调用 <code>ReactDOM.hydrate()</code>，会在标记过的节点上绑定事件。</p>
<p>但事实上，前端也会渲染一次，检查一下前端跟服务端渲染的内容是否一致（前端渲染的目的是为了检查一致性，而不是为了替换）。 如果我们在函数组件最开始打一个 debugger，然后趁 debugger 的时间在页面上把服务端渲染出来的 HTML 改一下，再继续执行，会发现报错：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-1.png" alt="如果前后端渲染不一致，会报错" /><figcaption aria-hidden="true">如果前后端渲染不一致，会报错</figcaption>
</figure>
<h3 id="静态页面生成ssg">静态页面生成（SSG）</h3>
<p>静态页面生成（Static Site Generation）是预渲染（Pre-rendering）的一种，类似于把 PHP 提前渲染成 HTML。</p>
<p>时机：</p>
<ul>
<li>生产环境中，静态化是在 <code>yarn build</code> 的时候实现的 优点：</li>
<li>能解决白屏问题</li>
<li>解决 SEO 问题</li>
<li>前端重复渲染相同内容的问题（可以将动态内容静态化，将需要客户端渲染的动态内容提前由服务端渲染好，然后作为静态内容发给前端） 缺点：</li>
<li>无法生成用户相关内容（每个人看到的都是一样的）</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticProps</span>, <span class="title class_">NextPage</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCallback, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPosts &#125; <span class="keyword">from</span> <span class="string">&quot;../../lib/posts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Post</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">date</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">posts</span>: <span class="title class_">Post</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PostsIndex</span>: <span class="title class_">NextPage</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个 props 其实前后端都能拿到</span></span><br><span class="line">  <span class="keyword">const</span> &#123; posts &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        posts.map((item) =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里不要忘了 export，如果不写的话，这段代码会被前端执行，会报错</span></span><br><span class="line"><span class="comment">// 在生产环境中，是在 build 的时候执行的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticProps</span>: <span class="title class_">GetStaticProps</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 服务端显然没必要通过 AJAX 去拿数据，直接去文件系统或者数据库拿</span></span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">getPosts</span>()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">posts</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(posts)),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PostsIndex</span></span><br></pre></td></tr></table></figure>
<p>前端也能拿到 props，因为 Next 会将这些数据放在 HTML 中给前端：</p>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-2.png" alt="Next 会将数据放在 HTML 中给前端" /><figcaption aria-hidden="true">Next 会将数据放在 HTML 中给前端</figcaption>
</figure>
<h4 id="同构代码的好处">同构代码的好处</h4>
<p>将数据放在 HTML 中之后，前端也能很方便地使用了，其实其他后端语言也能做到，但 Next.js 更加方便，因为：</p>
<ul>
<li>Next 支持 jsx，写出来的代码可以与 React 无缝对接，可以只写一份代码</li>
<li>Next 写出来的对象都是 JavaScript 对象，无需类型转换，如果是其他语言就需要进行额外的类型转换</li>
</ul>
<h4 id="yarn-build">yarn build</h4>
<p><code>yarn build</code> 的时候会提示你页面的类型：</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-3.png" /></p>
<p>比如空心圆代表静态页面，而实心圆代表使用了 getStaticProps 进行静态化。</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-3.png" /></p>
<p>可以看到编译之后，一个 SSG 页面（实心圆）变成了三个文件：</p>
<ul>
<li>html 是用户拿到的静态页面</li>
<li>js 里面也含有静态内容，是快速导航（Link）需要用到的，因为快速导航实际上是使用 js + json 做的，而不是再去请求一次 html</li>
<li>json 是 getStaticProps 得到的数据，为了方便 js 接入不同的数据，因此 js 和 json 需要分开</li>
</ul>
<h4 id="根据路径创建静态页面">根据路径创建静态页面</h4>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/posts/[id].tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPost, getPostIds &#125; <span class="keyword">from</span> <span class="string">&quot;../../lib/posts&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticPaths</span>, <span class="title class_">GetStaticProps</span>, <span class="title class_">NextPage</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">post</span>: <span class="title class_">Post</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Params</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PostShow</span>: <span class="title class_">NextPage</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; post &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;post.content&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PostShow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明路由：用这个来穷举静态页面的不同路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticPaths</span>: <span class="title class_">GetStaticPaths</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> idList = <span class="keyword">await</span> <span class="title function_">getPostIds</span>()</span><br><span class="line">  <span class="keyword">const</span> paths = idList.<span class="title function_">map</span>(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">params</span>: &#123; id &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    paths,</span><br><span class="line">    <span class="comment">// false：当请求的 id 不再 path 里面，直接返回 404</span></span><br><span class="line">    <span class="comment">// true：若不存在，则依然渲染页面</span></span><br><span class="line">    <span class="attr">fallback</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 context 中的 params 拿到上一个函数穷举出的路径，也就是我们的 id，然后借由 id 去获取内容并生成静态文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticProps</span>: <span class="title class_">GetStaticProps</span>&lt;<span class="title class_">Props</span>, <span class="title class_">Params</span>&gt; = <span class="keyword">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> id = context.<span class="property">params</span>!.<span class="property">id</span></span><br><span class="line">  <span class="keyword">const</span> post = <span class="keyword">await</span> <span class="title function_">getPost</span>(id)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      post,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-5.png" /></p>
<p>可以看到生成来的文件中只有一个 JS，但是有两个 JSON 和两个 HTML 文件，这就是根据不同路由的到的不同页面和数据。</p>
<h3 id="服务端渲染ssr">服务端渲染（SSR）</h3>
<p>服务端渲染（Server Side Render）也是预渲染的一种，类似于 PHP、Python、Ruby、Java 后台的基本功能。 比如当需要通过不同的用户 id 等渲染不同的内容，这时候就较难提前做静态化，这个时候就可以使用 SSR，由服务端渲染好首屏，再下拉刷新。</p>
<p>时机：</p>
<ul>
<li>无论是在开发环境还是生产环境，都是每次请求来到之后运行的 优点：</li>
<li>能解决白屏问题</li>
<li>解决 SEO 问题</li>
<li>可以生成跟用户有关系的内容 缺点：</li>
<li>无法获取客户端信息，比如浏览器窗口大小等</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetServerSideProps</span>, <span class="title class_">NextPage</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IBrowser</span>, <span class="title class_">UAParser</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ua-parser-js&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">browser</span>: <span class="title class_">IBrowser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span>: <span class="title class_">NextPage</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; browser &#125; = props</span><br><span class="line">  <span class="keyword">const</span> [clientWidth, setClientWidth] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 如果想要获取浏览器窗口的大小，不能使用 SSR，只能使用客户端渲染，这样的写法保证了下面的代码只会在浏览器中运行，防止 node 报错</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setClientWidth</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你的浏览器是 &#123;browser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你的窗口宽度是 &#123;clientWidth&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次请求的时候才会执行</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getServerSideProps</span>: <span class="title class_">GetServerSideProps</span> = <span class="keyword">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// context 中有 req 和 res，一般只需要 req</span></span><br><span class="line">  <span class="keyword">const</span> ua = context.<span class="property">req</span>.<span class="property">headers</span>[<span class="string">&quot;user-agent&quot;</span>]</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">UAParser</span>(ua).<span class="title function_">getResult</span>()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">browser</span>: result.<span class="property">browser</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三种渲染应该如何选择">三种渲染应该如何选择</h3>
<ol type="1">
<li>有动态内容吗？</li>
</ol>
<ul>
<li>有，跳到 2</li>
<li>没有，直接写 HTML 即可</li>
</ul>
<ol start="2" type="1">
<li>跟客户端相关（比如获取窗口大小等）吗？</li>
</ol>
<ul>
<li>相关，BSR</li>
<li>无关，跳到 3</li>
</ul>
<ol start="3" type="1">
<li>我的响应跟用户或请求相关吗？</li>
</ol>
<ul>
<li>相关，SSR（getServerSideProps）或 BSR</li>
<li>无关，SSG（getStaticProps） 或 SSR 或 BSR</li>
</ul>
<h1 id="typeorm">TypeORM</h1>
<p>TypeORM 是一个 Node 中对 TypeScript 支持比较好的关系对象映射，支持关联、事务、数据库迁移，同类产品还有 Sequelize。 Mac 和 Linux 可以用 &amp; 同时执行两个命令，Windows 可以用 concurrently 这个 npm 库。</p>
<h2 id="启动-postgresql-数据库">启动 Postgresql 数据库</h2>
<p>在项目目录里面新增 <code>blog-data</code> 目录，并将其添加进 <code>.gitignore</code> 中。</p>
<p>然后启动 postgresql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v <span class="string">&quot;<span class="variable">$PWD</span>/blog-data&quot;</span>:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_USER=blog -e POSTGRES_HOST_AUTH_METHOD=trust -d postgres</span><br></pre></td></tr></table></figure>
<p>将上述命令的 <code>-e POSTGRES_HOST_AUTH_METHOD=trust</code> 替换成 <code>-e POSTGRES_PASSWORD=123456</code> 就可以设置密码</p>
<p>然后可以这样进入 postgresql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">id</span> bash</span><br><span class="line">psql -U username -W</span><br></pre></td></tr></table></figure>
<p>然后可以执行 psql 的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\l <span class="comment"># list databases</span></span><br><span class="line">\c <span class="comment"># connect to a databases</span></span><br><span class="line">\dt <span class="comment"># display tables</span></span><br></pre></td></tr></table></figure>
<h2 id="创建-database">创建 database</h2>
<p>由于 TypeORM 没有为我们提供单纯创建数据库的 API，我们需要进入数据库用 SQL 语句来进行创建：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> blog_production <span class="keyword">ENCODING</span> <span class="string">&#x27;UTF8&#x27;</span> LC_COLLATE <span class="string">&#x27;en_US.utf8&#x27;</span> LC_CTYPE <span class="string">&#x27;en_US.utf8&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>一般来说需要创建三个数据库：development、test、production</p>
<h2 id="安装-typeorm">安装 TypeORM</h2>
<p><a href="https://typeorm.io/#/">官方文档在这里</a>。</p>
<p>注意！当按照官方文档操作，运行命令 <code>typeorm init --database postgres</code> 之后，<code>.gitignore</code> 、 <code>package.json</code> 和 <code>tsconfig.json</code> 将会被更改，这时需要检查他的更改并酌情处理！</p>
<p>比如当我们在使用 Next 搭配 TypeORM 的时候，会遇到问题是 Next 使用 Babel 处理 TypeScript，而 TypeORM 则推荐使用 ts-node，这样就冲突了：</p>
<ol type="1">
<li>先从 <code>package.json</code> 中删除命令擅自添加的 <code>ts-node</code></li>
<li>再想办法运行 <code>src/index.ts</code></li>
</ol>
<h3 id="自行使用-babel-来进行编译然后再用-node-运行编译好的-js">自行使用 babel 来进行编译，然后再用 node 运行编译好的 js</h3>
<p>TypeORM 想要我们直接运行 <code>src/index.ts</code>，但是我们需要安装 <code>@babel/cli</code> 之后使用命令 <code>npx babel ./src --out-dir dist --extensions ".ts,.tsx"</code> 来运行。</p>
<p>这时可能会遇到报错 <code>Support for the experimental syntax 'decorators-legacy' isn't currently enabled</code>。</p>
<p>解决方案可以看<a href="https://stackoverflow.com/questions/52262084/syntax-error-support-for-the-experimental-syntax-decorators-legacy-isnt-cur">这篇文章</a>。 同时可以参考<a href="https://nextjs.org/docs/advanced-features/customizing-babel-config">next 文档</a>来配置 <code>.babelrc</code></p>
<p>然后我们就可以在 dist 里面找到编译好的 <code>index.js</code>，用 node 直接运行他，但是注意需要修改 <code>ormconfig.json</code> 里面的配置，尤其是这一部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;entities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;dist/entity/**/*.js&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="让-next-帮我们编译帮我们运行">让 Next 帮我们编译，帮我们运行</h3>
<p>我们可以将上面 TypeORM 生成的 <code>src/index.ts</code> 放到 <code>pages</code> 目录下，这样 Next 就会在 请求(开发)/打包(生产) 的时候帮我们编译并执行。同样需要注意修改 <code>ormconfig.json</code>。</p>
<h2 id="synchronize-功能">synchronize 功能</h2>
<p>同步功能可以在 <code>ormconfig.json</code> 里面的 <code>synchronize</code> 项进行配置。</p>
<p>如果打开 synchronize，每次 <code>createConnection</code> 的时候都会将 entity 里面的表同步到我们的数据库中，这样就很可能导致我们在修改 User 的时候把数据删掉，这在生产环境肯定是不允许的。因此我们可以在一开始就把这个功能给关掉。</p>
<h2 id="通过-migration-创建表">通过 migration 创建表</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:create -n CreatePost</span><br></pre></td></tr></table></figure>
<p>然后对其创建的 <code>/src/migration/[timestamp]-CreatePosts.ts</code> 进行修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MigrationInterface</span>, <span class="title class_">QueryRunner</span>, <span class="title class_">Table</span> &#125; <span class="keyword">from</span> <span class="string">&quot;typeorm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CreatePosts1620523637192</span> <span class="keyword">implements</span> <span class="title class_">MigrationInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> <span class="title function_">up</span>(<span class="attr">queryRunner</span>: <span class="title class_">QueryRunner</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 升级数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> queryRunner.<span class="title function_">createTable</span>(<span class="keyword">new</span> <span class="title class_">Table</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;posts&quot;</span>,</span><br><span class="line">      <span class="attr">columns</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;id&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;int&quot;</span>, <span class="attr">isPrimary</span>: <span class="literal">true</span>, <span class="attr">isGenerated</span>: <span class="literal">true</span>, <span class="attr">generationStrategy</span>: <span class="string">&quot;increment&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;title&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;varchar&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;content&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> <span class="title function_">down</span>(<span class="attr">queryRunner</span>: <span class="title class_">QueryRunner</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 降级数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> queryRunner.<span class="title function_">dropTable</span>(<span class="string">&quot;posts&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>然后同样的，我们需要将其编译成 js，然后配置 <code>ormconfig.json</code> 中的 <code>migrations</code> 路径，然后再执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:run</span><br></pre></td></tr></table></figure>
<p>他会执行 <code>up</code> 中的代码，于是就创建了一个表。</p>
<p>当发生错误需要撤销这次 migration 的时候，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:revert</span><br></pre></td></tr></table></figure>
<p>他会执行 <code>down</code> 中的代码，在这里就会删除这个表。</p>
<h2 id="将数据映射到实体从而操作他">将数据映射到实体从而操作他</h2>
<p>在数据库中创建一个表之后，如果想操作他，我们通常需要他映射到 实体(Entity) 上，可以通过这个命令达成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm entity:create -n Post</span><br></pre></td></tr></table></figure>
<p>需要将 Entity Post 对应上数据库里面的信息：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Column</span>, <span class="title class_">Entity</span>, <span class="title class_">PrimaryGeneratedColumn</span> &#125; <span class="keyword">from</span> <span class="string">&quot;typeorm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span>(<span class="string">&quot;posts&quot;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PrimaryGeneratedColumn</span>(<span class="string">&quot;increment&quot;</span>)</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(<span class="string">&quot;varchar&quot;</span>)</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <a href="https://typeorm.io/#/entity-manager-api">EntityManager</a> 和 <a href="https://typeorm.io/#/repository-api">Repository</a> 这两种使用实体的方式，他们只是封装思路不同而已。</p>
<h2 id="seed">Seed</h2>
<p>也叫数据填充，我们可以通过 seed 脚本来构造数据。</p>
<h2 id="创建数据表关联">创建数据表关联</h2>
<p>可以参考 <a href="https://typeorm.io/#/relations">这篇文档</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">//... 其他字段</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span>(<span class="function"><span class="params">type</span> =&gt;</span> <span class="title class_">Post</span>, <span class="function"><span class="params">post</span> =&gt;</span> post.<span class="property">author</span>)</span><br><span class="line">  <span class="attr">posts</span>: <span class="title class_">Post</span>[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>Rails</title>
    <url>/hais-notebook/2023/01/16/Rails/</url>
    <content><![CDATA[<p>Rails 的一个项目是如何搭建起来的。</p>
<span id="more"></span>
<h1 id="gem-和-bundle">Gem 和 Bundle</h1>
<p>类似于 npm，gem 用于全局安装依赖，bundle 用于局部安装依赖。</p>
<p>如果 <code>gem install</code> 安装很慢，按照 <a href="https://gems.ruby-china.com/">RubyChina</a> 的方法进行操作。</p>
<h1 id="development">Development</h1>
<h2 id="创建-rails-项目">创建 Rails 项目</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install rails</span><br><span class="line">rails new [ProjectName] --database=postgresql --skip-action-mailbox --skip-action-text --skip-sprockets --skip-javascript --skip-turbolinks --skip-system-test --skip-test --api --skip-webpack-install</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>bin/rails server</code> 命令启动服务器，但是这时会报错，因为我们还没有数据库。</p>
<h2 id="创建-docker-容器">创建 docker 容器</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v [容器路径]:/var/lib/postgresql/data -p 5001:5432 -e POSTGRES_USER=[用户名] -e POSTGRES_PASSWORD=[密码] -d postgres:[版本号 也可以不指定]</span><br></pre></td></tr></table></figure>
<p>如果速度太慢，需要使用镜像，按照 <a href="http://guide.daocloud.io/dcs/daocloud-9153151.html">此教程</a> 进行配置。 可将镜像地址配置为中科大镜像地址：https://docker.mirrors.ustc.edu.cn</p>
<h3 id="其他的-docker-命令">其他的 docker 命令</h3>
<ul>
<li><code>docker ps -a</code> 查看所有的容器（Containers）</li>
<li><code>docker kill &lt;id|name&gt;</code> 关闭对应的容器</li>
<li><code>docker restart &lt;id|name&gt;</code> 重启关闭的容器</li>
<li><code>docker rm &lt;id|name&gt;</code> 删除对应的容器</li>
<li><code>docker container prune</code> 删除无用的容器，以节省空间</li>
</ul>
<h2 id="准备数据库">准备数据库</h2>
<h3 id="配置数据库">配置数据库</h3>
<p>数据库需要在 <code>config/database.yml</code> 中进行配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span> <span class="string">&amp;default</span> <span class="comment"># 默认公共配置</span></span><br><span class="line">  <span class="attr">adapter:</span> <span class="string">postgresql</span></span><br><span class="line">  <span class="attr">encoding:</span> <span class="string">unicode</span></span><br><span class="line">  <span class="attr">pool:</span> &lt;%=<span class="language-ruby"> ENV.fetch(<span class="string">&quot;RAILS_MAX_THREADS&quot;</span>) &#123; <span class="number">5</span> &#125; </span>%&gt;</span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">username:</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">xxx_development</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">xxx_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">morney_rails_1_production</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">morney_rails_1</span></span><br><span class="line">  <span class="attr">password:</span> &lt;%=<span class="language-ruby"> ENV[<span class="string">&#x27;MORNEY_RAILS_1_DATABASE_PASSWORD&#x27;</span>] </span>%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建数据库">创建数据库</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rials db:create</span><br></pre></td></tr></table></figure>
<h3 id="查看数据库">查看数据库</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入虚拟机并运行 bash：</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名&gt; bash</span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">psql -U &lt;用户名&gt;</span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">\c &lt;数据库名称&gt;</span><br><span class="line"><span class="comment"># display tables</span></span><br><span class="line">\dt</span><br><span class="line"><span class="comment"># 查看某一个表的内容</span></span><br><span class="line">select * from &lt;表名称&gt; <span class="built_in">limit</span> 10;</span><br></pre></td></tr></table></figure>
<h2 id="hello-rails">Hello Rails</h2>
<h3 id="routes">Routes</h3>
<p>路由需要在 <code>config/routes.rb</code> 中进行配置。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  get <span class="string">&#x27;/hello&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;first#hello&#x27;</span> <span class="comment"># get 请求路径 /hello 的时候，会去找 FirstController 上的 hello 方法 </span></span><br><span class="line">  get <span class="string">&#x27;/hi&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;first#hi&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>bin/rails routes</code> 命令查看所有的路由。</p>
<h3 id="controller">Controller</h3>
<h4 id="手动创建-controller">手动创建 controller</h4>
<p>controller 需要在 <code>app/controllers</code> 中进行配置。 比如如上面 routes 中的配置所说，我们需要一个 <code>app/controllers/first_controller.rb</code> 文件，里面有一个 <code>FirstController</code> class，其中对应有 <code>hello</code> 和 <code>hi</code> 方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承自 ApplicationController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="通过命令创建-controller">通过命令创建 controller</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller <span class="built_in">users</span></span><br></pre></td></tr></table></figure>
<h4 id="渲染-json">渲染 JSON</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">name:</span> <span class="string">&#x27;harvey&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="view">View</h3>
<h4 id="渲染-html">渲染 HTML</h4>
<p>一般前后端分离的情况下，不是由 rails 来渲染 HTML，当然 rails 也可以用于渲染 HTML，这时我们需要建立一个新的文件 <code>app/views/first/hello.html</code>，然后在 FirstController 中这样写：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    render <span class="string">&#x27;first/hello&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>注意，如果使用 API 模式，默认是不支持渲染 html 的，我们需要在 <code>app/controllersapplication_controller.rb</code> 中进行引入：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="keyword">include</span> ActionView::Layouts</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="layout">Layout</h4>
<p>erb 可以使用 <code>&lt;% %&gt;</code> 来包裹语句：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;% a = 5 %&gt;</span><br><span class="line">&lt;% if a &lt; 10 %&gt;</span><br><span class="line">  a 小于 10</span><br><span class="line">&lt;% end %&gt;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>&lt;%= %&gt;</code> 来表示需要渲染的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%= @dataInController %&gt;</span><br></pre></td></tr></table></figure>
<p>此外很多 html 有公共的部分，我们可以将其放在 <code>views/layoutsapplication.html.erb</code> 中，然后在其中空出类似插槽的东西：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前略 --&gt;</span></span><br><span class="line">&lt;%= yield %&gt;</span><br><span class="line"></span><br><span class="line">&lt;% if content_for? :footer %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    &lt;%= yield :footer %&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">&lt;% end %&gt;</span><br><span class="line"><span class="comment">&lt;!-- 后略 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>普通内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&lt;% content_for :footer do %&gt;</span><br><span class="line">  页脚内容</span><br><span class="line">&lt;% end %&gt;</span><br></pre></td></tr></table></figure>
<h2 id="注册功能">注册功能</h2>
<h3 id="第一步创建-model-与数据表">第一步：创建 Model 与数据表</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g model User</span><br><span class="line"><span class="comment"># 也可以像下面这样写，他会在数据库迁移脚本中多两个字段</span></span><br><span class="line">bin/rails g model User email:string password_digest:string</span><br></pre></td></tr></table></figure>
<p>执行此命令后，会创建一个数据库迁移脚本，和一个新文件 <code>app/model/user.rb</code>。</p>
<p>数据库迁移脚本形式如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUsers</span> &lt; ActiveRecord::Migration[6.1]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span></span></span><br><span class="line">    create_table <span class="symbol">:users</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">      t.string <span class="symbol">:email</span></span><br><span class="line">      t.string <span class="symbol">:password_digest</span></span><br><span class="line"></span><br><span class="line">      t.timestamps</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后需要运行迁移脚本，创建 User 表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails db:migrate</span><br></pre></td></tr></table></figure>
<p>然后可以在 rubyMine 中查看数据库、User 表。</p>
<h3 id="第二步配置路由">第二步：配置路由</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  get <span class="string">&#x27;/users&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;users#index&#x27;</span></span><br><span class="line">  get <span class="string">&#x27;/users/:id&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;users#show&#x27;</span></span><br><span class="line">  post <span class="string">&#x27;/users&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;users#create&#x27;</span></span><br><span class="line">  delete <span class="string">&#x27;/users/:id&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;users#destroy&#x27;</span></span><br><span class="line">  patch <span class="string">&#x27;/users/:id&#x27;</span>, <span class="symbol">to:</span> <span class="string">&#x27;users#update&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>简单的增删改查我们不需要配置如上的路由，只需要下面这一句，他就会帮我们自动创建路由：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">resources <span class="symbol">:users</span></span><br></pre></td></tr></table></figure>
<h3 id="第三步在-rails-console-中尝试进行增删改查">第三步：在 Rails Console 中尝试进行增删改查</h3>
<p>可以在 Rails Console 中先体验一下增删改查是如何进行的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails console</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u = User.new</span><br><span class="line">u.email = <span class="string">&#x27;1@qq.com&#x27;</span></span><br><span class="line">u.password_digest = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">u.save</span><br></pre></td></tr></table></figure>
<p>就会自动执行一个 SQL 语句，<strong>创建</strong> 一个新用户。</p>
<p>可以通过 <code>User.first</code> <code>User.second</code> 来 <strong>查看</strong> 已有的用户。</p>
<p>输入 <code>exit</code> 或者按 <code>Ctrl</code>+<code>D</code> 可以退出 Rails Console。</p>
<h3 id="第四步存储密码">第四步：存储密码</h3>
<p>我们平时的 User 表中不会存储密码的明文，而是存储一个 <code>password_digest</code> 字段，这可以通过 has_secure_password 来实现。</p>
<p>放开 <code>Gemfile</code> 中 <code>bcrypt</code> 的注释，通过 <code>bundle install</code> 安装依赖。</p>
<p>然后需要在 <code>app/modles/user.rb</code> 中加上 <code>has_secure_password</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_secure_password</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这时在 Rails Console 中执行以下代码试试：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u = User.new</span><br><span class="line">u.email = <span class="string">&#x27;1@qq.com&#x27;</span></span><br><span class="line">u.password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">u.password_confirmation = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">u.save</span><br></pre></td></tr></table></figure>
<p>这样就会自动在表中 <code>password_digest</code> 中存一段密文。</p>
<p>然后可以通过这样来比对用户的密码是否正确：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u.authenticate(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第五步创建与配置-controller">第五步：创建与配置 Controller</h3>
<p>我们可以通过如下命令创建 Controller，得到 <code>app/controllers/users_controller.rb</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller <span class="built_in">users</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    user = User.new create_params</span><br><span class="line">    user.save</span><br><span class="line">    <span class="comment"># new + save 可以简写为 User.create</span></span><br><span class="line">    render_resource user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_params</span></span></span><br><span class="line">    params.permit(<span class="symbol">:email</span>, <span class="symbol">:password</span>, <span class="symbol">:password_confirmation</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">render_resource</span><span class="params">(resource)</span></span></span><br><span class="line">    <span class="comment"># 也可以用 resource.valid?，不过据说会触发重新校验</span></span><br><span class="line">    <span class="keyword">if</span> resource.errors.empty?</span><br><span class="line">      render <span class="symbol">json:</span> &#123; <span class="symbol">resource:</span> resource &#125;, <span class="symbol">status:</span> <span class="number">200</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      render <span class="symbol">json:</span> &#123; <span class="symbol">errors:</span> resource.errors &#125;, <span class="symbol">status:</span> <span class="number">400</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="模拟请求进行调试">模拟请求进行调试</h4>
<h5 id="使用-rubymine-中的-http-client">使用 RubyMine 中的 HTTP Client</h5>
<p><code>Double Shift</code> - <code>HTTP Client</code>，然后可以通过 examples 看看如何使用。</p>
<h5 id="使用-postman-测试">使用 Postman 测试</h5>
<h3 id="第六步在-model-中进行数据校验">第六步：在 Model 中进行数据校验</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_secure_password</span><br><span class="line"></span><br><span class="line">  validates_presence_of <span class="symbol">:email</span> <span class="comment"># email 必须存在</span></span><br><span class="line">  validates_presence_of <span class="symbol">:password</span> <span class="comment"># password 必须存在</span></span><br><span class="line">  validates_presence_of <span class="symbol">:password_confirmation</span>, <span class="symbol">on:</span> [<span class="symbol">:create</span>] <span class="comment"># 在创建时，确认输入密码必须存在</span></span><br><span class="line"></span><br><span class="line">  validates_format_of <span class="symbol">:email</span>, <span class="symbol">with:</span> /.+@.+<span class="regexp">/, if: :email # 在 email 存在时校验邮箱格式</span></span><br><span class="line"><span class="regexp">  validates_length_of :password, minimum: 6, on: [:create], if: :password # 在创建时，校验密码格式</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第七步错误信息汉化">第七步：错误信息汉化</h3>
<p>首先需要在 <code>config/initializers/local.rb</code> 中添加：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">I18n.available_locales = [<span class="symbol">:en</span>, <span class="string">&#x27;zh-CN&#x27;</span>]</span><br><span class="line">I18n.default_locale = <span class="string">&#x27;zh-CN&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后按照提示在 <code>config/locales/zh-CN.yml</code> 中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zh-CN:</span></span><br><span class="line">  <span class="attr">activerecord:</span></span><br><span class="line">    <span class="attr">errors:</span></span><br><span class="line">      <span class="attr">models:</span></span><br><span class="line">        <span class="attr">user:</span></span><br><span class="line">          <span class="attr">attributes:</span></span><br><span class="line">            <span class="attr">password:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">密码不能为空</span></span><br><span class="line">              <span class="attr">too_short:</span> <span class="string">密码不能少于6个字符</span></span><br><span class="line">            <span class="attr">email:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">邮箱不能为空</span></span><br><span class="line">              <span class="attr">invalid:</span> <span class="string">邮箱必须含有</span> <span class="string">@</span> <span class="string">字符</span></span><br><span class="line">            <span class="attr">password_confirmation:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">请添加确认密码</span></span><br><span class="line">              <span class="attr">confirmation:</span> <span class="string">两次密码不匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="第八步发送邮件">第八步：发送邮件</h3>
<p>可以通过 <code>mailer</code> 来发送邮件，点击 <a href="https://ruby-china.github.io/rails-guides/action_mailer_basics.html">这里查看官方文档</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails generate mailer UserMailer</span><br></pre></td></tr></table></figure>
<p>这个命令会创建文件 <code>app/mailers/user_mailer</code>，详细请看 <a href="https://github.com/Hyuain/ruby-demo/commits/master">相关 commit</a></p>
<p>通过 <code>dotenv-rails</code> 和 <code>.env</code> <code>.env.local</code> 文件来抽出环境变量，注意 <code>.env.local</code> 需要被加入 <code>.gitignore</code> 中，防止将密码提交到 Git 记录中。</p>
<h2 id="登录功能">登录功能</h2>
<h3 id="第一步配置路由">第一步：配置路由</h3>
<p>按照惯例我们需要先配置路由：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  resources <span class="symbol">:sessions</span>, <span class="symbol">only:</span> %i[create destroy]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第二步创建-model">第二步：创建 Model</h3>
<p>Session 不需要写入数据库，故而不需要创建一个完整的 Model（继承于 ActiveRecord），而是一个轻量的 Model（继承于/include ActiveModel）。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:email</span>, <span class="symbol">:password</span></span><br><span class="line"></span><br><span class="line">  validates <span class="symbol">:email</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line">  validates <span class="symbol">:password</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  validates_format_of <span class="symbol">:email</span>, <span class="symbol">with:</span> /.+@.+<span class="regexp">/, if: :email</span></span><br><span class="line"><span class="regexp">  validates_length_of :password, minimum: 6, if: :password</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure>
<h4 id="attr_accessor">attr_accessor</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:xxx</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>会声明一个对象的属性：<code>@xxx</code></li>
<li>会定义一个方法：<code>xxx</code>，用于获取 <code>@xxx</code> 的值</li>
<li>会定义一个方法：<code>xxx=</code>，用于给 <code>@xxx</code> 赋值</li>
</ol>
<h3 id="第三步创建-controller">第三步：创建 Controller</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller sessions</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    s = Session.new create_params</span><br><span class="line">    s.validate</span><br><span class="line">    render_resource s</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">destroy</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_params</span></span></span><br><span class="line">    params.permit(<span class="symbol">:email</span>, <span class="symbol">:password</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第四步自定义校验校验账号密码">第四步：自定义校验，校验账号密码</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:email</span>, <span class="symbol">:password</span>, <span class="symbol">:email</span></span><br><span class="line"></span><br><span class="line">  validate <span class="symbol">:check_email</span>, <span class="symbol">if:</span> <span class="symbol">:email</span></span><br><span class="line">  validate <span class="symbol">:check_email_password_matched</span>, <span class="symbol">if:</span> Proc.new&#123; <span class="params">|s|</span> s.email.present? <span class="keyword">and</span> s.password.present? &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_email</span></span></span><br><span class="line">    <span class="variable">@user</span> <span class="params">||</span>= User.find_by <span class="symbol">email:</span> email</span><br><span class="line">    <span class="keyword">if</span> user.<span class="literal">nil</span>?</span><br><span class="line">      errors.add <span class="symbol">:email</span>, <span class="symbol">:unregistered</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_email_password_matched</span></span></span><br><span class="line">    <span class="variable">@user</span> <span class="params">||</span>= User.find_by <span class="symbol">email:</span> email</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">and</span> !user.authenticate(password)</span><br><span class="line">      errors.add <span class="symbol">:password</span>, <span class="symbol">:mismatch</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第五步使用中间件记录-sessioncookie">第五步：使用中间件，记录 session（cookie）</h3>
<p><code>config/application.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.session_store <span class="symbol">:cookie_store</span>, <span class="symbol">key:</span> <span class="string">&#x27;rails_demo_session_id&#x27;</span></span><br><span class="line">config.middleware.use ActionDispatch::Cookies</span><br><span class="line">config.middleware.use config.session_store, config.session_options</span><br></pre></td></tr></table></figure>
<p><code>session_controller.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    s = Session.new create_params</span><br><span class="line">    s.validate</span><br><span class="line">    render_resource s</span><br><span class="line">    session[<span class="symbol">:current_user_id</span>] = s.user.id <span class="comment"># 将 id 记录起来</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样前端在发送请求之后将会得到一个 cookie，RubyMine 可以在 <code>http-client.cookies</code> 中查看</p>
<h3 id="第六步获取当前用户的信息">第六步：获取当前用户的信息</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_user</span></span></span><br><span class="line">  <span class="comment"># 如果找不到，会返回 nil，ruby 这样会默认返回 current_user</span></span><br><span class="line">  <span class="variable">@current_user</span> <span class="params">||</span>= User.find_by_id session[<span class="symbol">:current_user_id</span>]</span><br><span class="line">  <span class="comment"># 如果找不到，会报错</span></span><br><span class="line">  <span class="comment"># User.find user_id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第七步注销登录">第七步：注销登录</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">destroy</span></span></span><br><span class="line">    session[<span class="symbol">:current_user_id</span>] = <span class="literal">nil</span></span><br><span class="line">    head <span class="symbol">:ok</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>将 session 中对应 id 的值删掉即可。</p>
<h3 id="单元测试">单元测试</h3>
<p>使用 RSpec 进行单元测试，详情查看 <a href="https://github.com/rspec/rspec-rails">RSpec For Rails 文档</a>。</p>
<p>详细请看 <a href="https://github.com/Hyuain/ruby-demo/commits/master">相关 commit</a></p>
<ul>
<li>Model 需要测试：validation 和 public 方法</li>
<li>Controller 需要测试：响应体和响应头（status、body、cookie），一般要测试正反两种情况（成功和不成功）</li>
</ul>
<h3 id="自动生成文档">自动生成文档</h3>
<p>使用 <code>rspec_api_documentation</code> 可以直接通过单元测试生成 API 文档，详细内容可以 <a href="https://github.com/zipmark/rspec_api_documentation">查看这里</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rake docs:generate</span><br><span class="line">start doc/api/index.html</span><br></pre></td></tr></table></figure>
<h3 id="其他技巧">其他技巧</h3>
<ol type="1">
<li>可以在 <code>rspec_helper.rb</code> 中定义一些常用的工具函数</li>
<li>可以使用 <code>rspec_api_documentation</code> 直接生成 API 文档</li>
</ol>
<h2 id="后端分页">后端分页</h2>
<p>使用 <code>kaminari</code> gem</p>
<h2 id="使用中间表关联两个表">使用中间表关联两个表</h2>
<p>比如我们需要建立 tagging 来关联 record 和 tag</p>
<h3 id="创建-model">创建 Model</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g model tagging</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateTaggings</span> &lt; ActiveRecord::Migration[6.1]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span></span></span><br><span class="line">    create_table <span class="symbol">:taggings</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">      t.references <span class="symbol">:tag</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">      t.references <span class="symbol">:record</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      t.timestamps</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于我们加了 <code>reference</code>，可以看到在 <code>schema.rb</code> 中多了一些东西：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">create_table <span class="string">&quot;taggings&quot;</span>, <span class="symbol">force:</span> <span class="symbol">:cascade</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">  t.bigint <span class="string">&quot;tag_id&quot;</span>, <span class="symbol">null:</span> <span class="literal">false</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.bigint <span class="string">&quot;record_id&quot;</span>, <span class="symbol">null:</span> <span class="literal">false</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.datetime <span class="string">&quot;created_at&quot;</span>, <span class="symbol">precision:</span> <span class="number">6</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  t.datetime <span class="string">&quot;updated_at&quot;</span>, <span class="symbol">precision:</span> <span class="number">6</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  t.index [<span class="string">&quot;record_id&quot;</span>], <span class="symbol">name:</span> <span class="string">&quot;index_taggings_on_record_id&quot;</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.index [<span class="string">&quot;tag_id&quot;</span>], <span class="symbol">name:</span> <span class="string">&quot;index_taggings_on_tag_id&quot;</span> <span class="comment"># 多了这一行</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后需要调整 <code>model/tagging.rb</code> <code>model/record.rb</code> <code>model/tag.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tagging</span> &lt; ApplicationRecord</span></span><br><span class="line">  belongs_to <span class="symbol">:record</span></span><br><span class="line">  belongs_to <span class="symbol">:tag</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:taggings</span></span><br><span class="line">  has_many <span class="symbol">:records</span>, <span class="symbol">through:</span> <span class="symbol">:taggings</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:taggings</span></span><br><span class="line">  has_many <span class="symbol">:tags</span>, <span class="symbol">through:</span> <span class="symbol">:taggings</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-factory-bot-加速测试">使用 Factory Bot 加速测试</h2>
<p>可以使用 <a href="https://github.com/thoughtbot/factory_bot">factory-bot</a> 来帮助我们自动化一些流程，比如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spec/factories/user_factory.rb</span></span><br><span class="line">FactoryBot.define <span class="keyword">do</span></span><br><span class="line">  factory <span class="symbol">:user</span> <span class="keyword">do</span></span><br><span class="line">    email &#123; <span class="string">&quot;test_email@qq.com&quot;</span> &#125;</span><br><span class="line">    password &#123; <span class="string">&quot;123456&quot;</span> &#125;</span><br><span class="line">    password_confirmation &#123; <span class="string">&quot;123456&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spec/requests/record.rb</span></span><br><span class="line">user = create(<span class="symbol">:user</span>)</span><br></pre></td></tr></table></figure>
<h1 id="deployment">Deployment</h1>
<h2 id="购买并登录阿里云服务器">购买并登录阿里云服务器</h2>
<ol type="1">
<li>去阿里云选择 ECS 服务器，购买一个。登录凭证选择使用密钥对。</li>
<li>使用 <code>ssh root@公网ip</code> 登录到机器上</li>
<li>公网 IP 很难记，建议记到 hosts 文件里</li>
</ol>
<h2 id="创建低权限用户">创建低权限用户</h2>
<ol type="1">
<li>进入 root 用户</li>
<li>安装 git：<code>apt update; apt install git -y</code></li>
<li>创建 harvey 用户：<code>adduser harvey</code>，密码为 <code>123456</code></li>
<li>让 harvey 用户也能 ssh 登录</li>
<li><code>mkdir -p /home/harvey/.ssh</code></li>
<li><code>cp ~/.ssh/authorized_keys /home/harvey/.ssh/</code></li>
<li><code>chown -R harvey:harvey /home/harvey/.ssh</code></li>
<li>退出 root（使用 <code>exit</code> 或 <code>ctrl + D</code>）</li>
<li>现在就可以使用 <code>ssh root@harvey</code> 登录 harvey 用户了</li>
</ol>
<h2 id="安装-docker">安装 Docker</h2>
<ol type="1">
<li>进入 root 用户</li>
<li>根据 <a href="https://www.runoob.com/docker/ubuntu-docker-install.html">菜鸟教程</a> 来安装 Docker</li>
<li>将 harvey 添加到 docker 用户组：<code>usermod -aG docker harvey</code>，这样 harvey 才能运行 docker 命令</li>
<li>运行 <code>docker run hello-world</code></li>
<li>如果 <code>docker run hello-wrold</code> 运行很慢，可以参考 <a href="https://developer.aliyun.com/article/29941">这篇文章</a> ，在 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">这里</a> 配置镜像加速器。</li>
</ol>
<h2 id="用-docker-启动数据库">用 Docker 启动数据库</h2>
<ol type="1">
<li>进入 harvey 用户</li>
<li>创建数据库目录 <code>mkdir /home/harvey/data</code></li>
<li>开启数据库 <code>docker run --net=host -v /home/harvey/data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_USER=harvey -e POSTGRES_PASSWORD=123456 --name psql1 -d postgres</code></li>
<li>注意如果 <code>-net=host</code> 没有写的话会导致两个容器网不通</li>
<li>此处用了端口 5432 而不是 5001，因为 <code>-net=host</code> 不支持 <code>5001:5432</code></li>
<li>测试数据库</li>
<li><code>docker exec -t psql1 bash</code> 进入容器</li>
<li><code>psql -U harvey</code></li>
<li><code>\l</code> 列出所有可用数据库</li>
</ol>
<h2 id="测试-ruby-容器">测试 Ruby 容器</h2>
<ol type="1">
<li>进入 harvey 用户</li>
<li>创建测试文件 <code>echo "p 'Hi, I am Harvey'" &gt; test.rb</code></li>
<li>使用 ruby 容器运行测试文件：<code>docker run -it --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp ruby ruby test.rb</code></li>
<li>看到 <code>Hi, I am Harvey</code> 就说明测试成功了，然后用 <code>rm test.rb</code> 删除测试代码</li>
</ol>
<h2 id="本地构建-rails-镜像">本地构建 Rails 镜像</h2>
<ol type="1">
<li>创建 <code>Dockerfile</code>： <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从哪里下载镜像，可以指定目录</span></span><br><span class="line"><span class="keyword">FROM</span> ruby</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br><span class="line"><span class="comment"># 把源代码拷贝到这个镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Gemfile .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Gemfile.lock .</span></span><br><span class="line"><span class="comment"># 在镜像中运行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> gem install bundler</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bundle install</span></span><br><span class="line"><span class="comment"># 将所有的文件都拷贝到这个镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 更新 bin 目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bundle <span class="built_in">exec</span> rake app:update:bin</span></span><br><span class="line"><span class="comment"># 暴露 3000 短开口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 入口命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;bin/rails&quot;</span>, <span class="string">&quot;server&quot;</span>, <span class="string">&quot;-b&quot;</span>,<span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;-p&quot;</span>,<span class="string">&quot;3000&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>将 <code>config/database.yml</code> 复制到 <code>config/database.sample.yml</code>，再把原来的 <code>config/database.yml</code> ignore 掉</li>
<li><code>docker build -t harvey/rails-demo:0.1 .</code>，得到镜像 <code>harvey/rails-demo</code> 版本为 0.1</li>
<li>运行刚刚得到的镜像：<code>docker run --net=host -p 3000:3000 harvey/rails-demo:0.1</code></li>
</ol>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>React</title>
    <url>/hais-notebook/2020/02/02/React/</url>
    <content><![CDATA[<p>.</p>
<span id="more"></span>
<h1 id="startup">Startup</h1>
<h2 id="引入-react">引入 React</h2>
<h3 id="cdn-引入">CDN 引入</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/react/16.10.2/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>cjs 和 umd 的区别？ - cjs 全称是 CommonJS，是 Node.js 支持的模块规范 - umd 是统一模块定义，兼容各种模块规范（包含浏览器） - 理论上优先使用 umd，同时支持 Node.js 和浏览器 - 最新的模块规范是使用 <code>import</code> 和 <code>export</code> 关键字</p>
<h3 id="通过-webpack-引入">通过 webpack 引入</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-create-react-app">使用 create-react-app</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app</span><br></pre></td></tr></table></figure>
<h2 id="函数与普通代码的区别">函数与普通代码的区别</h2>
<p>看 <a href="https://codesandbox.io/s/spring-waterfall-iyekc">这个例子</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">React</span> = <span class="variable language_">window</span>.<span class="property">React</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactDOM</span> = <span class="variable language_">window</span>.<span class="property">ReactDOM</span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">className</span>: <span class="string">&quot;red&quot;</span> &#125;, [</span><br><span class="line">    n,</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">      <span class="string">&quot;button&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          n += <span class="number">1</span>;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">          <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">App</span>(), root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;+1&quot;</span></span><br><span class="line">    )</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 App 不是函数，就不会更新</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">App</span>(), root);</span><br></pre></td></tr></table></figure>
<ul>
<li>普通代码<strong>立即求值</strong>，读取当前值</li>
<li>函数会等调用的时候再求值（<strong>延迟求值</strong>），求值时才会读取 <code>a</code> 的最新值</li>
</ul>
<h2 id="react-元素和函数组件的区别">React <strong>元素</strong>和<strong>函数组件</strong>的区别</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App1</span> = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, n) <span class="comment">// App1 是一个 React 元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App2</span> = (<span class="params"></span>) =&gt; <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, n) <span class="comment">// App2 是一个 React 函数组件</span></span><br><span class="line"><span class="comment">// App2 是延迟执行的代码，会在被调用的时候执行（会获取到 n 的最新值）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>React 元素
<ul>
<li><code>createElement</code> 的返回值 <code>element</code> 可以代表一个 <code>div</code></li>
<li>但是 <code>element</code> 不是真正的 DOM 对象，而是一个 <strong>虚拟 DOM</strong> 对象</li>
</ul></li>
<li>() ⇒ React 元素
<ul>
<li>返回 <code>element</code> 的函数，也可以代表一个 <code>div</code></li>
<li>函数可以多次执行，每次获取到最新的虚拟 <code>div</code></li>
<li>React 会对比两个虚拟 <code>div</code> ，找出不同，局部更新视图</li>
<li>找不同的算法叫做 <strong>DOM Diff 算法</strong></li>
</ul></li>
</ul>
<h1 id="jsx">JSX</h1>
<h2 id="引入-babel-loader">引入 babel-loader</h2>
<ul>
<li>CDN 引入：<code>&lt;script type="text/babel"&gt;&lt;/script&gt;</code></li>
<li>webpack 引入：babel-loader</li>
<li>create-react-app</li>
</ul>
<h2 id="jsx-语法">JSX 语法</h2>
<h3 id="嵌入表达式">嵌入表达式</h3>
<p>可以在大括号中使用任何合法的 JavaScript 表达式。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Josh Perez&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatName</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + user.<span class="property">lastName</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Harper&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Perez&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, &#123;formatName(user)&#125;!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>使用小括号将多行的 JSX 包裹起来，避免 JS 自动加分号的缺陷</p>
</div>
<h3 id="jsx-也是一个表达式">JSX 也是一个表达式</h3>
<p>可以返回在 <code>if</code> 语句和 <code>for</code> 循环中使用，可以传参给变量，可以作为参数接收，可以作为返回值</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeting</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定属性">指定属性</h3>
<p>注意如果要使用大括号包裹 JS 表达式，别在大括号外面写引号</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>注意 <code>class</code> 变成了 <code>className</code>、<code>tabindex</code> 变成了 <code>tabIndex</code> 等</p>
</div>
<h3 id="指定子元素">指定子元素</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Good to see you here.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="jsx-阻止-xss">JSX 阻止 XSS</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.<span class="property">potentiallyMaliciousInput</span>;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="jsx-代表了什么">JSX 代表了什么</h3>
<p>下面两个表达方式是一样的：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="component">Component</h1>
<h2 id="元素element与组件component">元素（Element）与组件（Component）</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>,...) <span class="comment">// React 元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Div</span> = (<span class="params"></span>) =&gt; <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>,...) <span class="comment">// React 组件</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>目前而言，</p>
<p>React 中，一个返回 React 元素的 <strong>函数</strong> 就是组件</p>
<p>Vue 中，一个 <strong>构造选项</strong> 就可以表示一个组件</p>
</div>
<h2 id="两种组件">两种组件</h2>
<ul>
<li>函数组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">// 会自动变成 React.createElement(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者的使用方法都是：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Welcome</span> name=<span class="string">&quot;frank&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>可以看看 <a href="https://codesandbox.io/s/tender-nightingale-eu1ne">这个例子</a></p>
<h2 id="react-中的标签会被翻译成什么">React 中的标签会被翻译成什么？</h2>
<p><code>&lt;div/&gt;</code> 会被翻译成 <code>React.createElement('div')</code></p>
<p><code>&lt;Welcome/&gt;</code> 会被翻译成 <code>React.createElement(Welcome)</code></p>
<h3 id="react.createlement"><code>React.creatElement</code></h3>
<ul>
<li>如果传入一个字符串 <code>'div'</code> ，则会创建一个 <code>div</code></li>
<li>如果传入一个函数，则会调用该函数，获取其返回值</li>
<li>如果传入一个类，则会在前面加类前面加 <code>new</code> （执行 constructor），获取一个组件的对象，然后调用对象的 render 方法，获取其返回值</li>
</ul>
<h2 id="类组件">类组件</h2>
<h3 id="创建类组件">创建类组件</h3>
<p>有两种方式创建类组件：</p>
<ul>
<li>ES 5 方式（过时）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> A</span><br></pre></td></tr></table></figure>
<ul>
<li>ES 6 方式（使用 class）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其实如果不在 constructor 里面加其他的东西，上面几行是可以省略掉的</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> B</span><br></pre></td></tr></table></figure>
<h3 id="props">Props</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">name</span>: <span class="string">&#x27;harvey&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">             <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">      <span class="comment">// 外部数据会被包装为一个对象：</span></span><br><span class="line">      <span class="comment">// &#123;name: &#x27;harvey&#x27;, onClick:..., children: &#x27;hi&#x27;&#125; </span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props) <span class="comment">// 这样会将 props 放到 this 上，这就是 props 的初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这样读取 props</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.name&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>不允许修改 Props</p>
</div>
<h4 id="componentwillreceiveprops"><code>componentWillReceiveProps</code></h4>
<p>会在 Props 变化的时候调用，目前已经不用了，并更名为 <code>UNSAFE_componentWillReceiveProps</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps, nextContext</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="props-的作用">Props 的作用</h4>
<ul>
<li>接受外部的数据：只能读不能写</li>
<li>接受外部的函数：在恰当时机调用</li>
</ul>
<h3 id="state">State</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="comment">// 初始化 State</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改 State，注意 setState 不会立即修改 State，会在 set 成功之后调用 fn</span></span><br><span class="line">    <span class="comment">// 因此最后 this.state.x 不会 +2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> + <span class="number">1</span></span><br><span class="line">    &#125;, fn)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> + <span class="number">1</span></span><br><span class="line">    &#125;, fn)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二种写法，这种情况下 this.state.x 会 +2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">x</span>: prevState.<span class="property">x</span> + <span class="number">1</span></span><br><span class="line">    &#125;), fn)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">x</span>: prevState.<span class="property">x</span> + <span class="number">1</span></span><br><span class="line">    &#125;), fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 读取 State</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>&#123;this.state.x&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 state 的时候会进行 <strong>Shallow Merge</strong>，新旧 state 进行一级合并</p>
<h3 id="react-lifecycle">React Lifecycle</h3>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/React-LifeCycle.png" alt="React LifeCycle" /><figcaption aria-hidden="true">React LifeCycle</figcaption>
</figure>
<ul>
<li><strong><code>constructor(props)</code></strong>：用于初始化 state 和为事件处理函数绑定实例（<code>bind(this)</code>）</li>
<li><code>static getDerivedStateFromProps(props, state)</code>：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容</li>
<li><strong><code>shouldComponentUpdate()</code></strong>：判断 React 组件的输出是否受当前 state 或 props 更改的影响</li>
<li><strong><code>render()</code></strong>：当 state 或 props 发生变化时调用，可以通过 <code>shouldComponentUpdate</code> 调解调用时机</li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>：会在最近一次渲染输出之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）</li>
<li><strong><code>componentDidMount()</code></strong>：会在组件挂载后（插入 DOM 树中）立即调用</li>
<li><strong><code>componentDidUpdate(prevProps, prevState, snapshot)</code></strong>： 会在更新后会被立即调用。首次渲染不会执行此方法</li>
<li><strong><code>componentWillUnmount()</code></strong>：会在组件卸载及销毁之前直接调用</li>
<li><code>static getDerivedStateFromError(error)</code>：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</li>
<li><code>componentDidCatch(error, info)</code>：此生命周期在后代组件抛出错误后被调用</li>
</ul>
<h4 id="constructor"><code>constructor</code></h4>
<h5 id="用途">用途</h5>
<ul>
<li>初始化 props</li>
<li>初始化 state，但此时不能调用 <code>setState</code></li>
<li>用来写 <code>bind this</code></li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onClick</span> = <span class="variable language_">this</span>.<span class="property">onClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用新语法代替</span></span><br></pre></td></tr></table></figure>
<h4 id="shouldcomponentupdate"><code>shouldComponentUpdate</code></h4>
<h5 id="用途-1">用途</h5>
<ul>
<li>返回 true 表示不阻止 UI 更新</li>
<li>返回 false 表示阻止 UI 更新</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(nextProps, nextState)</span><br></pre></td></tr></table></figure>
<h5 id="react.purecomponent"><code>React.PureComponent</code></h5>
<p>会在 <code>render</code> 之前对新旧 state 和 props 进行浅对比（只比较一层），来控制是否 <code>render</code>，只要有任何一个 key 的值不同，就会 <code>render</code></p>
<h4 id="render"><code>render</code></h4>
<p>用于展示视图，可以用 <code>&lt;React.Fragment&gt;</code> 将多个标签括起来</p>
<p>可以在 <code>render</code> 中写</p>
<ul>
<li>if / else</li>
<li>map</li>
</ul>
<h4 id="componentdidmount"><code>componentDidMount</code></h4>
<ul>
<li>在元素插入页面之后执行代码，这些代码通常依赖 DOM</li>
<li>同时官方推荐将加载数据的 AJAX 请求写在这里</li>
<li>首次渲染 <strong>会</strong> 执行这个钩子</li>
</ul>
<p>此外，推荐在使用 Ref 之前先赋值为一个 <code>undefined</code></p>
<h4 id="componentdidupdate"><code>componentDidUpdate</code></h4>
<ul>
<li>在视图更新后执行代码</li>
<li>此处也可以发起 AJAX 请求，通常是用于更新数据</li>
<li>首次渲染 <strong>不会</strong> 执行这个钩子</li>
<li>在这里 <code>setState</code> 可能会引起无限循环，除非用 <code>if</code> 进行限制</li>
<li><code>shouldComponentUpdate</code> 返回 <code>false</code> 时不会调用</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">compoentDidUpdate</span>(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure>
<h4 id="componentwillunmount"><code>componentWillUnmount</code></h4>
<ul>
<li>组件将要被移除页面并销毁时，执行代码</li>
<li>Unmount 过的组件不会再次 Mount</li>
<li>通常需要在这里取消监听、计时器、AJAX 请求等</li>
</ul>
<h2 id="函数组件">函数组件</h2>
<h3 id="创建函数组件">创建函数组件</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Hello1</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数缩写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Hello2</span> = props =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hello3</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数组件没有-state">函数组件没有 state</h3>
<p>使用 <code>useState</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [x, setX] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数组件没有生命周期">函数组件没有生命周期</h3>
<p>使用 <code>useEffect</code></p>
<ul>
<li>模拟 <code>componentDidMount</code>（第一次渲染）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟 <code>componentDidUpdate</code>（更新时执行）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [n])</span><br><span class="line"><span class="comment">// 这样的话第一次渲染也会执行，可以使用自定义 Hook 来解决</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useUpdate</span> = (<span class="params">fn, dep</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [updateCount, setUpdateCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setUpdateCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [dep])</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (updateCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [updateCount, fn])</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">useUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, n)</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟 <code>componentWillUnmount</code>（将要销毁时执行）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure>
<h1 id="props-1">Props</h1>
<p>可以查看 <a href="https://codesandbox.io/s/billowing-wind-d8kzw">CodeSandbox 上的这个例子</a>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      爸爸</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Son</span> <span class="attr">messageForSon</span>=<span class="string">&quot;儿子你好&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        我是儿子，爸爸对我说 &#123;this.props.messageForSon&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">messageForGrandson</span>=<span class="string">&#123;1</span> + <span class="attr">1</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Grandson</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Grandson&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我是孙子，爸爸对我说 &#123;props.messageForGrandson&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="state-1">State</h1>
<p>可以查看 <a href="https://codesandbox.io/s/silly-diffie-9yk38">CodeSandbox 上的这个例子</a>。</p>
<h2 id="类组件-1">类组件</h2>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">n</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">m</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.<span class="property">n</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 用函数写 setState，因为 setState 是异步的，他会等一会儿再改变 state,如果用函数就能很清楚的知道哪个是新的 n，哪个是旧的 n</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addM</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">m</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">m</span> + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="comment">// 类组件会自动合并第一层属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        儿子 n: &#123;this.state.n&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.addN()&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        m: &#123;this.state.m&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.addM()&#125;&gt;m+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Grandson</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数组件-1">函数组件</h2>
<p>使用 <code>useState</code>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Grandson</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 相当于</span></span><br><span class="line">  <span class="comment">// const array = React.useState(0)</span></span><br><span class="line">  <span class="comment">// const n = array[0]</span></span><br><span class="line">  <span class="comment">// const setN = array[1]</span></span><br><span class="line">  <span class="comment">// setN 会得到一个新的 n</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Grandson&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      孙子 n: &#123;n&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setN(n + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      m: &#123;m&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setM(m + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 函数组件的 setState 不会自动合并，建议分开写 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="usestate">useState</h3>
<div class="note warning"><p>注意与 class 组件的 setState 不同，他是 <strong>不能</strong> 只更新对象的某个部分的；</p>
<p>并且，如果对象修改前后的地址不变，则不会触发重新渲染，因此，最好使用函数</p>
</div>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="尝试自己实现一个-usestate">尝试自己实现一个 useState</h4>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state = []</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myUseState</span> = (<span class="params">initialValue</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> currentIndex = index</span><br><span class="line">  _state[currentIndex] = _state[currentIndex] === <span class="literal">undefined</span> ? initialValue : _state[currentIndex]</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = (<span class="params">newValue</span>) =&gt; &#123;</span><br><span class="line">    _state[currentIndex] = newValue</span><br><span class="line">    <span class="title function_">render</span>() <span class="comment">// 在这里做一个简化</span></span><br><span class="line">  &#125;</span><br><span class="line">  index ++</span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  index = <span class="number">0</span> <span class="comment">// 这句话很关键，每次渲染之后 index 变成 0</span></span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是使用数组来实现 state，导致其对顺序依赖非常大，Hook 在每次渲染中必须以 <strong>完全一样的顺序来调用</strong>，比如 React 中不允许使用这种代码：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">  [m, setM] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个函数组件对应一个 React 节点，每个节点将会保存 state（<code>memorizedState</code>） 和 index（链表）</p>
<h4 id="实现一个贯穿始终的状态">实现一个贯穿始终的状态</h4>
<p>使用 useState 的话每次重新渲染会产生不同的 state，如果非要实现一个贯穿始终状态，除了使用全局变量 <code>window</code> 以外，还有这两种方法：</p>
<h5 id="使用-useref">使用 useRef</h5>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="number">0</span>) <span class="comment">// &#123;current: 0&#125;</span></span><br><span class="line"><span class="comment">// 之后使用 nRef.current</span></span><br></pre></td></tr></table></figure>
<p>但是修改 <code>nRef.current</code> 不会让组件重新渲染，因此页面上的数据不会同步改变（但是 Vue 3 可以）</p>
<p>可以像这样手动让他更新：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 这样修改 nRef.current</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  nRef.<span class="property">current</span> += <span class="number">1</span></span><br><span class="line">  <span class="title function_">update</span>(nRef.<span class="property">current</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="使用-usecontext">使用 useContext</h5>
<p>详见 Context 部分</p>
<h2 id="setstate-的注意事项">setState 的注意事项</h2>
<ul>
<li><code>this.state.n += 1</code> 无效，UI 不会自动更新，需要用 <code>setState</code></li>
<li><code>setState</code> 不会马上改变 <code>state</code>，是异步更新的，推荐使用 <code>setState(函数)</code></li>
<li>不推荐 <code>this.setState(this.state)</code>，因为 React 不推荐我们修改旧的 <code>state</code>（不可变数据）</li>
</ul>
<h3 id="复杂-state">复杂 state</h3>
<ul>
<li>类组件的 <code>setState</code> 会自动合并第一层，建议使用 <code>Object.assign</code> 或者 <code>...sate</code></li>
<li>函数组件不会自动合并，建议分开写</li>
</ul>
<h1 id="composition">Composition</h1>
<p>React 提供了类似于 Vue slot 的组合模式：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wrapper</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Wrapper</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span> Welcome <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Wrapper</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，也可以预留很多个洞：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;split-pane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.left&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.right&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">left</span>=<span class="string">&#123;</span>&lt;<span class="attr">Left</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      right=&#123;<span class="tag">&lt;<span class="name">Right</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="context">Context</h1>
<p>Context 类似于 Vue 的 provide / eject，使得数据可以跨层传递，而不必显式地通过组件树逐层传递 props。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;defaultValue&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext</span> <span class="attr">value</span>=<span class="string">&quot;someValue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ButtonWrapper</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ButtonWrapper</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">MyContext</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">themeColor</span>=<span class="string">&#123;this.context&#125;/</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 Context 之外还有一种避免中间组件显式传递底层组件的各种属性值的方法：直接将底层组件作为属性传递下去。</p>
<h2 id="类组件-2">类组件</h2>
<h3 id="react.createcontext">React.createContext</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue)</span><br></pre></td></tr></table></figure>
<p>一旦有一个组件订阅了这个 Context 对象，这个组件会从组件树中寻找最近的匹配的 <code>Provider</code> 中读取 context 值；如果没有匹配到，则使用 <code>defaultValue</code>。需要注意的是，就算给 Provider 传递的是 <code>undefined</code>，<code>defaultValue</code> 也不会生效。</p>
<h3 id="context.provider">Context.Provider</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span> value=&#123;<span class="comment">/* SomeValue */</span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure>
<p>当 Provider 的 <code>value</code> 值发生变化时，内部所有的消费组件都会重新渲染，不受制于 <code>shouldComponentUpdate</code>，变化与否通过 <code>Object.is</code> 判定。</p>
<p>比如在下面这种情况时：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;something:</span> &#x27;<span class="attr">something</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦 Provider 的父组件 App 进行重新渲染，每次 value 就会被赋值为新的对象，会引起所有下面的 consumer 组件的重新渲染。为了防止这么做，需要使用 state：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">value</span>: &#123;<span class="attr">something</span>: <span class="string">&#x27;something&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class.contexttype">Class.contextType</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span></span><br></pre></td></tr></table></figure>
<p>通过挂载在 class 上的 <code>contextType</code> 属性获取一个 Context 对象，可以通过 <code>this.context</code> 来消费最近 Context 上的那个值，可以在包括 render 在内的任何生命周期中访问到他。</p>
<p>也可以通过 <code>static</code> 来初始化 <code>contextType</code>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">MyContext</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="context.consumer">Context.Consumer</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在函数式组件中，我们需要这样使用 context，中间的部分接受一个 context 值，返回一个 React 节点</p>
<h3 id="context.displayname">Context.displayName</h3>
<p>修改在 React DevTools 中显示的名字</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="comment">/* someValue */</span>)</span><br><span class="line"><span class="title class_">MyContext</span>.<span class="property">displayName</span> = <span class="string">&#x27;MyDisplayName&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt; <span class="comment">// 在 DevTools 中显示 &quot;MyDisplayName.Provider&quot;</span></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt; <span class="comment">// 在 DevTools 中显示 &quot;MyDisplayName.Consumer&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数组件-2">函数组件</h2>
<p>使用 <code>useContext</code>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 context</span></span><br><span class="line"><span class="keyword">const</span> C = <span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 圈定作用域并给初始值（初始值通常是一个读接口和写接口）</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">C.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;n,</span> <span class="attr">setN</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">C.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 子组件拿到读接口和写接口</span></span><br><span class="line">  <span class="keyword">const</span> &#123;n, setN&#125; = <span class="title function_">useContext</span>(C)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="refs">Refs</h1>
<h2 id="类组件-3">类组件</h2>
<h3 id="react.createref">React.createRef</h3>
<p>可以这样创建一个属性 <code>myRef</code>，然后传递给 DOM 元素 <code>div</code>，后续就可以使用 <code>this.myRef.current</code> 访问到这个 <code>div</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Ref 用于普通 HTML 元素时，<code>this.myRef.current</code> 为 HTML 元素：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  focusEvent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.focusEvent&#125;</span>&gt;</span>Focus<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Ref 用于自定义 class 组件时，<code>this.myRef.current</code> 为组件的实例：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 可以调用到 Child 组件里面的 focusTextInput 方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focusTextInput</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不能在函数组件 <strong>上</strong> 使用 ref（函数组件没有实例，ref.current 没办法指向函数组件），但是可以在函数组件 <strong>里面</strong> 使用 ref。</p>
<h3 id="回调-refs">回调 Refs</h3>
<p>在这种方式中，传递的不是 <code>createRef()</code> 创建 <code>ref</code> 属性，而是一个函数。这个函数中接受 React 组件实例或者 HTML DOM 元素作为参数。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = element</span><br><span class="line">  &#125;</span><br><span class="line">  focusTextInput = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用原生 DOM API 使得 textInput 获得焦点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">textInput</span>) <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">focusTextInput</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 给 ref 属性传一个一个回调函数，React 组件挂载式会调用回调函数并传入 element</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span>&gt;</span>Focus<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，你可以让 <code>textInput</code> 指向一个 class 组件，但仍然不能让其指向一个函数组件（因为函数组件没有实例）；但是你可以给函数组件传递一个回调，并将其赋值给函数组件内部的 <code>ref</code> 属性，React 在挂载的时候将调用这个回调，并传入 <code>element</code> 作为参数：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="literal">null</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">inputRef</span>=<span class="string">&#123;el</span> =&gt;</span> this.textInput = el&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↑ 在 <code>forWardRef</code> 出现之前，函数组件需要借用回调函数达到 Ref 转发的目的</p>
<h2 id="函数组件-3">函数组件</h2>
<ul>
<li>可以不使用 <code>React.creatRef</code>，而使用 <code>useRef</code></li>
<li>可以不使用回调函数手动转发 Ref，而使用 <code>forwardRef</code>，他允许组件接收 ref 并将其向下传递，最终可以使得 ref 指向最底层的 HTML DOM</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// const myRef = React.createRef()</span></span><br><span class="line">  <span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span>&gt;</span> I am a Button <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">className</span>=<span class="string">&quot;button-wrapper&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>通过这样的方式，我们在 MyComp 中就可以通过 <code>myRef.current</code> 获取到原生的 button 了</p>
<h2 id="高阶组件的-ref-转发">高阶组件的 Ref 转发</h2>
<p>有时候我们会使用高阶组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;old props: &#x27;</span>, prevProps)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">logProps</span>(<span class="title class_">Child</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果对 HOC 添加 ref，该 ref 将会引用到其外层的容器组件，而不是被包裹的组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 按照以前的逻辑，这里的 ref 应该指向组件 Child</span></span><br><span class="line">      <span class="comment">// 但实际上，这里的 ref 指向的并不是 Child，而是他外面的 LogProps</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们需要使用 <code>React.forward</code> 来将 ref 透传下去（就像之前函数组件使用 <code>React.forward</code> 将 ref 透传，指向了最终的 HTML DOM 元素一样），使得 ref 指向原来被包裹的组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LongProps</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;old props: &#x27;</span>, prevProps)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">fowardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">LongProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;/</span>&gt;</span></span>  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">logProps</span>(<span class="title class_">Child</span>)</span><br></pre></td></tr></table></figure>
<h1 id="other-hooks">Other Hooks</h1>
<h2 id="usereducer">useReducer</h2>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建初始状态</span></span><br><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 reducer</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">n</span>: state.<span class="property">n</span> + action.<span class="property">number</span>&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;multi&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">n</span>: state.<span class="property">n</span> * <span class="number">2</span>&#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;unknown type&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用 useReducer</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initial)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>, <span class="attr">number</span>: <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;n: state.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-usereducer-替代-redux">使用 useReducer 替代 redux</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数据初始状态</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">books</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">movies</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 reducer</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;setUser&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.<span class="property">user</span>&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;setBooks&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.<span class="property">user</span>&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;setMovies&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.<span class="property">user</span>&#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Context</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建对数据的读写 API</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, store)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 将读写 API 放到 Context 里面，并使用 Context.Provider 将 Context 提供给组件</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;state,</span> <span class="attr">dispatch</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">User</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">User</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;state, dispatch&#125; = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 AJAX 获取数据，并 dispatch(&#123;type: &#x27;setUser&#x27;, user&#125;)</span></span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>name: &#123;state.name ? state.user.name : &#x27;&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="useeffect">useEffect</h2>
<p>若同时有多个 useEffect，则他们将会依次执行</p>
<h3 id="什么是副作用">什么是副作用</h3>
<p>对环境的改变就是副作用，比如改变 <code>document.title</code></p>
<h3 id="模拟生命周期">模拟生命周期</h3>
<ul>
<li>模拟 <code>componentDidMount</code>（第一次渲染）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟 <code>componentDidUpdate</code>（更新时执行）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [n])</span><br><span class="line"><span class="comment">// 这样的话第一次渲染也会执行，可以使用自定义 Hook 来解决</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useUpdate</span> = (<span class="params">fn, dep</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [updateCount, setUpdateCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setUpdateCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [dep])</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (updateCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [updateCount, fn])</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">useUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, n)</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟 <code>componentWillUnmount</code>（将要销毁时执行）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure>
<h2 id="uselayouteffect">useLayoutEffect</h2>
<p>useEffect 将会在渲染完成之后被执行，因此有时候可能会出现闪烁，而 useLayoutEffect 将会在渲染完成之前（生成 DOM 之后）被执行</p>
<p>但是因为很多很时候我们不需要直接操作 DOM，不需要改变最后渲染的结果（外观），而且 useLayoutEffect 可能会延迟用户看到渲染完成结果的时间，因此优先使用 useEffect</p>
<h2 id="usememo">useMemo</h2>
<h3 id="react.memo">React.memo</h3>
<p>使用 React.memo 封装函数组件，使得其只在 props 变化的时候执行，但是有时候会出现这样的情况：给子组件添加一个事件监听，并传一个回调函数，因为父组件重新执行的时候，这个函数地址会改变，因此子组件还是会执行，使用 useMemo 解决</p>
<h3 id="usememo-1">useMemo</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这个返回值是才我想要缓存的那个函数，也可以返回一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []) <span class="comment">// 同样可以设置依赖</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个其实很像 Vue 2 的 computed</p>
<h2 id="usecallback">useCallback</h2>
<p>其实跟 useMemo 一样，只是不是在返回值中写：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是你想缓存的函数</span></span><br><span class="line">  &#125;, []) <span class="comment">// 同样可以设置依赖</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="useimperativehandle">useImperativeHandle</h2>
<p>相当于 "setRef"，可以定义一个 ref 的封装</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      realButton.<span class="property">current</span>.<span class="title function_">remove</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">realButton</span>: realButton</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="自定义-hook">自定义 Hook</h2>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;/list&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setList</span>(list)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list,</span><br><span class="line">    setList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="event">Event</h1>
<h2 id="类组件的事件">类组件的事件</h2>
<p>可以这样写事件</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">n</span>: <span class="number">0</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 这样写的 addN 是挂在原型上的  </span></span><br><span class="line">  <span class="title function_">addN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.<span class="property">n</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        n: &#123;this.state.n&#125;            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.addN()&#125;&gt; n + 1 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/*   这样最安全最好懂，箭头函数的 this 不会变   */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不能在 JSX 里面这样写：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">addN</span>&#125;&gt; n + <span class="number">1</span> &lt;/button&gt;</span><br><span class="line">&#123;<span class="comment">/*   这里面 addN 的 this 会变成 window   */</span>&#125;</span><br></pre></td></tr></table></figure>
<p>因为在点击的时候 React 实际上运行的是 <code>button.onClick.call(null,event)</code>，<code>this</code> 被 React 改了，当然我们可以通过 <code>bind</code> 来绑定 <code>this</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">addN</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt; n + <span class="number">1</span> &lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>也可以给箭头函数取个名字再来调用：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;  </span><br><span class="line">  <span class="title function_">addN</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">_addN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addN</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        n: &#123;this.state.n&#125;            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._addN&#125;</span>&gt;</span> n + 1 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以将 <code>addN</code> 写在 <code>constructor</code> 里面：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">n</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这样 addN 就是挂在每个实例对象上了  </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">addN</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> n = state.<span class="property">n</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        n: &#123;this.state.n&#125;            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.addN&#125;</span>&gt;</span> n + 1 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这种写法本质与上面的一样，只是 ES 6 的语法糖：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">n</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addN = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.<span class="property">n</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        n: &#123;this.state.n&#125;            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.addN&#125;</span>&gt;</span> n + 1 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fragments">Fragments</h1>
<p>类似于 <code>&lt;template&gt;</code>，使用 Fragments 可以创建类似的一个包裹器，而不会在 DOM 中添加额外的节点：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个简写版本，简写版不支持使用 key 或其他属性：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="higher-order-component">Higher-Order Component</h1>
<p>React 中经常会使用高阶组件（HOC, Higher-Order Component）来复用组件逻辑，它是一种设计模式。 具体来说，高阶组件是参数为组件，返回值为新组建的函数：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">higherOrderComponent</span>(<span class="title class_">WrappedComponent</span>)</span><br></pre></td></tr></table></figure>
<h2 id="hoc-的使用场景">HOC 的使用场景</h2>
<h3 id="修改-props">修改 props</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enhance</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> props = &#123;</span><br><span class="line">        ...<span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">        <span class="comment">// 增加 message 这个 Prop</span></span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="渲染劫持">渲染劫持</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enhance</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">data</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hoc-的例子">HOC 的例子</h2>
<h3 id="react-redux">React Redux</h3>
<p>通过 HOC 监听 redux store，然后把下级组件需要的 state、action creator 绑定到 WrappedComponent 的 props 上</p>
<h3 id="logger-和-debugger">logger 和 debugger</h3>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WrappedComponent: <span class="subst">$&#123;WrappedComponent.displayName&#125;</span>, Current props: `</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WrappedComponent: <span class="subst">$&#123;WrappedComponent.displayName&#125;</span>, Next props: `</span>, nextProps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页面权限管理">页面权限管理</h3>
<p>通过 HOC 对组件进行包裹，当用户跳转到其他页面的时候，检查用户是否含有对应的权限，如果有的话，渲染页面，如果没有的话，跳转到其他页面</p>
<h1 id="reconciliation">Reconciliation</h1>
<p>Reconciliation 直译为协调，即 React 的渲染机制，他有以下几步：</p>
<ol type="1">
<li>props 或 state 改变</li>
<li>render 函数返回不同的元素树（虚拟 DOM）</li>
<li>新旧 DOM 对比（vDOM Diff）</li>
<li>针对差异的地方进行更新</li>
<li>渲染为真实的 DOM 树</li>
</ol>
<h2 id="dom-diff-原理">DOM Diff 原理</h2>
<h3 id="设计思想">设计思想</h3>
<ol type="1">
<li>永远只比较同层的节点，不会跨层级比较</li>
<li>不同的两个节点产生不同的树（两个类型不同的节点直接用新的全部替代旧的，包括其后代）</li>
<li>通过 key 判断哪些元素是相同的（比如列表如果没有 key，从头部插入元素会导致列表全部更新），因此 key 需要在列表中保持唯一（不需要全局唯一）</li>
</ol>
<h3 id="比较流程">比较流程</h3>
<ul>
<li>若元素类型不相同：直接用新的树替换掉原来的树</li>
<li>若元素类型相同：
<ul>
<li>若都是 DOM 节点：更新 DOM 属性，比如 <code>style</code>、<code>title</code> 等，再向下递归找</li>
<li>若都是组件节点：组件实例保持不变，更新 Props</li>
</ul></li>
</ul>
<h2 id="如何减少-diff-过程">如何减少 Diff 过程</h2>
<blockquote>
<p>利用 <code>shouldComponentUpdate</code></p>
</blockquote>
<p>默认的 <code>shouldComponentUpdate</code> 会在 props 或 state 发生变化的时候返回 true，表示组件会重新渲染，然后调用 render 函数，进行 vDOM Diff；相对的，我们也可以通过控制它的返回值来控制是否发生 vDOM Diff</p>
<h2 id="浅比较与深比较">浅比较与深比较</h2>
<p>如果不想使用 <code>shouldComponentUpdate</code> 来一个一个检查，可以使用 <code>pureComponent</code> 对所有 <code>props</code> 和 <code>state</code> 进行 <strong>浅比较</strong>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数组件，可以使用 <code>React.memo</code>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>浅比较：</p>
<ol type="1">
<li>首先会使用等价于 <code>Object.is</code> 的方法进行判断，因此若引用类型的地址相同则判定为没有发生变化；</li>
<li>然后对于地址不同的，会进行 <strong>一层</strong> key 和 value 的比较</li>
</ol>
</div>
<p>因此，如果数据结构比较复杂，浅比较会损失掉很多信息，比如说通过 <code>push</code> 方法改变数组的值，浅比较将不能发现变化。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 这部分代码很糟，而且还有 bug</span></span><br><span class="line">  <span class="keyword">const</span> words = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">words</span>;</span><br><span class="line">  words.<span class="title function_">push</span>(<span class="string">&#x27;marklar&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">words</span>: words&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候应该使用不可变数据，尽量避免修改正在用于 props 或 state 的值，而是创建一个新的值，去覆盖原来的值：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">words</span>: state.<span class="property">words</span>.<span class="title function_">concat</span>([<span class="string">&#x27;marklar&#x27;</span>])</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 ES6 里的扩展运算符</span></span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">words</span>: [...state.<span class="property">words</span>, <span class="string">&#x27;marklar&#x27;</span>]</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于对象，我们可以用 <code>Object.assign</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateColorMap</span>(<span class="params">colorMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, colorMap, &#123;<span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用扩展运算符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateColorMap</span>(<span class="params">colorMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;...colorMap, <span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，尽管扩展运算符和 <code>Object.assign</code> 创建了新的引用，但是他们仍然是 <strong>浅拷贝</strong>，这并不冲突</p>
<h2 id="immutable-数据结构">immutable 数据结构</h2>
<p>immutable 的意义：浅比较缺点很明显，深比较有时候又比较浪费性能</p>
<p>简单来说：</p>
<ol type="1">
<li><strong>节省性能</strong>：immutable 内部采用多叉树结构，如果它里面有节点被改变，那么则更新 <strong>这个节点</strong> 和他有关的所有 <strong>上级节点</strong></li>
<li><strong>返回一个新的引用</strong>，即使是浅比较也能感知到数据的变化</li>
</ol>
<h3 id="一些-immutable-api">一些 immutable API</h3>
<h4 id="fromjs">fromJS</h4>
<p>将 JS 对象转换为 immutable 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">&#x27;immutable&#x27;</span></span><br><span class="line"><span class="keyword">const</span> immutableState = fromJS (&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="tojs">toJS</h4>
<p>将 immutable 对象转换为 JS 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsObj = immutableState.<span class="title function_">toJS</span>()</span><br></pre></td></tr></table></figure>
<h4 id="getgetin">get/getIn</h4>
<p>用来获取 immutable 对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.<span class="property">a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.<span class="property">a</span>.<span class="property">b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.<span class="title function_">getIn</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 传入一个数组</span></span><br></pre></td></tr></table></figure>
<h4 id="set">set</h4>
<p>用来给 immutable 对象的属性赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="merge">merge</h4>
<p>新旧数据对比，旧数据中不存在的属性直接添加，存在的属性用新数据覆盖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = <span class="title function_">fromJS</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.<span class="title function_">merge</span>(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="portals">Portals</h1>
<p>借助 Portal，可以将子节点渲染到存在于父组件以外的 DOM 节点。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container)</span><br></pre></td></tr></table></figure>
<p>其中，<code>child</code> 是任何可以渲染的 React 子元素，比如组件、字符串、fragment，<code>container</code> 是一个 DOM 元素</p>
<p>通常我们这样写一个子组件，然后在父组件中调用它：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有些时候如果父组件有 <code>overflow: hidden</code> <code>z-index</code> 等样式，如果子组件是对话框、悬浮卡或者提示框等时，我们需要让子组件跳脱出容器：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>,</span><br><span class="line">    domNode</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件处理">事件处理</h2>
<p>尽管 portal 可以被放在 DOM 树的任何位置，但他仍然在 React 树中，且与其在 DOM 树中的位置无关，因此像 context 之类的功能特性均不变。 事件冒泡也是这样，他会在 React 树中冒泡至 React 树的祖先，与 DOM 树无关。</p>
<h1 id="profiler">Profiler</h1>
<p><code>Profiler</code> 可以测量 React 多久渲染一次以及每次渲染的开销</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* Profiler 需要两个 Prop，一个是 id(string)，一个是当组件树中提交更新时被 React 调用的回调函数 onRender */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Profiler</span> <span class="attr">id</span>=<span class="string">&quot;Navigation&quot;</span> <span class="attr">onRender</span>=<span class="string">&#123;callback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navigation</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Profiler</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Profiler</span> <span class="attr">id</span>=<span class="string">&quot;Main&quot;</span> <span class="attr">onRender</span>=<span class="string">&#123;callback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Main</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Profiler</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">App</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onRenderCallback</span>(<span class="params"></span></span><br><span class="line"><span class="params">  id, <span class="comment">// 发生提交的 Profiler 树的 “id”</span></span></span><br><span class="line"><span class="params">  phase, <span class="comment">// &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一</span></span></span><br><span class="line"><span class="params">  actualDuration, <span class="comment">// 本次更新 committed 花费的渲染时间</span></span></span><br><span class="line"><span class="params">  baseDuration, <span class="comment">// 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span></span></span><br><span class="line"><span class="params">  startTime, <span class="comment">// 本次更新中 React 开始渲染的时间</span></span></span><br><span class="line"><span class="params">  commitTime, <span class="comment">// 本次更新中 React committed 的时间</span></span></span><br><span class="line"><span class="params">  interactions <span class="comment">// 属于本次更新的 interactions 的集合</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 合计或记录渲染时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="render-props">Render Props</h1>
<p>目的：封装组件，提高可复用性，可以这样使用：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">mouse</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/cat.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span> &#x27;<span class="attr">abosolute</span>&#x27;, <span class="attr">left:</span> <span class="attr">mouse.x</span>, <span class="attr">top:</span> <span class="attr">mouse.y</span>&#125;&#125;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleMouseMove = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: event.<span class="property">clientX</span>,</span><br><span class="line">      <span class="attr">y</span>: event.<span class="property">clientY</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> &#x27;<span class="attr">100</span>%&#x27;&#125;&#125; <span class="attr">onMouseMove</span>=<span class="string">&#123;this.handleMouseMove&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.render(this.state)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseTracker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>滑动鼠标<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以创建一个 HOC：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;/&gt;</span></span><br><span class="line">      ) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的功能也可以通过在 <code>&lt;Mouse&gt;</code> 中使用 <code>props.children</code>，然后直接使用类似于这样的写法：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span>&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">mouse</span> =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/<span class="title class_">Mouse</span>&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 render prop 会导致 <code>React.PureComponent</code> 失效，因为外层组件更新的时候，render prop 的函数总是新的，除非你把它写成一个实例方法。</p>
<h1 id="redux">Redux</h1>
<p>可以看看 <a href="https://codesandbox.io/s/jovial-gates-wbs8e">这个例子</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="keyword">function</span>(<span class="params">previousState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (previousState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    previousState = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;INCREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> previousState + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DECREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> previousState - <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> previousState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;value&quot;</span>).<span class="property">innerHTML</span> = store.<span class="title function_">getState</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>();</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">subscribe</span>(render); <span class="comment">// 每次 dispatch 就会触发 render</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addOne = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;INCREMENT&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minusOne = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  store.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;DECREMENT&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;increment&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, addOne);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;decrement&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, minusOne);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;incrementIfOdd&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (store.<span class="title function_">getState</span>() % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">addOne</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;incrementAsync&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(addOne, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="vue-react">Vue &amp; React</h1>
<p>共同点：</p>
<ul>
<li>都是对视图的封装，React 是用类和函数表示一个组件，Vue 是用构造选项表示一个组件</li>
<li>都提供了 <code>creatElement</code> 的 XML 简写，React 是 JSX，Vue 是 template</li>
</ul>
<p>不同点：</p>
<ol type="1">
<li>监听数据变化的实现原理不同
<ul>
<li>Vue 通过 getter/setter 和代理等方式进行劫持，能够精确知道数据的变化，不需要特别的优化</li>
<li>React 默认是通过比较引用的方式来进行的，可能会造成不必要的 vDOM 重新渲染，需要用诸如 PureComponent/shouldComponentUpdate 等方式来进行优化</li>
</ul></li>
<li>数据流不同
<ul>
<li>Vue 在 1.0 的时候 <strong>父子组件</strong> props 可以双向绑定，还有 v-model 可以实现 <strong>组件与 DOM</strong> 双向绑定</li>
<li>Vue 2 的时候 <strong>父子组件</strong> 不能双向绑定了（虽然仍然提供了 .sync 语法糖），并且还有 v-model</li>
<li>React 中是单向数据流，并且组件与 DOM 之间也需要使用 onChange/setState。</li>
</ul></li>
<li>HoC 和 mixins
<ul>
<li>Vue 中使用不同功能的组合是通过 mixins 实现的</li>
<li>React 中则使用 HoC</li>
</ul></li>
<li>组件间的通信
<ul>
<li>都有 props，也都可以跨层级通信，比如 Vue 的 provide/inject、React 的 context</li>
<li>React 本身不支持自定义事件，因此 Vue 里面一般使用事件，React 中一般使用父组件传来的回调函数</li>
</ul></li>
<li>更新视图
<ul>
<li>Vue 中一个对象，对应一个虚拟 DOM，当对象的属性改变时，把属性相关的 DOM 节点全部更新</li>
<li>React 一个对象，对应一个虚拟 DOM，另一个对象对应另一个虚拟 DOM，对比两个更新，用 DOM Diff 算法找不同，然后局部更新 DOM</li>
</ul></li>
<li>写法不同
<ul>
<li>Vue 是 JS in HTML</li>
<li>React 是 HTML in JS</li>
</ul></li>
<li>Vuex 和 Redux 的区别
<ul>
<li>Vue 中的 <code>$store</code> 直接注入到了组件实例中，可以直接用 dispatch、commit、mapState、<code>this.$store</code> 等；React 中需要用 connect 把 props 和 dispatch、state 连接起来</li>
<li>Vue 中可以用 dispatch action、commit mutation；React 中只能使用 dispatch，不能直接操作 reduce</li>
<li>Redux 中的使用的是不可变数据，每次都要用新的 State 替换旧的，而 Vue 中是直接修改的</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Ruby</title>
    <url>/hais-notebook/2022/03/13/Ruby/</url>
    <content><![CDATA[<p>结合网课、Ruby 文档和《Ruby 元编程 2》。</p>
<p>「元编程是编写能在运行时操作语言构件的代码。」</p>
<span id="more"></span>
<h1 id="startup">Startup</h1>
<h2 id="运行-ruby">运行 Ruby</h2>
<ul>
<li><code>irb</code> 可交互式命令行</li>
<li><code>ruby</code> + 文件路径</li>
</ul>
<h1 id="basic-syntax">Basic Syntax</h1>
<h2 id="值">值</h2>
<h3 id="变量">变量</h3>
<ul>
<li>没有 <code>var</code> <code>const</code> <code>let</code> 等关键字</li>
<li>局部变量：小写字母开头或 <code>_</code> 开头</li>
<li>全局变量：<code>$</code> 开头</li>
<li>类变量：<code>@@</code> 开头</li>
<li>实例变量：<code>@</code> 开头</li>
</ul>
<h3 id="常量">常量</h3>
<ul>
<li>任何以大写字母开头的引用（包括类名和模块名）都是常量</li>
<li>我们可以修改常量的值，尽管会得到一个警告</li>
<li>常量和变量的最大区别在于作用域不同，常量在所有作用域中都能访问，而不同作用域中的变量则是分开的（变量与作用域见 Blocks 章节）</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></span><br><span class="line">  MyConstant = <span class="string">&#x27;OuterConstant&#x27;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="comment"># 两个常量有着不同的作用域，他们是不同的</span></span><br><span class="line">    MyConstant = <span class="string">&#x27;InnerConstant&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    X = <span class="string">&#x27;a constant&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  C::X   <span class="comment"># =&gt; &#x27;a constant&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">M::C::X  <span class="comment"># =&gt; &#x27;a constant&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Y = <span class="string">&#x27;a root-level constant&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  Y = <span class="string">&#x27;a constant in M&#x27;</span></span><br><span class="line">  Y     <span class="comment"># =&gt; &#x27;a constant in M&#x27;</span></span><br><span class="line">  <span class="symbol">:</span><span class="symbol">:Y</span>   <span class="comment"># =&gt; &#x27;a root-level  constant&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Module</code> 类还有一个实例方法和类方法，方法名都叫 <code>constants</code>，<code>Module#constants</code> 方法返回当前范围内的所有常量，<code>Module.constants</code> 方法返回当前程序中所有顶层的常量。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">M.constans <span class="comment"># =&gt; [:C, :Y]</span></span><br><span class="line">Module.constants.<span class="keyword">include</span>? <span class="symbol">:Object</span> <span class="comment"># =&gt; true</span></span><br><span class="line">Module.constants.<span class="keyword">include</span>? <span class="symbol">:Module</span> <span class="comment"># =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>Module.nesting</code> 告诉我们当前代码所在的路径：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    <span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line">      Module.nesting <span class="comment"># =&gt; [M::C::M2, M::C, M]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="使用命名空间解决冲突的问题">使用命名空间解决冲突的问题</h4>
<p>比如你创建一个 Text 类，但 Action Mailer 中已经有了一个 Text Module，你可以使用命名空间来解决冲突：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="多重赋值">多重赋值</h3>
<ul>
<li><code>a,b,c = 1,2,3</code></li>
<li><code>a,b = [1,2]</code></li>
<li><code>a,b,*c = 1,2,3,4,5</code></li>
<li><code>a,*b,c = 1,2,3,4,5</code></li>
<li><code>a,b = b,a</code></li>
</ul>
<h3 id="字符串">字符串</h3>
<ul>
<li>单引号，没有转义，写 <code>'\n'</code> 里面就是 <code>\n</code></li>
<li>双引号，有转义</li>
<li>多行字符串</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&lt;&lt;eos</span></span><br><span class="line"><span class="string">dfa123</span></span><br><span class="line"><span class="string">fad</span></span><br><span class="line"><span class="string">eos</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<p>ruby 中只有对象，可以用 <code>.class</code> 查看类</p>
<ul>
<li><code>Integer</code> <code>Numeric</code> 整数</li>
<li><code>Float</code> 浮点数</li>
<li><code>String</code> 字符串</li>
<li><code>Array</code> 数组</li>
<li><code>Regexp</code> 正则</li>
<li><code>Time</code> 时间</li>
<li><code>File</code> 文件</li>
<li><code>Symbol</code> 符号</li>
<li><code>Exception</code> 异常</li>
<li><code>Hash</code> 散列</li>
</ul>
<p>每个对象都有唯一的 <code>object_id</code> 属性</p>
<h3 id="array">Array</h3>
<p><code>arr.methods</code> 可以看到有什么 api。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">element = <span class="number">30</span></span><br><span class="line">array &lt;&lt; element <span class="comment"># =&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure>
<h3 id="hash">Hash</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me = &#123; <span class="symbol">name:</span> <span class="string">&#x27;Harvey&#x27;</span>, <span class="symbol">age:</span> <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>name</code> 和 <code>age</code> 不是字符串，是 symbol，相当于</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me = &#123; <span class="symbol">:name</span> =&gt; <span class="string">&#x27;Harvey&#x27;</span>, <span class="symbol">:age</span> =&gt; <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>最初的写法相当于上面写法的在 ruby 2 以后的语法糖</p>
<p>symbol 相当于轻量的字符串，功能更少，可以通过 <code>.to_s</code> 得到字符串，通过 <code>.to_sym</code> 得到 symbol</p>
<h3 id="散列的遍历">散列的遍历</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me.each <span class="keyword">do</span> <span class="params">|key, value|</span> p key, value <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="与-js-对象的区别">与 JS 对象的区别</h3>
<ul>
<li>不能用 <code>me.name</code> 拿到属性，要用 <code>me[:name]</code>
<ul>
<li><code>'name'</code> 和 <code>:name</code> 是不一样的</li>
</ul></li>
<li>要给对象声明一个属性为函数，比较麻烦</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span></span></span><br><span class="line">  p <span class="string">&#x27;hi&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样写是不行的，他等价于 me[:say_hi] = say_hi()</span></span><br><span class="line">me[<span class="symbol">:say_hi</span>] = say_hi</span><br><span class="line"><span class="comment"># 要用 lambda 表达式</span></span><br><span class="line">me[<span class="symbol">:say_hi</span>] = <span class="built_in">lambda</span>&#123; p <span class="string">&#x27;hi&#x27;</span> &#125;</span><br><span class="line">me[<span class="symbol">:say_hi</span>].call</span><br></pre></td></tr></table></figure>
<h2 id="语句">语句</h2>
<h3 id="控制语句">控制语句</h3>
<h4 id="if">if</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> p <span class="string">&#x27;大&#x27;</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> p <span class="string">&#x27;大&#x27;</span> <span class="keyword">else</span> p <span class="string">&#x27;小&#x27;</span> <span class="keyword">end</span></span><br><span class="line">p(<span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> <span class="string">&#x27;大&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;小&#x27;</span> <span class="keyword">end</span>)</span><br><span class="line">p(<span class="keyword">if</span> a &gt; <span class="number">4</span></span><br><span class="line">  <span class="string">&#x27;大&#x27;</span></span><br><span class="line">  elseif a &gt; <span class="number">2</span></span><br><span class="line">  <span class="string">&#x27;中&#x27;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="string">&#x27;小&#x27;</span></span><br><span class="line">  <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> error</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> <span class="keyword">not</span> success</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">unless</span> success</span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<p>类似 <code>switch-case</code> 单不需要 <code>break</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">case</span> a</span><br><span class="line"><span class="keyword">when</span> <span class="number">1</span></span><br><span class="line">  <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">2</span></span><br><span class="line">  <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="string">&#x27;others&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<h4 id="times">times</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>.times <span class="keyword">do</span></span><br><span class="line">  p <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.times &#123; p <span class="string">&#x27;哈哈&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>times</code> 是函数，<code>do end</code> 和 <code>&#123;&#125;</code> 是代码块，作为 <code>times</code> 函数的最后的参数，一般多行用 <code>do end</code>，单行用 <code>&#123;&#125;</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>.times <span class="keyword">do</span> <span class="params">|i|</span> p <span class="string">&quot;<span class="subst">#&#123;i&#125;</span> time&quot;</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>|i|</code> 相当于给你的参数，表示第几次</p>
<h4 id="each">each</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each <span class="keyword">do</span> <span class="params">|item|</span> p item <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">7</span>).each <span class="keyword">do</span> <span class="params">|n|</span> p n <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="for">for</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">7</span> <span class="keyword">do</span> p i <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="whileuntil">while/until</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> &lt; <span class="number">3</span></span><br><span class="line">  p i</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> j &gt;= <span class="number">3</span></span><br><span class="line">  p j</span><br><span class="line">  j += <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="loop">loop</h4>
<p>一直循环</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">loop</span><br><span class="line">  p <span class="string">&#x27;ruby&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">10</span> <span class="keyword">then</span> <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="break-continue">break continue</h4>
<p><code>break</code> 和 <code>next</code> 对应 <code>break</code> 和 <code>continue</code></p>
<h2 id="其他">其他</h2>
<h3 id="log">log</h3>
<ul>
<li><code>print</code></li>
<li><code>puts</code> put string</li>
<li><code>p</code></li>
</ul>
<h3 id="注释">注释</h3>
<ul>
<li>单行注释 <code>#</code></li>
<li>多行注释</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure>
<h1 id="metaprogramming">Metaprogramming</h1>
<p>我们将变量、类、方法等这些称为<strong>语言构件</strong>。对于 C++ 这类语言，运行时就已经看不见他们了，我们无法在运行时询问一个类，他的实例方法有哪些；</p>
<p>但对于 Ruby 等语言，这些语言构件在运行时仍然存活，我们甚至可以在运行时询问某个构件，关于他的相关信息——这被称之为 <strong>内省（introspection）</strong>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(text)</span></span></span><br><span class="line">    <span class="variable">@text</span> = text</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">welcome</span></span></span><br><span class="line">    <span class="variable">@text</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">my_object = Greeting.new <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以在运行时通过这些方法来询问 <code>my_object</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">my_object.<span class="keyword">class</span> <span class="comment"># =&gt; Greeting</span></span><br><span class="line">my_object.<span class="keyword">class</span>.instance_methods(<span class="literal">false</span>) <span class="comment"># =&gt; [:welcome]</span></span><br><span class="line">my_object.instance_variables <span class="comment"># =&gt; [:<span class="doctag">@text</span>]</span></span><br></pre></td></tr></table></figure>
<p>我们甚至可以在运行时增加新的实例方法。</p>
<p>从广义上来说，用代码生成器也属于元编程（静态元编程 static metaprogramming），类似于模板；本书讨论的是另一种元编程（动态元编程 dynamic metaprogramming），即编写在运行时操作自身的代码。</p>
<h1 id="the-object-model">The Object Model</h1>
<p>Ruby 中，有很多语言构件：对象、类、模块、实例变量等，元编程操作的就是这些语言构件。所有这些语言构件存在的系统称之为<strong>对象模型</strong>。</p>
<ul>
<li><strong>对象</strong> 是一组 <strong>实例变量</strong> + 一个 <strong>指向类的引用</strong>（<code>.class</code>）</li>
<li>对象的方法存放在对象的类中，对于类来说，这些方法被称为类的实例方法</li>
<li><strong>类 </strong>是一个 <strong>对象</strong>（Class 类的一个实例） + 一组 <strong>实例方法</strong> + 一个 <strong>对其超类的引用</strong>（<code>.superclass</code>）</li>
<li>类有自己的方法（也就是 Class 的实例方法，比如 new）</li>
<li>Class 是 Module 的子类</li>
</ul>
<h2 id="打开类-open-classes">打开类 Open Classes</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接修改了 String 这个 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_alphanumeric</span></span></span><br><span class="line">    gsub(<span class="regexp">/[^\w\s]/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="类的定义">类的定义</h3>
<ol type="1">
<li>类定义中可以放任何语句</li>
<li>类可以重复“定义”，第二次使用 <code>class</code> 尝试定义他的时候，他并不会覆盖之前的定义，而是会增加一些内容，这种反复定义，称为 <strong>打开类</strong></li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    puts <span class="string">&quot;Hello&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在很多 Ruby 的库中都使用了打开类来对一些标准的 Ruby 类来进行魔改，比如 <code>monetize</code> 包就给 <code>Numeric</code> 类增加了 <code>to_money</code> 方法</p>
<blockquote>
<p>JavaScript 中其实也可以实现类似的操作，我们可以修改 Array、Number 的 prototype。但是经验上我并不会经常这么做，主要是怕重名或影响到别人的代码。</p>
</blockquote>
<h3 id="打开类的问题">打开类的问题</h3>
<p>确实，这种方法容易因为重名覆盖问题，导致其他的副作用。因此，有人称之为 <strong>猴子补丁 Monkeypatch</strong></p>
<h2 id="类的真相">类的真相</h2>
<h3 id="实例变量与实例方法">实例变量与实例方法</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="variable">@v</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>我们用 <code>#</code> 指类的实例方法，<code>.</code> 代指类的方法</li>
<li>实例变量 <code>[:@v]</code>：通过 <code>Object#instance_variables</code> 方法来查看。对象的类与实例变量没有关系，当给实例变量赋值时，他们就突然出现了。</li>
<li>实例方法 <code>[:my_method]</code>：通过 <code>Object#methods</code> 方法查看，他会给出所有继承的方法，我们可以通过 <code>Array#grep</code> 方法进行过滤。</li>
</ol>
<blockquote>
<p>实例变量存在对象中，而方法存放在类中。</p>
</blockquote>
<div class="note warning"><p>需要注意的是，我们不能说 <code>my_method</code> 是 <code>MyClass</code> 的方法，因为我们不能通过 <code>MyClass.my_method()</code> 这样来调用它。</p>
<p>我们只能说 <code>my_method</code> 是 <code>MyClass</code> 的一个 <strong>实例方法</strong>，因为我们必须要先定义一个 <code>MyClass</code> 的实例，然后通过实例调用它。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">String.instance_methods == <span class="string">&quot;abc&quot;</span>.methods  <span class="comment"># =&gt; true</span></span><br><span class="line">String.methods == <span class="string">&quot;abc&quot;</span>.methods  <span class="comment"># =&gt; false</span></span><br></pre></td></tr></table></figure>
</div>
<h3 id="类本身也是对象">类本身也是对象</h3>
<p>类本身也是对象，相当于是 <code>Class</code> 的实例，这又有点像 JavaScript 了</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="keyword">class</span> <span class="comment"># =&gt; String</span></span><br><span class="line">String.<span class="keyword">class</span>  <span class="comment"># =&gt; Class</span></span><br></pre></td></tr></table></figure>
<p>根据前面所述，<strong>实例的方法就是类的实例方法</strong>。因此，一个类的方法就是 <code>Class</code> 的实例方法</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># false 表示忽略继承的方法</span></span><br><span class="line">Class.instance_methods(<span class="literal">false</span>) <span class="comment"># =&gt; [:allocate,:new,:superclass]</span></span><br></pre></td></tr></table></figure>
<p><code>allocate</code> 方法是 <code>new</code> 方法的支撑方法，<code>superclass</code> 则跟继承有关：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Array.superclass  	 	<span class="comment"># =&gt; Object</span></span><br><span class="line">Object.superclass 		<span class="comment"># =&gt; BasicObject</span></span><br><span class="line">BasicObject.superclass  <span class="comment"># =&gt; nil</span></span><br><span class="line">Class.superclass  		<span class="comment"># =&gt; Module</span></span><br><span class="line">Module.superclass       <span class="comment"># =&gt; Object</span></span><br></pre></td></tr></table></figure>
<p><code>Class</code> 的 <code>superclass</code> 是 <code>Module</code>，类其实就是带有 <code>new</code> <code>allocate</code> <code>superclass</code> 的增强模块，这三个方法可以让我们按照一定层次创建对象。</p>
<ul>
<li>如果希望把代码 <code>include</code> 到别的代码中，就应该使用模块</li>
<li>如果希望代码被实例化或继承，应该使用类</li>
</ul>
<h3 id="方法调用">方法调用</h3>
<h4 id="方法查找">方法查找</h4>
<ul>
<li>接受者 receiver：调用方法所在所在的对象</li>
<li>祖先链 ancestors chain：找到对象的类（class）*，再找到类的超类（superclass），再找超类的超类（superclass），直到找到 <code>BasicObject</code> 类</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="string">&#x27;my_method()&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubclass</span> &lt; MyClass</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MySubclass.new</span><br><span class="line">obj.my_method() <span class="comment"># =&gt; &#x27;my_method()&#x27;</span></span><br><span class="line"></span><br><span class="line">MySubclass.ancestors <span class="comment"># =&gt; [MySubclass, MyClass, Object, Kernel, BasicObject]</span></span><br></pre></td></tr></table></figure>
<p><code>include</code> 某个模块或者继承某个类的时候，会将其加入到祖先链中。<code>prepend</code> 与 <code>include</code> 相似，前者会将模块插入到（祖先链中）该类的下方，后者会插入上方。</p>
<div class="note warning"><p>*事实上，查找方法的时候会先找该对象的 <strong>单件类（singleton_class）</strong>，再找 <strong>单件类的超类</strong>（也就是该对象的类）。但单件类并不会被 <code>class</code> 、<code>ancestors</code> 方法显示出来，详情请看单件类章节。</p>
</div>
<h5 id="kernel-模块">Kernel 模块</h5>
<p>我们可以随时调用比如 <code>print</code> 等方法，但其实 <code>print</code> 方法是 Kernel 模块的私有实例方法，Object 类包含了 Kernel 模块，使得每个对象都可以调用 Kernel 模块的方法</p>
<h4 id="执行方法">执行方法</h4>
<h5 id="self">self</h5>
<p><code>self</code> 代表了当前对象，当调用一个方法时，接受者就是 <code>self</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">testing_self</span></span></span><br><span class="line">    <span class="variable">@var</span> = <span class="number">10</span>   <span class="comment"># self 的一个实例变量</span></span><br><span class="line">    my_method() <span class="comment"># 相当于 self.my_method()</span></span><br><span class="line">    <span class="keyword">self</span>.my_private_method() <span class="comment"># 不能这样写，private 方法不能指定接受者，只能通过隐式的 self 调用</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="variable">@var</span> = <span class="variable">@var</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_private_method</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.testing_self <span class="comment"># =&gt; #&lt;MyClass:0x123 <span class="doctag">@var</span>=11&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>       <span class="comment"># =&gt; main</span></span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">class</span> <span class="comment"># =&gt; Object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="keyword">self</span>     <span class="comment"># =&gt; MyClass，在所有方法之外，self 是这个类或模块本身</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="细化-refinement">细化 Refinement</h4>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">StringExtensions</span></span></span><br><span class="line">  <span class="comment"># 为 String 类 refine 了一个 to_alphanumeric 方法，他默认不生效，不能直接通过 String#to_alphanumeric 来调用</span></span><br><span class="line">  refine String <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_alphanumeric</span></span></span><br><span class="line">      gsub(<span class="regexp">/[^\w\s]/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">StringStuff</span></span></span><br><span class="line">  using StringExtensions</span><br><span class="line">  <span class="string">&quot;my_string&quot;</span>.to_alphanumeric  <span class="comment"># =&gt; 可以调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;my_string&quot;</span>.to_alphanumeric    <span class="comment"># =&gt; 不能调用</span></span><br></pre></td></tr></table></figure>
<p>细化只有在两种场合有效：</p>
<ol type="1">
<li><code>refine</code> 代码内部</li>
<li><code>using</code> 语句开始到模块结束（或者在顶层作用域调用到文件结束）</li>
</ol>
<h1 id="methods">Methods</h1>
<h2 id="动态方法-dynamic-methods">动态方法 Dynamic Methods</h2>
<h3 id="动态调用方法">动态调用方法</h3>
<blockquote>
<p>实际上调用一个方法就是给一个对象发送消息</p>
</blockquote>
<p>除了使用点标识符 <code>(.)</code> 来调用方法，还可以使用 <code>Object#send</code> 方法来调用某个实例的方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(my_arg)</span></span></span><br><span class="line">    my_arg * <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method(<span class="number">3</span>)        <span class="comment"># =&gt; 6</span></span><br><span class="line">obj.send(<span class="symbol">:my_method</span>, <span class="number">3</span>) <span class="comment"># =&gt; 6</span></span><br><span class="line"><span class="comment"># send 的第一个参数是方法名，可以使用字符串，也可以使用符号；剩下的参数和代码块会被直接传递给调用的方法</span></span><br></pre></td></tr></table></figure>
<p>这样动态调用方法的技巧叫做 <strong>动态派发（Dynamic Dispatch）</strong></p>
<h3 id="动态定义方法">动态定义方法</h3>
<p>可以用 <code>Module#define_method()</code> 动态定义方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="comment"># 与 def 不同，define_method 允许在运行时决定方法的名字</span></span><br><span class="line">  define_method <span class="symbol">:my_method</span> <span class="keyword">do</span> <span class="params">|my_arg|</span></span><br><span class="line">    my_arg * <span class="number">3</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method(<span class="number">2</span>)    <span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure>
<h2 id="method_missing">method_missing</h2>
<p>当找不到方法是时，他就会调用对象上的 <code>method_missing</code> 方法，而我们可以覆写这个方法。调用者看起来调用了某个方法，但实际上这个方法却不存在，这称为 <strong>幽灵方法（Ghost Method）</strong></p>
<h3 id="respond_to_missing">respond_to_missing</h3>
<p>如果我们通过幽灵方法实现某功能，我们会发现使用 <code>respond_to?</code> 来查找方法的时候就会发现找不到这个方法。</p>
<p>需要使用 <code>respond_to_missing</code> 方法才能感知到幽灵方法。因此我们通常在使用 <code>method_missing</code> 的时候会覆写 <code>respond_to_missing</code> 方法</p>
<h3 id="const_missing">const_missing</h3>
<p>当引用一个不存在的常量的时候，Ruby 会把这个常量名作为一个符号传给 <code>const_missing</code> 方法，我们可以通过覆盖 <code>const_missing</code> 方法达到拦截的目的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;rake&#x27;</span></span><br><span class="line">task_class = Task  <span class="comment"># =&gt; 得到一个警告，让你使用 Rake::Task</span></span><br></pre></td></tr></table></figure>
<p>能达到上面的效果是因为 Rake 覆盖了 <code>Module#const_missing</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">const_missing</span><span class="params">(const_name)</span></span></span><br><span class="line">    <span class="keyword">case</span> const_name</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:Task</span></span><br><span class="line">      Rake.application.const_warning(const_name)</span><br><span class="line">      Rake::Task</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="白板类-blank-slates">白板类 Blank Slates</h2>
<p>用幽灵方法时经常会遇到名称与已经存在的方法冲突的情况，尤其是与他继承来的方法冲突。这时候就需要删掉继承的很多无用的方法。</p>
<h3 id="basicobject">BasicObject</h3>
<p><code>BasicObject</code> 只有几个实例方法，我们直接创建的类默认继承自 <code>Object</code> 类（<code>BasicObject</code> 的子类），我们可以将其改为继承 <code>BasicObject</code> 类</p>
<h3 id="删除方法">删除方法</h3>
<ol type="1">
<li><code>Module#undef_method</code>：删除（包括继承来的）方法</li>
<li><code>Module#remove_method</code>：删除接受者自己的方法</li>
</ol>
<h1 id="blocks">Blocks</h1>
<p>代码块源自像 LISP 这样的函数式编程语言</p>
<h2 id="代码块的基础使用">代码块的基础使用</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_method</span><span class="params">(a, b)</span></span></span><br><span class="line">  a + <span class="keyword">yield</span>(a, b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a_method(<span class="number">1</span>, <span class="number">2</span>) &#123; <span class="params">|x, y|</span> ( x + y ) * <span class="number">3</span> &#125;   <span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>代码块可以用 <code>do...end</code> 定义，也可以用大括号定义</li>
<li>只有在调用一个方法的时候才能定义一个块</li>
<li>这个块会被直接传递给这个方法，该方法可以用 <code>yield</code> 关键字调用这个块</li>
<li>在一个方法里，可以通过 <code>Kernel#block_given?</code> 询问当前方法的调用是否包含块</li>
</ul>
<h2 id="闭包与作用域">闭包与作用域</h2>
<h3 id="代码块是闭包">代码块是闭包</h3>
<p>可以运行的代码 = 代码本身 + 绑定</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">  x = <span class="string">&quot;Good bye&quot;</span></span><br><span class="line">  <span class="keyword">yield</span>(<span class="string">&quot;cruel&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">my_method &#123; <span class="params">|y|</span> <span class="string">&quot;<span class="subst">#&#123;x&#125;</span>, <span class="subst">#&#123;y&#125;</span> word&quot;</span> &#125;  <span class="comment"># =&gt; Hello, cruel world</span></span><br><span class="line"><span class="comment"># 创建代码块时，x 会成为局部绑定，然后把代码块连同绑定传给 my_method 方法</span></span><br><span class="line"><span class="comment"># 代码块中看到的 x 不是方法里面的 x，而是创建代码块时绑定的 x</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">just_yield</span></span></span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">top_level_variable = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">just_yield <span class="keyword">do</span></span><br><span class="line">  top_level_variable += <span class="number">1</span></span><br><span class="line">  local_to_block = <span class="number">1</span>  <span class="comment"># =&gt; 在代码块中定义的额外的绑定</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">top_level_variable  <span class="comment"># =&gt; 2</span></span><br><span class="line">local_to_block      <span class="comment"># =&gt; Error，看不到了，额外的绑定在代码块结束时消失了</span></span><br></pre></td></tr></table></figure>
<p>因此代码块，又被称为 <strong>闭包（Closure）</strong></p>
<h3 id="作用域">作用域</h3>
<p>Ruby 中没有内部作用域和外部作用域的概念（即在内部作用域中可以看到外部作用域的变量）。Ruby 中不同的作用域是分开的，没有“内部作用域可以看到外部作用域的变量”这样的说法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">v1 = <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  v2 = <span class="number">2</span></span><br><span class="line">  local_variables <span class="comment"># =&gt; [:v2]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    v3 = <span class="number">3</span></span><br><span class="line">    local_variables</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  local_variables <span class="comment"># =&gt; [:v2]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method <span class="comment"># =&gt; [:v3]</span></span><br><span class="line">local_variables <span class="comment"># =&gt; [:v1, :obj]</span></span><br></pre></td></tr></table></figure>
<h4 id="全局变量和顶级实例变量">全局变量和顶级实例变量</h4>
<p>全局变量</p>
<ul>
<li>全局变量可以在任何作用域中访问</li>
<li>变量名最开始有 <code>$</code></li>
<li>所有人都可以修改全局变量</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_scope</span></span></span><br><span class="line">  <span class="variable">$var</span> = <span class="string">&quot;some value&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_scope</span></span></span><br><span class="line">  <span class="variable">$var</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a_scope</span><br><span class="line">another_scope  <span class="comment"># =&gt; &quot;some value&quot;</span></span><br></pre></td></tr></table></figure>
<p>顶级实例变量</p>
<ul>
<li>顶级对象 <code>main</code> 的实例变量</li>
<li>有时可以用来代替全局变量</li>
<li>一般认为顶级实例变量更安全，但也不是完全安全</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">@var</span> = <span class="string">&quot;the top-level @var&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">  <span class="variable">@var</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">my_method	 <span class="comment"># =&gt; &quot;the top-level <span class="doctag">@var</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="variable">@var</span> = <span class="string">&quot;this is not the top-level @var&quot;</span></span><br><span class="line">    <span class="comment"># 由于这里的 self 不是 main，因此他不是顶级实例变量</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域门">作用域门</h4>
<p>在这三种情况下，程序会关闭前一个作用域，打开一个新的作用域：</p>
<ul>
<li>类定义 <code>class</code></li>
<li>模块定义 <code>module</code></li>
<li>方法 <code>def</code></li>
</ul>
<p><code>class</code> <code>module</code> <code>def</code> 是切换作用域的标志，每个关键字都对应一个 <strong>作用域门（Scope Gate）</strong>。</p>
<p>另外注意类和模组定义中的代码会立即自动执行一次，而方法定义中的则不会。</p>
<h4 id="扁平化作用域">扁平化作用域</h4>
<p>通过替换掉 <code>class</code> <code>def</code> 这些关键字，来让变量穿越作用域门，这种技巧叫嵌套文法作用域（nested lexical scopes），也称扁平化作用域（flattening the scope）。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">my_var = <span class="string">&quot;Success&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 Class.new 代替 class</span></span><br><span class="line">MyClass = Class.new <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;<span class="subst">#&#123;my_var&#125;</span> in the class definition&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 用 define_method 代替 def</span></span><br><span class="line">  define_method <span class="symbol">:my_method</span> <span class="keyword">do</span></span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;my_var&#125;</span> in the method&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">MyClass.new.my_method</span><br><span class="line"><span class="comment"># =&gt; Success in the class definition</span></span><br><span class="line"><span class="comment"># =&gt; Success in the method</span></span><br></pre></td></tr></table></figure>
<h4 id="共享作用域">共享作用域</h4>
<p>利用扁平化作用域，可以实现在一组方法之间共享某个变量，而其他方法则无法访问这个变量。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_methods</span></span></span><br><span class="line">  shared = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 定义 Kernel#counter 方法</span></span><br><span class="line">  Kernel.send <span class="symbol">:define_method</span>, <span class="symbol">:counter</span> <span class="keyword">do</span></span><br><span class="line">    shared</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  Kernel.send <span class="symbol">:define_method</span>, <span class="symbol">:inc</span> <span class="keyword">do</span></span><br><span class="line">    shared += x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">define_methods</span><br><span class="line"></span><br><span class="line">counter 	<span class="comment"># =&gt; 0</span></span><br><span class="line">inc(<span class="number">4</span>)</span><br><span class="line">counter   <span class="comment"># =&gt; 4</span></span><br></pre></td></tr></table></figure>
<h2 id="instance_eval"><code>instance_eval</code></h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@v</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line"></span><br><span class="line">obj.instance_eval <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">self</span>											<span class="comment"># =&gt; #&lt;MyClass:0x00000000062acbb8 <span class="doctag">@v</span>=1&gt;</span></span><br><span class="line">  <span class="variable">@v</span>												<span class="comment"># =&gt; 1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method!</span>;</span> <span class="keyword">end</span>       <span class="comment"># =&gt; 这样定义的方法是 obj 的单件方法</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>传给 <code>instance_eval</code> 中代码块中的 <code>self</code> 就是 <code>obj</code></li>
<li>并且在这个代码块中可以使用并修改实例变量 <code>@v</code></li>
<li>这个代码块中的当前类是接受者的 <strong>单件类</strong></li>
<li><code>instance_eval</code> 表示：我想修改 <code>self</code></li>
</ul>
<p>因此把传给 <code>BasicObject#instance_eval</code> 方法的代码块称为 <strong>上下文探针（Context Prob）</strong>，他就像一个深入到对象中的代码片段，并且可以对这个对象进行操作。</p>
<p><code>instance_eval</code> 会破坏封装，可以肆意查看私有数据，但有时在开发和测试中使用会非常方便。</p>
<h3 id="instance_exec"><code>instance_exec</code></h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@x</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">twisted_method</span></span></span><br><span class="line">    <span class="variable">@y</span> = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 注意这样打印的 <span class="doctag">@y</span> 是 nil，因为代码块已经不在 twisted_method 的作用域里面了</span></span><br><span class="line">    C.new.instance_eval &#123; p <span class="string">&quot;@x: <span class="subst">#&#123;<span class="variable">@x</span>&#125;</span>, @y: <span class="subst">#&#123;<span class="variable">@y</span>&#125;</span>&quot;</span> &#125;</span><br><span class="line">    <span class="comment"># 可以使用 instance_exec 方法将 <span class="doctag">@y</span> 传进去</span></span><br><span class="line">    C.new.instance_exec(<span class="variable">@y</span>) &#123; <span class="params">|y|</span> p <span class="string">&quot;@x: <span class="subst">#&#123;<span class="variable">@x</span>&#125;</span>, @y: <span class="subst">#&#123;y&#125;</span>&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">D.new.twisted_method</span><br></pre></td></tr></table></figure>
<h2 id="可调用对象">可调用对象</h2>
<p>代码块的使用分为：1. 打包代码；2. 通过 <code>yield</code> 语句执行代码。</p>
<p>除了代码块之外，还有三种打包代码的方式：</p>
<ol type="1">
<li>proc，proc 是由块转换来的对象</li>
<li>lambda，proc 的变种</li>
<li>使用方法</li>
</ol>
<h3 id="proc">Proc</h3>
<h4 id="创建-proc">创建 Proc</h4>
<h5 id="proc.new">Proc.new</h5>
<p>将代码块传给 <code>Proc.new</code> 就可以创建一个 <code>Proc</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">inc = Proc.new &#123; <span class="params">|x|</span> x + <span class="number">1</span> &#125;</span><br><span class="line">inc.call(<span class="number">2</span>)		<span class="comment"># =&gt; 3</span></span><br></pre></td></tr></table></figure>
<h5 id="lambda">lambda</h5>
<p>用 <code>Kernel#lambda</code> 方法也可以创建 <code>Proc</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">dec = <span class="built_in">lambda</span> &#123; <span class="params">|x|</span> x - <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment"># 上述代码也可以这样写</span></span><br><span class="line">dec = -&gt;(x) &#123; x - <span class="number">1</span> &#125;</span><br><span class="line">dec.<span class="keyword">class</span> 	  <span class="comment"># =&gt; Proc</span></span><br><span class="line">dec.call(<span class="number">2</span>)	  <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h5 id="操作符">&amp; 操作符</h5>
<p>通过给方法添加一个特殊的参数，可以将代码块附加到一个绑定上，这个参数必须满足：</p>
<ol type="1">
<li>是参数列表的最后一个参数</li>
<li>以 &amp; 开头</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math</span><span class="params">(a, b)</span></span></span><br><span class="line">  <span class="keyword">yield</span>(a, b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_math</span><span class="params">(a, b, &amp;operation)</span></span></span><br><span class="line">  <span class="comment"># 将 &amp; 去掉，就可以得到一个 Proc 对象；也可以将一个 Proc 加上 &amp; 得到一个代码块</span></span><br><span class="line">  p operation.<span class="keyword">class</span>    <span class="comment"># =&gt; Proc</span></span><br><span class="line">  math(a, b, &amp;operation)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">do_math(<span class="number">2</span>, <span class="number">3</span>) &#123; <span class="params">|x, y|</span> x * y &#125;		<span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure>
<h4 id="执行-proc">执行 Proc</h4>
<p>然后通过 <code>Proc#call</code> 方法执行 <code>Proc</code> 对应的代码块。</p>
<p>这种技巧被称为 <strong>延迟执行（Deferred Evaluation）</strong>：还可以使用 <code>lambda</code> 方法创建 Proc：#### &amp; 操作符</p>
<h3 id="proc-和-lambda">Proc 和 Lambda</h3>
<p>用 <code>lambda</code> 方法创建的 <code>Proc</code> 被称为 <code>lambda</code>， 其他方式创建的则称为 <code>proc</code>，可以通过 <code>Proc#lamda?</code> 方法来检测 <code>Proc</code> 是不是 <code>lambda</code>。</p>
<h4 id="proclambda-和-return">Proc、Lambda 和 return</h4>
<p><code>lambda</code> 和 <code>proc</code> 的 <code>return</code> 关键字含义不同。</p>
<ul>
<li><code>lambda</code> 中的 <code>return</code> 仅仅表示从这个 <code>lambda</code> 中返回</li>
<li><code>proc</code> 中的 <code>return</code> 表示从定义 <code>proc</code> 的作用域中返回</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(callable_object)</span></span></span><br><span class="line">  callable_object.call * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">lambda</span> &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</span><br><span class="line">double(l)			<span class="comment"># =&gt; 20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_double</span></span></span><br><span class="line">  p = Proc.new &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</span><br><span class="line">  result = p.call</span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>		<span class="comment"># 不可到达的代码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">another_double 				<span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure>
<p>因此下面代码是错误的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(callable_object)</span></span></span><br><span class="line">  callable_object.call * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p = Proc.new &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</span><br><span class="line">double(p)			<span class="comment"># 不可到达的代码</span></span><br></pre></td></tr></table></figure>
<p>可以不使用 <code>return</code> 来规避这 个问题</p>
<h4 id="proclambda-和参数数量">Proc、Lambda 和参数数量</h4>
<p>如果给一个定义了两个参数的 <code>proc</code> 或 <code>lambda</code> 传一个或三个参数，可能会导致错误，并且 <code>lambda</code> 的适应能力比 <code>proc</code> 和普通代码块差。</p>
<p>如果参数比期望的多，<code>proc</code> 会忽略多余的参数；如果参数数量不足，对于未指定的参数，<code>proc</code> 会赋值为 <code>nil</code>。</p>
<p>整体而言，<code>lambda</code> 更直观，因为他更像一个方法；因此许多 Ruby 程序员优先使用 <code>lambda</code>。</p>
<h3 id="method">Method</h3>
<ol type="1">
<li><p>通过 <code>Kernel#method</code> 方法可以获得一个用 Method 对象表示的方法，可以用 <code>Method#call</code> 来调用这个方法。</p></li>
<li><p>可以通过 <code>Kernel#singleton_method</code> 方法把 <strong>单件方法</strong> 名转换为 Method 对象。</p></li>
<li><p>可以通过 <code>Method#to_proc</code> 方法把 Method 转换为 Proc</p></li>
<li><p>可以通过 <code>define_method</code> 方法把代码块转换为方法</p></li>
<li><p>注意 <code>lambda</code> 在定义他的作用域中执行（闭包），Method 对象则在他自身所在对象的作用域中执行</p></li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="variable">@x</span> = value</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    p <span class="variable">@x</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new(<span class="number">1</span>)</span><br><span class="line">m = obj.method <span class="symbol">:my_method</span></span><br><span class="line">m.call 		<span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h4 id="自由方法">自由方法</h4>
<p>自由方法（unbound method）跟普通方法类似，但他从定义它的类或模块中脱离了。</p>
<p>通过 <code>Method#unbind</code> 方法可以讲一个方法变成自由方法，也可以直接调用 <code>Module#instance_method</code> 方法获得自有方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="number">42</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">unbound = MyModule.instance_method(<span class="symbol">:my_method</span>)</span><br><span class="line">unbound.<span class="keyword">class</span>			<span class="comment"># =&gt; UnboundMethod</span></span><br></pre></td></tr></table></figure>
<p>不能调用 UnboundMethod，但可以将它绑到一个对象上，让他再次成为 Method 对象。</p>
<p>可以通过 <code>UnboundMethod#bind</code> 方法，也可以通过 <code>Module#define_method</code> 方法来进行绑定。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">String.send <span class="symbol">:define_method</span>, <span class="symbol">:another_method</span>, unbound</span><br><span class="line"><span class="string">&quot;abc&quot;</span>.another_method		<span class="comment"># =&gt; 42</span></span><br></pre></td></tr></table></figure>
<h1 id="class">Class</h1>
<h2 id="类的定义-1">类的定义</h2>
<h3 id="当前类">当前类</h3>
<p>不管在哪里，都会有一个当前对象：<code>self</code>，和一个当前类（或模块）。定义一个方法时，那个方法将成为当前类的一个实例方法。</p>
<ul>
<li>在程序的顶层，当前类是 <code>Object</code>，这是 <code>main</code> 对象所属的类。在程序顶层定义的方法会成为 <code>Object</code> 实例方法。</li>
<li>在一个方法中，当前类就是当前对象的类。</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m1</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m2</span>;</span> <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = D.new</span><br><span class="line">obj.m1</span><br><span class="line"></span><br><span class="line">C.instance_methods(<span class="literal">false</span>)    	<span class="comment"># =&gt; [:m1, :m2]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当用 <code>class</code> 关键字打开一个类时（或用 <code>module</code> 关键字打开模块时），这个类成为当前类。</li>
</ul>
<h4 id="class_eval"><code>class_eval</code></h4>
<p>通过 <code>Module#class_eval</code>方法（别名 <code>module_eval</code> 方法），可以不使用 <code>class</code> 关键字就修改某个类，在不知道某个类的名字的时候比较好用：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_method_to</span><span class="params">(a_class)</span></span></span><br><span class="line">  a_class.class_eval <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span>;</span> <span class="string">&#x27;Hello!&#x27;</span>; <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">add_method_to String</span><br><span class="line"><span class="string">&quot;abc&quot;</span>.m				<span class="comment"># =&gt; &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>与 <code>Object#instance_eval</code> 方法不同：
<ul>
<li><code>instance_val</code> 修改 <code>self</code> ，并且会把当前类修改为接受者的单件类；</li>
<li><code>class_eval</code> 会修改当前类和 <code>self</code>。</li>
</ul></li>
<li><code>class_eval</code> 与 <code>class</code> 不同，并不会打开一个新的作用域，而可以使用外部的变量。</li>
<li>另外还有 <code>module_exec</code> 和 <code>class_exec</code>，可以接受额外的参数。</li>
</ul>
<h3 id="类实例变量">类实例变量</h3>
<p>类定义中的 <code>self</code> 是类本身，因此不要混淆了 <strong>类的实例变量</strong> 和 <strong>类的对象的实例变量</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">   <span class="variable">@my_var</span> = <span class="number">1</span></span><br><span class="line">   def <span class="keyword">self</span>.read; <span class="variable">@my_var</span>; <span class="keyword">end</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">write</span>;</span> <span class="variable">@my_var</span> = <span class="number">2</span>; <span class="keyword">end</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">read</span>;</span> <span class="variable">@my_var</span>; <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.read			<span class="comment"># =&gt; nil</span></span><br><span class="line">obj.write</span><br><span class="line">obj.read			<span class="comment"># =&gt; 2</span></span><br><span class="line">MyClass.read  <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h3 id="类变量">类变量</h3>
<p>类变量可以被子类或类的实例所使用。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="variable">@@v</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="variable">@@v</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">D.new.my_method			<span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>因为类变量不属于这个类，而是属于类体系结构，因此会产生一些别的问题：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">@@v</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="variable">@@v</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @<span class="doctag">@v</span> 属于 main 的类 Object，所以也属于 Object 的所有后代，MyClass 继承自 Object，也共享了这个变量</span></span><br><span class="line"><span class="variable">@@v</span> 	 <span class="comment"># =&gt; 2</span></span><br></pre></td></tr></table></figure>
<h2 id="单件方法">单件方法</h2>
<p>只对单个对象生效的方法，称为 <strong>单件方法（Singleton Method）</strong>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;just a regular string&quot;</span></span><br><span class="line"></span><br><span class="line">def str.title?</span><br><span class="line">  <span class="keyword">self</span>.upcase == <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str.title?										<span class="comment"># =&gt; false</span></span><br><span class="line">str.methods.grep(<span class="regexp">/title?/</span>)		<span class="comment"># =&gt; [:title?]</span></span><br><span class="line">str.singleton_methods					<span class="comment"># =&gt; [:title?]</span></span><br></pre></td></tr></table></figure>
<h3 id="类方法">类方法</h3>
<p>类方法其实就是一个类的单件方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">def obj.a_singleton_method; <span class="keyword">end</span></span><br><span class="line">def MyClass.another_class_method; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单件方法</span></span><br><span class="line">def object.method</span><br><span class="line">  <span class="comment"># 方法的主体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>一共有三种方式可以定义类方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">def MyClass.a_class_method; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  def <span class="keyword">self</span>.another_class_method; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">yet_another_class_method</span>;</span> <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="类宏">类宏</h3>
<h4 id="attr_accessor"><code>attr_accessor</code></h4>
<p>Ruby 的对象是没有属性的，如果想要得到 JavaScript 类似的属性的效果，得定义 <strong>拟态方法</strong>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_attribute=</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="variable">@my_attribute</span> = value</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_attribute</span></span></span><br><span class="line">    <span class="variable">@my_attribute</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_attribute = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">obj.my_attribute          <span class="comment"># =&gt; &quot;x&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样的写法（也叫访问器）很麻烦，可以用 <code>Module#attr_*</code> 方法定义访问器，<code>Module#attr_reader</code> 生成读方法、<code>Module#attr_writer</code> 生成写方法、<code>Module#attr_accessor</code> 同时生成两者：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:my_attribute</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>所有的 <code>attr_*</code> 方法都定义在 <code>Module</code> 类中，因此不管 <code>self</code> 是类还是模块，都可以使用。这种方法被称为 <strong>类宏（Class Macro）</strong>，简单来说就是可以在类定义中使用的方法。</p>
<p>下面是一个使用类宏来标记方法名已弃用的例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line">  def title <span class="comment">#...</span></span><br><span class="line">  def subtitle <span class="comment">#...</span></span><br><span class="line">  def lend_to <span class="comment">#...</span></span><br><span class="line">  </span><br><span class="line">  def <span class="keyword">self</span>.deprecate(old_method, new_method)</span><br><span class="line">    define_method(old_method) <span class="keyword">do</span> <span class="params">|*args, &amp;block|</span></span><br><span class="line">      warn <span class="string">&quot;Warning <span class="subst">#&#123;old_method&#125;</span>() is deprecated. Use <span class="subst">#&#123;new_method&#125;</span>()&quot;</span></span><br><span class="line">      send(new_method, *args, &amp;block)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  deprecate <span class="symbol">:GetTitle</span>, <span class="symbol">:title</span></span><br><span class="line">  deprecate <span class="symbol">:LEND_TO_USER</span>, <span class="symbol">:lend_to</span></span><br><span class="line">  deprecate <span class="symbol">:title2</span>, <span class="symbol">:subtitle</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="单件类">单件类</h2>
<p>根据之前所学，查找方法时会先进入接受者的类，然后沿着 superclass 向上查找。但是这里面都没有容纳对象单件方法的地方。</p>
<p>事实上，每个对象都有一个特有的隐藏类（这个类不能用 <code>Object#class</code> 方法查看到），被称为该对象的单件类，也被称为元类（metaclass）或本征类（eigenclass）。</p>
<p>可以通过一个 <strong>特殊的语法</strong> <code>class &lt;&lt; my_object</code> 进入该单件类的作用域，并获得他的引用：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    <span class="string">&#x27;C#a_method()&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = D.new</span><br><span class="line"></span><br><span class="line">singleton_class = <span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></span><br><span class="line">  <span class="comment"># 这里是你的代码</span></span><br><span class="line">  <span class="comment"># 这里定义的方法 = 单件类的实例方法 = 单件方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_singleton_method</span></span></span><br><span class="line">    <span class="string">&#x27;obj#a_singleton_method&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 可以返回 self，让外面得到单件类的引用</span></span><br><span class="line">  <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">singleton_class.<span class="keyword">class</span>				 <span class="comment"># =&gt; Class</span></span><br><span class="line">singleton_class.superclass 	 <span class="comment"># =&gt; D，对象的单件类的超类 = 对象的类</span></span><br></pre></td></tr></table></figure>
<p>还可以通过 <code>Object#singleton_class</code> 方法来获得单件类的引用：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.singleton_class		<span class="comment"># =&gt; #&lt;Class:#&lt;String:0x0000000006df44a8&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>每个单件类只有一个实例，单件类不能被继承，单件方法就在单件类中：</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">def obj.my_singleton_method; <span class="keyword">end</span></span><br><span class="line">singleton_class.instance_method.grep(<span class="regexp">/my_/</span>)    <span class="comment"># =&gt; [:my_singleton_method]</span></span><br></pre></td></tr></table></figure>
<h3 id="单件类和继承">单件类和继承</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_class_method</span></span></span><br><span class="line">      <span class="string">&#x27;C.a_class_method()&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.singleton_class							<span class="comment"># =&gt; #&lt;Class:C&gt;，注意单件类前面有#</span></span><br><span class="line">D.singleton_class   					<span class="comment"># =&gt; #&lt;Class:D&gt;</span></span><br><span class="line">D.singleton_class.superclass 	<span class="comment"># =&gt; #&lt;Class:C&gt;，注意类的单件类的 superclass 与普通对象的单件类的 superclass 不同</span></span><br><span class="line">C.signleton_class.superclass	<span class="comment"># =&gt; #&lt;Class:Object&gt;</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Ruby%20%E5%8D%95%E4%BB%B6%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF.jpg" alt="Ruby 单件类和继承" /><figcaption aria-hidden="true">Ruby 单件类和继承</figcaption>
</figure>
<div class="note warning"><p>一个对象的单件类的超类是这个对象的类。</p>
<p>一个类的单件类的超类是这个类的超类的单件类。</p>
</div>
<p><code>Kernel</code> 模块置于 <code>Object</code> <code>BasicObnject</code> 之间，他也有自己的单件类，但他的单件类并不是 <code>obj</code> 或者 <code>#D</code> 祖先链上的一员。</p>
<p>用这种组织方式，可以在子类上调用父类的类方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">D.a_class_method 		<span class="comment"># =&gt; &quot;C.a_class_method()&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实单件类也有自己的单件类，暂时不用管这个。</p>
</blockquote>
<h3 id="单件类的用处">单件类的用处</h3>
<p>给一个类定义类属性：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这样定义的话，b 实际上在 Class 上，所有的类都会增加 b</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:b</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">MyClass.b = <span class="number">42</span></span><br><span class="line">MyClass.b				<span class="comment"># =&gt; 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以定义到 MyClass 的单件类上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:c</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">MyClass.c = <span class="string">&quot;It works!&quot;</span></span><br><span class="line">MyClass.c				<span class="comment"># =&gt; &quot;It works!&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="类扩展">类扩展</h3>
<p>类扩展：通过 <code>include</code> 的方式为类添加单件方法。</p>
<p>尝试在模块中定义一个单件方法，然后通过 <code>include</code> 的方式让类可以访问到他，失败了：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  def <span class="keyword">self</span>.my_method; <span class="string">&#x27;hi&#x27;</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  def <span class="keyword">self</span>.my_method; <span class="string">&#x27;hello&#x27;</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p D.my_method    <span class="comment"># =&gt; ‘hi&#x27;</span></span><br><span class="line">p E.my_method	   <span class="comment"># =&gt; NoMethodError!</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>include</code> 获得的是该模块的实例方法，这与继承有点区别。</p>
<p>如果要达到想要的效果，需要在模块中定义普通的实例方法，然后让类的单件类来包含这个模块：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">&#x27;hello&#x27;</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">include</span> M</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">MyClass.my_method			<span class="comment"># =&gt; &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象扩展">对象扩展</h3>
<p>对象扩展：用类扩展的技巧，为对象添加单件方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">&#x27;hello&#x27;</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = Object.new</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj.my_method							<span class="comment"># =&gt; &#x27;hello&#x27;</span></span><br><span class="line">obj.singleton_methods			<span class="comment"># =&gt; [:my_method]</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>Object#extend</code> 方法来更好地书写类扩展和对象扩展：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">&#x27;hello&#x27;</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = Object.new</span><br><span class="line">obj.extend M</span><br><span class="line">obj.my_method					<span class="comment"># =&gt; &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  extend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.my_method						<span class="comment"># =&gt; &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="方法包装器">方法包装器</h2>
<p>有三种方式可以用一个方法包装另一个方法。</p>
<h3 id="方法别名与环绕别名">方法别名与环绕别名</h3>
<p>可以用 <code>alias</code> 关键字或 <code>Module#alias_method</code> 来给方法取一个新名字</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">&#x27;my_method()&#x27;</span>; <span class="keyword">end</span></span><br><span class="line">  alias_method <span class="symbol">:m</span>, <span class="symbol">:my_method</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method			<span class="comment"># =&gt; &quot;my_method()&quot;</span></span><br><span class="line">obj,m							<span class="comment"># =&gt; &quot;my_method()&quot;</span></span><br></pre></td></tr></table></figure>
<p>重新定义方法的时候，并不会真正修改原来的方法，因此如果给一个方法取了别名之后，重新定义一个跟之前名字相同的方法，别名仍然绑定的原来的方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  alias_method <span class="symbol">:real_length</span>, <span class="symbol">:length</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">length</span></span></span><br><span class="line">    real_length &gt; <span class="number">5</span> <span class="string">&#x27;long&#x27;</span> : <span class="string">&#x27;short&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;War and Peace&quot;</span>.length 		   <span class="comment"># =&gt; &quot;long&quot;</span></span><br><span class="line"><span class="string">&quot;war and Peace&quot;</span>.real_length  <span class="comment"># =&gt; 13</span></span><br></pre></td></tr></table></figure>
<p>可以用 <strong>环绕别名</strong> 的技巧来包装一个一个方法：</p>
<ol type="1">
<li>给方法定义一个别名</li>
<li>重新定义这个方法</li>
<li>在新方法中调用老方法</li>
</ol>
<div class="note warning"><p>环绕别名实际上也是一种猴子补丁，他会全局性地破坏已有代码。</p>
</div>
<h3 id="细化封装器">细化封装器</h3>
<p>在细化的方法中调用 <code>super</code> 方法，就会调用没有细化的原始方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">StringRefinement</span></span></span><br><span class="line">  refine String <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span></span></span><br><span class="line">      <span class="keyword">super</span> &gt; <span class="number">5</span> ? <span class="string">&#x27;long&#x27;</span> : <span class="string">&#x27;short&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">using StringRefinement</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;War and Peace&quot;</span>.length 	 <span class="comment"># =&gt; &quot;long&quot;</span></span><br></pre></td></tr></table></figure>
<p>同其他细化一样，细化封装器的作用范围只到文件末尾处（Ruby 2.1 中是模块定义的范围内），因此比环绕别名更安全。</p>
<h3 id="moduleprepend-与下包含包装器"><code>Module#prepend</code> 与下包含包装器</h3>
<p>与 <code>include</code> 类似，但是 <code>Module#prepend</code> 方法会将包含的模块插在祖先链中该类的下方，而非上方。因此可以用这个技巧复写同名方法，也可以用 <code>super</code> 调用到该类的原始方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">ExplicitString</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">length</span></span></span><br><span class="line">    <span class="keyword">super</span> &gt; <span class="number">5</span> ? <span class="string">&#x27;long&#x27;</span> : <span class="string">&#x27;short&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">String.class_eval <span class="keyword">do</span></span><br><span class="line">  prepend ExplicitString</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用打开类的方式书写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  prepend ExplicitString</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;War and Peace&quot;</span>.length 	 <span class="comment"># =&gt; &quot;long&quot;</span></span><br></pre></td></tr></table></figure>
<p>这种技巧被称为下包含包装器。</p>
<h1 id="code-that-writes-code">Code That Writes Code</h1>
<h2 id="kerneleval"><code>Kernel#eval</code></h2>
<p>使用 <code>Kenerl#eval</code> 方法可以直接执行包含 Ruby 代码的字符串：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">element = <span class="number">30</span></span><br><span class="line">eval(<span class="string">&quot;array &lt;&lt; element&quot;</span>)    <span class="comment"># =&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure>
<p>比如在 REST Client 中，通过这种方式批量定义这些方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们需要定义形如这样的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(path, *args, &amp;b)</span></span></span><br><span class="line">  r[path].get(*args, &amp;b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以这样使用 eval 定义</span></span><br><span class="line">POSSIBLE_VERBS = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>]</span><br><span class="line"></span><br><span class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></span><br><span class="line">  <span class="comment"># 这种方式被称为 here 文档（here document, heredoc）</span></span><br><span class="line">  <span class="comment"># 在 eval 后面接一个字符串，&lt;&lt; 后面紧跟一个结束序列（terminal sequence）（在这里是 end_eval）</span></span><br><span class="line">  <span class="comment"># 下次再遇到结束列的时候，字符串定义结束</span></span><br><span class="line">  eval <span class="string">&lt;&lt;-end_eval</span></span><br><span class="line"><span class="string">		def <span class="subst">#&#123;m&#125;</span>(path, *args, &amp;b)</span></span><br><span class="line"><span class="string">			r[path].<span class="subst">#&#123;m&#125;</span>(*args, &amp;b)</span></span><br><span class="line"><span class="string">		end</span></span><br><span class="line"><span class="string">	end_eval</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定对象">绑定对象</h3>
<p><code>Binding</code> 就是一个用对象表示的完整作用域，可以通过 <code>Binding</code> 对象来捕获并带走当前的作用域，然后通过 <code>eval</code> 方法在这个 <code>Binding</code> 对象所携带的作用域中执行代码。</p>
<p>可以用 <code>Kernel#binding</code> 方法来创建 <code>Binding</code> 对象：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    <span class="variable">@x</span> = <span class="number">1</span></span><br><span class="line">    binding</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">b = MyClass.new.my_method</span><br></pre></td></tr></table></figure>
<p><code>Binding</code> 对象可以看做是比代码块更“纯净”的闭包，因为他只包含作用域，不包含代码。</p>
<p>可以将 <code>Binding</code> 对象传给 <code>eval</code> 方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">eval <span class="string">&quot;@x&quot;</span>, b  	<span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>Ruby 中还有一个常量 <code>TOPLEVEL_BINDING</code>，表示顶级作用于的 <code>Binding</code> 对象：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></span><br><span class="line">    eval <span class="string">&quot;self&quot;</span>, TOPLEVEL_BINDING</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">AnotherClass.new.my_method		<span class="comment"># =&gt; main</span></span><br></pre></td></tr></table></figure>
<h3 id="应该选择哪种-eval">应该选择哪种 <code>*eval</code></h3>
<p>现在有三种 <code>*eval</code>：<code>eval</code>、<code>instance_eval</code> 和 <code>class_eval</code>：</p>
<ol type="1">
<li><p><code>eval</code> 只能执行代码字符串，不能执行代码块；<code>instance_eval</code> 和 <code>class_eval</code> 除了执行代码块，也可以执行代码字符串</p></li>
<li><p>代码字符串中也可以像块那样访问局部变量：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">x = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">array.instance_eval <span class="string">&quot;self[1] = x&quot;</span></span><br><span class="line"></span><br><span class="line">array   <span class="comment"># =&gt; [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>能使用代码块就尽量用代码块，代码字符串安全性会有问题</p></li>
</ol>
<h4 id="代码注入">代码注入</h4>
<p>比如你写了一个方法，检查数组是否存在某方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">explore_array</span><span class="params">(method)</span></span></span><br><span class="line">  code = <span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].<span class="subst">#&#123;method&#125;</span>&quot;</span></span><br><span class="line">  puts <span class="string">&quot;Evaluating: <span class="subst">#&#123;code&#125;</span>&quot;</span></span><br><span class="line">  eval code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>结果用户输入了这样一个字符串：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">object_id; Dir.glob(*)</span><br><span class="line"><span class="comment"># 就会执行</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].object_id; Dir.glob(<span class="string">&quot;*&quot;</span>)		<span class="comment"># =&gt; 你的私有信息就会暴露在这里</span></span><br></pre></td></tr></table></figure>
<h4 id="防止代码注入">防止代码注入</h4>
<ol type="1">
<li>完全禁止 <code>eval</code>，根据具体的问题寻找替代方法，比如动态方法、动态派发</li>
<li>用下面的一些方法更安全地使用 <code>eval</code></li>
</ol>
<h4 id="污染对象和安全级别">污染对象和安全级别</h4>
<p>Ruby 会自动将不安全的对象（尤其是外部传入的对象）标记为污染对象，可以用 <code>Object#tainted?</code> 方法来判断一个对象是不是被污染了：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">user_input = <span class="string">&quot;User input <span class="subst">#&#123;gets()&#125;</span>&quot;</span></span><br><span class="line">puts user_input.tainted?			<span class="comment"># =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>可以通过给 <code>$SAFE</code> 全局变量赋值来设置一个安全级别，就可以禁止某些危险操作：</p>
<ul>
<li>默认 0，什么都可以做；在任何大于 0 的安全级别上，Ruby 都会拒绝执行污染的字符串</li>
<li>2 可以禁止绝大多数与文件相关的操作</li>
<li>最高 3，创建的每一个对象都是被污染的</li>
</ul>
<p>可以通过 <code>Object#untain</code> 方法来手动去除字符串的污染性。</p>
<p><strong>沙盒（Sandbox）</strong>指的就是通过使用安全级别为 <code>eval</code> 方法创造的一个可控环境。</p>
<p>比如 ERB 中对 HTML 模板中写的 Ruby 代码，会创建一个沙盒来执行：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ERB</span></span></span><br><span class="line">  <span class="comment"># new_toplevel 是顶级变量 TOPLEVEL_BINDING 的一个拷贝</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(b=new_toplevel)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@safe_level</span></span><br><span class="line">      <span class="comment"># 使用 Proc 作为一个洁净室</span></span><br><span class="line">      <span class="built_in">proc</span> &#123;</span><br><span class="line">        <span class="comment"># 这个安全级别只有 proc 中有效</span></span><br><span class="line">        <span class="variable">$SAFE</span> = <span class="variable">@safe_level</span></span><br><span class="line">        eval(<span class="variable">@src</span>, b, (<span class="variable">@filename</span> <span class="params">||</span> <span class="string">&#x27;(erb)&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">      &#125;.call</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      eval(<span class="variable">@src</span>, b, (<span class="variable">@filename</span> <span class="params">||</span> <span class="string">&#x27;erb&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h2 id="钩子方法">钩子方法</h2>
<p>有不少钩子方法，可以通过覆写这些方法在特定的时间完成一些操作，比如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  def <span class="keyword">self</span>.inherited(subclass)</span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;<span class="keyword">self</span>&#125;</span> was inherited by <span class="subst">#&#123;subclass&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line">  def <span class="keyword">self</span>.included(othermod)</span><br><span class="line">    puts <span class="string">&quot;M1 was included into <span class="subst">#&#123;othermod&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line">  def <span class="keyword">self</span>.prepended(othermod)</span><br><span class="line">    puts <span class="string">&quot;M2 was prepended to <span class="subst">#&#123;othermod&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另外还有 <code>Module#extend_object</code> <code>method_added</code> <code>method_removed</code> <code>undefined</code> 等方法。</p>
<p>如果需要捕获单件方法，则需要使用 <code>singleton_method_added</code> <code>singleton_methoded_removed</code> 等方法。</p>
<h2 id="例子">例子</h2>
<p>需要编写一个 <code>add_checked_attribute</code> 方法，为类添加一个经过校验的属性，下面是测试用例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;test/unit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCheckedAttribute</span> &lt; Test::Unit::<span class="title">TestCase</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span></span><br><span class="line">    add_checked_attribute(Person, <span class="symbol">:age</span>)</span><br><span class="line">    <span class="variable">@bob</span> = Person.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_accepts_valid_values</span></span></span><br><span class="line">    <span class="variable">@bob</span>.age = <span class="number">20</span></span><br><span class="line">    assert_equal <span class="number">20</span>, <span class="variable">@bob</span>.age</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_refuses_nil_values</span></span></span><br><span class="line">    assert_raises RuntimeError, <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">do</span></span><br><span class="line">      <span class="variable">@bob</span>.age = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_refuses_false_values</span></span></span><br><span class="line">    assert_raises RuntimeError, <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">do</span></span><br><span class="line">      <span class="variable">@bob</span>.age = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-eval-来完成">使用 <code>eval</code> 来完成</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_checked_attribute</span><span class="params">(klass, attribute, &amp;validation)</span></span></span><br><span class="line">  eval <span class="string">&quot;</span></span><br><span class="line"><span class="string">		class <span class="subst">#&#123;klass&#125;</span></span></span><br><span class="line"><span class="string">			def <span class="subst">#&#123;attribute&#125;</span>=(value)</span></span><br><span class="line"><span class="string">				raise &#x27;Invalid attribute&#x27; unless value</span></span><br><span class="line"><span class="string">				@<span class="subst">#&#123;attribute&#125;</span> = value</span></span><br><span class="line"><span class="string">			end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			def <span class="subst">#&#123;attribute&#125;</span>()</span></span><br><span class="line"><span class="string">				@<span class="subst">#&#123;attribute&#125;</span></span></span><br><span class="line"><span class="string">			end</span></span><br><span class="line"><span class="string">		end</span></span><br><span class="line"><span class="string">  &quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="去掉-eval">去掉 <code>eval</code></h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_checked_attribute</span><span class="params">(klass, attribute)</span></span></span><br><span class="line">  klass.class_eval <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">&quot;<span class="subst">#&#123;attribute&#125;</span>=&quot;</span> <span class="keyword">do</span> <span class="params">|value|</span></span><br><span class="line">      raise <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">unless</span> value</span><br><span class="line">      instance_variable_set(<span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span>, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method attribute <span class="keyword">do</span></span><br><span class="line">      instance_variable_get <span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="通过一个代码块来实现校验">通过一个代码块来实现校验</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;test/unit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCheckedAttribute</span> &lt; Test::Unit::<span class="title">TestCase</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span></span><br><span class="line">    add_checked_attribute(Person, <span class="symbol">:age</span>) &#123; <span class="params">|v|</span> v &gt;= <span class="number">18</span> &#125;</span><br><span class="line">    <span class="variable">@bob</span> = Person.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_refueses_invalid_values</span></span></span><br><span class="line">    assert_raises RuntimeError, <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">do</span></span><br><span class="line">      <span class="variable">@bob</span>.age = <span class="number">17</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_checked_attribute</span><span class="params">(klass, attribute, &amp;validation)</span></span></span><br><span class="line">  klass.class_eval <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">&quot;<span class="subst">#&#123;attribute&#125;</span>=&quot;</span> <span class="keyword">do</span> <span class="params">|value|</span></span><br><span class="line">      raise <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">unless</span> validation.call(value)</span><br><span class="line">      instance_variable_set(<span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span>, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method attribute <span class="keyword">do</span></span><br><span class="line">      instance_variable_get <span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="把内核方法改造成一个类宏让他对所有类都可以用">把内核方法改造成一个类宏，让他对所有类都可以用</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;test/unit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">	attr_checked <span class="symbol">:age</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">    v &gt;= <span class="number">18</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCheckedAttribute</span> &lt; Test::Unit::<span class="title">TestCase</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span></span><br><span class="line">    <span class="variable">@bob</span> = Person.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">attr_checked</span><span class="params">(attribute, &amp;validation)</span></span></span><br><span class="line">    define_method <span class="string">&quot;<span class="subst">#&#123;attribute&#125;</span>=&quot;</span> <span class="keyword">do</span> <span class="params">|value|</span></span><br><span class="line">      raise <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">unless</span> validation.call(value)</span><br><span class="line">      instance_variable_set(<span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span>, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    define_method attribute <span class="keyword">do</span></span><br><span class="line">      instance_variable_get <span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="写在一个模块中">写在一个模块中</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">  <span class="keyword">include</span> CheckedAttributes</span><br><span class="line">  </span><br><span class="line">  attr_checked <span class="symbol">:age</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">    v &gt;= <span class="number">18</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">CheckedAttributes</span></span></span><br><span class="line">  def <span class="keyword">self</span>.included(base)</span><br><span class="line">    base.extend ClassMethods</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attr_checked</span><span class="params">(attribute, &amp;validation)</span></span></span><br><span class="line">      define_method <span class="string">&quot;<span class="subst">#&#123;attribute&#125;</span>=&quot;</span> <span class="keyword">do</span> <span class="params">|value|</span></span><br><span class="line">        raise <span class="string">&#x27;Invalid attribute&#x27;</span> <span class="keyword">unless</span> validation.call(value)</span><br><span class="line">        instance_variable_set(<span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span>, value)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      define_method attribute <span class="keyword">do</span></span><br><span class="line">        instance_variable_get <span class="string">&quot;@<span class="subst">#&#123;attribute&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
  </entry>
  <entry>
    <title>翻译：RxJS 中的错误处理</title>
    <url>/hais-notebook/2021/03/03/RxJS-ErrorHandling/</url>
    <content><![CDATA[<p>本文是 <a href="https://blog.angular-university.io/rxjs-error-handling/">RxJS Error Handling</a> 的翻译。 主要介绍了 catchError、throwError、Finalize、retryWhen、delayWhen 等操作符，以及捕获并替代策略、捕获并重抛策略、重试策略等错误处理方法。</p>
<span id="more"></span>
<h1 id="observable-中的约定与错误处理">Observable 中的约定与错误处理</h1>
<p>为了理解 RxJS 中的错误处理，我们需要先知道尽管数据流可以不发送值，也可以发送多个值，但 <strong>一个数据流（stream）只能输出一次错误</strong>。我们做出如此的约定，因为在实践中我们所观察（observe）的所有的流都是这样工作的，比如可能发生错误的网络请求等。</p>
<p>一个流可以顺利完成（complete），这意味着：</p>
<ul>
<li>一个流结束了他的生命周期，在此期间没有发生任何错误</li>
<li>结束之后，这个流将不会再发出别的值</li>
</ul>
<p>一个流也可以报错（error out）：</p>
<ul>
<li>流带着一个错误结束了他的生命周期</li>
<li>当错误被抛出之后，这个流将不会再发出别的值</li>
</ul>
<p>注意 <strong>完成</strong> 和 <strong>报错</strong> 是互斥的：</p>
<ul>
<li>当流完成之后，他不能再报错</li>
<li>当流报错之后，他不能再完成</li>
</ul>
<p>同样需要注意流没有义务去“完成”或者“报错”，这两种可能性均是可选的，但是他们中只有一种情况会出现（是不是有点像薛定谔的猫，你永远不知道一个异步请求会成功还是报错(笑)）。</p>
<p>这意味着，根据 Observable 的约定，当某个流报错之后，我们就不能再使用它了。现在，你一定在考虑一个问题——那么如何来让他从错误中恢复过来呢？</p>
<h1 id="rxjs-中的-subscribe-方法与-error-回调">RxJS 中的 subscribe 方法与 error 回调</h1>
<p>现在，我们首先来创建一个流并订阅（subscribe）他。记住 subscribe 方法接受 3 个可选的参数：</p>
<ul>
<li>一个处理成功的函数，每当流发送一个值时就会调用这个函数</li>
<li>一个处理错误的函数，只有当错误发生的时候才会调用，这个函数将会接受错误（error）本身作为参数</li>
<li>一个处理完成的函数，只有当流完成的时候才会调用</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./home.component.html&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HomeComponent</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">    http$.<span class="title function_">subscribe</span>(</span><br><span class="line">      <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">      <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完成行为的举例">完成行为的举例</h2>
<p>当这个流没有报错，你可以在控制台看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP response &#123; payload: Array(9) &#125;</span><br><span class="line">HTTP HTTP request completed.</span><br></pre></td></tr></table></figure>
<p>这个 HTTP 流只发送了一个值，随即结束，这意味着他没有发生错误。</p>
<p>但如果他抛出一个错误会怎么样呢？在这种情况下，我们可以在控制台中看到这样的东西：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-1.png" /></p>
<p>此时流并没有发出任何值，并且立即报错。在报错之后，他没有执行完成回调。</p>
<h2 id="subscribe-方法中的-error-回调函数的局限性">subscribe 方法中的 error 回调函数的局限性</h2>
<p>有时候给 subscribe 传递 error 回调已经满足了我们处理错误的需求，但这种错误处理的方法是有局限性的。比如我们不能从错误信息中恢复过来，也不能发送另一个备用的值（fallback value）来替代我们原先希望从后端获取的值。</p>
<h1 id="catcherror-操作符">catchError 操作符</h1>
<p>在同步编程中，我们可以使用 <code>try</code> 语句来包裹代码，用 <code>catch</code> 来获取并处理可能发生的错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  <span class="keyword">const</span> httpResponse = <span class="title function_">getHttpResponseSync</span>(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个机制非常强大，这样我们就可以在一个地方处理 <code>try/catch</code> 代码块中发生的任何错误了。</p>
<p>但问题在于，Javascript 中很多操作都是异步的，HTTP 请求就是其中的一个。</p>
<p>RxJS 则通过 <code>catchError</code> 操作符提供了一些类似的功能。</p>
<h2 id="catcherror-是如何工作的">catchError 是如何工作的？</h2>
<p>与其他的 RxJS 运算符一样，<code>catchError</code> 只是一个输入 Observable，然后输出 Observable 的函数。</p>
<p>每次调用 <code>catchError</code> 的时候，需要传给他一个错误处理函数（error handling function）。</p>
<p><code>catchError</code> 操作符将可能报错的 Observable 作为输入，然后开始在他输出的 Observable 中发出输入的 Observable 的值。</p>
<p>如果没有错误发生，他输出的 Observable 跟输入的 Observable 将以同样的方式工作。</p>
<h2 id="当错误发生时会怎样">当错误发生时会怎样？</h2>
<p>然而，当错误发生时，<code>catchError</code> 逻辑开始生效。<code>catchError</code> 操作符将会拿到这个错误，并将其传递给错误处理函数。</p>
<p>这个函数需要返回一个 Observable，他返回的 Observable 将会代替出错的流。</p>
<p>显然根据 Observable 约定，我们不能在使用已经出错的输入 <code>catchError</code> 的那个流。</p>
<p>错误处理函数返回的替代的 Observable 将会随即被订阅（subscribe）并且它发出的值将会代替已经报错的输入的 Observable。</p>
<h1 id="捕获并替代策略the-catch-and-replace-strategy">捕获并替代策略（The Catch and Replace Strategy）</h1>
<p>来看一个 <code>catchError</code> 用来提供替代的 Observable 并发出备用值的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">of</span>([]))</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们可以将「捕获并替代策略」分解如下：</p>
<ul>
<li>传递给 <code>catchError</code> 操作符一个错误处理函数</li>
<li>这个错误处理函数并不会立即调用，通常也不会调用</li>
<li>只有输入 <code>catchError</code> 的 Observable 发生错误时，才会调用错误处理函数</li>
<li>如果输入的流发生错误，错误处理函数将会返回一个用 <code>of([])</code> 构造的 Observable</li>
<li>这个 <code>of()</code> 函数只会返回一个值（<code>[]</code>），然后完成</li>
<li>错误处理函数返回的恢复 Observable（<code>of([])</code>）将会被 <code>catchError</code> 操作符订阅（subscribe）</li>
<li><code>catchError</code> 将会把恢复 Observable 的值作为替代值发出</li>
</ul>
<p>最终，<code>http$</code> Observable 将不会报错，我们可以在控制台看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP response []</span><br><span class="line">HTTP request completed.</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>subscribe()</code> 中的错误处理回调不再被调用，而是发生了下面的操作：</p>
<ul>
<li>一个空数组 <code>[]</code> 被发出</li>
<li><code>http$</code> Observable 随即结束</li>
</ul>
<p>尽管最初的 <code>https$</code> 确实报错了，但替代的 Observable 为 <code>http$</code> 的订阅者（subscriber）提供了一个默认的备用值（<code>[]</code>）。</p>
<p>注意我们也可以在返回替代的 Observable 之前做一些其他的错误处理。</p>
<p>这就是「捕获并替代策略」，接下来我们看看如何使用 <code>catchError</code> 来重新抛出一个错误，而不是提供替代的值。</p>
<h1 id="捕获并重抛策略the-catch-and-rethrow-strategy">捕获并重抛策略（The Catch and Rethrow Strategy）</h1>
<p>注意上面我们通过 <code>catchError</code> 提供的替代 Observable 也可能会报错——就像其他任何 Observable 一样。</p>
<p>此时，错误将会被广播给 <code>catchError</code> 输出的 Observable 的订阅者。</p>
<p>这种错误广播的行为给了我们一种在本地处理错误之后，重新抛出被 <code>catchError</code> 捕获的错误的机制。我们可以这样搞：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handling error locally and rethrowing it...&#x27;</span>, err)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">throwError</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="拆解捕获并重抛策略">拆解捕获并重抛策略</h2>
<p>来一步步拆解这个「捕获并重抛策略」：</p>
<ul>
<li>像之前一样，我们正在捕获一个错误，并且返回一个替代的 Observable</li>
<li>但这次，我们在 <code>catchError</code> 函数中对这个错误进行本地处理，而不是提供一个像 <code>[]</code> 这样的替代值</li>
<li>在这个案例中，我们只是简单地在控制台输出错误，但是我们也可以增加任何我们需要的错误处理逻辑，比如向用户展示错误信息等</li>
<li><code>throwError</code> 创建了一个不会发出任何值的 Observable，并且会立即报出与 <code>catchError</code> 捕获的错误一样的错</li>
<li>这意味着 <code>catchError</code> 输出的 Observable 也会报与输入的 Observable 一样的错</li>
<li>这意味着我们终于成功地将 <code>catchError</code> 输入的 Observable 的最初的报错 <strong>重新抛给</strong> 输出的 Observable</li>
</ul>
<p>我们可以在控制台得到：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-2.png" /></p>
<h1 id="在-observable-链条中使用多次-catcherror">在 Observable 链条中使用多次 catchError</h1>
<p>注意我们可以在 Observable 链条中的不同节点根据需要多次使用 catchError，他们可以使用不同的策略。</p>
<p>比如我们可以在 Observable 链条上游中捕获错误，处理并且重抛他，然后在下游捕获同样的错误（这次我们提供一个替代的值，不再重抛他）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="string">&#x27;payload&#x27;</span>]),</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handling error locally and rethrowing it...&#x27;</span>, err)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">throwError</span>(err)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught rethrown error, providing fallback value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">of</span>([])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-3.png" /></p>
<p>我们可以看到，错误事实上最开始被重抛了，但错误并没有到达 subscribe 的错误处理函数，而是发出了 <code>[]</code> 这个替代值。</p>
<h1 id="finalize-操作符">Finalize 操作符</h1>
<p>除了错误处理中的 <code>catch</code> 代码块之外，同步 Javascript 语法还提供了 <code>finally</code> 代码块来包裹一定会被执行的代码。</p>
<p><code>finally</code> 代码块在释放昂贵资源的时候特别有用，比如关闭网络请求或释放内存。</p>
<p>与 <code>catch</code> 代码块中的代码不同，<code>finally</code> 代码块中的的执行不受报错的影响。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  <span class="keyword">const</span> httpResponse =  <span class="title function_">getHttpResponseSync</span>(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// 处理错误，只有当错误发生的时候才会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 不管什么情况下都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RxJS 也提供了像 <code>finally</code> 一样功能的操作符——<code>finalize</code> 操作符。</p>
<blockquote>
<p>由于是 <code>finally</code> 是保留字，因此不能使用。</p>
</blockquote>
<h2 id="finalize-操作符的例子">Finalize 操作符的例子</h2>
<p>就像 <code>catchError</code> 操作符一样，为了让不同的资源正确释放，我们可以在 Observable 链条中的不同位置添加多个 <code>finalize</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="string">&#x27;payload&#x27;</span>]),</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught mapping error and rethrowing&#x27;</span>, err)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">throwError</span>(err)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">finalize</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first finalize() block executed&#x27;</span>)),</span><br><span class="line">    <span class="title function_">catchError</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught rethrown error, providing fallback value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">of</span>([])</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">finalize</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second finalize() block executed&#x27;</span>))</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-4.png" /></p>
<p>注意 <code>finalize</code> 代码块在 subscribe 成功回调和完成回调之后执行</p>
<h1 id="重试策略the-retry-strategy">重试策略（The Retry Strategy）</h1>
<p>除了重抛错误与提供备用值以外，我们还可以重试已经报错的 Observable。</p>
<p>我们知道，一旦流报错，我们不能再恢复他，但我们可以重新从流的源头订阅一次，并创建一个新的流。</p>
<p>它是这样工作的：</p>
<ul>
<li>我们拿到一个输入的 Observable，然后订阅（subscribe）他，创建一个新的流</li>
<li>如果流没有报错，我们让他的结果在输出的时候展现</li>
<li>但如果流报错了，我们需要去重新订阅这个输入的 Observable，然后创建一个新的流</li>
</ul>
<h2 id="什么时候重试">什么时候重试？</h2>
<p>一个大问题是，我们什么时候重新订阅这个输入的 Observable，然后重新执行？</p>
<ul>
<li>马上重试？</li>
<li>等一小会儿，期待着这个问题被解决，然后再重试？</li>
<li>只重试限定的次数，然后报错？</li>
</ul>
<p>为了解决这些问题，我们需要一个辅助的 Observable，我们叫他「通知者」（Notifier Observable），他会决定什么时候重试。</p>
<p>作为整个「重试策略」的核心 <code>retryWhen</code> 将会使用这个「通知者」。</p>
<h1 id="rxjs-retrywhen-操作符的子弹图">RxJS retryWhen 操作符的子弹图</h1>
<p>为了理解 <code>retryWhen</code> Observable 的工作机制，我们可以看看他的子弹图：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-5.png" /></p>
<p>注意被重试的 Observable 是第二条线的 Observable 1-2，而不是第一条线的 Observable。</p>
<p>第一条线的发出 r-r 值的 Observable 是「通知者」，他会决定什么时候重试。</p>
<h2 id="拆解-retrywhen-是如何工作的">拆解 retryWhen 是如何工作的</h2>
<ul>
<li>Observable 1-2 被订阅，然后他的值被立即反射在 <code>retryWhen</code> 的输出 Observable 中</li>
<li>甚至在 Observable 1-2 结束之后，他仍然可以被重试</li>
<li>订阅者在 Observable 1-2 结束之后发出值 <code>r</code></li>
<li>订阅者发出的值可以是任何形式的（在这里就是 <code>r</code>）</li>
<li>重要的是 <code>r</code> 发出的时机，因为这就是 Observable 1-2 重试的时机</li>
<li>Observable 1-2 被 <code>retryWhen</code> 重新订阅，他的值又会被重新反射到 <code>retryWhen</code> 的输出 Observable 中</li>
<li>然后，订阅者最终还是结束了</li>
<li>在这个时候，正在进行中的 Observable 1-2 重试也被提早结束，意味着只发出了 1，而不会发出 2</li>
</ul>
<p>我们可以看到，<code>retryWhen</code> 只是在观察着发出值的时候重试输入的 Observable。</p>
<p>既然我们理解了 <code>retryWhen</code> 是如何工作的，我们现在来创建一个「通知者」</p>
<h1 id="创建一个通知者notification-observable">创建一个通知者（Notification Observable）</h1>
<p>我们需要在传递给 <code>retryWhen</code> 操作符的函数中直接创建一个通知者。这个函数将一个 Errors Observable（发出输入的 Observable 的错误的 Observable）作为参数。</p>
<p>然后通过订阅这个 Errors Observable，我们可以准确地知道什么时候发生了错误。我们现在来看看如何实施一个「立即重试策略」</p>
<h1 id="立即重试策略immediate-retry-strategy">立即重试策略（Immediate Retry Strategy）</h1>
<p>为了在错误发生之后立即重试，我们只需要返回这个 Errors Observable 即可。</p>
<p>在这个案例中，我们使用 <code>tap</code> 操作符来打 log，因此 Errors Observable 还是不变的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">tap</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HTTP request executed&quot;</span>)),</span><br><span class="line">    <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(res[<span class="string">&#x27;payload&#x27;</span>])),</span><br><span class="line">    <span class="title function_">shareReplay</span>(),</span><br><span class="line">    <span class="title function_">retryWhen</span>(<span class="function"><span class="params">errors</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors</span><br><span class="line">        .<span class="title function_">pipe</span>(</span><br><span class="line">          <span class="title function_">tap</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;retrying...&#x27;</span>))</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们从 <code>retryWhen</code> 函数返回的 Observable 就是「通知者」（Notification Observable）。</p>
<p>他发出的值并不重要，重要的是只有他发出的时机，因为这就是重试的时机。</p>
<h2 id="立即重试策略的控制台输出内容">立即重试策略的控制台输出内容</h2>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-6.png" /></p>
<p>我们可以看到，HTTP 请求最开始错误了，但是后来尝试了一次，并且第二次的请求成功了。</p>
<p>可以看看两次尝试之间的延迟：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-7.png" /></p>
<h1 id="延迟重试策略delayed-retry-strategy">延迟重试策略（Delayed Retry Strategy）</h1>
<p>让我们来实施另一个错误恢复策略，比如在错误发生之后等待 2 秒再重试。</p>
<p>这个策略在一些从一些特定的错误（比如服务器拥塞导致的请求失败）上恢复的时候特别有效。</p>
<p>在某些错误间歇性发生的案例中，我们可以简单地在一小段延迟之后重试，然后第二次请求可能就没问题了。</p>
<h1 id="计时器timer-observable创建函数">计时器（Timer Observable）创建函数</h1>
<p>为了实施延迟重试策略，我们需要创建一个错误发生之后 2 秒再发出值的通知者。</p>
<p>接下来我们来尝试用 <code>timer</code> 来创建一个通知者，这个 <code>timer</code> 函数接受两个值：</p>
<ul>
<li>一个在第一个值发出之前的初始延迟</li>
<li>一个我们希望周期性发出值时的周期性延迟</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-8.png" /></p>
<p>我们可以看到，第一个值 0 在 3 秒之后才发出，然后每隔 1 秒发出一个值。</p>
<p>注意第二个参数是可选的，比如在我们希望在只发出一个值 0 之后就结束。</p>
<p>接下来我们来看看如何如何结合 <code>retryWhen</code> 和 <code>delayWhen</code> 操作符。</p>
<h1 id="delaywhen-操作符">delayWhen 操作符</h1>
<p>一件很重要的事情就是，定义通知者的函数只会被调用一次，因此我们只有一次机会来定义这个确定何时重试的通知者。</p>
<p>我们将要获取 Errors Observable，然后应用在 <code>delayWhen</code> 操作符上来定义通知者。</p>
<p>来在这张子弹图上想一想，源 Observable a-b-c 是 Errors Observable，会随着时间发出失败的 HTTP 错误：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-9.png" /></p>
<h2 id="delaywhen-操作符的拆解">delayWhen 操作符的拆解</h2>
<p>我们通过这张图来学习一下：</p>
<ul>
<li>输入的 Errors Observable 的每个值都会被延迟之后展示在输出 Observable 中</li>
<li>每个值的延迟可以不同，并且将会被用非常灵活的方式创建</li>
<li>为了确定延迟，我们将会每个输入的 Errors Observable 的值调用传递给 <code>delayWhen</code> 的函数（也叫作持续时间选择函数，duration selector function））</li>
<li>这个函数将会发出一个将会决定每个值发出之后的延迟</li>
<li>a-b-c 中的每一个值都有自己的持续时间选择器（duration selector Observable），他最终会发出一个值（可以是任何值），然后结束</li>
<li>当三个持续时间选择器中的每个发出值的时候，对应的输入值 a-b-c 就会在最后的输出中展示</li>
<li>注意值 <code>b</code> 在 <code>c</code> 之后出现，这是很正常的</li>
<li>因为 <code>b</code> 持续时间选择器在 <code>c</code> 持续时间选择器之后发出值</li>
</ul>
<h2 id="实施延迟重试策略">实施延迟重试策略</h2>
<p>让我们现在来把这些都放到一起，看看我们怎样按顺序在 2 秒后重试每一个发生错误的 HTTP 请求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="property">get</span>&lt;<span class="title class_">Course</span>[]&gt;(<span class="string">&#x27;/api/courses&#x27;</span>)</span><br><span class="line">http$</span><br><span class="line">  .<span class="title function_">pipe</span>(</span><br><span class="line">    <span class="title function_">tap</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HTTP request executed&quot;</span>)),</span><br><span class="line">    <span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(res[<span class="string">&#x27;payload&#x27;</span>])),</span><br><span class="line">    <span class="title function_">shareReplay</span>(),</span><br><span class="line">    <span class="title function_">retryWhen</span>(<span class="function"><span class="params">errors</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors</span><br><span class="line">        .<span class="title function_">pipe</span>(</span><br><span class="line">          <span class="title function_">delayWhen</span>(<span class="function">() =&gt;</span> <span class="title function_">timer</span>(<span class="number">2000</span>)),</span><br><span class="line">          <span class="title function_">tap</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;retrying...&#x27;</span>)),</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP response&#x27;</span>, res),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP Error&#x27;</span>, err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP request completed.&#x27;</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>来拆解一下：</p>
<ul>
<li>传给 <code>retryWhen</code> 的函数只会调用一次</li>
<li>我们在那个函数中返回一个 Observable，他在任何需要重试的时候就会发送值</li>
<li>每当出现一个错误，<code>delayWhen</code> 操作符就会通过调用 <code>timer</code> 函数来创建一个持续时间选择器（duration selector Observable）</li>
<li>这个持续时间选择器将会在 2 秒后发出 0，然后结束</li>
<li>每当这发生的时候，delayWhen Observable 就会知道输入的错误的延迟已经结束了</li>
<li>只有当延迟结束之后，错误才会在通知者的输出中出现</li>
<li>一旦通知者中的值发出，<code>retryWhen</code> 操作符就会执行重试</li>
</ul>
<h2 id="延迟策略的控制台输出内容">延迟策略的控制台输出内容</h2>
<p>下面是某个 HTTP 请求，重试了 5 次，并且其中 4 次报错的情况：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-10.png" /></p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-11.png" /></p>
<p>可以看到与预期一样，重试在错误发生 2 秒之后才会进行。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>RxJS</title>
    <url>/hais-notebook/2021/05/13/RxJS-Overview/</url>
    <content><![CDATA[<p>One Core Type: Observable.</p>
<p>Satellite Types: Observer, Schedulers, Subjects.</p>
<p>Operators: map, filter, reduce, every, etc.</p>
<span id="more"></span>
<h1 id="observable">Observable</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>SINGLE</th>
<th>MULTIPLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pull</td>
<td>Function</td>
<td>Iterator</td>
</tr>
<tr class="even">
<td>Push</td>
<td>Promise</td>
<td>Observable</td>
</tr>
</tbody>
</table>
<p>一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意：当 subscribed 的时候，Observable push 1, 2, 3 的过程是同步执行的！ </span></span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="number">4</span>);</span><br><span class="line">    subscriber.<span class="title function_">complete</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;just before subscribe&#x27;</span>);</span><br><span class="line">observable.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;got value &#x27;</span> + x); &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">err</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;something wrong occurred: &#x27;</span> + err); &#125;,</span><br><span class="line">  <span class="title function_">complete</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;just after subscribe&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">just before subscribe</span><br><span class="line">got value 1</span><br><span class="line">got value 2</span><br><span class="line">got value 3</span><br><span class="line">just after subscribe</span><br><span class="line">got value 4</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="pull-和-push">Pull 和 Push</h2>
<p>在描述 <strong>数据生产者(Producer)</strong> 和 <strong>数据消费者(Consumer)</strong> 之间的沟通时，有 <strong>Pull</strong> 和 <strong>Push</strong> 两种不同的方案。</p>
<h3 id="pull">Pull</h3>
<p>消费者决定了何时从生产者那里拿数据。</p>
<p>比如每个 JS 函数就是一个 Pull System：函数是数据的生产者，调用函数的地方从函数那里 pull <strong>一个</strong> 返回值。 ES6 引入的 generator 函数和迭代器也是一种 Pull System：消费者调用 <code>iterator.next()</code>，从迭代器那里 pull <strong>多个</strong> 值。</p>
<h3 id="push">Push</h3>
<p>生产者决定了何时发送数据给消费者。</p>
<p>比如 Promise(生产者) 给 回调函数(消费者) 传输数据，Promise 掌控了 push 数据的时机。 Observable(生产者) 给 Observer(消费者) 传输数据。</p>
<h2 id="observable-与函数">Observable 与函数</h2>
<blockquote class="blockquote-center">
<p>function.call() 表示 <em>同步地给我一个值</em> observable.subscribe() 表示 <em>同步或异步地给我一堆值</em></p>

</blockquote>
<h3 id="observable-与函数的相同点">Observable 与函数的相同点</h3>
<h4 id="懒执行">懒执行</h4>
<p>如果不 call Function，那么函数就不会执行； 如果不 subscribe Observable，那么 Observable 中注册的回调函数也不会执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo.<span class="title function_">call</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="keyword">const</span> y = foo.<span class="title function_">call</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">foo.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.<span class="title function_">subscribe</span>(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行上面两段代码的结果是一样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<h4 id="每个-subscribing-都是独立的">每个 subscribing 都是独立的</h4>
<p>就像每次 Function calling 都是独立的一样，每次 Observable subscribing 也是独立的，他们之间的副作用互不干扰——这与 EventEmitter 不同。</p>
<h4 id="observable-可同步可异步">Observable 可同步可异步</h4>
<p>Observable 并不是都是异步的，如果没有引入其他异步数据源，他其实是同步的，这跟 Function 也是类似的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">call</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上两段代码运行的结果也是一样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure>
<h3 id="observable-与函数的不同点">Observable 与函数的不同点</h3>
<h4 id="observable-可以发出多个值">Observable 可以发出多个值</h4>
<p>在函数中，我们不能这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// dead code. will never happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在 Observable 却可以这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">100</span>); <span class="comment">// &quot;return&quot; another value</span></span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">200</span>); <span class="comment">// &quot;return&quot; yet another</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure>
<h4 id="observable-可以异步发出值">Observable 可以异步发出值</h4>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">100</span>);</span><br><span class="line">  subscriber.<span class="title function_">next</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="number">300</span>); <span class="comment">// happens asynchronously</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br><span class="line">300</span><br></pre></td></tr></table></figure>
<h2 id="创建-observablecreating">创建 Observable：Creating</h2>
<p>Observable 构造函数只需要一个参数：subscribe 函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Observable，他会给一个 subscriber 每秒钟都发出 &quot;hi&quot;</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="keyword">function</span> <span class="title function_">subscribe</span>(<span class="params">subscriber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="订阅-observablesubscribing">订阅 Observable：Subscribing</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">observable.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x));</span><br></pre></td></tr></table></figure>
<p>当调用 <code>observable.subscribe</code> 的时候，subscribe 函数会用给定的 subscriber 运行，并且每次调用都是独立的。 与 <code>addEventListener</code> 这种 API 不一样，Observer 并没有注册为一个 listener，Observable 里面也没有维护 Observer 的列表。</p>
<h2 id="执行-observableexecuting">执行 Observable：Executing</h2>
<p>在 <code>new Observable(function subscribe(subscriber) &#123;...&#125;)</code> 中的代码表示一个 Observable execution。</p>
<p>Observable Execution 可以发出三种类型的值： - "Next" 通知：会伴随一个 Number、String、Object 等类型的值 - "Error" 通知：会伴随一个 JS Error 或者异常 - "Complete" 通知：不会伴随任何值</p>
<p>通常来说，Execution 会随着时间通过 Next 通知发出多个值。但当发出 Error 或者 Complete 通知之后，就不会再发出值了。</p>
<h2 id="释放-executionsdisposing-executions">释放 Executions：Disposing Executions</h2>
<p>当调用 <code>observable.subscribe</code> 之后，Observer 会跟一个新创建的 Observable execution 绑定。并且返回一个 <code>Subscription</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = observable.<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x));</span><br></pre></td></tr></table></figure>
<p>Subscription 就代表了正在执行的 execution。 - 可以通过 <code>subscription.unsubscribe()</code> 来取消正在执行的 execution。 - Complete 或 Error 也会取消 execution。</p>
<p>我们有时候需要自定义一个 <code>unsubscribe</code> 函数来在取消 execution 的时候释放资源。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="keyword">function</span> <span class="title function_">subscribe</span>(<span class="params">subscriber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数会在 unsubscribe 的时候执行，清除掉 interval</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="observer">Observer</h1>
<p>Observer 是 Observable 发出数据的消费者，其实就是一个对象，对象包含了三个分别用于处理 Observable 三种通知类型的回调函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = &#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Observer got a next value: &#x27;</span> + x),</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Observer got an error: &#x27;</span> + err),</span><br><span class="line">  <span class="attr">complete</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Observer got a complete notification&#x27;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observable.<span class="title function_">subscribe</span>(observer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然也可以直接将回调函数作为参数传进去，他会自动帮我们创建 Observer 对象</span></span><br><span class="line">observable.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Observer got a next value: &#x27;</span> + x))</span><br></pre></td></tr></table></figure>
<h1 id="operators">Operators</h1>
<p>Operator 就是函数。有两种类型的 Operator： - Pipeable Operator：不会改变原来的 Observable 实例，他接受一个 Observable 作为参数，然后再返回一个 Observable - Creation Operator：会创建一个新的 Observable</p>
<h2 id="高阶-observable">高阶 Observable</h2>
<p>可以这样构造一个高阶 Observable，用 map 返回一个 Observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clicks = <span class="title function_">fromEvent</span>(<span class="variable language_">document</span>, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> higherOrder = clicks.<span class="title function_">pipe</span>(<span class="title function_">map</span>(<span class="function"><span class="params">ev</span> =&gt;</span> <span class="title function_">of</span>(ev)));</span><br></pre></td></tr></table></figure>
<p>这时候就需要用例如 concatAll 等操作符将其拍平。</p>
<h1 id="subscription">Subscription</h1>
<p>Subscription 通常是一个 Observable 的 Execution，主要是用来调用释放资源 API <code>unsubscribe</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = <span class="title function_">interval</span>(<span class="number">400</span>).<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first: &#x27;</span> + x));</span><br><span class="line"><span class="keyword">const</span> childSubscription = <span class="title function_">interval</span>(<span class="number">300</span>).<span class="title function_">subscribe</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second: &#x27;</span> + x));</span><br><span class="line"></span><br><span class="line">subscription.<span class="title function_">add</span>(childSubscription);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 同时 unsubscribe subcription 和 childSubscription</span></span><br><span class="line">  subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="subject">Subject</h1>
<p>Subject 是一种特殊的 Observable，他可以向多个 Observer 以多播的形式发出值——而普通的 Observable 是单播，每个订阅的 Observer 对这个 Observable 都有自己独立的 Execution。</p>
<ul>
<li><strong>每个 Subject 都是 Observable</strong>。你可以 <code>subscribe</code> 一个 Subject。对于 Subject 来说，<code>subscribe</code> 并不会产生一个新的 Execution，他会将这个 Observer 注册到一个 ObserverList，就像 <code>addListner</code> 一样</li>
<li><strong>每个 Subject 都是 Observer</strong>。他有 <code>next()</code> <code>error()</code> <code>complete()</code> 方法。只需要调用 <code>next()</code>，就会广播给所有已经注册了的 Observer。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 Subject 都是 Observable：可以 subscribe 他</span></span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个 Subject 都是 Observer：调用他的 next() 方法，就会广播给所有已经注册的 Observer</span></span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerB: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个 Subject 都是 Observer：可以把他传给 subscribe 函数</span></span><br><span class="line"><span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).<span class="title function_">subscribe</span>(subject);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerB: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br><span class="line"><span class="comment">// observerA: 3</span></span><br><span class="line"><span class="comment">// observerB: 3</span></span><br></pre></td></tr></table></figure>
<h2 id="多播-observable">多播 Observable</h2>
<p>注意！在 RxJS 7 已经将多播 API 进行了调整！<a href="https://rxjs.dev/guide/subject#multicasted-observables">文档</a>中的 <code>multicast</code> 操作符将不再适用。详情请查看 <a href="https://rxjs.dev/deprecations/multicasting">这篇文档</a>。</p>
<h3 id="connectable">connectable</h3>
<p>可以通过 connectable 创建一个可以多播的 Observable：</p>
<h2 id="behaviorsubject">BehaviorSubject</h2>
<p>他会保存发给消费者的最后一个值，并且当一个新的 Observer subscribe 的时候，他会从 <code>BehaviorSubject</code> 那里立即接收到这个值。</p>
<blockquote>
<p>BehaviorSubject 非常适合用于表示 “随着时间发出值”。比如表示 “生日” 事件的流是 Subject，但表示 “年龄” 的流是 BehaviourSubject。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 0 表示初始值</span></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">BehaviorSubject</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">subscribe</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;subscribe1&#x27;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">  subject.<span class="title function_">subscribe</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;subscribe2&#x27;</span>, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// subscribe1 0</span></span><br><span class="line"><span class="comment">// next!</span></span><br><span class="line"><span class="comment">// subscribe1 1</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// subscribe2 1</span></span><br><span class="line"><span class="comment">// after</span></span><br></pre></td></tr></table></figure>
<h2 id="replaysubject">ReplaySubject</h2>
<p>他跟 <code>BehaviorSubject</code> 很像，不同的是 <code>BehaviourSubject</code> 只会保存最后一个值，而 <code>ReplaySubject</code> 会保存很多个值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">ReplaySubject</span>(<span class="number">3</span>, <span class="number">500</span>); <span class="comment">// 会缓存 3 个最新的值，最久保存 500ms</span></span><br><span class="line"> </span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerA: 3</span></span><br><span class="line"><span class="comment">// observerA: 4</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br><span class="line"><span class="comment">// observerB: 3</span></span><br><span class="line"><span class="comment">// observerB: 4</span></span><br><span class="line"><span class="comment">// observerA: 5</span></span><br><span class="line"><span class="comment">// observerB: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="asyncsubject">AsyncSubject</h2>
<p>当 Observable execution complete 的时候才会发出值，并且只会发出最后一个值——这跟 <code>last()</code> 操作符差不多。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">AsyncSubject</span>();</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">next</span>(<span class="number">5</span>);</span><br><span class="line">subject.<span class="title function_">complete</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 5</span></span><br><span class="line"><span class="comment">// observerB: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="void-subject">Void Subject</h2>
<p>简单来说，Subject 可以发出空值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>&lt;<span class="built_in">void</span>&gt;();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> subject.<span class="title function_">next</span>(), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="scheduler">Scheduler</h1>
<p>Scheduler 可以控制 subscription 开始和发出值的时间：</p>
<ul>
<li><strong>Scheduler 是一个数据结构</strong>：他知道如何存储数据，并可以基于优先级来管理任务队列</li>
<li><strong>Scheduler 是一个执行上下文</strong>：他代表了任务在何时、何地执行（比如立即、或在某个回调中）</li>
<li><strong>Scheduler 有一个虚拟时钟</strong>：他提供了 <code>noew()</code> 函数来表示时间，由 Scheduler 管理的任务都依附于这个时间。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span>, asyncScheduler &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observeOn &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 proxyObserver 实际上是由 observeOn(asyncScheduler) 根据 finalObserver 创建的</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function">(<span class="params">proxyObserver</span>) =&gt;</span> &#123;</span><br><span class="line">  proxyObserver.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">  proxyObserver.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line">  proxyObserver.<span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">  proxyObserver.<span class="title function_">complete</span>();</span><br><span class="line">&#125;).<span class="title function_">pipe</span>(</span><br><span class="line">  <span class="title function_">observeOn</span>(asyncScheduler)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> finalObserver = &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;got value &#x27;</span> + x)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;something wrong occurred: &#x27;</span> + err);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">complete</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;just before subscribe&#x27;</span>);</span><br><span class="line">observable.<span class="title function_">subscribe</span>(finalObserver);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;just after subscribe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LOGS:</span></span><br><span class="line"><span class="comment">// just before subscribe</span></span><br><span class="line"><span class="comment">// just after subscribe</span></span><br><span class="line"><span class="comment">// got value 1</span></span><br><span class="line"><span class="comment">// got value 2</span></span><br><span class="line"><span class="comment">// got value 3</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure>
<p>一个 <code>observeOn(asyncScheduler)</code> 创建的 <code>proxyObserver</code> 可以近似理解为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyObserver = &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    asyncSheduler.<span class="title function_">shedule</span>(</span><br><span class="line">      <span class="function">(<span class="params">x</span>) =&gt;</span> finalObserserver.<span class="title function_">next</span>(x),</span><br><span class="line">      <span class="number">0</span>, <span class="comment">// 延迟</span></span><br><span class="line">      val, <span class="comment">// 会传给上面的 x</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的 Scheduler 是通过 <code>setTimeout</code> 或 <code>setInterval</code> 操作，因此就算延迟是 0，也是异步操作。</p>
<h2 id="scheduler-的类型">Scheduler 的类型</h2>
<table>
<thead>
<tr class="header">
<th>SCHEDULER</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null</td>
<td>通知都是同步地、递归地发出的，用于正常时间的操作和尾递归</td>
</tr>
<tr class="even">
<td>queueScheduler</td>
<td>以队列的形式在当前事件帧安排，用于迭代操作</td>
</tr>
<tr class="odd">
<td>asapScheduler</td>
<td>在同 promise 一样的微任务队列中安排，用于异步会话</td>
</tr>
<tr class="even">
<td>asyncScheduler</td>
<td>使用 <code>setInterval</code>，用于基于时间的操作</td>
</tr>
<tr class="odd">
<td>animationFrameScheduler</td>
<td>任务会在浏览器下一次重绘（repaint）之前进行，用于创建流畅的浏览器动画</td>
</tr>
</tbody>
</table>
<h2 id="使用-scheduler">使用 Scheduler</h2>
<p>以后用到再翻译，先看<a href="https://rxjs.dev/guide/scheduler">文档</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>RxJS 小技巧</title>
    <url>/hais-notebook/2021/05/14/RxJS-Trick/</url>
    <content><![CDATA[<p>利用 share 防止重复请求。</p>
<span id="more"></span>
<h1 id="防止重复请求">防止重复请求</h1>
<p>参考了 <a href="https://stackoverflow.com/questions/50864978/angular-rxjs-6-how-to-prevent-duplicate-http-requests">这篇文章</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request.ts</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dataObservable</span>: <span class="title class_">Observable</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = (): <span class="title class_">Observerble</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (dataObservable) &#123; <span class="keyword">return</span> dataObservable &#125;</span><br><span class="line">  dataObservable = <span class="keyword">new</span> <span class="title class_">Observable</span>&lt;<span class="built_in">any</span>&gt;(<span class="function">(<span class="params">subscriber</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mock Run API&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mock API Callback&quot;</span>)</span><br><span class="line">      subscriber.<span class="title function_">next</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">      subscriber.<span class="title function_">complete</span>()</span><br><span class="line">      <span class="comment">// 可以根据需求自行确定这个 observable 销毁的时机</span></span><br><span class="line">      dataObservable = <span class="literal">undefined</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;).<span class="title function_">pipe</span>(<span class="title function_">share</span>())</span><br><span class="line">  <span class="keyword">return</span> dataObservable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// somewhere.ts</span></span><br><span class="line"><span class="title function_">request</span>().<span class="title function_">subscribe</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">request</span>().<span class="title function_">subscribe</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">request</span>().<span class="title function_">subscribe</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// mock Run API</span></span><br><span class="line"><span class="comment">// mock API Callback</span></span><br><span class="line"><span class="comment">// 1 0.403....</span></span><br><span class="line"><span class="comment">// 2 0.403....       跟 1 打出的值一样</span></span><br><span class="line"><span class="comment">// mock Run API      上面的 500 ms 之后</span></span><br><span class="line"><span class="comment">// mock API Callback</span></span><br><span class="line"><span class="comment">// 3 0.838....       新的值</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>小程序拖拽排序</title>
    <url>/hais-notebook/2021/08/18/SourceCode-Work-MovableArea/</url>
    <content><![CDATA[<p>借助小程序的 movableArea 和 movableView 实现拖拽排序。</p>
<span id="more"></span>
<h1 id="官方文档">官方文档</h1>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/movable-area.html">movable-area</a></p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html">movable-view</a></p>
<h1 id="整体思路">整体思路</h1>
<p>借助 Move 类实现，每个 movable-area 对应一个 Move 类的实例。</p>
<ul>
<li>长按
<ul>
<li>用一个对象 <code>moveItemInfo</code> 记录正在移动的元素的信息：记录准备移动的元素开始时的 <code>index</code></li>
</ul></li>
<li>移动
<ul>
<li>更新 <code>moveItemInfo</code>：更新实时的 <code>x</code> <code>y</code></li>
<li>*计算出移动中元素实时的 <code>index</code>：初始化的时候传入可移动元素的宽、高、间距，以及列的数量，然后结合当前 <code>moveItemInfo</code> 中的 <code>x</code> <code>y</code> 信息，计算拖动到的 <code>index</code></li>
<li>*将元素移动导新的 <code>index</code>：遍历当前的所有可移动元素，找到他们的 <code>index</code>，根据当前移动中的元素是向前还是向后移动，来确定其他的元素是否需要移动、需要向哪个方向移动</li>
<li>更新其他元素的 <code>movable-view</code> 中的 <code>x</code> 和 <code>y</code> 属性，达到移动的效果</li>
</ul></li>
<li>松手：计算出可移动对象最终的 index，并更新整个列表的位置信息</li>
</ul>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>长列表优化：小程序虚拟列表</title>
    <url>/hais-notebook/2020/05/13/SourceCode-Work-VirtualList/</url>
    <content><![CDATA[<p>借助小程序的 createIntersectionObserver 来实现虚拟列表。</p>
<span id="more"></span>
<h1 id="用例">用例</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;</span><br><span class="line">    &lt;!-- 通过 overRenderScreenCount 控制当前实际渲染在页面中的项数 --&gt;</span><br><span class="line">    &lt;virtual-list-item overRenderScreenCount=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line">        &lt;view slot=&quot;skeleton&quot;&gt;</span><br><span class="line">            ...skeleton template</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/virtual-list-item&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>微信小程序提供了 <code>createIntersectionObserver</code> API，这个 API 可以监听元素的相交情况。利用此 API，我们可以知道元素何时进入（需要被渲染出来的）可视区域，何时退出可视区域，从而控制其是否渲染。 此外，还需要记录每个元素的高度，并在元素不被渲染出来的时候，提供一个 minHeight，防止高度塌陷。</p>
<h1 id="伪代码">伪代码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 当元素没有实际渲染出来的时候，需要提供最小高度，防止高度塌陷 --&gt;</span><br><span class="line">&lt;view class=&quot;.virtual-item&quot; style=&quot;minHeight: &#123;&#123;isShow ? 0 : virtualHeight&#125;&#125;px&quot;&gt;</span><br><span class="line">    &lt;block wx:if=&quot;&#123;&#123;isShow&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">    &lt;block wx:else&gt;</span><br><span class="line">        &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersectionObserver</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ready</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> margin = props.<span class="property">overRenderScreenCount</span> * windowHeight</span><br><span class="line">  intersectionObserver = wx.<span class="title function_">createIntersectionObserver</span>(&#123; <span class="attr">initialRatio</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    .<span class="title function_">relativeToViewPort</span>(&#123; <span class="attr">top</span>: margin, <span class="attr">bottom</span>: margin &#125;)</span><br><span class="line">    .<span class="title function_">observe</span>(<span class="string">&quot;.virtual-item&quot;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      data.<span class="property">isShow</span> = res.<span class="property">intersectionRatio</span> &gt; <span class="number">0</span></span><br><span class="line">      data.<span class="property">virtualHeight</span> = res.<span class="property">boundingClientRect</span>.<span class="property">height</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">detached</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  intersectionObserver?.<span class="property">disonnect</span>?.()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/hais-notebook/2020/03/21/TypeScript/</url>
    <content><![CDATA[<p>TypeScript 三个好处： 1. 自动提示更智能；2. 不能随便写 .xxx()；3. 错误前移到编译时</p>
<span id="more"></span>
<h1 id="typescript-中的类型">Typescript 中的类型</h1>
<h2 id="原始类型">原始类型</h2>
<p>TS 中的原始类型包括 <code>boolean</code> <code>number</code> <code>string</code> <code>void</code> <code>undefined</code> <code>null</code> <code>symbol</code> <code>bigint</code>，与 JS 不同的是多了 <code>void</code> 和 <code>bigint</code> 这两个：</p>
<h3 id="void">void</h3>
<p>表示没有任何类型，相当于 <code>undfined | null</code>，通常用在一个函数没有返回值时（<code>undefiend</code>）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h3 id="bigint">bigint</h3>
<p>主要是为了解决大数超过精度范围的问题的，需要注意的是 <code>bigint</code> 与 <code>number</code> 是两种类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">max</span>: bigint = <span class="title class_">BigInt</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">max1</span>: bigint = max + <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">max2</span>: bigint = max + <span class="number">2n</span>;</span><br><span class="line"></span><br><span class="line">max1 !== max2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="其他类型">其他类型</h2>
<ul>
<li><p><strong>顶级类型</strong>：<code>any</code> <code>unknown</code> *计算机类型系统理论中的顶级类型（Top Type）通常是指某种包含了所有可能类型的类型，其他所有的类型都是其子类型</p></li>
<li><p><strong>底部类型</strong>：<code>never</code> *与顶级类型相反，底部类型（Bottom Type）又称为零类型（Zero）或空类型（Empty），表示什么都没有，他是任何类型的子类型，甚至连 <code>undefiend</code> 或者 <code>null</code> 都不能赋值给 <code>never</code></p></li>
<li><p><strong>非原始类型</strong>：<code>object</code> <code>array</code> <code>tuple</code> 等</p></li>
</ul>
<h3 id="any">any</h3>
<p>有些时候，我们在编程阶段还不知道某个变量的类型，比如来自用户的输入或者第三方代码库，我们用 <code>any</code> 可以让他通过类型检查</p>
<div class="note warning"><p>但是注意，尽量不用 <code>any</code>，因为会造成蝴蝶效应，可能导致很严重的问题</p>
</div>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="unknown">unknown</h3>
<p><code>unknow</code> 是 TypeScript 3.0 引入的比 <code>any</code> 更加安全的类型，区别是有时候需要一些必要的检查：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">value = <span class="title class_">Symbol</span>(<span class="string">&#x27;type&#x27;</span>);</span><br><span class="line">value = &#123;&#125;;</span><br><span class="line">value = [];</span><br></pre></td></tr></table></figure>
<p><code>unknown</code> 也可以是任何类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: unknown;</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">value = <span class="title class_">Symbol</span>(<span class="string">&#x27;type&#x27;</span>);</span><br><span class="line">value = &#123;&#125;;</span><br><span class="line">value = [];</span><br></pre></td></tr></table></figure>
<p>区别在于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value.<span class="property">foo</span>.<span class="property">bar</span>;</span><br><span class="line"><span class="title function_">value</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">value</span>();</span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>而 <code>unknow</code> 则不能</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: unknown;</span><br><span class="line"></span><br><span class="line">value.<span class="property">foo</span>.<span class="property">bar</span>; <span class="comment">// ERROR</span></span><br><span class="line"><span class="title function_">value</span>();       <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">value</span>();   <span class="comment">// ERROR</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>];   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<p>你得通过某种方式确认 <code>value</code> 的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">value: unknown</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">toISOString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="never">never</h3>
<p><code>never</code> 是任何类型的子类型，可以赋值给任何类型，然而没有别的类型可以赋值给 <code>never</code>，下面是一些例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出异常的函数不会有返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，而且永远是空的</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">empty</span>: <span class="built_in">never</span>[] = []</span><br></pre></td></tr></table></figure>
<h3 id="array">array</h3>
<p>有两种方式可以定义一个数组：</p>
<ul>
<li>使用泛型：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>在元素后面加上 <code>[]</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h3 id="tuple">tuple</h3>
<p>元祖与数组的不同是，元素的各元素类型不必相同：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>, <span class="literal">false</span>]; <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>];            <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>];        <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>];        <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>注意元祖元素的顺序不同也会报错，类型检查比数组严格；并且元祖还有越界问题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>];</span><br><span class="line">tuple.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tuple); <span class="comment">// 元素正常打印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tuple[<span class="number">2</span>]); <span class="comment">// Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="object">object</h3>
<p>事实上，普通对象、枚举、数组、元素都是 <code>object</code> 类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Center</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line">value = <span class="title class_">Direction</span>;</span><br><span class="line">value = [<span class="number">1</span>];</span><br><span class="line">value = [<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line">value = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型">枚举类型</h2>
<p>通常在某个变量只有几种可能的取值时，可以使用枚举类型</p>
<h3 id="数字枚举">数字枚举</h3>
<p>若没有赋值，默认就是从 0 开始的数字枚举：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Down</span> === <span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>若给第一个赋值为数字，则后面则会累加：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">10</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Down</span> === <span class="number">11</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串枚举">字符串枚举</h3>
<p>枚举类型的值也可以是字符串类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异构枚举">异构枚举</h3>
<p>但是通常不这样写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">    <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反向映射">反向映射</h3>
<p>数字枚举可以进行反向映射，因为他会被编译成诸如 <code>Direction[Direction["Up"] = 0] = "Up"</code> 的语句，<em>而字符串枚举则不具备这样的特性</em>，并且也不推荐这样做（<code>Potentially invalid target of indexed property access</code>）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="number">0</span>]); <span class="comment">// Up</span></span><br></pre></td></tr></table></figure>
<h3 id="常量枚举">常量枚举</h3>
<p>我们可以将枚举使用 <code>const</code> 声明为常量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Direction</span>.<span class="property">Up</span></span><br></pre></td></tr></table></figure>
<p>这时将会被编译为 <code>const a = 'Up'</code>，而不是之前的 <code>const a = Direction.Up</code>——这可以提升性能，除非添加编译选项 <code>--preserveConstEnums</code> 使他保留对象 <code>Direction</code></p>
<h3 id="联合枚举">联合枚举</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Direction</span>; <span class="comment">// 可以看成声明了联合类型 Direction.Up | Direction.Down | Direction.Left | Direction.Right</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title class_">Dog</span>,</span><br><span class="line">  <span class="title class_">Cat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="title class_">Direction</span>.<span class="property">Up</span>; <span class="comment">// OK</span></span><br><span class="line">a = <span class="title class_">Animal</span>.<span class="property">Dog</span>;   <span class="comment">// Assigned expression type Animal.Dog is not assignable to type Direction</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举合并">枚举合并</h3>
<p>分开声明的枚举会自动合并，而不会发生冲突</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Center</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="interface">interface</h1>
<p>一个简单的栗子，包括只读属性、可选属性和函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">say</span>: <span class="function">(<span class="params">words: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性检查">属性检查</h2>
<p>有时候会出现这样的情况：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calc</span>(<span class="params">config: Config</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> square = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    square = config.<span class="property">width</span> * config.<span class="property">width</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> square</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">calc</span>(&#123;<span class="attr">x</span>: <span class="number">5</span>&#125;) <span class="comment">// Argument type &#123;x: number&#125; is not assignable to parameter type Config</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>使用类型断言</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">calc</span>(&#123;<span class="attr">x</span>: <span class="number">5</span>&#125; <span class="keyword">as</span> <span class="title class_">Config</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>添加字符串索引签名，这样 <code>Config</code> 就可以拥有任意数量的属性了</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转化为 <code>any</code></li>
</ul>
<h2 id="可索引属性">可索引属性</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承接口">继承接口</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">VIPUser</span> <span class="keyword">extends</span> <span class="title class_">User</span>, <span class="title class_">SuperUser</span> &#123;</span><br><span class="line">  <span class="attr">broadcast</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="class">class</h1>
<h2 id="抽象类">抽象类</h2>
<p><code>abstract</code> 关键字可以用于定义一个抽象类或在抽象类中定义抽象方法，抽象类是专门用来派生的，一般不会被实例化</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earth...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接使用 new Animal() 创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;miaou~&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">cat.<span class="title function_">makeSound</span>(); <span class="comment">// &#x27;miaou~&#x27;</span></span><br><span class="line">cat.<span class="title function_">move</span>(); <span class="comment">// &#x27;roaming the earth...&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="访问限定符">访问限定符</h2>
<p>包括 public、private、protected</p>
<h3 id="public">public</h3>
<p>TS 中成员默认为 public，可以被外部访问：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car.<span class="title function_">run</span>(); <span class="comment">// &#x27;start...&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="private">private</h3>
<p>private 成员只能被类的内部访问</p>
<h3 id="protected">protected</h3>
<p>protected 成员可以被类的内部以及子类访问</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GTR</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="keyword">const</span> gtr = <span class="keyword">new</span> <span class="title function_">GTR</span>();</span><br><span class="line"></span><br><span class="line">car.<span class="title function_">run</span>(); <span class="comment">// Protected member is not accessible</span></span><br><span class="line">gtr.<span class="title function_">init</span>(); <span class="comment">// &#x27;start...&#x27;</span></span><br><span class="line">gtr.<span class="title function_">run</span>(); <span class="comment">// Protected member is not accessible</span></span><br></pre></td></tr></table></figure>
<h2 id="class-作为-interface">class 作为 interface</h2>
<p>在 React 中比较常用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props 的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">children</span>: <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElment</span>&lt;<span class="built_in">any</span>&gt;&gt; | <span class="title class_">React</span>.<span class="property">ReactElment</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">never</span>[] = [];</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">500</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">height</span>: <span class="built_in">number</span> = <span class="number">160</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Carousel</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">Props</span>, <span class="title class_">State</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = <span class="keyword">new</span> <span class="title class_">Props</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="function">function</h1>
<h2 id="定义函数类型">定义函数类型</h2>
<p>很多时候函数的类型并不需要刻意去定义，TypeScript 会自己进行类型推断：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b = <span class="number">10</span>, c?: <span class="built_in">number</span></span>) =&gt; a + b + (c ? c : <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 当然也可以显式定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mul</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> a * b;</span><br></pre></td></tr></table></figure>
<p>当然也可以使用 <code>...</code> 来表示剩余参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) =&gt; rest.<span class="title function_">reduce</span>((<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b), a)</span><br></pre></td></tr></table></figure>
<h2 id="overload">overload</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="attr">top</span>: <span class="built_in">number</span>,</span><br><span class="line">  bottom?: <span class="built_in">number</span>,</span><br><span class="line">  left?: <span class="built_in">number</span>,</span><br><span class="line">  right?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assigned</span>(<span class="params">all: <span class="built_in">number</span></span>): <span class="title class_">Direction</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assigned</span>(<span class="params">topAndBottom: <span class="built_in">number</span>, leftAndRight: <span class="built_in">number</span></span>): <span class="title class_">Direction</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assigned</span>(<span class="params">top: <span class="built_in">number</span>, right: <span class="built_in">number</span>, bottom: <span class="built_in">number</span>, left: <span class="built_in">number</span></span>): <span class="title class_">Direction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assigned</span> (<span class="attr">a</span>: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span>, d?: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="literal">undefined</span> &amp;&amp; c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    b = c = d = a;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    c = a;</span><br><span class="line">    d = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">top</span>: a,</span><br><span class="line">    <span class="attr">right</span>: b,</span><br><span class="line">    <span class="attr">bottom</span>: c,</span><br><span class="line">    <span class="attr">left</span>: d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">assigned</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">assigned</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">assigned</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// Argument types do not match parameters </span></span><br><span class="line"><span class="title function_">assigned</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>接受不同个数的参数，实现函数的重载，但是需要对函数做三次类型声明，否则可能会在传入 3 个参数（代码事实上不允许传入 3 个参数）的时候不报错</p>
<h2 id="generics">generics</h2>
<p>有些时候，我们在静态编写的时候并不确定传入的参数到底是什么类型，只有在运行时传入参数之后才能确定。那么就需要一个变量，用于表示类型，而这个类型变量，则称为 <strong>泛型（generics）</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函数名称后面声明泛型变量 &lt;T&gt;</span></span><br><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以同时有多个泛型变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]) &#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="泛型变量">泛型变量</h2>
<p>有时候我们可能会写出这样的代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getArrayLength&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 类型 T 上不存在 length</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器并不知道 <code>T</code> 上有 <code>length</code> 这个属性，我们可以写成 <code>Array&lt;T&gt;</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getArrayLength&lt;T&gt;(<span class="attr">arg</span>: <span class="title class_">Array</span>&lt;T&gt;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((arg <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;).<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口">泛型接口</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnItemFn</span>&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">para</span>: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">returnItem</span>: <span class="title class_">ReturnItemFn</span>&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure>
<h2 id="泛型类">泛型类</h2>
<p>泛型可以作用域类本身，也可以作用于成员函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">arr</span>: T[] = [];</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束">泛型约束</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Params</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Params</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">arr</span>: T[] = [];</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束与索引类型">泛型约束与索引类型</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">obj: <span class="built_in">object</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要这样修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: U) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型与-new">泛型与 new</h2>
<p>我们需要这样声明一个泛型为构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> factory&lt;T&gt;(<span class="title class_">Constructor</span>: &#123;<span class="title function_">new</span>(): T&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Constructor</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型断言与类型守卫">类型断言与类型守卫</h1>
<h2 id="类型断言">类型断言</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;xiaoming&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">20</span>;          <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="双重断言">双重断言</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&#x27;xiaoming&#x27;</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> <span class="title class_">Person</span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="类型守卫">类型守卫</h2>
<p>使用类型守卫可以缩小类型的范围</p>
<h3 id="instanceof">instanceof</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;petty&#x27;</span>;</span><br><span class="line">  color = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSometing</span>(<span class="params">arg: Person | Animal</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型细化为 Person</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> <span class="title class_">Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">color</span>); <span class="comment">// Error，因为arg被细化为Person，而Person上不存在 color属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">age</span>); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类型细化为 Person</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> <span class="title class_">Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">age</span>); <span class="comment">// Error，因为arg被细化为Animal，而Animal上不存在 age 属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">color</span>); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in">in</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;petty&#x27;</span>;</span><br><span class="line">  color = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSometing</span>(<span class="params">arg: Person | Animal</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">color</span>); <span class="comment">// Error，因为arg被细化为Person，而Person上不存在 color属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">age</span>); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;color&#x27;</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">age</span>); <span class="comment">// Error，因为arg被细化为Animal，而Animal上不存在 age 属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">color</span>); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字面量类型守卫">字面量类型守卫</h3>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">arg: Foo | Bar</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.<span class="property">kind</span> === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">foo</span>); <span class="comment">// ok</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">bar</span>); <span class="comment">// Error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">foo</span>); <span class="comment">// Error</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">bar</span>); <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型兼容性">类型兼容性</h1>
<h2 id="结构类型">结构类型</h2>
<p>结构类型是一种只使用其成员来表示类型的方式，一个栗子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> weight: <span class="built_in">number</span>, <span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> born: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">weight</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">120</span>, <span class="string">&#x27;xx&#x27;</span>, <span class="string">&#x27;22-22-22&#x27;</span>) <span class="comment">// OK，多的可以赋值给少的</span></span><br></pre></td></tr></table></figure>
<p>这时我们说 <code>Dog</code> 兼容 <code>Person</code>， 因为 <code>Dog</code> 的属性 <code>Person</code> 都有，反之则不然。</p>
<h2 id="函数类型">函数类型</h2>
<p>首先查看参数列表（的类型）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Assigned expression type (b: number, s: string) =&gt; 0 is not assignable to type (a: number) =&gt; 0</span></span><br></pre></td></tr></table></figure>
<p>少的可以赋值给多的</p>
<h2 id="枚举类型的兼容性">枚举类型的兼容性</h2>
<p>枚举与数字类型相互兼容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="title class_">Ready</span>,</span><br><span class="line">  <span class="title class_">Waiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = <span class="title class_">Status</span>.<span class="property">Ready</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">status = num;</span><br><span class="line">num = status;</span><br></pre></td></tr></table></figure>
<h2 id="类的类型兼容性">类的类型兼容性</h2>
<p>只有实例成员和方法会被比较，构造函数和静态成员则不会被检查：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">feet</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">  <span class="attr">feet</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">meters: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="title class_">Size</span>;</span><br><span class="line"></span><br><span class="line">a = s; <span class="comment">// OK</span></span><br><span class="line">s = a; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>而 private 和 protected 必须来自相同的类</p>
<h1 id="vue-的-ts-组件">Vue 的 TS 组件</h1>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;source/_posts/Others-QA-Vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>, <span class="title class_">Prop</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个装饰器，告诉 Vue 这是一个组件，Vue 会自动把下面的东西处理成 data、method 等</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// components: &#123;Child,...&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  num = <span class="number">0</span>; <span class="comment">// 这就是 TS 组件的 data</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(<span class="title class_">Number</span>) <span class="attr">propA</span>: <span class="built_in">number</span> | <span class="literal">undefined</span>; <span class="comment">// 这是 vue-property-decorator 带来的 props 写法</span></span><br><span class="line">  <span class="comment">// @Prop 是装饰器，告诉 Vue，后面的东西不是 data，是 prop</span></span><br><span class="line">  <span class="comment">// 左边的 Number 是告诉 Vue，propsA 是 Number，是**运行时**的类型检查</span></span><br><span class="line">  <span class="comment">// 右边的 number 是告诉 TS propsA 的类型，是**编译时**的类型检查，比如说你没办法写 this.propA.xxx，会无法编译成功</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123; <span class="comment">// 这就是 TS 组件的 methods</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = num ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">propA</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译时与运行时">编译时与运行时</h2>
<p>TypeScript --编译--&gt; JavaScript --运行--&gt; 浏览器</p>
<p>编译时：编译错误 -&gt; 无法得到 JS，会在编译的终端 Error 运行时：运行错误 -&gt; 控制台 Error（浏览器）</p>
<h1 id="typescript-的本质">TypeScript 的本质</h1>
<blockquote class="blockquote-center">
<p>JS: 类型</p>

</blockquote>
<p>TSC（TypeScriptCompiler）会利用类型来检查 JS 代码：</p>
<ul>
<li>若检查出错误，就会编译报错，但还是会编译成 JS</li>
<li>若没有检查出错误，就会删掉类型，然后编译成 JS（TSC 或者 Babel 都可以编译，有一点点区别）</li>
</ul>
<h1 id="高级类型">高级类型</h1>
<h2 id="交叉类型">交叉类型</h2>
<p>交叉类型是将多个类型合并为一个类型，比较常见的是用在 JavaScript 的混入模式（从两个对象中刚创建一个新对象）中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAnyObject</span> &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> mixin&lt;T <span class="keyword">extends</span> <span class="title class_">IAnyObject</span>, U <span class="keyword">extends</span> <span class="title class_">IAnyObject</span>&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = mixin(&#123;a: &#x27;hello&#x27;&#125;, &#123;b: 42&#125;);</span><br><span class="line"></span><br><span class="line">const a = x.a;</span><br><span class="line">const b = x.b;</span><br></pre></td></tr></table></figure>
<h2 id="联合类型">联合类型</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    line = command.<span class="title function_">trim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">trim</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型别名">类型别名</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> a = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123;<span class="attr">value</span>: T&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>type 与 interface？</strong></p>
<ul>
<li>interface 只能用于定义 <strong>对象类型</strong></li>
<li>type 还可以定义 <strong>原始类型</strong>、<strong>交叉类型</strong> 和 <strong>联合类型</strong> 等，用途更加广泛</li>
<li>但是 interface 可以实现 extends 和 implements，也可以实现接口合并声明</li>
</ul>
</div>
<h1 id="可辨识联合类型">可辨识联合类型</h1>
<h2 id="字面量类型">字面量类型</h2>
<p>字面量类型（Literal Type）主要分为 <strong>真值字面量类型（Boolean Literal Type）</strong>、<strong>数字字面量类型（Numeric Literal Type）</strong>、<strong>枚举字面量类型（Enum Literal Type）</strong>、<strong>大整数字面量类型（BigInt Literal Type）</strong> 和 <strong>字符串字面量类型（String Literal Type）</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="string">&#x27;xiaoming&#x27;</span> = <span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="string">&#x27;xiaoming&#x27;</span> = <span class="string">&#x27;xiaohong&#x27;</span>; <span class="comment">// Initializer type &quot;xiaohong&quot; is not assignable to variable type &quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure>
<p>字面量类型有时候可以模拟一个类似枚举的效果：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;North&#x27;</span> | <span class="string">&#x27;East&#x27;</span> | <span class="string">&#x27;South&#x27;</span> | <span class="string">&#x27;West&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="类型字面量">类型字面量</h2>
<p>类型字面量（Type Literal）则跟 JavaScript 中的对象字面量语法很相似：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">baz</span>: [</span><br><span class="line">    <span class="built_in">number</span>,</span><br><span class="line">    <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="title function_">toString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可辨识的联合类型">可辨识的联合类型</h2>
<p>有时候会出现这样的需求，有两个 <code>action</code>，一个是创建用户 <code>create</code>，一个是删除用户 <code>delete</code>，我们在创建用户的时候不需要 id，在删除用糊的时候需要，因此我们可能会这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserAction</span> &#123;</span><br><span class="line">  id?: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">action</span>: <span class="string">&#x27;create&#x27;</span> | <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">  <span class="attr">info</span>: <span class="title class_">Info</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样并不能区分开创建用户和删除用户操作，我们就需要使用类型字面量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserAction</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">action</span>: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">  <span class="attr">info</span>: <span class="title class_">Info</span></span><br><span class="line">&#125; | &#123;</span><br><span class="line">  <span class="attr">action</span>: <span class="string">&#x27;create&#x27;</span></span><br><span class="line">  <span class="attr">info</span>: <span class="title class_">Info</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">userReducer</span> = (<span class="params">userAction: UserAction</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (userAction.<span class="property">action</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;delete&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(userAction.<span class="property">id</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在输入 <code>userAction.</code> 之后，IDE 会有所提示，因为我们通过 <code>userAction.action</code> 分开了不同的情况，<code>userAction.action</code> 就是我们识别的关键，被称为 <strong>可辨识的标签</strong>。</p>
<p>要想达成这样的效果，需要实现这样几个要素：</p>
<ul>
<li>具有普通的单例类型属性，也就是要有可辨识的特征，比如 <code>delete</code> 和 <code>create</code></li>
<li>一个包含 <strong>联合类型</strong> 的类型别名</li>
<li>类型守卫的特征，比如使用 <code>if</code> 或 <code>switch</code> 等来进行判断</li>
</ul>
<h1 id="装饰器">装饰器</h1>
<p>装饰器的主要作用是给已有的方法或类扩展一些新的行为，而不是修改他本身</p>
<p>需要在 <code>tsconfig.json</code> 中添加一些选项使其支持装饰器：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>装饰器本质上是一个函数，<code>@expression</code> 的形式其实是一个语法糖，<code>expression</code> 求值后也必须是一个函数，他会在运行时被调用，被装饰的声明信息作为参数传入</p>
<h2 id="类装饰器">类装饰器</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 18 </span></span><br></pre></td></tr></table></figure>
<p>其中 <code>constructor</code> 是 <code>Person</code></p>
<h2 id="属性方法装饰器">属性/方法装饰器</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prop&#x27;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;desc&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@method</span> <span class="comment">// 其实是相当于使用了 Object.defineProperty 来修改方法和属性</span></span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;instance method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@method</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xm = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">xm.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// Cannot assign to read only property &#x27;say&#x27; of object &#x27;#&lt;Person&gt;&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;edit&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>target</code> 是当前对象的原型 <code>Person.prototype</code></p>
<h2 id="参数装饰器">参数装饰器</h2>
<p>参数装饰器在 Angular 和 Nestjs 中都有运用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target, propertyKey, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="meta">@logParameter</span> <span class="attr">message</span>: <span class="built_in">string</span>, <span class="meta">@logParameter</span> <span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;message&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">greet</span>(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其中 <code>target</code> 是当前对象的原型 <code>Person.prototype</code>，<code>propertyKey</code> 是 <code>greet</code>，在这里装饰器起到的作用主要是能够提供一系列的信息（元数据）</p>
<h2 id="装饰器工厂">装饰器工厂</h2>
<p>可以使用装饰器工厂封装不同的装饰器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logClass</span>(<span class="params">target: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMethod</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (args.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> logClass.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 需要将 --strictBindCallApply 关掉</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> logProperty.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> args[<span class="number">2</span>] === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> logParameter.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> logMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Decorators are not valid here!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="meta">@log</span> message : <span class="built_in">string</span>) : <span class="built_in">string</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> say: <span class="subst">$&#123;message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器顺序">装饰器顺序</h2>
<p>可以同时应用多个装饰器，装饰器可以写在一行或多行上，执行的步骤是：</p>
<ol type="1">
<li>从上到下依次对装饰器表达式求值</li>
<li>求值的结果会被当做函数，从下到上一次调用</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类中的各种装饰器调用顺序：</p>
<ol type="1">
<li>参数装饰器、方法装饰器、访问符装饰器、属性装饰器应用到每个实例成员</li>
<li>参数装饰器、方法装饰器、访问符装饰器、属性装饰器应用到每个静态成员</li>
<li>参数装饰器应用到静态函数</li>
<li>类装饰器应用到类</li>
</ol>
<h1 id="reflect-metadata">Reflect Metadata</h1>
<p>属于 ES7 的一个提案，主要作用是在声明的时候读取和添加元数据，不再需要手动在属性上添加元数据，目前需要先引入 npm 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>
<p>而且需要在 <code>tsconfig.json</code> 中配置 <code>emitDecoratorMetadata</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">hello</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;name&#x27;</span>, A);</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="keyword">new</span> <span class="title function_">A</span>());</span><br></pre></td></tr></table></figure>
<h2 id="常用方法">常用方法</h2>
<h3 id="设置获取元数据">设置/获取元数据</h3>
<p>可以使用 <code>metadata</code> API，利用装饰器给目标添加元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">metadata</span>(<span class="params"></span></span><br><span class="line"><span class="params">  metadataKey: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  metadataValue: <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>): &#123;</span><br><span class="line">  (<span class="attr">target</span>: <span class="title class_">Function</span>): <span class="built_in">void</span>;</span><br><span class="line">  (<span class="attr">target</span>: <span class="title class_">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | symbol): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>defineMetadata</code> 添加元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target);</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br></pre></td></tr></table></figure>
<p>可以这样使用他：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xiaomimg&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;2019/10/10&#x27;</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">say</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;name&#x27;</span>, <span class="title class_">Person</span>)); <span class="comment">// xiaomimg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;time&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>, <span class="string">&#x27;say&#x27;</span>)); <span class="comment">// 2019/10/10</span></span><br></pre></td></tr></table></figure>
<p>注意取出 <code>say</code> 上的元数据时需要先实例化，因为元数据是被添加在实例方法上的，要想不实例化的话，则需要添加在静态方法上</p>
<h3 id="内置元数据">内置元数据</h3>
<p>可以获取一些 TypeScript 本身内置的一些元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:type&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>, <span class="string">&#x27;say&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> typeParam = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:paramtypes&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>, <span class="string">&#x27;say&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> typeReturn = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:returntype&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>, <span class="string">&#x27;say&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="明确赋值断言">明确赋值断言</h1>
<p><code>--strictPropertyInitialization</code> 可以保证变量声明和实例属性都会有初始值，但有时候我们需要提醒编译器 ”这里不需要一个初始值“ 或者 ”这里稍后将会有值，你别管“，这是加上 <code>!</code> 即可</p>
<h1 id="is-关键字">is 关键字</h1>
<p>作用是为了判断类型，看一个栗子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">test: <span class="built_in">any</span></span>): test is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> test === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">foo: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果将 <code>test is string</code> 改成 <code>boolean</code>，就会报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">  Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.(2339)</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>is</code> 将类型的范围给缩小了</p>
<h1 id="可调用类型注解">可调用类型注解</h1>
<p>想让一个 interface 被注解为可执行的、可实例化的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ToString</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">somethingToString</span>: <span class="title class_">ToString</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">somethingToString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// This expression is not callable.</span></span><br><span class="line"><span class="comment">//    Type &#x27;ToString&#x27; has no call signatures.</span></span><br></pre></td></tr></table></figure>
<p>可以这样修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ToString1</span> &#123;</span><br><span class="line">  (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">somethingToString1</span>: <span class="title class_">ToString1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">somethingToString1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ToString2</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">somethingToString2</span>: <span class="title class_">ToString2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">somethingToString2</span>();</span><br></pre></td></tr></table></figure>
<h1 id="一些问题">一些问题</h1>
<h2 id="强制指定类型">强制指定类型</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">inputNumber</span>(<span class="params">event: MouseEvent | TouchEvent</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> button = (event.<span class="property">target</span> <span class="keyword">as</span> <span class="title class_">HTMLButtonElement</span>); <span class="comment">// 因为有的元素的 textContent 可能为空（比如图片），所以我们需要强制指定为 Button 元素</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(button.<span class="property">textContent</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以给返回值强制指定类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;records&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>) <span class="keyword">as</span> <span class="title class_">RecordItem</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配合-js-使用">配合 JS 使用</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx <span class="built_in">require</span>(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="全局声明-type">全局声明 <code>type</code></h2>
<p>在 <code>src</code> 中创建 <code>custom.d.ts</code>（也可以叫 <code>xxx.d.ts</code>），在里面声明 <code>type</code></p>
<h2 id="void-1">void</h2>
<p>一般来讲 <code>void</code> 就是 <code>undefined</code> 或者 <code>null</code>，但在 <code>sctricNullChecks</code> 关闭时才可以取 <code>null</code>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/hais-notebook/2020/02/02/VSCode/</url>
    <content><![CDATA[<p>收集关于 VSCode 的用法及插件。</p>
<span id="more"></span>
<h1 id="插件">插件</h1>
<ul>
<li>Vue
<ul>
<li>Vetur</li>
<li>Vue VSCode Snippets</li>
</ul></li>
<li>TypeScript
<ul>
<li>TypeScript Importer</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/hais-notebook/2020/01/30/Vue/</url>
    <content><![CDATA[<p>For Vue 2.</p>
<span id="more"></span>
<h1 id="start">Start</h1>
<h2 id="历史">历史</h2>
<ul>
<li>2015 年，1.0 版，是 MVVM 框架</li>
<li>2016 年，2.0 版，没有完全遵循 MVVM 模型</li>
<li>2019 年，2.6 版</li>
<li>2020 年，3.0 版，完全不是 MVVM</li>
</ul>
<h2 id="创建一个-vue-项目">创建一个 vue 项目</h2>
<ul>
<li>使用 <span class="citation" data-cites="vue-cli">@vue-cli</span></li>
<li>或者使用 webpack 或者 rollup 从零开始</li>
</ul>
<h2 id="完整版和运行时版本">完整版和运行时版本</h2>
<ul>
<li><strong>完整版</strong>：同时包含编译器和运行时的版本，也就是 CDN 里面的 <code>vue.js</code>，可以直接在页面里面写 ，相当于把视图放在 html 里面写</li>
<li><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切，也就是 CDN 里面的 <code>vue.runtime.js</code>，不支持从 html 里面获取视图，也不支持在 template 里面写，没有编译器（compiler），代码体积小 30%</li>
<li>webpack 中的 vue-loader 可以在最后打包的时候将 template 里面的东西编译成 JS，因此我们不需要使用完整版</li>
</ul>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 26%" />
<col style="width: 41%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>完整版</th>
<th>运行时版</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>特点</td>
<td>有 compiler</td>
<td>没有 compiler</td>
<td>compiler 占 40% 的体积</td>
</tr>
<tr class="even">
<td>视图</td>
<td>写在 HTML 里，或者写在 template 选项中</td>
<td>写在 render 函数里，用 h 来创建标签 h 是 Vue 写好传给 render 的</td>
<td></td>
</tr>
<tr class="odd">
<td>CDN 引入</td>
<td>vue.js</td>
<td>vue.runtime.js</td>
<td>文件名不同，生产环境后缀为 .min.js</td>
</tr>
<tr class="even">
<td>webpack 引入</td>
<td>需要配置 alias</td>
<td>默认使用此版</td>
<td></td>
</tr>
<tr class="odd">
<td><span class="citation" data-cites="vue/cli">@vue/cli</span> 引入</td>
<td>需要额外配置</td>
<td>默认使用此版</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="options">Options</h1>
<h2 id="data">Data</h2>
<h3 id="data-1">data</h3>
<ul>
<li>接收内部属性</li>
<li>有两种写法：对象和函数，函数 return 一个对象</li>
<li>优先使用函数，避免两个组件共用一个 data，此外在 vue 组件中的 data 不能使用对象</li>
<li>data 有 bug</li>
</ul>
<p>关于更多 data 与 响应式的内容，可以看看 <a href="https://hais-teatime.com/post/2019-12-25-vue-1/">我的一篇博客</a></p>
<h3 id="props">props</h3>
<ul>
<li>接收外部属性，一个数组</li>
<li><code>message="n"</code> 传入字符串</li>
<li><code>:message="n"</code> 传入 this.n 数据</li>
<li><code>:fn="add"</code> 传入 this.add 函数</li>
<li>如果外部有谁用了这个组件，可以在他的 <code>template</code> 里面把数据传给这个组件</li>
<li>如果传的时候在前面加上冒号，传的就是 JS 代码（变量），<strong>比如要传数字、布尔值、数组、对象等都需要加冒号</strong></li>
<li>子组件 <strong>不能</strong> 修改父组件传来的 prop，子组件如果想要进行修改或转换，最好是定义一个本地的 data，然后把 prop 作为初值赋给 data，或者使用 computed</li>
</ul>
<p>如果想要将一个对象的所有属性都作为 prop 传入，可以使用不带参数的 <code>v-bind</code> 这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以为 prop 指定类型（<code>String</code> <code>Number</code> <code>Boolean</code> <code>Array</code> <code>Object</code> <code>Function</code> <code>Date</code> <code>Symbol</code> 或者一个自定义的构造函数）或进行验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    <span class="attr">propB</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propF</span>: &#123;</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">     <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">     <span class="attr">watch</span>: &#123;</span><br><span class="line">       <span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">         <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><code>props</code> 和 <code>data</code> 的区别： 如果需要传值，就放在 <code>props</code> 里面</p>
</div>
<h3 id="computed">computed</h3>
<p>可以查看 <a href="https://codesandbox.io/s/beautiful-blackburn-5dn48">在 CodeSandbox 上的这个例子</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">email</span>: <span class="string">&quot;harvey@example.com&quot;</span>,</span><br><span class="line">      <span class="attr">nickname</span>: <span class="string">&quot;hai&quot;</span>,</span><br><span class="line">      <span class="attr">phone</span>: <span class="string">&#x27;1234567890&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>:&#123; <span class="comment">// 能够将计算而来的属性作为属性</span></span><br><span class="line">    <span class="title function_">displayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="variable language_">this</span>.<span class="property">user</span></span><br><span class="line">      <span class="keyword">return</span> user.<span class="property">nickname</span> || user.<span class="property">email</span> || user.<span class="property">phone</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 或者写成：</span></span><br><span class="line">    <span class="attr">displayName</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="variable language_">this</span>.<span class="property">user</span></span><br><span class="line">        <span class="keyword">return</span> user.<span class="property">nickname</span> || user.<span class="property">email</span> || user.<span class="property">phone</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">user</span>.<span class="property">nickname</span> = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;displayName&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>computed 是有缓存的，如果 computed 依赖的属性没有变化，那么就不会重新计算 而普通的函数（方法），或者 getter / setter 默认是不会做缓存的，Vue 做了特殊处理</p>
</div>
<h3 id="watch">watch</h3>
<p>简单来说就是当数据变化的时候执行一个函数，可以参考 <a href="https://codesandbox.io/s/dry-architecture-6cp4p">这个简单的计算器的例子</a> watch 也可以用来实现 computed 的效果，可以参考 <a href="https://codesandbox.io/s/long-dust-7jb3q">这个例子</a></p>
<div class="note warning"><p>什么叫数据变化？其实就是 <code>===</code> 的规则，简单类型比较值，引用类型比较地址 <code>obj.a</code> 进行修改 → <code>obj</code> 没变 <code>obj</code> 进行修改 → <code>obj</code> 变了</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changed&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 这个可以使得监听到内部数据的变化，如果里面变了，那么就触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>不要使用箭头函数来定义 watcher，<code>this</code> 是 <code>window</code></p>
</div>
<div class="note warning"><p><code>computed</code> 和 <code>watch</code> 的区别？</p>
<ul>
<li><code>computed</code> 是用来计算一个值的，调用的时候不需要加括号，会根据依赖缓存</li>
<li><code>watch</code> 有两个比较常用的选项：<code>immediate</code> 和 <code>deep</code>，通常是在需要进行异步或者开销比较大的操作的时候使用</li>
</ul>
</div>
<h2 id="dom">DOM</h2>
<h3 id="el">el</h3>
<ul>
<li>想要挂载到哪个节点，节点内容会被替换</li>
<li>在里面写了内容，基本上是不太可能被用户看见的，除非用户网速特别慢</li>
<li>可以用不用 el，替换为 $mount，效果一样：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(demo)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="template">template</h3>
<h4 id="三种写法">三种写法</h4>
<ol type="1">
<li>Vue 完整版，写在 HTML 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">  &#123;n&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#xxx&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  <span class="attr">methods</span>: &#123; <span class="title function_">add</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">n</span> += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>Vue 完整版，写在 options 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=xxx&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  <span class="attr">methods</span>: &#123; <span class="title function_">add</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">n</span> += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 注意这个时候 div#app 会被替代</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>Vue 运行时版，写在 <code>.vue</code> 文件里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template 不是 HTML，是 XML，有闭合标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> &#123; <span class="attr">n</span>:<span class="number">0</span> &#125; &#125;, <span class="comment">// data 必须为函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123; <span class="title function_">add</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">n</span> += <span class="number">1</span> &#125; &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* CSS-Code */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span> <span class="comment">// App 是一个 options 对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>HTML 与 XML 写法不同： <code>&lt;input name="username"&gt;</code> - HTML <code>&lt;input name="username"/&gt;</code> - XML <code>&lt;div&gt;&lt;/div&gt;</code> - HTML <code>&lt;div/&gt;</code> - XML</p>
</div>
<h4 id="模板语法">模板语法</h4>
<h5 id="展示内容">展示内容</h5>
<h6 id="表达式">表达式</h6>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; object.a &#125;&#125; <span class="comment">&lt;!-- 表达式 --&gt;</span></span><br><span class="line">&#123;&#123; n + 1 &#125;&#125; <span class="comment">&lt;!-- 运算 --&gt;</span></span><br><span class="line">&#123;&#123; fn(n) &#125;&#125; <span class="comment">&lt;!-- 调用函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&quot;表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>如果值为 undefined 或 null 就不显示</p>
</div>
<h6 id="html-内容">HTML 内容</h6>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>span</code> 将会被 <code>rawHtml</code> 的内容所替换，并且 <code>rawHtml</code> 里面的数据绑定将会失效，因此我们不能用 <code>v-html</code> 来在 <code>template</code> 里面使用 <code>template</code>，这个时候需要用 <code>component</code> 来进行组件的组合。</p>
<h6 id="纯文本">纯文本</h6>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-pre 不会对模板进行编译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="绑定属性">绑定属性</h5>
<p>Mustache 语法（双大括号）并不能使用在 HTML 属性上，这时我们需要依靠 <code>v-bind</code> 来帮我们绑定属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;x&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可简写为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;x&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:style</span>=<span class="string">&quot;&#123;border: &#x27;1px solid red&#x27;, height: 100&#125;&quot;</span>&gt;</span></span><br><span class="line">这里可以把 &#x27;100px&#x27; 写成 100</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="绑定-class">绑定 Class</h6>
<ul>
<li>对象语法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置 <code>isActive</code> 和 <code>hasError</code> 的值为 <code>true</code> 或者 <code>false</code> 来控制 <code>div</code> 是否有 <code>active</code> 和 <code>text-danger</code> 这两个 class</p>
<ul>
<li>数组语法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过给 <code>activeClass</code> 和 <code>errorClass</code> 赋值来控制 <code>div</code> 的 class</p>
<p>可以在数组语法中使用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样将始终添加 <code>errorClass</code> 里面的值，但是只有在 <code>isActive</code> 为真时才添加 <code>activeClass</code> 里面的值</p>
<p>也可以在数组语法中使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>给一个自定义组件加上 class 的话，会自动渲染到他的最外面的那个元素上面，并且最外面元素自身的 class 不会被覆盖，同样也支持对象语法等</p>
<h6 id="绑定-style">绑定 Style</h6>
<ul>
<li>对象语法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以为 <code>activeColor</code> 和 <code>fontSize</code> 赋值，来改变 Style</p>
<ul>
<li>数组语法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数组中可以装下多个样式对象</p>
<h5 id="绑定事件">绑定事件</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add()，自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;add(1)&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add(1)，不自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;n+=1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 n+=1 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以缩写 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>$event</code> 传递原始的 DOM 事件“</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="指令">指令</h5>
<ul>
<li>v- 开头的就是指令： <code>v-指令名:参数=值</code>，比如 <code>v-on:click=add</code></li>
<li>如果值里面没有特殊字符，可以不加引号</li>
<li>有的指令没有参数和值，比如 <code>v-pre</code></li>
<li>有的指令没有值，比如 <code>v-on:click.prevent</code>，阻止默认动作</li>
</ul>
<h6 id="动态参数">动态参数</h6>
<p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用 --&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="修饰符">修饰符</h6>
<p>有的指令支持修饰符，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@click.stop=&quot;add&quot; 阻止冒泡</span><br><span class="line">@click.prevent=&quot;add&quot; 阻止默认动作</span><br><span class="line">@click.stop.prevent=&quot;add&quot;</span><br><span class="line">@keypress.13 当按下回车时执行，或者用 @keypress.enter，有很多都有别名</span><br></pre></td></tr></table></figure>
<ul>
<li>.sync 修饰符</li>
</ul>
<p>查看 <a href="https://codesandbox.io/s/kind-cookies-1o6rs">这个在 CodeSandbox 上的例子</a>，或者 <a href="https://codesandbox.io/s/kind-cookies-1o6rs">这个例子</a></p>
<ul>
<li>组件不能修改 <code>props</code> 外部数据</li>
<li><code>$emit</code> 可以触发一个事件，并传参（发布）， <code>v-on</code> 可以监听他（订阅）</li>
<li><code>$event</code> 可以获取 <code>$emit</code> 的参数</li>
<li>由于经常会出现让组件想要更新数据的情况，所以有了 <code>.sync</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:money.sync=&quot;total&quot;</span><br><span class="line">等价于</span><br><span class="line">:money=&quot;total&quot; v-on:update:money=&quot;total = $event&quot;</span><br><span class="line">update:money 是事件名</span><br></pre></td></tr></table></figure>
<h5 id="条件渲染">条件渲染</h5>
<h6 id="v-if">v-if</h6>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;x &gt; 0&quot;</span>&gt;</span></span><br><span class="line">  x 大于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;x === 0&quot;</span>&gt;</span></span><br><span class="line">  x 为 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  x 小于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候我们需要加上 <code>key</code> 来管理元素的复用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为 label 没有 key，所以 label 复用了，仅仅是替换掉了文字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果没有 key，那么切换的时候 input 里面的内容将会保留，这就是元素的复用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="v-show">v-show</h6>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;n % 2 === 0&quot;</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 近似等于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;display: n%2===0 ? &#x27;block&#x27; : &#x27;none&#x27;&#125;&quot;</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 但是注意，不是所有看得见的元素 display 都是 block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table 是 table，li 是 list-item --&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p><code>v-if</code> 与 <code>v-show</code></p>
<ul>
<li><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>，<code>v-if</code> 则都支持</li>
<li><code>v-if</code> 在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，<code>v-show</code> 则只是切换了 <code>display</code> 属性</li>
<li>若初始条件为假，<code>v-if</code> 不会渲染，<code>v-show</code> 则会渲染</li>
</ul>
</div>
<h5 id="列表渲染">列表渲染</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(user, index) in users&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">    索引: &#123;&#123;index&#125;&#125; 值：&#123;&#123;user.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    属性名: &#123;&#123;name&#125;&#125; 属性值：&#123;&#123;value&#125;&#125; 索引: &#123;&#123;index&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p><code>:key="index"</code> 有 Bug， <code>v-for</code> 一定要有 <code>:key</code>，尽量要是不重合的值</p>
</div>
<p>当 <code>v-if</code> 和 <code>v-for</code> 同时使用的时候， <code>v-for</code> 的优先级会更高，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将只渲染未完成的 todo</p>
<p>在组件上使用 <code>v-for</code> 时需要手动将数据给传进去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="双向绑定">双向绑定</h5>
<p><code>v-model</code> 可以实现常用表单元素的双向绑定，包括文本、多行文本、复选框、单选按钮、选择框等</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相当于这样的简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="lifecycle-hooks">Lifecycle Hooks</h2>
<h3 id="vue-lifecycle">Vue Lifecycle</h3>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" /></p>
<p>在调用每个生命周期钩子的时候，已经完成了哪些事情：</p>
<ol type="1">
<li><strong>beforeCreate</strong>：创建一个新的 Vue 实例，初始化事件与生命周期</li>
<li><strong>created</strong>：初始化数据，进行数据的观测（比如将使用 <code>Object.defineProperty</code> 改造 data，并将 vm 作为代理）</li>
<li><strong>beforeMount</strong>：将模板编译为 render 函数，将 v-if 变为 if、v-for 变为 map 等</li>
<li><strong>mounted</strong>：给 vm 添加 $el 成员，并且替换掉挂载的 DOM 元素</li>
<li><strong>updated</strong>：数据发生改变，触发组件更新，将会使用新的数据构造一份新的 DOM，替换掉原来的</li>
<li><strong>destroyed</strong>：vm 指示的所有东西都会解绑，所有的事件监听器被移除，所有的子实例被销毁</li>
</ol>
<p>对于父子组件：</p>
<ol type="1">
<li>加载渲染过程 父 BeforeCreate -&gt; 父 Created -&gt; 父 BeforeMount -&gt; 子 BeforeCreate -&gt; 子 Created -&gt; 子 BeforeMount -&gt; 子 Mounted -&gt; 父 Mounted</li>
<li>子组件更新过程 父 BeforeUpdate -&gt; 子 BeforeUpdate -&gt; 子 Updated -&gt; 父 Updated</li>
<li>父组件更新过程 父 BeforeUpdate -&gt; 父 Updated</li>
<li>销毁过程 父 BeforeDestroy -&gt; 子 BeforeDestroy -&gt; 子 Destroyed -&gt; 父 Destroyed</li>
</ol>
<h2 id="assets">Assets</h2>
<h3 id="directives">directives</h3>
<h4 id="指令声明">指令声明</h4>
<p>可以查看 <a href="https://codesandbox.io/s/dank-cloud-99drb">在 CodSandbox 上的这个例子</a></p>
<p>声明全局指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;x&#x27;</span>, directiveOptions)</span><br><span class="line"><span class="comment">// 然后就可以全局使用 v-x 了</span></span><br></pre></td></tr></table></figure>
<p>声明局部指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; derectiveOptions &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只能在当前组件用 v-x，其子组件也不能用</span></span><br></pre></td></tr></table></figure>
<h4 id="directiveoptions">directiveOptions</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">bind</span>(el, info, vnode, oldVnode) <span class="comment">// 类似 created</span></span><br><span class="line"><span class="title function_">inserted</span>(el, info, vnode, oldVnode) <span class="comment">// 类似 mounted</span></span><br><span class="line"><span class="title function_">update</span>(el, info, vnode, oldVnode) <span class="comment">// 类似 updated</span></span><br><span class="line"><span class="title function_">componentUpdated</span>(el, info, vnode, oldVnode)</span><br><span class="line"><span class="title function_">unbind</span>(el, info, vnode, oldVnode) <span class="comment">// 类似 destroyed</span></span><br></pre></td></tr></table></figure>
<h4 id="指令的作用">指令的作用</h4>
<ul>
<li><strong>用于 DOM 操作</strong>
<ul>
<li>Vue 的实例/组件主要用于数据绑定、事件监听、DOM 更新；Vue 指令主要目的是原生 DOM 操作</li>
</ul></li>
<li><strong>减少重复</strong>
<ul>
<li>如果某个 DOM 操作经常使用/很复杂，可以封装成指令</li>
</ul></li>
</ul>
<h3 id="filters">filters</h3>
<p>尽量不用，用 methods</p>
<h3 id="components">components</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以引入一个 vue 文件，叫做 Demo，作为 frank 组件（局部注册）</span></span><br><span class="line"><span class="comment">// 优先使用这种，但是局部注册的组件在其子组件中不可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Demo</span> <span class="keyword">from</span> <span class="string">&#x27;./Demo.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="attr">frank</span>: <span class="title class_">Demo</span>, <span class="comment">// 如果是 Demo: Demo，就可以简化为 Demo</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以新建一个组件，后面接受的参数与 new Vue(options) 里面的 options 一样（除了没有 el），这叫全局组件</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写，options 也跟外面的一样（除了没有 el）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="attr">frank</span>: options,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件是一个抽象概念</li>
<li>文件名没有特殊规定，如果非常讲究，可以全用小写，因为比如 Windows 10 就不分大小写</li>
<li>组件名推荐首字母大写</li>
</ul>
<h2 id="composition">Composition</h2>
<h3 id="mixins">mixins</h3>
<p>目的：减少 data、methods、钩子的重复，可以查看在 <a href="https://codesandbox.io/s/lingering-microservice-6cw8h">Codesandbox 上的这个例子</a> 选项会智能合并：data、钩子等都会合并，在冲突的时候优先使用组件自己的</p>
<h3 id="extends">extends</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVue</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(options)</span><br><span class="line"><span class="comment">// 然后就可以用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyVue</span>(options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyVue</span> <span class="keyword">from</span> <span class="string">&quot;../MyVue.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">extends</span>: <span class="title class_">MyVue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看在 <a href="https://codesandbox.io/s/amazing-frog-f9xz5">CodeSandbox 上的这个例子</a></p>
<h3 id="provide-inject">provide &amp;&amp; inject</h3>
<p>用于大范围的数据共用，简单数据类型不能直接更改，需要通过函数，传过去的函数的 this 会自动绑定到 Provider 上面，可以查看在 <a href="https://codesandbox.io/s/affectionate-jennings-v4y1t">Codesandbox 上的这个例子</a></p>
<h1 id="component">Component</h1>
<ol type="1">
<li>用 JS 对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用 TS 类</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;source/_posts/Others-QA-Vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>, <span class="title class_">Prop</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// components: &#123;...&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Prop</span>(<span class="title class_">Number</span>) <span class="attr">propA</span>: <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = num ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">propA</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用 JS 类</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>, <span class="title class_">Prop</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  @<span class="title class_">Prop</span>(<span class="title class_">Number</span>) propA</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = num ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">propA</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="vue-router">Vue Router</h1>
<h2 id="基本使用">基本使用</h2>
<h3 id="html">HTML</h3>
<p><code>&lt;router-link/&gt;</code> 就像 <code>&lt;a&gt;</code> 标签，来链接到不同的路由</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/foo&quot;</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;router-view/&gt;</code> 用来装路由匹配出来的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="javascript">JavaScript</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 引入 VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入要被路由的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;../Foo.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Bar</span> <span class="keyword">from</span> <span class="string">&#x27;../Bar.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由，相当于定义 router 的配置选项</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span>&#125;,      </span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">&#x27;/bar&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Bar</span>&#125;      </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建根实例，并使用 VueRouter</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="路由匹配">路由匹配</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 22%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/user/:username</td>
<td>/user/evan</td>
<td><code>&#123; username: 'evan' &#125;</code></td>
</tr>
<tr class="even">
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td><code>&#123; username: 'evan', post_id: '123' &#125;</code></td>
</tr>
</tbody>
</table>
<div class="note warning"><p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用，组件的生命周期钩子不会再被调用</p>
</div>
<p>如果想要对路由参数的变化做出响应，需要 watch $route 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 beforeRouterUpdate：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套路由">嵌套路由</h2>
<p>一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>，此时要在 <code>VueRouter</code> 的参数中增加 <code>children</code> 的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">UserHome</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">UserProfile</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">UserPosts</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>以 / 开头的嵌套路径会被当作根路径</p>
</div>
<h2 id="编程式导航">编程式导航</h2>
<h3 id="router.pushlocation-oncomplete-onabort"><code>router.push(location, onComplete?, onAbort?)</code></h3>
<p>相当于 <code>&lt;router-link :to="..."&gt;</code>，两者的语法规则相同</p>
<div class="note warning"><p>在 Vue 实例里面，可以通过 <span class="math inline">\(router 访问路由实例 `router`。因此可以调用 this.\)</span>router.push</p>
</div>
<p>参数可以是字符串路径或者一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 提供了 path 之后 params 不生效</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>
<p><code>onComplete</code> 和 <code>onAbort</code> 参数可以传入两个回调：将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<div class="note warning"><p>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)</p>
</div>
<h3 id="router.replacelocation-oncomplete-onabort"><code>router.replace(location, onComplete?, onAbort?</code></h3>
<p>相当于 <code>router-link :to="..." replace</code>，不会向 history 添加新的记录，而是替换掉当前的 history 目录</p>
<div class="note warning"><p>跟 <code>push</code> 的主要区别就是 <code>replace</code> 可以回去，<code>push</code> 则不能</p>
</div>
<h3 id="router.gon"><code>router.go(n)</code></h3>
<p>类似 <code>window.history.go(n)</code> 意为在 history 记录中前进或后退多少步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">100</span>)</span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h2 id="命名视图">命名视图</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view two&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view three&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="title class_">Foo</span>,</span><br><span class="line">        <span class="attr">a</span>: <span class="title class_">Bar</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="title class_">Baz</span></span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="导航守卫">导航守卫</h2>
<h3 id="全局前置导航守卫-router.beforeeach">全局前置导航守卫 <code>router.beforeEach</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中 确保要调用 next 方法，否则钩子就不会被 resolved</p>
</div>
<ul>
<li><p><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p></li>
<li><p><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</p></li>
<li><p><code>next('/')</code> 或者 <code>next(&#123; path: '/' &#125;)</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: 'home'</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code> 中的选项。</p></li>
<li><p><code>next(error)</code>: 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调。</p></li>
</ul>
<h3 id="全局解析守卫-router.beforeresolve">全局解析守卫 <code>router.beforeResolve</code></h3>
<p>类似 <code>router.beforeEach</code>，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
<h3 id="全局后置钩子-router.aftereach">全局后置钩子 <code>router.afterEach</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="路由独享的守卫-beforeenter">路由独享的守卫 <code>beforeEnter</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Foo</span>,</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="组件内的守卫">组件内的守卫</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">    <span class="comment">// 但是可以通过传给 next 一个回调来访问组件实例          </span></span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 通常用来禁止用户在还未保存修改前突然离开，通过 next(false) 来取消用户的导航    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导航的解析流程">导航的解析流程</h3>
<ol type="1">
<li>导航被触发</li>
<li>在失活的组件里调用离开守卫</li>
<li>调用全局的 <code>beforeEach</code> 守卫</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)</li>
<li>在路由配置里调用 <code>beforeEnter</code></li>
<li>解析异步路由组件</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code></li>
<li>调用全局的 <code>beforeResolve</code> 守卫</li>
<li>导航被确认</li>
<li>调用全局的 <code>afterEach</code> 钩子</li>
<li>触发 DOM 更新</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数</li>
</ol>
<h1 id="vue">Vue</h1>
<p>可以先看一下 <a href="https://codesandbox.io/s/quizzical-kalam-303z8">这个例子</a></p>
<h2 id="基本使用-1">基本使用</h2>
<p>Vuex 的核心就是一个状态仓库，与普通的全局对象有所不同：</p>
<ol type="1">
<li>Vuex 的状态存储是响应式的，store 变化 -&gt; 组件响应式更新</li>
<li>不能直接修改 store 中的状态，只能通过提交 mutation 的方式来改变状态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// 定义一个初始的状态</span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 定义一些 mutation 来操作状态的变更</span></span><br><span class="line">  <span class="attr">mutation</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以通过 store.state 获取对象，或者通过 store.commit 来触发变更</span></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<h2 id="state">State</h2>
<p>Vuex 使用单一状态树，每个应用仅仅包含一个 store 实例</p>
<h3 id="在-vue-组件中获得-vuex-状态">在 Vue 组件中获得 Vuex 状态</h3>
<h4 id="方法一通过计算属性">方法一：通过计算属性</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每个需要使用 state 的组件中就都需要导入 store</p>
<h4 id="方法二将状态从根组件注入每个子组件">方法二：将状态从根组件注入每个子组件</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Counter</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;counter/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样子组件就可以通过 <code>this.$store</code> 访问到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span>  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三mapstate">方法三：<code>mapState</code></h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: <span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// 可以使用箭头函数</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以使用普通函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> + <span class="variable language_">this</span>.<span class="property">localCount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若计算属性的名称与子节点名称相同，的也可以给 mapState 传一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: <span class="title function_">mapState</span>([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h4 id="将-mapstate-与局部计算属性混用">将 mapState 与局部计算属性混用</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getter">Getter</h2>
<p>从 store 的 state 中派生出一些状态，类似于 store 的计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="comment">// 可以传入 state 作为第一个参数</span></span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">done</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以传入其他 getter 作为第二个参数</span></span><br><span class="line">    <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.<span class="property">doneTodos</span>.<span class="property">length</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以让 getter 返回一个函数来实现给 getter 传参</span></span><br><span class="line">    <span class="attr">getTodoById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">todo</span>.<span class="title function_">find</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">id</span> === id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到时候通过 store.getters.getTodoById(2) 这样访问</span></span><br><span class="line">    <span class="comment">// 这样通过方法访问就不会有缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以像访问 State 访问这些 Getter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="property">doneTodos</span> <span class="comment">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">doneTodosCount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过 mapGetters</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">  ...<span class="title function_">mapGetters</span>([</span><br><span class="line">  <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mutation">Mutation</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 将 state 作为第一个参数</span></span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将 payload 作为第二个参数，大多数情况下 payload 应该传一个对象</span></span><br><span class="line">    decrement (state, payload) &#123;</span><br><span class="line">      state.<span class="property">count</span> -= payload.<span class="property">amount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样提交</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;decrement&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成含有 type 属性的对象</span></span><br><span class="line">sotre.<span class="title function_">commit</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中提交</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapMutations</span></span><br><span class="line">  ...<span class="title function_">mapMutations</span>([</span><br><span class="line">    <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>Mutation 必须是同步函数，因为异步会使得很难调试，无法区分谁先回调</p>
</div>
<h2 id="action">Action</h2>
<p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态</li>
<li>Action 可以包含任意异步操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接受一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">  <span class="comment">// 这个 context 对象也有 context.state context.getters 这种方法</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以这样简化代码：</span></span><br><span class="line">  <span class="attr">action</span>: &#123;</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样触发，同 Mutation 一样，也支持 payload 和含有 type 的对象的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;incrementAsync&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中触发</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;incrementAsync&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapActions</span></span><br><span class="line">  ...<span class="title function_">mapActions</span>([</span><br><span class="line">    <span class="string">&#x27;incrementAsync&#x27;</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;incrementAsync&#x27;)`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...<span class="title function_">mapActions</span>(&#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="string">&#x27;incrementAsync&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;incrementAsync&#x27;)`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="module">Module</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.<span class="property">state</span>.<span class="property">a</span> <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.<span class="property">state</span>.<span class="property">b</span> <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/hais-notebook/2021/03/03/Webpack/</url>
    <content><![CDATA[<p>我们可以通过 Babel 提供的 Parser、Traverse、Generator 转换代码、分析依赖。 Webpack 的核心就是通过 Babel 将 ESModule 的语法转变为 CommonJS，使得浏览器支持，并将所有的文件打包成一个 js。</p>
<span id="more"></span>
<h1 id="尝试-webpack">尝试 Webpack</h1>
<p>Loader 和 Plugin？</p>
<ul>
<li>翻译</li>
<li>解释：加载文件；拓展功能</li>
<li>加载一个个 JS 文件，把 JS 文件转换成低版本浏览器可以支持的（JS Loader）；加载 CSS 文件，把 CSS 变成标签，或者进行其他处理 （CSS Loader、Style Loader）；加载图片，对图片进行优化；</li>
<li>HTML Webpack Plugin 生成 HTML 文件</li>
<li>Mini CSS Extract Plugin 抽取 CSS 文件</li>
</ul>
<h2 id="加载-javascript-文件">加载 JavaScript 文件</h2>
<p>可以这样来调用本地安装的 webpack：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/webpack —version </span><br><span class="line"><span class="comment"># 或者用 npx，但 npx 不够稳定，比如如果 node 装到了有空格的目录，可能就有问题</span></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<p>webpack 自带了 JS Loader，我们需要自定义一下 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 默认为 &#x27;./src/index.js&#x27;</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>HTTP Cache</strong> Response Header: Cache-Control</p>
</blockquote>
<p>可以设置 <code>package.json</code> 中的 <code>script</code>，让他每次自动删除之前的 <code>dist</code> 目录</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rm -rf dist &amp;&amp; webpack&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>之后只要每次用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>
<h2 id="生成-html-文件">生成 HTML 文件</h2>
<p>可以使用 <a href="https://webpack.js.org/plugins/html-webpack-plugin/">html-webpack-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>使用 html-webpack-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">HtmlWebPackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebPackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;my title&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;src/assets/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在 template 文件里面的 title 需要这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="加载-css-文件">加载 CSS 文件</h2>
<p>可以使用 <a href="https://webpack.js.org/loaders/css-loader/">css-loader</a> 和 <a href="https://webpack.js.org/loaders/style-loader/">style-loader</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure>
<p>使用 css-loader 和 style-loader 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>CSSLoader 会把 .css 后缀的文件读到 JS 里面 StyleLoader 会把 style 标签放到 HTML 的 head 里面</p>
</div>
<h2 id="预览与调试网页">预览与调试网页</h2>
<p>可以使用 <a href="https://webpack.js.org/guides/development/">webpack-dev-server</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>使用 webpack-dev-server 同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在 <code>package.json</code> 里面加入 <code>script</code> 方便使用</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --open&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="提取-css">提取 CSS</h2>
<p>可以使用 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<p>使用 mini-css-extract-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// all options are optional</span></span><br><span class="line">      <span class="attr">filename</span>: devMode ? <span class="string">&#x27;[name].css&#x27;</span> : <span class="string">&#x27;[name].[hash].css&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: devMode ? <span class="string">&#x27;[id].css&#x27;</span> : <span class="string">&#x27;[id].[hash].css&#x27;</span>,</span><br><span class="line">      <span class="attr">ignoreOrder</span>: <span class="literal">false</span>, <span class="comment">// Enable to remove warnings about conflicting order</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="comment">// you can specify a publicPath here</span></span><br><span class="line">              <span class="comment">// by default it uses publicPath in webpackOptions.output</span></span><br><span class="line">              <span class="attr">publicPath</span>: <span class="string">&#x27;../&#x27;</span>,</span><br><span class="line">              <span class="attr">hmr</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="加载-sass">加载 Sass</h2>
<div class="note warning"><p>node sass 已经过时，应该使用 dart sass</p>
</div>
<p>可以使用 <a href="https://webpack.js.org/loaders/sass-loader/">sass-loader</a></p>
<p>同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.scss$/i</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>:&#123;<span class="attr">implementation</span>: <span class="built_in">require</span>(<span class="string">&#x27;dart-sass&#x27;</span>)&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="加载-less">加载 Less</h2>
<p>可以使用 <a href="https://webpack.js.org/loaders/less-loader/">less-loader</a></p>
<h2 id="加载-stylus">加载 Stylus</h2>
<p>可以使用 <a href="https://github.com/shama/stylus-loader">stylus-loader</a></p>
<h2 id="加载图片">加载图片</h2>
<p>可以使用 file-loader，把文件变成文件路径</p>
<h2 id="懒加载">懒加载</h2>
<p>等到真正需要的时候再加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title function_">import</span>(<span class="string">&#x27;./lazy.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 将会得到一个 Promise 对象</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">module</span>.<span class="title function_">default</span>() <span class="comment">// 将会执行 export default 导出的函数</span></span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="在-github-pages-上部署">在 GitHub Pages 上部署</h2>
<p>第一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch gh-pages</span><br><span class="line">git checkout gh-pages</span><br><span class="line"><span class="comment"># 删除别的，只留下 dist、node_modules 和 .gitignore</span></span><br><span class="line"><span class="built_in">mv</span> dist/* ./</span><br><span class="line"><span class="built_in">rm</span> -rf dist</span><br></pre></td></tr></table></figure>
<p>以后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build: &amp;&amp;</span><br><span class="line">git checkout gh-pages &amp;&amp;</span><br><span class="line"><span class="built_in">rm</span> -rf *.html *.js *.css *.png &amp;&amp;</span><br><span class="line"><span class="built_in">mv</span> ./dist/* ./ &amp;&amp;</span><br><span class="line"><span class="built_in">rm</span> -rf dist</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m <span class="string">&#x27;update&#x27;</span> &amp;&amp;</span><br><span class="line">git push &amp;&amp;</span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure>
<h1 id="babel">Babel</h1>
<h2 id="原理">原理</h2>
<ol type="1">
<li><strong>Parse</strong>(<code>@babel/parser</code>): 把代码变成 AST</li>
<li><strong>Traverse</strong>(<code>@babel/traverse</code>)：遍历 AST 进行修改，或者遍历 AST 找到源代码的依赖</li>
<li><strong>Generate</strong>(<code>@babel/generator</code>)：把新的 AST 变成另外的代码</li>
</ol>
<p><code>@babel/core</code> 包含了前三者，<code>@babel/preset-env</code> 中有很多内置的规则</p>
<blockquote>
<p>为什么要用 AST？ 因为显然用正则表达式是不太科学的，需要识别到每个单词的意思</p>
</blockquote>
<h2 id="示例把-let-变成-var">示例：把 let 变成 var</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span></span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;@babel/generator&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = &quot;let&quot;; let b = 2`</span></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;)</span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="comment">// 进入时执行的钩子</span></span><br><span class="line">  <span class="attr">enter</span>: <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">type</span>, kind &#125; = item.<span class="property">node</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&quot;VariableDeclaration&quot;</span> &amp;&amp; kind === <span class="string">&quot;let&quot;</span>) &#123;</span><br><span class="line">      item.<span class="property">node</span>.<span class="property">kind</span> = <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">generate</span>(ast, &#123;&#125;, code)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">code</span>)</span><br></pre></td></tr></table></figure>
<p>可使用命令执行上述 DEMO：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -r --inspect-brk ts-node/register [filename]</span><br></pre></td></tr></table></figure>
<h2 id="示例把代码转变为-es5">示例：把代码转变为 ES5</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&quot;@babel/core&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = &quot;let&quot;; const b = 2`</span></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> result = babel.<span class="title function_">transformFromAstSync</span>(ast, code, &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="示例依赖分析">示例：依赖分析</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="attr">enter</span>: <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">node</span>.<span class="property">type</span> === <span class="string">&quot;ImportDeclaration&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// import 后面的路径，往往是一个相对路径</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">node</span>.<span class="property">source</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>可以用一个 hash 表来存放依赖关系</li>
<li>可以用递归实现嵌套依赖分析</li>
<li>可以记住以前分析过的依赖，如果发现分析过就直接 return，这样就能实现对循环依赖的静态分析（不执行代码，只进行字面理解）</li>
</ol>
<h1 id="webpack-核心原理">Webpack 核心原理</h1>
<h2 id="让浏览器支持-import-export">让浏览器支持 import / export</h2>
<p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">MDN 上的描述</a>，在浏览器中，import 语句只能在声明了 type="module" 的 script 的标签中使用。并且 IE 是不支持这个特性的。</p>
<ul>
<li>兼容策略 1：把代码全部放在 <code>&lt;script type="module"&gt;</code> 中，这样会导致 IE 不兼容，并且会导致文件请求过多，因为每个被依赖的文件都需要被单独发出请求</li>
<li>兼容策略 2：把关键字转译为普通的代码，并且把所有的文件打包成一个文件</li>
</ul>
<h2 id="babelcore-帮助我们转义-import-和-export"><span class="citation" data-cites="babel/core">@babel/core</span> 帮助我们转义 import 和 export</h2>
<p>babel 会帮助我们将 ESModule 的语法按照 CommonJS 的规则书写：import 关键字会变成 require 函数，export 关键字会变成 exports 对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&quot;@babel/core&quot;</span></span><br><span class="line"><span class="keyword">const</span> es5Code = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">getB</span>: <span class="function">() =&gt;</span> b.<span class="property">value</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel 转译之后的 es5 代码</span></span><br><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;); <span class="comment">// 给当前模块添加 __esModule 属性，方便与 CommonJS 分开</span></span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _b = <span class="title function_">_interopRequireDefault</span>(<span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实是为了给这个模块增加 default，因为 CommonJS 模块没有默认导出，这样是方便兼容，大部分 _interop 开头的代码都是为了兼容旧代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_interopRequireDefault</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.<span class="property">__esModule</span> ? obj : &#123; <span class="string">&quot;default&quot;</span>: obj &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">getB</span>: <span class="keyword">function</span> <span class="title function_">getB</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _b[<span class="string">&quot;default&quot;</span>].<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _default = a;</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default;</span><br></pre></td></tr></table></figure>
<h2 id="将所有文件打包成一个文件">将所有文件打包成一个文件</h2>
<blockquote>
<p>这个文件<strong>包含</strong>了所有的模块，并且能<strong>执行</strong>所有的模块</p>
</blockquote>
<p>思路：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最终文件应该长这个样子</span></span><br><span class="line"><span class="keyword">var</span> depRelation = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">&quot;index.js&quot;</span>, <span class="attr">deps</span>: [<span class="string">&quot;a.js&quot;</span>, <span class="string">&quot;b.js&quot;</span>], <span class="attr">code</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">&quot;a.js&quot;</span>, <span class="attr">deps</span>: [<span class="string">&quot;c.js&quot;</span>], <span class="attr">code</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">&quot;b.js&quot;</span>, <span class="attr">deps</span>: [<span class="string">&quot;d.js&quot;</span>], <span class="attr">code</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125; &#125;,</span><br><span class="line">] <span class="comment">// 这样一个 depRelation 数组存放了依赖关系，他的第一项就是入口文件</span></span><br><span class="line"><span class="comment">// 通过 execute 执行第一个文件，这样就会自动执行依赖中的其他文件</span></span><br><span class="line"><span class="title function_">excute</span>(depRelation[<span class="number">0</span>].<span class="property">key</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = depRelation.<span class="title function_">find</span>(<span class="function"><span class="params">i</span> =&gt;</span> i.<span class="property">key</span> === key)</span><br><span class="line">  item.<span class="title function_">code</span>() <span class="comment">// 我们要执行依赖中的代码，因此上面的 code 最好是一个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题一如何收集依赖">问题一：如何收集依赖？</h3>
<p>这个问题在上面已经讨论过了，可以借助 AST 来分析依赖</p>
<h3 id="问题二如何将文件中的-code-变为一个函数方便我们执行">问题二：如何将文件中的 code 变为一个函数方便我们执行？</h3>
<p>我们可以这样将文件里面的 code 变为函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">code = <span class="string">`</span></span><br><span class="line"><span class="string">  var b = require(&quot;./b.js&quot;)</span></span><br><span class="line"><span class="string">  exports.default = &quot;a&quot;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// require、module、exports 是 commonJS 2 规范所定</span></span><br><span class="line">code2 = <span class="string">`function(require, module, exports) &#123;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"><span class="comment">// 这样做最后写到文件中之后就是函数了</span></span><br></pre></td></tr></table></figure>
<h3 id="问题三execute-函数应该怎么写">问题三：execute 函数应该怎么写？</h3>
<p>下面是基本实现思路：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = &#123;&#125; <span class="comment">// modules 用于缓存所有模块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (modules[key]) &#123; <span class="keyword">return</span> modules[key] &#125;</span><br><span class="line">  <span class="keyword">var</span> item = depRelation.<span class="title function_">find</span>(<span class="function"><span class="params">i</span> =&gt;</span> i.<span class="property">key</span> === key)</span><br><span class="line">  <span class="comment">// require 其实就是 excute，区别在于 require 后面接的是一个路径，我们需要把它转成 key</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">require</span> = (<span class="params">path</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">execute</span>(<span class="title function_">pathToKey</span>(path))</span><br><span class="line">  &#125;</span><br><span class="line">  modules[key] = &#123; <span class="attr">__esModule</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable language_">module</span> = &#123; <span class="attr">exports</span>: modules[key] &#125;</span><br><span class="line">  <span class="comment">// 为了这个 item.code 在执行完成之后把自己的导出挂在 module.exports 上</span></span><br><span class="line">  item.<span class="title function_">code</span>(<span class="built_in">require</span>, <span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>)</span><br><span class="line">  <span class="keyword">return</span> modules[key] <span class="comment">// 其实就是 module.exports</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个简易的打包器">一个简易的打包器</h2>
<p>copy 过来的代码，仅供自己学习使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync, readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&#x27;@babel/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;project_1&#x27;</span>)</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DepRelation</span> = &#123; <span class="attr">key</span>: <span class="built_in">string</span>, <span class="attr">deps</span>: <span class="built_in">string</span>[], <span class="attr">code</span>: <span class="built_in">string</span> &#125;[]</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">depRelation</span>: <span class="title class_">DepRelation</span> = [] <span class="comment">// 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line"><span class="title function_">collectCodeAndDeps</span>(<span class="title function_">resolve</span>(projectRoot, <span class="string">&#x27;index.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="title function_">writeFileSync</span>(<span class="string">&#x27;dist_3.js&#x27;</span>, <span class="title function_">generateCode</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  code += <span class="string">&#x27;var depRelation = [&#x27;</span> + depRelation.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, deps, code &#125; = item</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      key: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span>, </span></span><br><span class="line"><span class="string">      deps: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(deps)&#125;</span>,</span></span><br><span class="line"><span class="string">      code: function(require, module, exports)&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + <span class="string">&#x27;];\n&#x27;</span></span><br><span class="line">  code += <span class="string">&#x27;var modules = &#123;&#125;;\n&#x27;</span></span><br><span class="line">  code += <span class="string">`execute(depRelation[0].key)\n`</span></span><br><span class="line">  code += <span class="string">`</span></span><br><span class="line"><span class="string">  function execute(key) &#123;</span></span><br><span class="line"><span class="string">    if (modules[key]) &#123; return modules[key] &#125;</span></span><br><span class="line"><span class="string">    var item = depRelation.find(i =&gt; i.key === key)</span></span><br><span class="line"><span class="string">    if (!item) &#123; throw new Error(\`\$&#123;item&#125; is not found\`) &#125;</span></span><br><span class="line"><span class="string">    var pathToKey = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      var dirname = key.substring(0, key.lastIndexOf(&#x27;/&#x27;) + 1)</span></span><br><span class="line"><span class="string">      var projectPath = (dirname + path).replace(\/\\.\\\/\/g, &#x27;&#x27;).replace(\/\\\/\\\/\/, &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">      return projectPath</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var require = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      return execute(pathToKey(path))</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    modules[key] = &#123; __esModule: true &#125;</span></span><br><span class="line"><span class="string">    var module = &#123; exports: modules[key] &#125;</span></span><br><span class="line"><span class="string">    item.code(require, module, module.exports)</span></span><br><span class="line"><span class="string">    return modules[key]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">collectCodeAndDeps</span>(<span class="params">filepath: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="title function_">getProjectPath</span>(filepath) <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="keyword">if</span> (depRelation.<span class="title function_">find</span>(<span class="function"><span class="params">i</span> =&gt;</span> i.<span class="property">key</span> === key)) &#123;</span><br><span class="line">    <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">readFileSync</span>(filepath).<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">code</span>: es5Code &#125; = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123; key, <span class="attr">deps</span>: [], <span class="attr">code</span>: es5Code &#125;</span><br><span class="line">  depRelation.<span class="title function_">push</span>(item)</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  <span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">    <span class="attr">enter</span>: <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">type</span> === <span class="string">&#x27;ImportDeclaration&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = <span class="title function_">resolve</span>(<span class="title function_">dirname</span>(filepath), path.<span class="property">node</span>.<span class="property">source</span>.<span class="property">value</span>)</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = <span class="title function_">getProjectPath</span>(depAbsolutePath)</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        item.<span class="property">deps</span>.<span class="title function_">push</span>(depProjectPath)</span><br><span class="line">        <span class="title function_">collectCodeAndDeps</span>(depAbsolutePath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProjectPath</span>(<span class="params">path: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">relative</span>(projectRoot, path).<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="webpack-loader-原理">Webpack Loader 原理</h1>
<h2 id="加载-css">加载 CSS</h2>
<p>思路：</p>
<ol type="1">
<li>我们的打包器只能加载 JS</li>
<li>我们想要加载 CSS</li>
<li>如果能把 CSS 变成 JS，就能加载 CSS 了</li>
</ol>
<p>在获取文件内容的时候，可以通过文件路径来判断是否是 css 文件，并稍作处理加载进 JS 中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code = <span class="title function_">readFileSync</span>(filePath).<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.<span class="title function_">test</span>(filePath)) &#123;</span><br><span class="line">  code = <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">      style.innerHTML = str</span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-loader">CSS Loader</h2>
<p>可以将上述代码变为 loader 的形式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transform</span> = (<span class="params">code</span>) =&gt; <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">      style.innerHTML = str</span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundler.ts</span></span><br><span class="line"><span class="keyword">let</span> code = <span class="title function_">readFileSync</span>(filePath).<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.<span class="title function_">test</span>(filePath)) &#123;</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">&#x27;css-loader&#x27;</span>)(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尝试对-css-loader-进行优化">尝试对 CSS Loader 进行优化</h2>
<blockquote class="blockquote-center">
<p>单一职责原则：每个 Loader 只做一件事情</p>

</blockquote>
<p>我们的 Loader 做了两件事情，第一是将 CSS 变为 JS 字符串，第二是将 JS 字符串放到了 style 标签里面，现在要对其进行拆分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transform</span> = (<span class="params">code</span>) =&gt; <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transform</span> = (<span class="params">code</span>) =&gt; <span class="string">`</span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">      style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bunlder.ts</span></span><br><span class="line"><span class="keyword">let</span> code = <span class="title function_">readFileSync</span>(filePath).<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.<span class="title function_">test</span>(filePath)) &#123;</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">&#x27;css-loader&#x27;</span>)(code)</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">&#x27;style-loader&#x27;</span>)(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是有问题的。最终得到的文件将不是我们想要的文件。</p>
<p>Loader 有不同的类型，像 sass-loader、less-loader 是将代码从一种语言转译为另外一种，这样的 loader 可以直接连接起来。但 style-loader 是插入代码而不是转译，所以需要寻找恰当的插入时机和位置——比如 css-loader 拿到结果之后。</p>
<h2 id="其他的-loader-源码">其他的 Loader 源码</h2>
<p>可以查看 Raw Loader、CSS Loader 等深入学习</p>
<div class="note warning"><p>webpack 安装的所有东西都是 --dev</p>
</div>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>npm &amp; yarn</title>
    <url>/hais-notebook/2020/02/02/npm/</url>
    <content><![CDATA[<p>收集 npm 的包和问题。 参考了 <a href="https://segmentfault.com/a/1190000039289332">1</a> , <a href="https://juejin.cn/post/6844903870578032647">2</a></p>
<span id="more"></span>
<h1 id="依赖包分类">依赖包分类</h1>
<h2 id="dependencies-devdependencies">dependencies, devDependencies</h2>
<table>
<thead>
<tr class="header">
<th>dependencies</th>
<th>devDependencies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>npm install [name]</code></td>
<td><code>npm install [name] --save-dev</code></td>
</tr>
<tr class="even">
<td>生产环境，属于线上代码的一部分</td>
<td>开发时才需要的依赖</td>
</tr>
<tr class="odd">
<td>vue、element-ui 等</td>
<td>webpack、babel-loader 等</td>
</tr>
</tbody>
</table>
<ul>
<li><code>npm install</code> 的时候，两个模块的包都会被下载</li>
<li>可以通过 <code>npm install --production</code> 忽略开发依赖，只安装基本依赖</li>
<li>模块是否被打包，取决于项目是否引入了该模块，而不取决于是在 dependencies 还是在 devDependencies 中</li>
<li>对于普通项目来说，把包写在哪里区别不大，但如果将这个包发布，那么写在 devDependencies 中的依赖将不会被下载</li>
</ul>
<h2 id="peerdependencies-bundledependencies-optionaldependencies">peerDependencies, bundleDependencies, optionalDependencies</h2>
<p>这三个属性主要是面向包的发布者。</p>
<h3 id="peerdependencies">peerDependencies</h3>
<p>表明如果想要使用这个包，需要的宿主环境所安装的包。</p>
<p>比如在 <code>vuei</code> 的 <code>1.0.0-alpha.24</code> 版本中，有：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;peerDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.5.16&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>表明如果在要使用该版本的 <code>vuei</code>，需要 <code>vue</code> 的版本 <code>&gt;=2.5.16</code> 且 <code>&lt;3.0.0</code>。</p>
<p>在 npm3.x 以上的版本中，如果安装结束后宿主环境没有满足要求，就会在控制台打出警告。</p>
<h3 id="bundleddependencies">bundledDependencies</h3>
<p>如果想在本地保留一个完整的 npm 包或者想生成一个压缩文件来获取 npm 包，会用到这个 bundleDependencies。使用 <code>npm pack</code> 进行打包的时候会将 bundleDependencies 中的包一起打包，并在 <code>npm install</code> 的时候进行安装。</p>
<p>比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-npm-pack&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bundleDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;renderized&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;super-streams&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>npm pack</code> 之后会生成 <code>my-npm-pack-1.0.0.tgz</code> 文件，该文件中包含 <code>renderized</code> 和 <code>super-streams</code> 依赖。当执行 <code>npm install my-npm-pack-1.0.0.tgz</code> 时，会自动安装这两个依赖。他们的版本需要在 dependencies 中指定。</p>
<p>当使用 <code>npm publish</code> 来发布包的话，这个属性将不起作用。</p>
<h3 id="optionaldependencies">optionalDependencies</h3>
<p>写在 optionalDependencies 里面的包，如果安装失败了也不会影响安装过程，并且 optionalDependencies 中的配置会覆盖 dependencies 中对应包的配置。</p>
<h1 id="scripts">scripts</h1>
<ul>
<li>定义在 <code>scripts</code> 中的命令，可以用过 <code>npm run &lt;command&gt;</code> 来执行</li>
<li><code>test</code> <code>start</code> <code>restart</code> <code>stop</code> 可以不用加 <code>run</code></li>
<li><code>npm run env</code> 可以获取到脚本运行时所有的环境变量</li>
<li><code>npm run</code> 会将 <code>node_modules/.bin/</code> 加入到 <code>shell</code> 的环境变量 <code>PATH</code> 中，这样局部安装的包就可以直接执行而不用加 <code>node_modules/.bin/</code> 的前缀</li>
</ul>
<h1 id="package-lock.json">package-lock.json</h1>
<p><a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json">文档在这里</a></p>
<p>对于 npm 来说，<code>package.json</code> 可以看做他的输入，<code>node_modules</code> 可以看成他的输出。</p>
<p>那么在理想情况下 npm 应该是一个 <strong>纯函数</strong>，但大多数时候并不能做到这一点，主要是因为：</p>
<ul>
<li>使用者 npm 版本可能不同，不同版本有不同的算法</li>
<li><code>^2.6.1</code> 这样的写法会使得安装的版本不同</li>
<li>我们可以写死版本，但却无法控制包的依赖的升级</li>
</ul>
<p>为了解决这个问题，npm5.x 开始加入了 <code>package-lock.json</code> 文件，每当 <code>npm install</code> 的时候，npm 都会产生/更新 <code>package-lock.json</code> 文件，他的作用就是锁定当前依赖安装结构。</p>
<p>我们需要注意 <code>pacakge-lock.json</code> 中的 <code>requires</code> 和 <code>dependencies</code> 两个属性的不同：</p>
<ul>
<li><code>requires</code> 表示包的依赖，与包的 <code>package.json</code> 中的 <code>dependencies</code> 依赖项相同</li>
<li><code>dependencies</code> 是存在包的 <code>node_modules</code> 中的依赖（不是所有的包都有，只有当包的依赖包的版本与根目录 <code>node_moduels</code> 中的依赖冲突时才会有</li>
</ul>
<p>从 npm3.x 开始，就采用扁平化的方式安装 <code>node_modules</code>。在安装的时候，npm 会遍历整个依赖树，不管是项目的直接依赖还是依赖的依赖，都会优先安装在根目录的 <code>node_modules</code> 中。遇到相同名称的包，如果发现根目录的 <code>node_modules</code> 中存在，但不符合 semver-range，就会将包的依赖装在包的 <code>node_modules</code> 中。</p>
<h2 id="npm-安装的流程">npm 安装的流程</h2>
<ol type="1">
<li>从磁盘加载 <code>node_modules</code> 树</li>
<li>克隆 <code>node_modules</code> 树</li>
<li>获取 <code>package.json</code> 文件和分类完毕的元数据信息，并把元数据信息插入到克隆树中</li>
<li>遍历克隆树，检查是否有丢失的依赖。如果有，把他们添加到克隆树中，依赖会尽可能地添加到最高层</li>
<li>比较原始树和克隆树，列出将原始树转换为克隆树需要采取的具体步骤</li>
<li>执行具体步骤，包括 install、update、remove、move 等</li>
</ol>
<h3 id="例1">例1</h3>
<p>假设 <code>package&#123;dep&#125;</code> 结构代表包和包的依赖，现在有 <code>A&#123;B,C&#125;</code> <code>B&#123;C&#125;</code> <code>C&#123;D&#125;</code>，按照算法执行完毕之后，生成 <code>node_modules</code> 如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">+-- D</span><br></pre></td></tr></table></figure>
<p>在安装 <code>B</code> 的依赖——<code>C</code> 的时候，发现顶层已经有 <code>C</code> 了，于是不会再在 <code>B</code> 的 <code>node_modules</code> 中再次安装；安装 <code>D</code> 的时候发现顶层没有 <code>D</code>，于是就将 <code>D</code> 安装在顶层。</p>
<h3 id="例2">例2</h3>
<p>当我们使用 <code>A&#123;B,C&#125;</code> <code>B&#123;C, D@1&#125;</code> <code>C&#123;D@2&#125;</code> 这样的依赖关系，产生的结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">    +-- D@2</span><br><span class="line">+-- D@1</span><br></pre></td></tr></table></figure>
<p><code>B</code> 依赖 <code>D@1</code>，安装时发现顶层没有，就会把 <code>D@1</code> 装在顶层；<code>C</code> 又依赖了 <code>D@2</code>，但安装 <code>D@2</code> 的时候发现顶层已经有了，npm 不允许同层存在两个名字相同的包，于是就将 <code>D@2</code> 装在了 <code>C</code> 自己的 <code>node_modules</code> 中。</p>
<p>模块安装的顺序会影响当存在相同依赖时，哪个版本会被安装在顶层。首先是项目中依赖的第一层包，然后这些包会被按照 a-z 的顺序依次进行安装（与在 <code>package.json</code> 中写入的顺序无关）。</p>
<h3 id="例3">例3</h3>
<p>有时，我们项目中所引用的包版本比较低，比如 <code>A&#123;B@1, C&#125;</code>，但 <code>C&#123;B@2&#125;</code>，首先安装的结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B@1</span><br><span class="line">+-- C</span><br><span class="line">    +-- B@2</span><br></pre></td></tr></table></figure>
<p>然后我们将项目中的 <code>B</code> 升级到 <code>B@2</code>，理想结构应该如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B@2</span><br><span class="line">+-- C</span><br></pre></td></tr></table></figure>
<p>但现在 <code>package-lock.json</code> 却是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B@2</span><br><span class="line">+-- C</span><br><span class="line">    +-- B@2</span><br></pre></td></tr></table></figure>
<p><code>B@2</code> 出现了两份，一份在顶层，一份在 <code>C</code> 中，这个时候需要我们手动执行 <code>npm dedupe</code> 进行去重操作。</p>
<h2 id="npm-ci">npm ci</h2>
<p>现在我们知道了，<code>package-lock.json</code> 在每次 <code>npm install</code> 的时候都可能发生更新，他只是精确描述了当前安装的 <code>node-moduels</code> 树。并不是说 <code>package-lock.json</code> 中是什么版本，我用 <code>npm install</code> 安装的就是什么版本——若想要达成这样的效果，需要使用 <a href="https://docs.npmjs.com/cli/v7/commands/npm-ci"><code>npm ci</code></a></p>
<p>ci 就是 <code>clean install</code> 的意思，他不会改变 <code>package-lock.json</code>，并且会完全按照 <code>package-lock.json</code> 中的样子进行安装，比较适合用于一些自动生成的环境，比如测试平台、持续集成等。</p>
<h1 id="npm-shrinkwrap.json">npm-shrinkwrap.json</h1>
<p>在 npm5.x 之前，可以手动通过 <code>npm srhinkwrap</code> 生成 <code>npm-shrinkwrap.json</code> 文件，他与 <code>package-lock.json</code> 作用相同。当二者在项目中同时存在的时候，将优先使用 <code>npm-shrinkwrap.json</code></p>
<h1 id="npm-outdated"><code>npm-outdated</code></h1>
<p>可以查看当前的依赖的包版本是否过时，默认只列出顶层，可以通过 <code>--depth</code> 参数控制深度。</p>
<h1 id="一些问题">一些问题</h1>
<h2 id="怎么知道包的最新版是多少">怎么知道包的最新版是多少？</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm info [name] version</span><br></pre></td></tr></table></figure>
<h1 id="好用的-npm-包">好用的 npm 包</h1>
<h2 id="nrm">nrm</h2>
<p>一个 npm 镜像管理工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br><span class="line">nrm use taobao</span><br><span class="line"><span class="comment"># 所有的全局安装都在 C:\Users\Zhang\AppData\Roaming\npm\</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn global add yrm</span><br><span class="line">yrm use taobao</span><br><span class="line"><span class="comment"># 用 yrm ls 可以看所有源</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
</search>
