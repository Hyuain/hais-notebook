<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 入门</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-Git/</url>
    <content><![CDATA[<p>主要记录 Git 的基本用法及一些坑的解决。</p>
<a id="more"></a>

<h1 id="Git-本地仓库"><a href="#Git-本地仓库" class="headerlink" title="Git 本地仓库"></a>Git 本地仓库</h1><h2 id="六行配置"><a href="#六行配置" class="headerlink" title="六行配置"></a>六行配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name [username] </span><br><span class="line">git config --global user.email [useremail@example.com]</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">"code --wait"</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>git init</code></td>
<td>创建 <code>.git</code> 目录，容纳代码快照</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>准备将文件提交进 git 目录（本地仓库），路径可以是绝对路径、相对路径、<code>.</code>（当前目录）和 <code>*</code></td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看目前的状态</td>
</tr>
<tr>
<td><code>git commit</code></td>
<td>提交（实际上是复制到了.git目录）</td>
</tr>
<tr>
<td><code>git commit -m &quot;version1&quot;</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>git commit -v（--verbose）</code></td>
<td>推荐，提交理由写得更详细</td>
</tr>
<tr>
<td><code>git reset --hard xxxxxx（提交号的前六位）</code></td>
<td>这个操作会使没有 commit 过的变动消失</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看历史记录</td>
</tr>
<tr>
<td><code>git reflog</code></td>
<td>查看包括 reset 的历史记录</td>
</tr>
<tr>
<td><code>git branch xxx</code></td>
<td>基于当前的commit创建一份新的分支</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看所有分支和当前分支</td>
</tr>
<tr>
<td><code>git branch -d xxx</code></td>
<td>删除分支</td>
</tr>
<tr>
<td><code>git checkout xxx</code></td>
<td>切换分支，当前未提交的文件如果与另一个分支不冲突，切换分支的操作就不会产生影响，如果冲突，可以用git stash或合并冲突</td>
</tr>
<tr>
<td><code>git merge xxx</code></td>
<td>合并分支，先到达想要保留的分支再使用</td>
</tr>
</tbody></table>
<p><code>.gitignore</code> 文件中可以输路径来忽略不想提交的文件，比如 <code>node_modules</code> <code>DS_Store</code> <code>.idea</code> <code>.vscode</code></p>
<h1 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个私钥和公钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C [useremail@example.com]</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传一个本地仓库</span></span><br><span class="line">git remote add origin [git@github.com:Hyuain/git-demo-1.git]</span><br><span class="line">git push -u origin master <span class="comment"># 一个新的分支需要写 -u 和后面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git：创建一个新目录，与 xxx 同名</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git yyy：创建一个新目录，命名为 yyy</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git .：不会新建目录，使用当前目录容纳代码和 .git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="comment"># git stash：把文件藏起来</span></span><br><span class="line"><span class="comment"># git stash pop：再把文件取出来</span></span><br></pre></td></tr></table></figure>

<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias ga="git add"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gc="git commit -v"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gl="git pull"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gp="git push"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gco="git checkout"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gst="git status -sb"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">code ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后加上</span></span><br><span class="line"><span class="built_in">alias</span> glog=<span class="string">"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit -- | less"</span></span><br></pre></td></tr></table></figure>

<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="git-log-中文乱码"><a href="#git-log-中文乱码" class="headerlink" title="git log 中文乱码"></a>git log 中文乱码</h2><p>输入以下命令即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>

<h2 id="git-push-clone-报错"><a href="#git-push-clone-报错" class="headerlink" title="git push / clone 报错"></a>git push / clone 报错</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>防火墙添加 22 端口入站策略配置为允许，有时候不能解决问题。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ol>
<li>在 <code>~/.ssh</code> 存放密钥（<code>id_rsa</code> 和 <code>id_rsa.pub</code>）的文件夹，新建 <code>config</code>，内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User XXX@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>刷新 <code>config</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"XXX"</span></span><br><span class="line">git config --global user.email XXX@xx.com</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>有时候还是不能解决问题</p>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><ol>
<li>修改 hosts 文件，也可以进入 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress</a> 查询这域名的 IP 地址。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>刷新 DNS 缓存</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>常识</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-CommonSense-Command/</url>
    <content><![CDATA[<p>主要记录命令行的基本用法。</p>
<a id="more"></a>

<h1 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd ~</code></td>
<td>~ 表示用户目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>Print Work Directory，展示当前的绝对路径</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>List，查看当前目录文件内容（默认不显示以 <code>.</code> 开头的文件）</td>
</tr>
<tr>
<td><code>ls [file path]</code></td>
<td>查看文件路径内容</td>
</tr>
<tr>
<td><code>ls -l</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>Concatenate，打印文件内容</td>
</tr>
<tr>
<td><code>head</code></td>
<td>展示前 10 行文件，或者 <code>-n [数字]</code></td>
</tr>
<tr>
<td><code>tail</code></td>
<td>展示后 10 行文件</td>
</tr>
<tr>
<td><code>less</code></td>
<td>进入一个可滚动的界面，按上、下（或 J、K ）滚动，按 Q 退出</td>
</tr>
</tbody></table>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>touch</code></td>
<td>创建空文件，可以同时创建多个文件；或者修改文件的更新时间</td>
</tr>
<tr>
<td><code>echo</code></td>
<td>返回你 <code>echo</code> 的东西</td>
</tr>
<tr>
<td><code>echo [content] &gt; 4.txt</code></td>
<td>创建有内容的文件，会覆盖之前的内容</td>
</tr>
<tr>
<td><code>echo [content] &gt;&gt; 4.txt</code></td>
<td>追加内容</td>
</tr>
<tr>
<td><code>echo -e &quot;[content]\n&quot; &gt;&gt; 4.txt</code></td>
<td>有换行的内容</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录，可以同时创建多个目录</td>
</tr>
<tr>
<td><code>mkdir -p a/b/c/d</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>cp [filename] [new filename]</code></td>
<td>复制文件</td>
</tr>
<tr>
<td><code>cp -r [dir] [new dir]</code></td>
<td>复制目录</td>
</tr>
</tbody></table>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>rm</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>rm -r</code></td>
<td>删除目录</td>
</tr>
<tr>
<td><code>rm -rf</code></td>
<td>强制删除（不管里面有没有内容）</td>
</tr>
</tbody></table>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>使用 VSCode 打开</td>
</tr>
<tr>
<td><code>start</code></td>
<td>使用默认程序打开</td>
</tr>
<tr>
<td><code>mv [filename] .</code></td>
<td>移动到当前目录</td>
</tr>
<tr>
<td><code>mv [filename] [new filename]</code></td>
<td>重命名文件</td>
</tr>
</tbody></table>
<h2 id="命令的组合"><a href="#命令的组合" class="headerlink" title="命令的组合"></a>命令的组合</h2><ul>
<li>成功返回 <code>0</code>，失败返回 <code>error</code> 和非 <code>0</code> 值，通过 <code>echo $?</code> 查看</li>
<li><code>&amp;&amp;</code>：第一条命令后才会执行后面的</li>
<li><code>;</code>：不管前面是否成功都会执行后面的</li>
</ul>
<h2 id="把命令变成文件"><a href="#把命令变成文件" class="headerlink" title="把命令变成文件"></a>把命令变成文件</h2><ul>
<li>MAC上需要执行：<code>chmod +x [filename]</code>，赋予执行权限</li>
<li>执行命令：<code>./[filename]</code> 或者 <code>sh [filename]</code></li>
<li>如果加入 <code>PATH</code>，就可以不用输入文件路径，也不用输入 <code>./</code>，输入文件名就能执行</li>
<li>命令行的本质就是可执行文件</li>
<li>windows 会优先去找 <code>.exe</code> 的文件</li>
</ul>
]]></content>
      <categories>
        <category>常识</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM API</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-DOM/</url>
    <content><![CDATA[<p>Document Object Model，即将网页抽象成对象，并用 JS 进行操作的方式。</p>
<a id="more"></a>

<h1 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.id <span class="comment">// 或者直接 id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'idxxx'</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'div&gt;span:nth-child(2)'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'.red'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="获取特定的元素"><a href="#获取特定的元素" class="headerlink" title="获取特定的元素"></a>获取特定的元素</h2><ul>
<li>获取 html： <code>document.documentElement</code></li>
<li>获取 head： <code>document.head</code></li>
<li>获取 body： <code>document.body</code></li>
<li>获取 window： <code>window</code></li>
<li>获取所有元素： <code>document.all</code>，第 6 个 <code>falsy</code> 值，别的浏览器为了不使用为了 IE 设计的代码（这个是 IE 发明的）</li>
</ul>
<h2 id="获取的元素的原型"><a href="#获取的元素的原型" class="headerlink" title="获取的元素的原型"></a>获取的元素的原型</h2><p>div 的原型链：</p>
<p><code>HTMLDivElement.prototype</code> → <code>HTMLElement.prototype</code> → <code>Elment.prototype</code> → <code>Node.prototype</code> → <code>EventTarget.prototype</code> → <code>Object.prototype</code></p>
<h2 id="节点（Node）和元素（Element）的区别"><a href="#节点（Node）和元素（Element）的区别" class="headerlink" title="节点（Node）和元素（Element）的区别"></a>节点（Node）和元素（Element）的区别</h2><p>使用 x.nodeType 可以得到一个数字：</p>
<ul>
<li>1 表示 Element（也叫 Tag ）</li>
<li>3 表示 Text</li>
<li>8 表示 Comment</li>
<li>9 表示 Document</li>
<li>11 表示 DocumentFragment</li>
</ul>
<h2 id="获取附近的元素"><a href="#获取附近的元素" class="headerlink" title="获取附近的元素"></a>获取附近的元素</h2><ul>
<li>查爸爸： <code>div.parentNode</code> 或者 <code>div.parentElement</code></li>
<li>查子代： <code>div.childNodes</code> 或者 <code>div.children</code>，推荐使用后者，因为前者包括了文本节点，比如空格，两者都会实时变化</li>
<li>查兄弟姐妹： <code>div.parentNode.childNodes</code> 或者 <code>div.parentNode.children</code>，然后再排除自己</li>
<li>查看老大： <code>div.firstChild</code></li>
<li>查看老幺： <code>div.lastChild</code></li>
<li>查看上一个哥哥： <code>div.previousSibling</code>（有可能查到文本节点，可以用 <code>div.previousElementSibling</code>）</li>
<li>查看下一个弟弟： <code>div.nextSibling</code>（有可能查到文本节点，可以用 <code>div.nextElementSibling</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历一个 div 里面所有的元素</span></span><br><span class="line">travel = <span class="function">(<span class="params">node, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  fn(node)</span><br><span class="line">    <span class="keyword">if</span>(node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">      travel(node.children[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">travel(div1, (node) =&gt; <span class="built_in">console</span>.log(node))</span><br></pre></td></tr></table></figure>

<h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><h2 id="创建一个标签"><a href="#创建一个标签" class="headerlink" title="创建一个标签"></a>创建一个标签</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="创建一个文本节点"><a href="#创建一个文本节点" class="headerlink" title="创建一个文本节点"></a>创建一个文本节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">text = <span class="built_in">document</span>.createTextNode(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在标签里面插入文本"><a href="#在标签里面插入文本" class="headerlink" title="在标签里面插入文本"></a>在标签里面插入文本</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div1.appendChild(text1)</span><br><span class="line">div1.innerText = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">div1.textContent = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">//但是不能用</span></span><br><span class="line">div.appendChild(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="插入到页面中"><a href="#插入到页面中" class="headerlink" title="插入到页面中"></a>插入到页面中</h2><ul>
<li><code>document.body.appendChild(div)</code> 或者 <code>已经在页面中的元素.appendChild(div)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有 div#test1 和 div#test2</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">test1.appendChild(div)</span><br><span class="line">test2.appendChild(div)</span><br><span class="line"><span class="comment">// div 最终只会出现在 test2 里面</span></span><br></pre></td></tr></table></figure>

<ul>
<li>让两个地方都有： <code>let div2 = div1.cloneNode(true)</code>，如果后面为 <code>true</code> 则使用深拷贝，所有的后代也会被拷贝</li>
</ul>
<h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.parentNode.removeChild(div)</span><br><span class="line">div.remove()</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>如果一个 Node 被移除了页面（DOM）树，它还可以再被放回去，它暂存在了内存里面，如果想删除，<code>div = null</code>，一会儿会自动回收</p>
          </div>

<h1 id="编辑节点"><a href="#编辑节点" class="headerlink" title="编辑节点"></a>编辑节点</h1><h2 id="编辑属性"><a href="#编辑属性" class="headerlink" title="编辑属性"></a>编辑属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.className = <span class="string">'red blue'</span><span class="comment">// 会覆盖掉之前的 class，要用 div.className += ' red'</span></span><br><span class="line"></span><br><span class="line">div.classList.add(<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line">div.style = <span class="string">'color: blue'</span></span><br><span class="line"><span class="comment">// 会覆盖掉之前的 style，一般就写 style 的一部分</span></span><br><span class="line"><span class="comment">// 比如 div.style.color = 'blue'，注意大小写问题：div.style.backgroundColor</span></span><br><span class="line"></span><br><span class="line">div.setAttribute(<span class="string">'data-x'</span>, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">div.getAtrribute(<span class="string">'data-x'</span>) <span class="comment">// 强加的，这样写也行</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>如果用 <code>a.href</code> 获取属性，然后是相对路径的话，他会把域名一起弄下来<br>如果用 <code>a.href.getAttribute(&#39;href&#39;)</code> 只获取属性里面写了的部分</p>
          </div>

<h2 id="编辑事件"><a href="#编辑事件" class="headerlink" title="编辑事件"></a>编辑事件</h2><ul>
<li><code>div.onclick</code> 默认为 <code>null</code>，如果改成 <code>fn</code>，那么在点击的时候就会调用 <code>fn.call(div, event)</code>，<code>event</code> 包含了点击事件的所有信息，比如坐标</li>
<li><code>div.addEventListener</code></li>
</ul>
<h2 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h2><h3 id="编辑文本内容"><a href="#编辑文本内容" class="headerlink" title="编辑文本内容"></a>编辑文本内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerText = <span class="string">'hi'</span></span><br><span class="line">test.textContent = <span class="string">'hi'</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-HTML-内容"><a href="#修改-HTML-内容" class="headerlink" title="修改 HTML 内容"></a>修改 HTML 内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 里面的字符不能超过两万个</span></span><br></pre></td></tr></table></figure>

<h3 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 先清空</span></span><br><span class="line">test.appendChild(div) <span class="comment">//再加内容</span></span><br></pre></td></tr></table></figure>

<h2 id="跨线程"><a href="#跨线程" class="headerlink" title="跨线程"></a>跨线程</h2><p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.start</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.end</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.classList.add(<span class="string">'start'</span>)</span><br><span class="line">test.clientWidth <span class="comment">// 如果没有这句话，上下两句话就会合并，这句话会触发重新渲染</span></span><br><span class="line">test.classList.add(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><ul>
<li>标准属性，会自动同步，比如 <code>id</code> <code>className</code> <code>title</code></li>
<li><code>data-*</code> 属性，也会自动同步</li>
<li>非标准属性，不会同步到页面里，只会停留在JS 线程中，而不会自动同步到页面上</li>
</ul>
<p><img src="/hais-notebook/images/JS-007.png" alt=""><br><img src="/hais-notebook/images/JS-008.png" alt=""></p>
<div class="note warning">
            <p>自定义属性最好以 <code>data-</code> 为前缀</p>
          </div>

<h3 id="Property-和-Attribute"><a href="#Property-和-Attribute" class="headerlink" title="Property 和 Attribute"></a>Property 和 Attribute</h3><ul>
<li>Property 是 JS 线程中 div1 的所有属性</li>
<li>Attribute 是 渲染引擎中 div1 对应标签的属性</li>
<li>大部分时候，同名的 Property 和 Attribute 值相等</li>
<li>如果不是标准属性，那么他们俩只会在一开始的时候相等</li>
<li>但注意 Attribute 只支持字符串，而 Property 支持字符串、布尔等类型</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 世界</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-World/</url>
    <content><![CDATA[<p>介绍 JavaScript 这个世界从诞生开始的故事。</p>
<a id="more"></a>

<h1 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h1><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><ul>
<li>固件是固定在主板上的存储设备，里面有开机程序</li>
<li>开机程序会将文件里的 OS 加载到内存里运行</li>
</ul>
<h2 id="操作系统（以-Linux-为例）"><a href="#操作系统（以-Linux-为例）" class="headerlink" title="操作系统（以 Linux 为例）"></a>操作系统（以 Linux 为例）</h2><ul>
<li>首先加载操作系统内核</li>
<li>然后启动初始化进程，编号为 1，每个进程都有 PID</li>
<li>启动系统服务：文件、安全、联网</li>
<li>等待用户登录：输入密码登录 / ssh 登录</li>
<li>登录后，运行 shell，用户就可以和操作系统对话了</li>
<li>bash 是一种 shell，图形化界面可认为是一种 shell</li>
</ul>
<h1 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h1><h2 id="chrome-exe"><a href="#chrome-exe" class="headerlink" title="chrome.exe"></a>chrome.exe</h2><ul>
<li>运行 chrome.exe 文件</li>
<li>开启 chrome 进程，作为主进程</li>
<li>主进程会开启一些辅助进程，如网络服务、GPU 加速</li>
<li>每新建一个标签，就有可能开启一个子进程</li>
</ul>
<h2 id="浏览器的功能"><a href="#浏览器的功能" class="headerlink" title="浏览器的功能"></a>浏览器的功能</h2><ul>
<li>发起请求、下载 HTML、解析 HTML、下载 CSS、解析 CSS、渲染界面、下载 JS、解析 JS、执行 JS</li>
<li>功能模块：用户界面、渲染引擎、JS 引擎、存储等，这些功能模块属于不同的线程<ul>
<li>JS 通过<strong>跨线程通信</strong>，使渲染引擎重新渲染</li>
<li>JS 是单线程的</li>
<li>DOM 操作慢：跨线程通信慢</li>
</ul>
</li>
</ul>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><ul>
<li>浏览器用的什么 JS 引擎？<ul>
<li>Chrome 用的是 V8 引擎，C++ 编写</li>
<li>网景用的是 SpiderMonkey，后被 Firefox 使用，C++</li>
<li>Safari 用的是 JavaScriptCore</li>
<li>IE 用的是 Chakra（JScript 9）</li>
<li>Edge 用的是 Chakra (JavaScript)</li>
<li>Node.js 用的是 V8 引擎</li>
</ul>
</li>
<li>主要功能<ul>
<li>编译：把 JS 代码翻译为机器能执行的字节码或机器码</li>
<li>优化：改写代码，使其更加高效</li>
<li>执行：执行上面的字节码或机器码</li>
<li>垃圾回收：把 JS 用完的内存回收，方便之后再次使用</li>
</ul>
</li>
</ul>
<h2 id="运行-JavaScript-代码"><a href="#运行-JavaScript-代码" class="headerlink" title="运行 JavaScript 代码"></a>运行 JavaScript 代码</h2><ul>
<li>准备工作<ul>
<li>提供 API： window、document、setTimeout（这些功能成为运行环境 runtime env）</li>
</ul>
</li>
<li>内存图<ul>
<li><img src="/hais-notebook/images/JS-002.png" alt=""></li>
<li>红色区域（存放数据，但不会存变量名）<ul>
<li>Stack 栈：每个数据顺序存放，非对象都存在 Stack</li>
<li>Heap 堆：每个数据随机存放，对象都存在 Heap（数组、函数）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JavaScript-世界"><a href="#JavaScript-世界" class="headerlink" title="JavaScript 世界"></a>JavaScript 世界</h1><blockquote class="blockquote-center"><p><strong>JS 公式：<code>对象.__proto__ === 其构造函数.prototype</code></strong><br><strong>根公理：<code>Object.prototype</code> 是所有对象的（直接或间接）原型</strong><br><strong>函数公理：所有函数都是由 <code>Function</code> 构造的</strong></p>
</blockquote>

<p><img src="/hais-notebook/images/JS-003.png" alt=""><br><img src="/hais-notebook/images/JS-004.png" alt=""><br><img src="/hais-notebook/images/JS-005.png" alt=""><br><img src="/hais-notebook/images/JS-006.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Function</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Function/</url>
    <content><![CDATA[<p>正式介绍 JavaScript 中的函数。</p>
<a id="more"></a>

<h1 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h1><h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参</span>) </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>) </span>&#123; 函数体 &#125; <span class="comment">// 右边的部分也叫函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">形参</span>)</span>&#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 如果函数的声明是在 = 右边</span></span><br><span class="line"><span class="comment">// fn 的作用域只能在 = 右边</span></span><br><span class="line"><span class="comment">// 别的地方不能用 fn 这个名字</span></span><br></pre></td></tr></table></figure>

<h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入参数 =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> 语句</span><br><span class="line">&#125;</span><br><span class="line">x =&gt; (&#123; <span class="attr">name</span>: <span class="string">'...'</span> &#125;) <span class="comment">// 如果要返回对象，就要加圆括号</span></span><br></pre></td></tr></table></figure>

<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数可以先使用再声明，因为 function 会跑到最前面<br>但是 <code>let fn = function(){}</code> 不是函数提升，他不能先使用再声明，因为这句话是赋值，右边的匿名函数不会提升</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li><strong>全局变量与局部变量</strong>：在 <strong>顶级作用域</strong> 声明的变量是全局变量（比如 window 上的变量是全局变量）；其他的都是局部变量</li>
<li><strong>就近原则</strong>：如果有多个作用域有同名变量 <code>a</code>，那么查找 <code>a</code> 的声明时，就向上取最近的作用域</li>
<li><strong>作用域的确定与函数的执行无关（JavaScript 的作用域为静态作用域），但变量的值在函数执行的时候才能确定</strong></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>函数用到了外部的变量，则函数+这个变量=闭包，作用域遵循就近原则</p>
</blockquote>
<p>闭包的作用：隐藏局部变量，暴露操作函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = createAdd()</span><br><span class="line">add() <span class="comment">// 1</span></span><br><span class="line">add() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>闭包的缺点：容易内存泄露。注意，虽然闭包并不会造成内存泄露，真实原因是 JS 引擎的实现有问题。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>复制内存图中 stack 里面的东西（简单类型复制值，对象复制地址）</p>
<h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>实际上就是变量声明： <code>var x = arguments[0]</code></p>
<div class="note warning">
            <p>形参可多可少</p>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>每个函数都有返回值，默认是 <code>undefined</code></li>
<li>只有函数才有返回值</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><ul>
<li>JS 在调用函数之前，需要把函数的环境 push 到一个数组（调用栈）里面，等函数执行完之后把环境 pop 出来，然后 return 到之前的环境中</li>
<li>递归很容易把栈压满：爆栈</li>
<li>调用栈最长有多少？Chrome 12578；Firefox 26773；Node 12536</li>
</ul>
<h1 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h1><blockquote>
<p>关于 this 更多的内容可以看看这篇文章—— <a href="https://hais-teatime.com/post/2019-12-24-this/" target="_blank" rel="noopener">再看 this</a>。</p>
</blockquote>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>调用函数即传入 arguments， arguments 是包含传入参数的伪数组</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><code>this</code> 的存在是为了解决函数获取一个对象的引用的问题</li>
<li>如果不给任何的条件， <code>this</code> 为 <code>window</code></li>
<li>如果想要指定 <code>this</code>，要用 <code>fn.call(xxx, 1, 2, 3)</code> 传入 <code>this</code> 和 <code>arguments</code>（如果传入的 <code>this</code> 不是对象，将会默认封装成对象，除非加上 <code>&#39;use strict&#39;</code>，JS的糟粕）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this: '</span> + <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">1</span>) <span class="comment">// 'this: 1'</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>) <span class="comment">// 'this: undefined'</span></span><br></pre></td></tr></table></figure>

<h3 id="两种调用函数的方法"><a href="#两种调用函数的方法" class="headerlink" title="两种调用函数的方法"></a>两种调用函数的方法</h3><h4 id="隐式传递"><a href="#隐式传递" class="headerlink" title="隐式传递"></a>隐式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi()</span><br><span class="line"><span class="comment">// 会自动地把 person 传到函数里，作为 this</span></span><br></pre></td></tr></table></figure>

<h4 id="显式传递"><a href="#显式传递" class="headerlink" title="显式传递"></a>显式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi.call(person)</span><br><span class="line"><span class="comment">// 手动把 person 传到函数里，作为 this</span></span><br><span class="line"><span class="comment">// apply 跟 call 的区别就是后面要加中括号（参数传的是数组）</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">p1, p2</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>, p1, p2) &#125;</span><br><span class="line"><span class="keyword">let</span> f3 = f1.bind( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125;, <span class="string">'hi'</span> )</span><br><span class="line">f3()  <span class="comment">// 等价于 f1.call( &#123;name:'hai'&#125;, 'hi' )</span></span><br><span class="line">      <span class="comment">// 相当于让 f3 的 this 和 arguments 永远等于这个</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>没有 <code>arguments</code> 和 <code>this</code>，里面的 <code>this</code> 就是外面的 <code>this</code>，就算加 <code>call</code> 也没有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">fn() <span class="comment">// window</span></span><br><span class="line">fn.call( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125; ) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>只想要一个局部变量，而不想要一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="regexp">/-/</span><span class="number">1</span>*<span class="regexp">/! function ()&#123; var a = 2; console.log(a) &#125; ()</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明了一个全局函数，立即调用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Array/</url>
    <content><![CDATA[<p>JS 的数组不是典型的数组，而是一个对象；<strong>元素的数据类型可以不同，内存不一定连续，是通过字符串下标（而不是数字下标）获取元素</strong>。</p>
<a id="more"></a>

<h1 id="获得新数组"><a href="#获得新数组" class="headerlink" title="获得新数组"></a>获得新数组</h1><h2 id="新建数组"><a href="#新建数组" class="headerlink" title="新建数组"></a>新建数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的简便定义</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的标准写法</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者只传入一个参数，表示数组的长度</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以','分隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'1,2,3'</span>.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有间隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'123'</span>.split(<span class="string">''</span>)</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象转换</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转化为字符串</span></span><br><span class="line"><span class="keyword">let</span> str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<p>数组对象除了 <code>__proto__</code> 之外，还包括 <strong>索引</strong> 和 <strong>长度（<code>length</code>）</strong> 这两个自身属性。</p>
<div class="note warning">
            <p><strong>伪数组</strong>：伪数组的原型链中没有数组的原型<br>比如 <code>let divList = document.querySelector(&#39;div&#39;)</code> 将得到一个伪数组；一个普通的对象只是加上 <code>length</code> 属性，也将得到一个伪数组。<br>通常我们需要把它转化为数组来使用<br><code>let divArray = Array.from(divList)</code></p>
          </div>

<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr1.concat(arr2) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h2 id="截取数组"><a href="#截取数组" class="headerlink" title="截取数组"></a>截取数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">2</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">0</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];  <span class="keyword">delete</span> arr[<span class="string">'0'</span>]</span><br><span class="line"><span class="comment">// arr 为 [ empty, 'b', 'c']，如果3个都是 empty，称为稀疏数组，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改 length 也可以删除数组的元素，不推荐</span></span><br><span class="line"></span><br><span class="line">arr.shift()</span><br><span class="line"><span class="comment">// 删除最开始的元素，并返回他，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.pop()</span><br><span class="line"><span class="comment">// 删除最后一个元素，并返回他，arr 被修改</span></span><br><span class="line"> </span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，并返回删除的部分，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，增加 'x' 和 'y'</span></span><br><span class="line"><span class="comment">// 并返回删除的部分，arr 被修改</span></span><br></pre></td></tr></table></figure>

<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="built_in">Object</span>.values(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`$(index) : $(item)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两种基本没有区别</span></span><br><span class="line"><span class="comment">// 但 for 关键字有 continue 和 break，forEach 没有</span></span><br><span class="line"><span class="comment">// for 是块级作用域，forEach 是函数作用域</span></span><br></pre></td></tr></table></figure>

<h2 id="查找单个元素"><a href="#查找单个元素" class="headerlink" title="查找单个元素"></a>查找单个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexOf(item) <span class="comment">// 有就会返回 index，没有就会返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> ===<span class="number">0</span>) </span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> ===<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素对应的索引</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><strong>索引越界</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[arr.length] === <span class="literal">undefined</span></span><br><span class="line">a[<span class="number">-1</span>] === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
          </div>

<h1 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push()</span><br><span class="line"><span class="comment">// 在尾部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.unshift()</span><br><span class="line"><span class="comment">// 在头部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">8</span>, <span class="number">0</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 增加 'x' 和 'y'，并返回删除的部分（[]），arr 被修改</span></span><br></pre></td></tr></table></figure>

<h1 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reverse() <span class="comment">// arr 被修改</span></span><br><span class="line">arr.sort() <span class="comment">// arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.sort( <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a &gt; b ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a === b ) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回 1，a 在 b 之后</span></span><br><span class="line"><span class="comment">// 返回 0，不变</span></span><br><span class="line"><span class="comment">// 返回 -1，b 在 a 之后</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.score - b.score) <span class="comment">// 按 score 从小到大排序</span></span><br></pre></td></tr></table></figure>

<h1 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h1><p>得到新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map： n 变 n</span></span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter：n 变少</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce：n 变 1</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item, <span class="number">0</span>)</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result.concat(item * item), [])</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span></span><br><span class="line">  result.concat(item % <span class="number">2</span> === <span class="number">1</span> ? [] : item), [])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Object</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Object/</url>
    <content><![CDATA[<p>简单来说，对象实际上就是无序的数据集合，或者说是 <strong>键/值对（Key/Value Paris）</strong>的集合.</p>
<a id="more"></a>

<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>对象有以下这样几种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的简便声明</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 对象的标准写法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对象也可以作为参数直接传入函数</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这里我们需要注意以下几个细节：</p>
<ul>
<li>键名是字符串，不是标识符，可以是任意字符</li>
<li>引号可以省略，省略之后就只能写标识符或者以数字开头</li>
<li><strong>就算引号省略了，键名也还是字符串</strong>（不一定，键名也可能是函数、日期、正则等）</li>
<li>奇怪的属性名： <code>1e2</code> 会变成 <code>&#39;100&#39;</code>， <code>.234</code> 会变成 <code>&#39;0.234&#39;</code>， <code>0xFF</code> 会变成 <code>&#39;255&#39;</code></li>
<li>变量也可以作为属性名，比如：<code>let obj = { [p1]: &#39;harvey&#39; }</code>，这样就会用 <code>p1</code> 里面的值了，<strong>中括号里面的东西都会先求值</strong></li>
</ul>
<h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><h2 id="隐藏的属性"><a href="#隐藏的属性" class="headerlink" title="隐藏的属性"></a>隐藏的属性</h2><p><strong>每一个</strong> 对象都有一个隐藏属性 <code>__proto__</code>，这个属性存着 <strong>一个对象的地址</strong>，这个对象包含了这类对象（普通对象、数组、函数等）的 <strong>共有属性</strong></p>
<p><code>__proto__</code> 里面存的实际上就是 <strong>原型的地址</strong></p>
<p>因此，<strong>每一个对象都有原型</strong></p>
<p>比如 <code>obj = {}</code>，他的原型的地址就存储在 <code>obj.__proto__</code> 中，而<code>obj.__proto__</code> 也是一个对象，因此他也有原型，但我们规定，他的原型值为 <code>null</code></p>
<h2 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h2><p>有以下两种删除对象属性的方法：</p>
<ol>
<li><code>obj.name = undefined</code>，这样做只会删除属性的值，不会把属性完全删除</li>
<li><code>delete obj.name</code>，同时删除属性名和属性值，或者用 <code>delete obj[&#39;name&#39;]</code> 也是可以的</li>
</ol>
<p>删除完成后可以对删除的结果进行检查：</p>
<ol>
<li><code>&#39;name&#39; in obj</code>，检查 <code>&#39;name&#39;</code> 是不是 <code>obj</code> 的属性名，如果是用上面的第一种方法删除，检查的结果将是 <code>true</code>；如果是第二种方法删除，则会返回 <code>false</code>；注意属性名有引号（因为属性名实际上是字符串）</li>
<li><code>&#39;name&#39; in obj &amp;&amp; obj.name === undefined</code>，检查是否含有属性名且值为 <code>undefined</code>，如果是上面第一种方法删除，则会返回 <code>true</code></li>
</ol>
<h2 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h2><ul>
<li><code>Object.keys(obj)</code>，查看 <code>obj</code> 的 <strong>自身</strong> 属性名</li>
<li><code>Object.values(obj)</code>，查看 <code>obj</code> 的  <strong>自身</strong> 属性值</li>
<li><code>Object.entries(obj)</code>，返回结果包含两个数组，第一个数组是 <code>obj</code> 的 <strong>自身</strong> 属性名，第二个数组是 <code>obj</code> 的 <strong>自身</strong> 属性值</li>
<li><code>console.dir(obj)</code>，查看 <code>obj</code> 的 <strong>自身属性 + 共有属性</strong></li>
<li><code>in</code>，查看是不是 <strong>自身属性 + 共有属性</strong> （相当于所有属性）</li>
<li><code>obj.hasOwnProperty(&#39;toString&#39;)</code>，查看 <code>&#39;toString&#39;</code> 是不是 <code>&#39;obj&#39;</code> <strong>自身的</strong> 属性</li>
</ul>
<div class="note warning">
            <p><code>obj.name</code> 等价于 <code>obj[&#39;name&#39;]</code>，不等价于 <code>obj[name]</code></p>
          </div>

<h2 id="添加或修改属性"><a href="#添加或修改属性" class="headerlink" title="添加或修改属性"></a>添加或修改属性</h2><p>直接赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'name'</span>] = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'na'</span>+<span class="string">'me'</span>] = <span class="string">'harvey'</span> <span class="comment">// 因为属性名本质是字符串，上面三句话实际上是一样的</span></span><br></pre></td></tr></table></figure>

<p>批量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj, &#123;<span class="attr">p1</span>:<span class="number">1</span>, <span class="attr">p2</span>:<span class="number">2</span>, <span class="attr">p3</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>但是，不能直接修改共有属性（原型上的属性）：比如，不能通过 <code>obj.toString</code> 来修改原型上的<code>&#39;toString&#39;</code>，这样只会为 <code>obj</code> 增添一个本身的<code>&#39;toString&#39;</code> 属性，而不会修改原型，除非这样写代码（但是这是不推荐的）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型的属性</span></span><br><span class="line">obj.__proto__.toString =</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString =</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(common)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">person.__proto__ = common <span class="comment">// 原型链增加一个环节</span></span><br></pre></td></tr></table></figure>

<h1 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h1><div class="note warning">
            <p>所有的函数自带 prototype<br>prototype 中自带 constructor<br>constructor 里面的东西就是函数的内容</p>
          </div>

<h2 id="new-X"><a href="#new-X" class="headerlink" title="new X()"></a>new X()</h2><ol>
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>X.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现一个类似 new 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.b = b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> X(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NEW</span>(<span class="params">fun, arguments</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = &#123;&#125;</span><br><span class="line">    newObj.__proto__ = fun.prototype</span><br><span class="line">    fun.apply(newObj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = NEW(X, [<span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="构造函数-X"><a href="#构造函数-X" class="headerlink" title="构造函数 X"></a>构造函数 <code>X</code></h2><ul>
<li><code>X</code> 自身用于添加新对象的<strong>自身的属性</strong></li>
<li><code>X.prototype</code> 负责保存对象的<strong>共用属性</strong></li>
</ul>
<p>一般来讲有这样的代码规范：</p>
<ul>
<li>所有构造函数首字母大写，被构造出来的对象首字母小写</li>
<li><code>new</code> 后面的函数使用名词；其他的函数一般用动词开头</li>
</ul>
<h2 id="如何确定一个对象的原型？"><a href="#如何确定一个对象的原型？" class="headerlink" title="如何确定一个对象的原型？"></a>如何确定一个对象的原型？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.__proto__ === 其构造函数.prototype</span><br></pre></td></tr></table></figure>

<h2 id="数据类型与对象的分类"><a href="#数据类型与对象的分类" class="headerlink" title="数据类型与对象的分类"></a>数据类型与对象的分类</h2><blockquote>
<p> 数据类型是 JavaScript 数据的类型，一共有 7 种；<br> 对象的分类则有无数种，常见的有 Array、Function、Date、RegExp 等</p>
</blockquote>
<p>我们常见的有这几种类型的对象：</p>
<ul>
<li><p>数组对象</p>
<ul>
<li>自身属性：<code>&#39;0&#39;</code> <code>&#39;1&#39;</code> <code>&#39;2&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;push&#39;</code> <code>&#39;pop&#39;</code> <code>&#39;shift&#39;</code> <code>&#39;unshift&#39;</code> <code>&#39;join&#39;</code></li>
</ul>
</li>
<li><p>函数对象</p>
<ul>
<li>自身属性：<code>&#39;name&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;call&#39;</code> <code>&#39;apply&#39;</code> <code>&#39;bind&#39;</code></li>
</ul>
</li>
</ul>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><blockquote>
<p><strong>Q: window 是谁构造出来的？</strong><br>A: 可以通过 constructor 属性看出构造者</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Object 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的</p>
</blockquote>
<blockquote>
<p><strong>Q: window.Function 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的，浏览器构造了 Function，然后指定它的构造者是自己</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数据类型与运算符</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-DataTypes-Operators/</url>
    <content><![CDATA[<p>JavaScript 有 7 种数据类型，3 种变量声明的方式，以及一些奇怪的运算符。</p>
<a id="more"></a>

<h1 id="字符存储"><a href="#字符存储" class="headerlink" title="字符存储"></a>字符存储</h1><ul>
<li>如何存数字？十进制转二进制，用十六进制（HEX）表示二进制</li>
<li>如何存字符？转换为数字，48 号表示 0，65 号表示 A，97 号表示 a</li>
<li>如何表示汉字（GB、GBK）？0000~FFFF，16 位，2 字节</li>
<li>Unicode 已收录 13 万字符（大于 16 位），全世界通用，以后还会继续扩充；缺点：两个字节不够用了，至少要三个字节</li>
<li>UTF-8：通过变长的存法，减小容量</li>
</ul>
<h1 id="7-种数据类型"><a href="#7-种数据类型" class="headerlink" title="7 种数据类型"></a>7 种数据类型</h1><blockquote>
<p>4 基 2 空 1 对象</p>
</blockquote>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote>
<p>64 位浮点数组成</p>
</blockquote>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p><code>0</code> <code>+0</code> <code>-0</code><br><code>Infinity</code> <code>+Infinity</code> (1/0) <code>-Infinity</code> (1/-0)<br><code>NaN</code>（0/0，但他还是一个数字，NaN不等于NaN）</p>
<h3 id="范围和精度"><a href="#范围和精度" class="headerlink" title="范围和精度"></a>范围和精度</h3><p><img src="/hais-notebook/images/JS-001.png" alt=""></p>
<p>范围：<code>Number.MAX_VALUE</code> 到 <code>Number.MIN_VALUE</code><br>精度：大概是 15 个十进制有效数字</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>每个字符两个字节（阉割版 UTF-8，两个字符定长）</p>
</blockquote>
<h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>单引号、双引号、反引号，引号不是字符串的一部分</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><code>\r</code> 表示回车， <code>\uFFFF</code> 表示对应的 Unicode 字符， <code>\xFF</code> 表示前256个 Unicode 字符</p>
<h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><p>字符串本来不应该有属性，只有对象才有属性，但是这个有渊源</p>
<ul>
<li>长度： <code>s.length</code></li>
<li>下标： <code>s[0]</code></li>
<li>base64 转码： <code>window.btoa</code> 编码， <code>window.atob</code> 反编码</li>
</ul>
<h2 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h2><blockquote>
<p>否定运算、相等运算、比较运算可以得到 bool 值</p>
</blockquote>
<div class="note warning">
            <p><strong>5 个 falsy 值</strong><br><code>undefined</code> <code>null</code> <code>0</code> <code>NaN</code> <code>&#39;&#39;</code></p>
          </div>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><blockquote>
<p>每个 Symbol 都不一样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>如果声明了没有赋值，默认是 <code>undefined</code><br>如果函数没有写 <code>return</code>，默认是 <code>undefined</code></p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>习惯上把非对象空值写成 undefined，对象空值写成 null；<br>null 通常表示即该处不应该有值，undefined 通常表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><div class="note warning">
            <p>数组、函数、日期都是 Object，不是单独的数据类型，但是使用 <code>typeof</code> 的时候，可以分辨出 function</p>
          </div>

<h1 id="3-种变量声明的方式"><a href="#3-种变量声明的方式" class="headerlink" title="3 种变量声明的方式"></a>3 种变量声明的方式</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ul>
<li>过时的，不好的</li>
<li>函数作用域</li>
<li>可以重复声明</li>
<li>可以先使用再声明</li>
<li>全局声明的 <code>var</code> 变量会变成 <code>window</code> 的属性</li>
</ul>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul>
<li>新的，更合理的</li>
<li>遵循块作用域</li>
<li>不能重复声明</li>
<li>可以赋值，也可以不赋值</li>
<li>必须先声明再使用</li>
<li>全局声明的 <code>let</code> 变量不会再变成 <code>window</code> 的属性</li>
<li><code>let</code> 配合 <code>for</code> 循环有奇效</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>跟 <code>let</code> 几乎一样，但声明时必须赋值，且不能再更改</p>
<div class="note warning">
            <p>变量声明指定值的时候同时也指定了类型，但是 <strong>值和类型都可以随意变化</strong></p>
          </div>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a>Number</h3><ul>
<li>余数 <code>-x % 7</code> 为 <code>-(x % 7)</code></li>
<li>指数 <code>x ** 3</code></li>
<li>自增 <code>a++</code> 表达式的值是 <code>a</code> 加之前的值， <code>++a</code> 表达式的值是 <code>a</code> 加之后的值</li>
<li>求值运算符 <code>+</code>，附属运算符 <code>-</code></li>
</ul>
<h3 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h3><ul>
<li>连接运算 <code>+</code></li>
</ul>
<div class="note warning">
            <p><code>number + string</code>，变成字符串<br><code>string - number</code>，变成数字</p>
          </div>

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><ul>
<li>模糊相等，发生自动类型转换，别用两个等于</li>
<li>JavaScript 三位一体</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title="==="></a>===</h3><p>全等，基本类型看值是否相等，对象看地址是否相等</p>
<ul>
<li><code>[] !== []</code></li>
<li><code>{} !== {}</code></li>
<li><code>NaN !== NaN</code></li>
</ul>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 防止 console.log 报错（防御性编程）</span></span><br><span class="line">a = a || <span class="number">100</span> <span class="comment">// 但是五个 falsy 值都会让 a 为假，因此有 bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用函数来赋初值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><h3 id="或与否"><a href="#或与否" class="headerlink" title="或与否"></a>或与否</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> | <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1111</span></span><br><span class="line">(<span class="number">0b1111</span> &amp; <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1010</span></span><br><span class="line">(~<span class="number">0b1010</span>).toString <span class="comment">// 涉及到补码，留坑</span></span><br></pre></td></tr></table></figure>

<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> ^ <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>按位取反可以用 <code>^1</code></p>
          </div>

<h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">(<span class="number">0b0010</span> &lt;&lt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="头部补零的右移运算符"><a href="#头部补零的右移运算符" class="headerlink" title="头部补零的右移运算符"></a>头部补零的右移运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="如何使用运算符判断奇偶？"><a href="#如何使用运算符判断奇偶？" class="headerlink" title="如何使用运算符判断奇偶？"></a>如何使用运算符判断奇偶？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">偶数 &amp; <span class="number">1</span> === <span class="number">0</span></span><br><span class="line">奇数 &amp; <span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-gt-gt-lt-lt-gt-gt-gt-来取整"><a href="#使用-gt-gt-lt-lt-gt-gt-gt-来取整" class="headerlink" title="使用 ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; | 来取整"></a>使用 <code>~</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> <code>|</code> 来取整</h3><blockquote>
<p>位运算不支持小数，会自动抹去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~ <span class="number">6.83</span> <span class="comment">// 6</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> | <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt;&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-来交换-a-b-的值"><a href="#使用-来交换-a-b-的值" class="headerlink" title="使用 ^ 来交换 a b 的值"></a>使用 <code>^</code> 来交换 <code>a</code> <code>b</code> 的值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版语法</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符"></a>点运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 属性值</span><br></pre></td></tr></table></figure>

<p>如果不是对象，JS会创建一个对象，用完之后再自动删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.xxx = <span class="string">'harvey'</span> <span class="comment">// 'harvey'</span></span><br><span class="line">a.xxx <span class="comment">// undefiend</span></span><br></pre></td></tr></table></figure>

<h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h3><blockquote>
<p>求表达式的值或执行语句，然后 <code>void</code> 的值总为 <code>undefined</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 表达式或语句</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止假动作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"example.com"</span> <span class="attr">onclick</span>=<span class="string">"console.log(hi); return false;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(console.log('hi'))"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote>
<p>表示取后面的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// a 为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'hi'</span>); <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> (<span class="built_in">console</span>.log(<span class="string">'hi'</span>), x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 跟上面是一样的，先执行 console.log，再让 return 为x + 1</span></span><br></pre></td></tr></table></figure>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>圆括号的优先级最高</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 表达式与语句</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Expressions/</url>
    <content><![CDATA[<p>JavaScript 的表达式与语句，包括标识符、block 等概念。</p>
<a id="more"></a>

<h1 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h1><ul>
<li>表达式一般都有值，语句可能有也可能没有</li>
<li>语句一般会改变环境（声明、赋值），逗号表示语句没完</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>          <span class="comment">// 值为 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)      <span class="comment">// 值为函数的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log    <span class="comment">// 值为函数本身</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// 值为函数的返回值：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p><code>retrun</code> 后面不能接回车，否则相当于返回 <code>undefined</code></p>
          </div>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 JavaScript 中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。（有时候也可以用其他的 Unicode 字符，比如中文，比如 Emoji）</p>
<h2 id="代码区块-block"><a href="#代码区块-block" class="headerlink" title="代码区块 block"></a>代码区块 block</h2><p>简单来说就是把代码用大括号包在一起</p>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>如果前面是 <strong>真的</strong>，就执行后面的（若前面是假的，表达式的值为前面；若前面是真的，表达式的值为后面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.f1 &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'f1 存在'</span>)</span><br><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 因为 IE 没有 console.log，所以可以这样写防止出错</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="||"></a>||</h2><p>如果前面是 <strong>假的</strong>，就执行后面的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a || <span class="number">100</span> <span class="comment">// 可以用于设置保底值</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 5 5 5 5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">a</span>:<span class="number">1</span> &#125; <span class="comment">// a 是一个 label，值是 1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 序章</title>
    <url>/hais-notebook/2020/01/29/2020-01-29-JS-Overview/</url>
    <content><![CDATA[<p>JavaScript 的历史和评价的简单介绍。</p>
<a id="more"></a>

<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>1994 年，网景公司（当时叫 Mosaic Communications）发布了一款名为 <strong>Mosaic Netscape</strong> 的网页浏览器，在四个月内，这款浏览器就占据了四分之三的浏览器市场，并成为 1990 年代互联网的主要浏览器。</p>
<blockquote>
<p>因为世界最早流行的图形接口网页浏览器 <strong>NCSA Mosaic</strong> 是美国国家超级电脑应用中心（NCSA）与 1993 年发布的，网景公司为了避免版权纠纷，将浏览器改名为 <strong>Netscape Navigator</strong>，而公司则改名为 <strong>Netscape Communications</strong>。</p>
</blockquote>
<p>这款浏览器发布之后，网景意识到，<strong>光有静态的页面是不行的，需一种网页脚本语言，使得浏览器可以与网页互动。</strong></p>
<p>1995 年，昇阳（Sun）正式向市场推出 Java，网景公司看到 Java 的前景，决定与之结盟，并在浏览器中支持 Java，但如果直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂。</p>
<p>同年，网景招募了布兰登（Brendan Eich），授意其开发一款 <strong>“未来的脚本语言”</strong> ，这种语言需要：“看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手。”——这个决定就排除了 Perl、Python、Tcl 或 Scheme 这些选项，同时也促成了 JavaScript 的诞生。</p>
<p>由于对 Java 不感兴趣，布兰登只用了十天时间就设计出了这款语言的原型，并命名为 <strong>Mocha</strong>，后续又改名为 <strong>LiveScript</strong>，但在 1995 年 12 月，公司为了蹭 Java 的热度，改名为 <strong>JavaScript</strong>。而事实上，JavaScript 和 Java 关系并不大。</p>
<blockquote>
<p>总的来说，布兰登的设计思路是这样的：</p>
<ol>
<li>借鉴 C 的基本语法；</li>
<li>借鉴 Java 的数据类型和内存管理；</li>
<li>借鉴 Scheme，将函数提升到“第一等公民”（first class）的地位；</li>
<li>借鉴 Self，使用基于原型（prototype）的继承机制。</li>
</ol>
</blockquote>
<p>由于 JavaScript 在浏览器上的大获成功，微软（Microsoft）在后续推出的 IE 3 上也使用了 <strong>JScript</strong> ——这与 JavaScript 是类似、但不同标准的语言。于是当年市场上出现了两者对峙的情况，网页设计者通常会在主页放上“用Netscape可达到最佳效果”或“用IE可达到最佳效果”的标志。</p>
<p>1996 年 11 月，网景正式向 <strong>欧洲计算机制造商协会（ECMA）</strong> 提交语言标准；1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。自然 JavaScript 也成为了 ECMAScript 最著名的实现之一。</p>
<p>由于只有短短十天的设计时间，而且世界上之前没有出现过结合了函数式编程和对象编程的语言，以及发展的迅速导致没有时间调整设计，JavaScript 成功成为了有着众多设计缺陷的语言，在这里不做细谈。</p>
<p>2001 年，微软发布 Windows XP，并捆绑了 IE 6。由于 Windows XP 迅速爆火以及长期的垄断，IE 6 也随之占据非常高的市场份额。前文已经说过，IE 6 对 JavaScript 支持并不好，同时 IE 6 对 CSS 标准的支持也不尽完善，导致前端技术的发展进入了漫长的蛰伏期。</p>
<p>2004 年，谷歌（Google）发布爆款应用 Gmail。这款应用在刚推出时，容量就比起其他受欢迎的电子邮箱服务如雅虎和微软的 Hotmail 多出过百倍，成为市场爆品，同时也让众多开发者看到了页面交互的巨大前景和可能性。</p>
<p>2005 年，Jesse 将谷歌用到的技术命名为 AJAX。</p>
<p>2006 年，至今为止最为长寿的 JavaScript 库—— jQuery，发布。</p>
<p>2008 年，谷歌发布 Chrome 浏览器；同年，Chrome 的使用率上升至 1%。其使用高性能 JavaScript 引擎 V8。</p>
<p>2009 年，Ryan 基于 V8 写了 Node.js。</p>
<p>2010 年，Isaac 基于 Node.js 写了 npm。</p>
<p>2010 年，TJ 受 Sinatra 启发，写了 Express.js。赶上了这几波顺风车的 JavaScript 迅速发展，并将触手伸向了后端。自此，JavaScript 也能胜任后端的一些工作了。</p>
<p>2012 年，Chrome 全球占有率达到 33%，超越 IE 跃居首位。</p>
<p>2015 年 12 月，Chrome 中国占有率达到 37%，超越 IE。</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><ul>
<li>JS 是历史的选择，最开始浏览器支持 Java、Flash、VBScript，只有 JS 活到了最后</li>
<li>JS 低开高走，一开始是一个玩具语言，但每次都走对了风口（ECMA 标准、Gmail、移动端、Node.js）</li>
<li>对于初学者，目前可以忽略与 IE 相关的知识</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>饥人谷</tag>
      </tags>
  </entry>
</search>
