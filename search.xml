<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>翻译：Angular 如何检查变化</title>
    <url>/hais-notebook/2021/05/17/Angular-ChangeDetection/</url>
    <content><![CDATA[<p>翻译文章 <a href="https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/" target="_blank" rel="noopener">Angular Change Detection - How Does It Really Work?</a>。</p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>变化检查是如何进行的？</li>
<li>Angular 变化检查器是什么样的？</li>
<li>默认的变化检查机制是怎样进行的</li>
<li>开启/关闭变化检查，手动触发他</li>
<li>避开变化检查循环：生产模式和开发模式</li>
<li><code>OnPush</code> 变化检查模式究竟做了什么？</li>
<li>使用 Immutable.js 来简化 Angular 应用的构建</li>
<li>总结</li>
</ul>
<p>如果想要了解更多关于 OnPush 变化检查机制，请查阅 <a href="https://blog.angular-university.io/onpush-change-detection-how-it-works" target="_blank" rel="noopener">这篇文章</a></p>
<h1 id="变化检查是如何实现的"><a href="#变化检查是如何实现的" class="headerlink" title="变化检查是如何实现的"></a>变化检查是如何实现的</h1><p>当组件的数据变化的时候，Angular 可以探测到，并重新渲染视图来相应这次变化。为了理解工作原理，我们需要首先意识到 JavaScript 中整个运行时都是可重写的。我们可以重写类似于 <code>String</code> 或 <code>Number</code> 等方法。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJS 小技巧</title>
    <url>/hais-notebook/2021/05/14/Tools-RxJS-Trick/</url>
    <content><![CDATA[<p>利用 share 防止重复请求。</p>
<a id="more"></a>
<h1 id="防止重复请求"><a href="#防止重复请求" class="headerlink" title="防止重复请求"></a>防止重复请求</h1><p>参考了 <a href="https://stackoverflow.com/questions/50864978/angular-rxjs-6-how-to-prevent-duplicate-http-requests" target="_blank" rel="noopener">这篇文章</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request.ts</span></span><br><span class="line"><span class="keyword">let</span> dataObservable: Observable&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = (): Observerble&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (dataObservable) &#123; <span class="keyword">return</span> dataObservable &#125;</span><br><span class="line">  dataObservable = <span class="keyword">new</span> Observable&lt;<span class="built_in">any</span>&gt;<span class="function">(<span class="params">(<span class="params">subscriber</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">console</span>.log(<span class="params">"mock Run API"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    setTimeout(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="built_in">console</span>.log(<span class="params">"mock API Callback"</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      subscriber.next(<span class="params"><span class="built_in">Math</span>.random(<span class="params"></span>)</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      subscriber.complete(<span class="params"></span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">// 可以根据需求自行确定这个 observable 销毁的时机</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      dataObservable = <span class="literal">undefined</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;, 500</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>).<span class="params">pipe</span>(<span class="params">share(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">dataObservable</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// somewhere.ts</span></span><br><span class="line">request().subscribe(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">request().subscribe(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  request().subscribe(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// mock Run API</span></span><br><span class="line"><span class="comment">// mock API Callback</span></span><br><span class="line"><span class="comment">// 1 0.403....</span></span><br><span class="line"><span class="comment">// 2 0.403....       跟 1 打出的值一样</span></span><br><span class="line"><span class="comment">// mock Run API      上面的 500 ms 之后</span></span><br><span class="line"><span class="comment">// mock API Callback</span></span><br><span class="line"><span class="comment">// 3 0.838....       新的值</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJS Overview</title>
    <url>/hais-notebook/2021/05/13/Tools-RxJS-Overview/</url>
    <content><![CDATA[<p>One Core Type: Observable.<br>Satellite Types: Observer, Schedulers, Subjects.<br>Operators: map, filter, reduce, every, etc.</p>
<a id="more"></a>
<h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>SINGLE</th>
<th>MULTIPLE</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pull</td>
<td>Function</td>
<td>Iterator</td>
</tr>
<tr>
<td>Push</td>
<td>Promise</td>
<td>Observable</td>
</tr>
</tbody>
</table>
</div>
<p>一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意：当 subscribed 的时候，Observable push 1, 2, 3 的过程是同步执行的！ </span></span><br><span class="line">  subscriber.next(<span class="number">1</span>);</span><br><span class="line">  subscriber.next(<span class="number">2</span>);</span><br><span class="line">  subscriber.next(<span class="number">3</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscriber.next(<span class="number">4</span>);</span><br><span class="line">    subscriber.complete();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just before subscribe'</span>);</span><br><span class="line">observable.subscribe(&#123;</span><br><span class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'got value '</span> + x); &#125;,</span><br><span class="line">  error(err) &#123; <span class="built_in">console</span>.error(<span class="string">'something wrong occurred: '</span> + err); &#125;,</span><br><span class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'done'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just after subscribe'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">just before subscribe</span><br><span class="line">got value 1</span><br><span class="line">got value 2</span><br><span class="line">got value 3</span><br><span class="line">just after subscribe</span><br><span class="line">got value 4</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="Pull-和-Push"><a href="#Pull-和-Push" class="headerlink" title="Pull 和 Push"></a>Pull 和 Push</h2><p>在描述 <strong>数据生产者(Producer)</strong> 和 <strong>数据消费者(Consumer)</strong> 之间的沟通时，有 <strong>Pull</strong> 和 <strong>Push</strong> 两种不同的方案。</p>
<h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>消费者决定了何时从生产者那里拿数据。</p>
<p>比如每个 JS 函数就是一个 Pull System：函数是数据的生产者，调用函数的地方从函数那里 pull <strong>一个</strong> 返回值。<br>ES6 引入的 generator 函数和迭代器也是一种 Pull System：消费者调用 <code>iterator.next()</code>，从迭代器那里 pull <strong>多个</strong> 值。</p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>生产者决定了何时发送数据给消费者。</p>
<p>比如 Promise(生产者) 给 回调函数(消费者) 传输数据，Promise 掌控了 push 数据的时机。<br>Observable(生产者) 给 Observer(消费者) 传输数据。</p>
<h2 id="Observable-与函数"><a href="#Observable-与函数" class="headerlink" title="Observable 与函数"></a>Observable 与函数</h2><blockquote class="blockquote-center"><p>function.call() 表示 <em>同步地给我一个值</em><br>observable.subscribe() 表示 <em>同步或异步地给我一堆值</em></p>
</blockquote>
<h3 id="Observable-与函数的相同点"><a href="#Observable-与函数的相同点" class="headerlink" title="Observable 与函数的相同点"></a>Observable 与函数的相同点</h3><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>如果不 call Function，那么函数就不会执行；<br>如果不 subscribe Observable，那么 Observable 中注册的回调函数也不会执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo.call();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">const</span> y = foo.call();</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  subscriber.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">foo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行上面两段代码的结果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<h4 id="每个-subscribing-都是独立的"><a href="#每个-subscribing-都是独立的" class="headerlink" title="每个 subscribing 都是独立的"></a>每个 subscribing 都是独立的</h4><p>就像每次 Function calling 都是独立的一样，每次 Observable subscribing 也是独立的，他们之间的副作用互不干扰——这与 EventEmitter 不同。</p>
<h4 id="Observable-可同步可异步"><a href="#Observable-可同步可异步" class="headerlink" title="Observable 可同步可异步"></a>Observable 可同步可异步</h4><p>Observable 并不是都是异步的，如果没有引入其他异步数据源，他其实是同步的，这跟 Function 也是类似的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.call());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<p>以上两段代码运行的结果也是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Observable-与函数的不同点"><a href="#Observable-与函数的不同点" class="headerlink" title="Observable 与函数的不同点"></a>Observable 与函数的不同点</h3><h4 id="Observable-可以发出多个值"><a href="#Observable-可以发出多个值" class="headerlink" title="Observable 可以发出多个值"></a>Observable 可以发出多个值</h4><p>在函数中，我们不能这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// dead code. will never happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在 Observable 却可以这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  subscriber.next(<span class="number">42</span>);</span><br><span class="line">  subscriber.next(<span class="number">100</span>); <span class="comment">// "return" another value</span></span><br><span class="line">  subscriber.next(<span class="number">200</span>); <span class="comment">// "return" yet another</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Observable-可以异步发出值"><a href="#Observable-可以异步发出值" class="headerlink" title="Observable 可以异步发出值"></a>Observable 可以异步发出值</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  subscriber.next(<span class="number">42</span>);</span><br><span class="line">  subscriber.next(<span class="number">100</span>);</span><br><span class="line">  subscriber.next(<span class="number">200</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscriber.next(<span class="number">300</span>); <span class="comment">// happens asynchronously</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br><span class="line">300</span><br></pre></td></tr></table></figure>
<h2 id="创建-Observable：Creating"><a href="#创建-Observable：Creating" class="headerlink" title="创建 Observable：Creating"></a>创建 Observable：Creating</h2><p>Observable 构造函数只需要一个参数：subscribe 函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Observable，他会给一个 subscriber 每秒钟都发出 "hi"</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">subscriber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscriber.next(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="订阅-Observable：Subscribing"><a href="#订阅-Observable：Subscribing" class="headerlink" title="订阅 Observable：Subscribing"></a>订阅 Observable：Subscribing</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<p>当调用 <code>observable.subscribe</code> 的时候，subscribe 函数会用给定的 subscriber 运行，并且每次调用都是独立的。<br>与 <code>addEventListener</code> 这种 API 不一样，Observer 并没有注册为一个 listener，Observable 里面也没有维护 Observer 的列表。</p>
<h2 id="执行-Observable：Executing"><a href="#执行-Observable：Executing" class="headerlink" title="执行 Observable：Executing"></a>执行 Observable：Executing</h2><p>在 <code>new Observable(function subscribe(subscriber) {...})</code> 中的代码表示一个 Observable execution。</p>
<p>Observable Execution 可以发出三种类型的值：</p>
<ul>
<li>“Next” 通知：会伴随一个 Number、String、Object 等类型的值</li>
<li>“Error” 通知：会伴随一个 JS Error 或者异常</li>
<li>“Complete” 通知：不会伴随任何值</li>
</ul>
<p>通常来说，Execution 会随着时间通过 Next 通知发出多个值。但当发出 Error 或者 Complete 通知之后，就不会再发出值了。</p>
<h2 id="释放-Executions：Disposing-Executions"><a href="#释放-Executions：Disposing-Executions" class="headerlink" title="释放 Executions：Disposing Executions"></a>释放 Executions：Disposing Executions</h2><p>当调用 <code>observable.subscribe</code> 之后，Observer 会跟一个新创建的 Observable execution 绑定。并且返回一个 <code>Subscription</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<p>Subscription 就代表了正在执行的 execution。</p>
<ul>
<li>可以通过 <code>subscription.unsubscribe()</code> 来取消正在执行的 execution。</li>
<li>Complete 或 Error 也会取消 execution。</li>
</ul>
<p>我们有时候需要自定义一个 <code>unsubscribe</code> 函数来在取消 execution 的时候释放资源。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">subscriber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscriber.next(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数会在 unsubscribe 的时候执行，清除掉 interval</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(intervalId);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h1><p>Observer 是 Observable 发出数据的消费者，其实就是一个对象，对象包含了三个分别用于处理 Observable 三种通知类型的回调函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = &#123;</span><br><span class="line">  next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</span><br><span class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observable.subscribe(observer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然也可以直接将回调函数作为参数传进去，他会自动帮我们创建 Observer 对象</span></span><br><span class="line">observable.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x))</span><br></pre></td></tr></table></figure>
<h1 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h1><p>Operator 就是函数。有两种类型的 Operator：</p>
<ul>
<li>Pipeable Operator：不会改变原来的 Observable 实例，他接受一个 Observable 作为参数，然后再返回一个 Observable</li>
<li>Creation Operator：会创建一个新的 Observable</li>
</ul>
<h2 id="高阶-Observable"><a href="#高阶-Observable" class="headerlink" title="高阶 Observable"></a>高阶 Observable</h2><p>可以这样构造一个高阶 Observable，用 map 返回一个 Observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clicks = fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">const</span> higherOrder = clicks.pipe(map(<span class="function"><span class="params">ev</span> =&gt;</span> of(ev)));</span><br></pre></td></tr></table></figure>
<p>这时候就需要用例如 concatAll 等操作符将其拍平。</p>
<h1 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h1><p>Subscription 通常是一个 Observable 的 Execution，主要是用来调用释放资源 API <code>unsubscribe</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = interval(<span class="number">400</span>).subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'first: '</span> + x));</span><br><span class="line"><span class="keyword">const</span> childSubscription = interval(<span class="number">300</span>).subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'second: '</span> + x));</span><br><span class="line"></span><br><span class="line">subscription.add(childSubscription);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 同时 unsubscribe subcription 和 childSubscription</span></span><br><span class="line">  subscription.unsubscribe();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject 是一种特殊的 Observable，他可以向多个 Observer 以多播的形式发出值——而普通的 Observable 是单播，每个订阅的 Observer 对这个 Observable 都有自己独立的 Execution。</p>
<ul>
<li><strong>每个 Subject 都是 Observable</strong>。你可以 <code>subscribe</code> 一个 Subject。对于 Subject 来说，<code>subscribe</code> 并不会产生一个新的 Execution，他会将这个 Observer 注册到一个 ObserverList，就像 <code>addListner</code> 一样</li>
<li><strong>每个 Subject 都是 Observer</strong>。他有 <code>next()</code> <code>error()</code> <code>complete()</code> 方法。只需要调用 <code>next()</code>，就会广播给所有已经注册了的 Observer。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 Subject 都是 Observable：可以 subscribe 他</span></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个 Subject 都是 Observer：调用他的 next() 方法，就会广播给所有已经注册的 Observer</span></span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerB: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个 Subject 都是 Observer：可以把他传给 subscribe 函数</span></span><br><span class="line"><span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).subscribe(subject);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerB: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br><span class="line"><span class="comment">// observerA: 3</span></span><br><span class="line"><span class="comment">// observerB: 3</span></span><br></pre></td></tr></table></figure>
<h2 id="多播-Observable"><a href="#多播-Observable" class="headerlink" title="多播 Observable"></a>多播 Observable</h2><p>注意！在 RxJS 7 已经将多播 API 进行了调整！<a href="https://rxjs.dev/guide/subject#multicasted-observables" target="_blank" rel="noopener">文档</a>中的 <code>multicast</code> 操作符将不再适用。详情请查看 <a href="https://rxjs.dev/deprecations/multicasting" target="_blank" rel="noopener">这篇文档</a>。</p>
<h3 id="connectable"><a href="#connectable" class="headerlink" title="connectable"></a>connectable</h3><p>可以通过 connectable 创建一个可以多播的 Observable：</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>他会保存发给消费者的最后一个值，并且当一个新的 Observer subscribe 的时候，他会从 <code>BehaviorSubject</code> 那里立即接收到这个值。</p>
<blockquote>
<p>BehaviorSubject 非常适合用于表示 “随着时间发出值”。比如表示 “生日” 事件的流是 Subject，但表示 “年龄” 的流是 BehaviourSubject。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 0 表示初始值</span></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> BehaviorSubject&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">subject.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'subscribe1'</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">  subject.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'subscribe2'</span>, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// subscribe1 0</span></span><br><span class="line"><span class="comment">// next!</span></span><br><span class="line"><span class="comment">// subscribe1 1</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// subscribe2 1</span></span><br><span class="line"><span class="comment">// after</span></span><br></pre></td></tr></table></figure>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>他跟 <code>BehaviorSubject</code> 很像，不同的是 <code>BehaviourSubject</code> 只会保存最后一个值，而 <code>ReplaySubject</code> 会保存很多个值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> ReplaySubject(<span class="number">3</span>, <span class="number">500</span>); <span class="comment">// 会缓存 3 个最新的值，最久保存 500ms</span></span><br><span class="line"> </span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br><span class="line">subject.next(<span class="number">3</span>);</span><br><span class="line">subject.next(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">subject.next(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 1</span></span><br><span class="line"><span class="comment">// observerA: 2</span></span><br><span class="line"><span class="comment">// observerA: 3</span></span><br><span class="line"><span class="comment">// observerA: 4</span></span><br><span class="line"><span class="comment">// observerB: 2</span></span><br><span class="line"><span class="comment">// observerB: 3</span></span><br><span class="line"><span class="comment">// observerB: 4</span></span><br><span class="line"><span class="comment">// observerA: 5</span></span><br><span class="line"><span class="comment">// observerB: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>当 Observable execution complete 的时候才会发出值，并且只会发出最后一个值——这跟 <code>last()</code> 操作符差不多。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> AsyncSubject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br><span class="line">subject.next(<span class="number">3</span>);</span><br><span class="line">subject.next(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(<span class="number">5</span>);</span><br><span class="line">subject.complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// observerA: 5</span></span><br><span class="line"><span class="comment">// observerB: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="Void-Subject"><a href="#Void-Subject" class="headerlink" title="Void Subject"></a>Void Subject</h2><p>简单来说，Subject 可以发出空值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject&lt;<span class="built_in">void</span>&gt;();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> subject.next(), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>Scheduler 可以控制 subscription 开始和发出值的时间：</p>
<ul>
<li><strong>Scheduler 是一个数据结构</strong>：他知道如何存储数据，并可以基于优先级来管理任务队列</li>
<li><strong>Scheduler 是一个执行上下文</strong>：他代表了任务在何时、何地执行（比如立即、或在某个回调中）</li>
<li><strong>Scheduler 有一个虚拟时钟</strong>：他提供了 <code>noew()</code> 函数来表示时间，由 Scheduler 管理的任务都依附于这个时间。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable, asyncScheduler &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observeOn &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 proxyObserver 实际上是由 observeOn(asyncScheduler) 根据 finalObserver 创建的</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">proxyObserver</span>) =&gt;</span> &#123;</span><br><span class="line">  proxyObserver.next(<span class="number">1</span>);</span><br><span class="line">  proxyObserver.next(<span class="number">2</span>);</span><br><span class="line">  proxyObserver.next(<span class="number">3</span>);</span><br><span class="line">  proxyObserver.complete();</span><br><span class="line">&#125;).pipe(</span><br><span class="line">  observeOn(asyncScheduler)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> finalObserver = &#123;</span><br><span class="line">  next(x) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got value '</span> + x)</span><br><span class="line">  &#125;,</span><br><span class="line">  error(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'something wrong occurred: '</span> + err);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete() &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just before subscribe'</span>);</span><br><span class="line">observable.subscribe(finalObserver);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just after subscribe'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LOGS:</span></span><br><span class="line"><span class="comment">// just before subscribe</span></span><br><span class="line"><span class="comment">// just after subscribe</span></span><br><span class="line"><span class="comment">// got value 1</span></span><br><span class="line"><span class="comment">// got value 2</span></span><br><span class="line"><span class="comment">// got value 3</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure>
<p>一个 <code>observeOn(asyncScheduler)</code> 创建的 <code>proxyObserver</code> 可以近似理解为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyObserver = &#123;</span><br><span class="line">  next(val) &#123;</span><br><span class="line">    asyncSheduler.shedule(</span><br><span class="line">      (x) =&gt; finalObserserver.next(x),</span><br><span class="line">      <span class="number">0</span>, <span class="comment">// 延迟</span></span><br><span class="line">      val, <span class="comment">// 会传给上面的 x</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的 Scheduler 是通过 <code>setTimeout</code> 或 <code>setInterval</code> 操作，因此就算延迟是 0，也是异步操作。</p>
<h2 id="Scheduler-的类型"><a href="#Scheduler-的类型" class="headerlink" title="Scheduler 的类型"></a>Scheduler 的类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>SCHEDULER</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>通知都是同步地、递归地发出的，用于正常时间的操作和尾递归</td>
</tr>
<tr>
<td>queueScheduler</td>
<td>以队列的形式在当前事件帧安排，用于迭代操作</td>
</tr>
<tr>
<td>asapScheduler</td>
<td>在同 promise 一样的微任务队列中安排，用于异步会话</td>
</tr>
<tr>
<td>asyncScheduler</td>
<td>使用 <code>setInterval</code>，用于基于时间的操作</td>
</tr>
<tr>
<td>animationFrameScheduler</td>
<td>任务会在浏览器下一次重绘（repaint）之前进行，用于创建流畅的浏览器动画</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用-Scheduler"><a href="#使用-Scheduler" class="headerlink" title="使用 Scheduler"></a>使用 Scheduler</h2><p>以后用到再翻译，先看<a href="https://rxjs.dev/guide/scheduler" target="_blank" rel="noopener">文档</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记：《程序是怎么跑起来的》</title>
    <url>/hais-notebook/2021/05/13/Book-HowProgramWorks/</url>
    <content><![CDATA[<p>将之前的读书笔记腾挪至此。</p>
<a id="more"></a>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>简单来讲，CPU 由寄存器、控制器、运算器和时钟组成（也可以认为时钟位于 CPU 的外部）</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>程序是把寄存器作为对象来描述的，寄存器可以用于存放 <strong>指令</strong> 或者 <strong>数据</strong>，通过地址将这，其中 <strong>数据</strong> 又分为 “用于运算的值” 和 “表示内存地址的值”，这又对应了多种不同的寄存器</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器决定程序的流程，存的实际上是当前执行的指令的地址</p>
<h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><p>由于指令可能占据多个内存地址，每次执行时程序计数器的值只需要增加与指令长度相当的数值就可以了</p>
<h4 id="条件分支和循环"><a href="#条件分支和循环" class="headerlink" title="条件分支和循环"></a>条件分支和循环</h4><p>使用跳转指令（jump）可以让程序计数器的值设定为任意值</p>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ul>
<li><p>函数在调用（call）的时候实际上就是将程序计数器的值设定为函数所在的地址，执行完成之后再跳回（return）到调用原点的地址</p>
</li>
<li><p>call 指令会把调用函数后需要执行的命令地址存在 “栈” 内</p>
</li>
<li><p>return 指令会把保存在 “栈” 中的地址再设定回程序计数器中</p>
</li>
</ul>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>在进行运算的时候，标志寄存器负责用标志的形式存储计算结果，这些计算结果在执行判断的时候可以用上，比如对于32位的寄存器，他的第 0、1、2 位为 1 时分别表示“运算结果为正、运算结果为 0 、运算结果为负”</p>
<p>在 CPU 中的大小比较实际上是做减法运算，然后将结果的正负保存在标志寄存器中</p>
<h3 id="基址寄存器和变址寄存器"><a href="#基址寄存器和变址寄存器" class="headerlink" title="基址寄存器和变址寄存器"></a>基址寄存器和变址寄存器</h3><p>基址寄存器的值不变化，而变址寄存器的值变化（相当于数组索引的数值），可以综合使用这两个寄存器来表示数组，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 实际地址 &#x3D; 基址寄存器的值 + 变址寄存器的值</span><br><span class="line">    ↓           ↓             ↓</span><br><span class="line">10000000  &#x3D;  10000000  +  00000000</span><br><span class="line">10000001  &#x3D;            +  00000001</span><br><span class="line">10000002  &#x3D;            +  00000002</span><br><span class="line">  ....                      ....</span><br><span class="line">1000FFFF  &#x3D;            +  0000FFFF</span><br></pre></td></tr></table></figure>
<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul>
<li><p>左移运算，高位溢出丢弃，低位补 <code>0</code></p>
</li>
<li><p>右移运算，低位溢出丢弃，高位补 <code>0</code> 或 <code>1</code></p>
</li>
</ul>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>二进制最高位其实是符号位，为 <code>0</code> 时表示整数，为 <code>1</code> 时表示负数，但是需要注意的是：<code>1</code> 是 <code>00000001</code>，但 <code>-1</code> 并不是 <code>10000001</code>，而是 <code>11111111</code></p>
<h4 id="补码的计算"><a href="#补码的计算" class="headerlink" title="补码的计算"></a>补码的计算</h4><p>按位取反，再 +1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1  -&gt;  00000001  -&gt;  11111110  -&gt;  11111111</span><br></pre></td></tr></table></figure>
<h4 id="补码的作用"><a href="#补码的作用" class="headerlink" title="补码的作用"></a>补码的作用</h4><p>计算机内的减法运算其实都是用加法运算实现的，这也是使用二进制补码来表示负数的重要原因之一，比如对于运算 <code>1 - 1</code>（也就是 <code>1 + (- 1)</code>），答案应该为 <code>0</code> ；但若用 <code>10000001</code> 表示 <code>-1</code>，则运算结果为 <code>10000010</code>，是不正确的</p>
<p>如果使用补码来表示 -1，即 <code>11111111</code>，则运算结果为正确的 <code>00000000</code>，最高位的 <code>1</code> 溢出舍弃</p>
<p>有一个重要的结论：<strong>二进制按位取反后加 <code>1</code> 的结果，与原来的正值相加，结果为 <code>0</code></strong></p>
<p>因为，按位取反与原数相加，必得 <code>11111111</code>，加 <code>1</code> 之后，最高位溢出，答案为 <code>0</code></p>
<h3 id="逻辑右移和算术右移"><a href="#逻辑右移和算术右移" class="headerlink" title="逻辑右移和算术右移"></a>逻辑右移和算术右移</h3><h4 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h4><p>当二进制数的值表示 <strong>图形模式</strong> 而非 <strong>数值</strong> 时，移位后需要在最高位补 0</p>
<h4 id="算术右移"><a href="#算术右移" class="headerlink" title="算术右移"></a>算术右移</h4><p>考虑到符号位的存在，移位后需要在高位重新填充符号位的值，这就是算术右移：</p>
<p><code>-4</code> （<code>11111100</code>）算术右移之后为 <code>-1</code> (<code>11111111</code>)，空出来的高位由符号位 <code>1</code> 填充</p>
<h4 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h4><p>如果将 8 位二进制数转换为 16 位或 32 位等，多出来的高位，依旧用符号位的值填充即可</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>将二进制数表示的信息作为四则运算的数值来处理，就是 <strong>算术运算</strong>；而单纯像图形一样处理 <code>0</code> 和 <code>1</code> 的罗列，就是 <strong>逻辑运算</strong></p>
<p>逻辑运算有四种：非（NOT）、与（AND）、或（OR）、异或（XOR/EOR）</p>
<h2 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h2><p>二进制小数存在精度问题，因为二进制位只能表示以 1/2、1/4、1/8、1/16 等位权组合而成的小数，这导致很多十进制小数是没办法用有限的二进制小数表示的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0000  -&gt;  0</span><br><span class="line">0.0001  -&gt;  0.0625</span><br><span class="line">0.0010  -&gt;  0.125</span><br><span class="line">0.0011  -&gt;  0.1875</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>计算机内部无法直接使用像 <code>1011.0011</code> 这样的带小数点的表现形式，通常的编程语言提供了两种表示小数的数据类型：<strong>单精度浮点数</strong> 和 <strong>双精度浮点数</strong>，前者用 32 位，后者用 64 位来表示全体小数</p>
<p>浮点数用 <strong>符号</strong>、<strong>尾数</strong>、<strong>基数</strong> 和 <strong>指数</strong> 这四部分来表示小数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ±    m  ×  n   ^   e</span><br><span class="line"> ↓    ↓     ↓       ↓</span><br><span class="line">符号  尾数  基数     指数</span><br></pre></td></tr></table></figure>
<p>其中符号部分占 1 位，指数部分占 8/11 位，尾数部分占 23/52 位（IEEE 规定）</p>
<h4 id="正则表达式和-EXCESS-系统"><a href="#正则表达式和-EXCESS-系统" class="headerlink" title="正则表达式和 EXCESS 系统"></a>正则表达式和 EXCESS 系统</h4><p>尾数部分使用 <strong>正则表达式</strong> 来表示，二进制数规定尾数部分一定满足 “<strong>小数点前面的值固定为 1</strong>”，这样我们就可以不保存小数点前面的值了</p>
<p>指数部分使用 <strong>EXCESS 系统</strong> 来表示，因为有可能有负值，因此将所有可以表示的数分为两半，中间为 0，比如单精度浮点数用 <code>01111111</code> 表示 0，<code>10000000</code> 表示 <code>1</code>，<code>01111110</code> 表示 <code>-1</code></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存的物理工作机制"><a href="#内存的物理工作机制" class="headerlink" title="内存的物理工作机制"></a>内存的物理工作机制</h2><p>比如对于某个内存 IC，它有数个引脚：</p>
<ul>
<li><p>VCC、GND：电源</p>
</li>
<li><p>D0 ~ D7：数据信号，一共 8 个引脚，代表一次可以输出 8 位（1 Byte）的数据</p>
</li>
<li><p>A0 ~ A9：地址信号，一共 10 个引脚，代表可以有 2 ^ 10 个地址，可以存储 2 ^ 10 Byte，即 1 KB 的数据</p>
</li>
<li><p>RD、WR：控制信号，表示是读数据还是写数据</p>
</li>
</ul>
<p>比如要写数据，WR 为 1，然后通过地址信号指定写入地址，数据信号指定写入值即可</p>
<h2 id="内存的逻辑模型"><a href="#内存的逻辑模型" class="headerlink" title="内存的逻辑模型"></a>内存的逻辑模型</h2><p>内存就像一幢楼房，每楼代表一个地址，地址是连续的。编程语言通过指定 <strong>数据类型</strong> 来指定占用的楼层数（内存大小）</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在某些变成语言中会有指针，比如 C。简单的来讲，<strong>指针</strong> 也是一种变量，他存储着数据的内存地址</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是多个同样的数据类型在内存中连续排列的形式，每个元素通过连续的编号（索引）被区分来开，需要注意的是 JS 的数组并不是这种严格意义上的数组</p>
<h3 id="栈、队列以及环形缓冲区"><a href="#栈、队列以及环形缓冲区" class="headerlink" title="栈、队列以及环形缓冲区"></a>栈、队列以及环形缓冲区</h3><p>栈和队列都可以不通过指定地址和索引来读写数组的元素，其中栈用的是 LIFO 的方式，而队列则是 FIFO</p>
<p>队列一般是以环状缓冲区（ring buffer）的方式来实现的</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在数组的各个元素中，除了数据的值以外，给其附带上下一个元素的索引，即可实现链表，通过链表可以高效地追加或删除数据</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在链表的基础上往数组增加元素的时候，考虑到数据的大小关系，将其分为左右两个方向，这样可以增加查找的效率</p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘缓存是将磁盘中读取出来的数据存储到内存空间的方式，可以大大提高磁盘数据的访问速度</p>
<h2 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h2><p>磁盘将其物理表面划分成多个空间来使用，划分的方式有 <strong>扇区方式</strong> 和 <strong>可变长方式</strong>；前者是固定空间，而后者则将磁盘划分为长度可变的空间</p>
<p>在 Windows 中，一般就采取扇区方式：将磁盘表面分成若干个同心圆的空间（<strong>磁道</strong>），再把磁道按照固定大小划分成（<strong>扇区</strong>）</p>
<p>此外，在 Windows 中，在逻辑层面读写磁盘的单位是扇区的整数倍<strong>簇</strong>，根据磁盘容量不同，1 簇可以是 512 B、1 KB、2 KB 等。<strong>不同的文件是不能存储在同一簇中的</strong>，但需要注意的时候，程序可以在逻辑上以字节为单位对内容进行读写</p>
<h1 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h1><h2 id="RLE-算法"><a href="#RLE-算法" class="headerlink" title="RLE 算法"></a>RLE 算法</h2><p>简单来说就是将文件内容用 “数据 × 重复次数” 的形式来表示，比如用 <code>A3B2C9</code> 表示 <code>AAABBCCCCCCCCC</code></p>
<p>该算法的主要缺点是不适合文本文件的压缩，而比较适合经常连续出现的图像、文件等</p>
<h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>简单来说就是将出现频率很高的字符用更短的位数来表示（比如小于 8 位），出现频率低的字符用长编码来表示</p>
<p>比如摩尔斯编码就是将在文本中出现频率比较高的字符用短编码来表示，但是需要注意的是文件在存储的时候仍然是以 8 位的字节为单位的</p>
<p>可以用二叉树来实现哈夫曼编码</p>
<h2 id="可逆压缩与非可逆压缩"><a href="#可逆压缩与非可逆压缩" class="headerlink" title="可逆压缩与非可逆压缩"></a>可逆压缩与非可逆压缩</h2><p>比如对 EXE 文件、文本文件，他们的每个字符、数值都有具体的含义，因此必须要还原到和压缩前同样的内容，因此称为 <strong>可逆压缩</strong>；</p>
<p>而图片压缩之后有一些模糊也可以接受，不必使用同样的算法，有的算法是无法还原到之前相同的内容的，称为 <strong>非可逆压缩</strong></p>
<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><ul>
<li><p>汇编语言 = 本地代码（机器语言） + 助记符</p>
<ul>
<li>汇编语言     —汇编器进行汇编—&gt;    本地代码</li>
<li>汇编语言  &lt;—反汇编程序进行反汇编—  本地代码</li>
</ul>
</li>
</ul>
<h1 id="硬件控制"><a href="#硬件控制" class="headerlink" title="硬件控制"></a>硬件控制</h1><h2 id="IN-与-OUT-指令"><a href="#IN-与-OUT-指令" class="headerlink" title="IN 与 OUT 指令"></a>IN 与 OUT 指令</h2><p>Windows 控制硬件借助的是输入和输出指令，比较具有代表性的就是 IN 和 OUT 指令：<strong>IN 指令</strong> 通过指定的端口号输入数据，并存储在 CPU 内部的寄存器中；<strong>OUT 指令</strong> 则把 CPU 寄存器中存储的数据，输出到指定的端口</p>
<p><strong>I/O 控制器</strong> 用来是用来交换计算机主机通外围设备电流特性的 IC，他内部有用于临时保存输入输出数据的内存（端口）</p>
<p>I/O 端口号是所有的外围设备都必需的</p>
<h2 id="IRQ"><a href="#IRQ" class="headerlink" title="IRQ"></a>IRQ</h2><p>IRQ（Interrupt Request）是 <strong>中断请求</strong>，用来暂停当前正在运行的程序，并跳转到其他程序运行，这种机制被称为 <strong>中断处理</strong></p>
<p>实施中断请求的是连接外围设备的 I/O 控制器，实施中断处理程序的是 CPU，外围设备的中断请求会使用 <strong>中断编号</strong> 进行标记，操作系统和 BIOS 会提供响应中断编号的中断处理程序</p>
<p>IRQ 只对于需要中断处理的外围设备是必需的</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA（Direct Memory Access）是指在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送。磁盘等通过利用 DMA 可以让大量的数据在短时间内传送到主内存，节省了 CPU 作为中介的时间</p>
<p>DMA 只对于需要 DMA 机制的外围设备是必需的</p>
<h2 id="文字及图片的显示机制"><a href="#文字及图片的显示机制" class="headerlink" title="文字及图片的显示机制"></a>文字及图片的显示机制</h2><p>显示器中显示的信息一直都存在 VRAM（Video RAM）中，只要往 VRAM 中写入数据，该数据就会在显示器中显示出来——这是由操作系统或者 BIOS 听的，并借助中断来进行处理的</p>
<p>现在的计算机中，显卡等硬件中一般都有与主内存像独立的 VRAM 和 GPU（Graphics Processing Unit）</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记：《计算机科学精粹》</title>
    <url>/hais-notebook/2021/05/09/Book-ComputerScienceDistilled/</url>
    <content><![CDATA[<p>有幸得贵人赠书《计算机科学精粹》，将纸质版读书笔记提炼誊抄至此。</p>
<a id="more"></a>
<h1 id="第一章：预备知识"><a href="#第一章：预备知识" class="headerlink" title="第一章：预备知识"></a>第一章：预备知识</h1><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote>
<p>我们称 <code>-&gt;</code> 为条件运算符，可读作「若……，则……」</p>
</blockquote>
<p>一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A: 泳池暖和</span><br><span class="line">B: 我去游泳</span><br><span class="line">A -&gt; B: 如果泳池暖和，我就去游泳</span><br></pre></td></tr></table></figure>
<h4 id="换质位法"><a href="#换质位法" class="headerlink" title="换质位法"></a>换质位法</h4><p>指的是这两句话含义相同（即逆否命题与原命题含义相同）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; B: 如果泳池暖和，我就去游泳</span><br><span class="line">!B -&gt; !A: 如果我不去游泳，那么泳池就不暖和</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>A -&gt; B</code> 和 <code>B -&gt; A</code> 含义并不相同！</p>
          </div>
<h4 id="双条件"><a href="#双条件" class="headerlink" title="双条件"></a>双条件</h4><p>若要使 <code>A -&gt; B</code> 和 <code>B -&gt; A</code> 都成立，则需要使用双条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &lt;-&gt; B: 当且仅当泳池暖和，我才去游泳</span><br></pre></td></tr></table></figure>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><h4 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A and ( B and C ) &#x3D; ( A and B ) and C</span><br><span class="line">A or ( B or C ) &#x3D; ( A or B ) or C</span><br></pre></td></tr></table></figure>
<h4 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A and ( B or C ) &#x3D; ( A and B ) or ( A and C )</span><br><span class="line">A or ( B and C ) &#x3D; ( A or B ) and ( A or C )</span><br></pre></td></tr></table></figure>
<h4 id="德摩根定律"><a href="#德摩根定律" class="headerlink" title="德摩根定律"></a>德摩根定律</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!( A and B ) &#x3D; !A or !B</span><br><span class="line">!( A or B ) &#x3D; !A and !B</span><br></pre></td></tr></table></figure>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>两个不相关事件的可能性用乘法计算：</p>
<script type="math/tex; mode=display">
{m}\cdot{n}</script><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>n 个项的排列方式种数：</p>
<script type="math/tex; mode=display">
n!</script><p>n 个元素中选 m 个排成一列：</p>
<script type="math/tex; mode=display">
A_{n}^{m} = \frac{n!}{(n-m)!}</script><p>n 个元素中，r 个相同排成一列：</p>
<script type="math/tex; mode=display">
\frac{n!}{r!}</script><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>n 个不同元素，选 m 个并成一组（与顺序无关）：</p>
<script type="math/tex; mode=display">
\tbinom{n}{m} = C_{n}^{m} = \frac{n!}{m!(n-m)!}</script><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><ul>
<li>独立事件：两个事件的结果不会相互影响，概率相乘</li>
<li>互斥事件：两个事件结果不能同时发生，概率相加</li>
<li>对立事件：两个互斥事件概率涵盖所有可能的结果，概率之和为 1</li>
</ul>
<h1 id="第二章：复杂度"><a href="#第二章：复杂度" class="headerlink" title="第二章：复杂度"></a>第二章：复杂度</h1><h2 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h2><p>例：选择排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 外层循环执行 n-1 次，每次执行赋值、交换两项操作，共 2n-2 次</span></span><br><span class="line">  <span class="keyword">for</span> (current = <span class="number">1</span> ... list.length <span class="number">-1</span>) &#123;</span><br><span class="line">    smallest = current</span><br><span class="line">    <span class="comment">// 内层循环执行 n-1（外层第一次）、n-2（外层第二次）、n-3 次，共计 (n*n-n)/2 次赋值与交换操作，也就是 n*n-n 次操作 </span></span><br><span class="line">    <span class="keyword">for</span> (i = current + <span class="number">1</span> ... list.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i] &lt; list[current]) &#123;</span><br><span class="line">        smallest = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.swap_items(current, smallest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此上述选择排序算法总计进行了 $T(n) = n^2 + n - 2$ 次操作</p>
<h2 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大 O 符号"></a>大 O 符号</h2><p>表示最坏情况下算法成本函数的主项，比如选择排序的时间复杂度可记为 $O(n^2)$</p>
<h2 id="空间复杂度的计算"><a href="#空间复杂度的计算" class="headerlink" title="空间复杂度的计算"></a>空间复杂度的计算</h2><p>比如对于选择排序，只需要一组固定的变量作为存储空间，因此空间复杂度可以记为 $O(1)$</p>
<h1 id="第三章：策略"><a href="#第三章：策略" class="headerlink" title="第三章：策略"></a>第三章：策略</h1><p>本章主要讲解这几种策略：</p>
<ul>
<li>通过 <strong>迭代</strong> 处理 <em>重复性</em> 任务</li>
<li>通过 <strong>递归</strong> 进行优雅地 <em>迭代</em></li>
<li>资源允许时使用 <strong>蛮力法</strong></li>
<li>测试不可行的选择并 <strong>回溯</strong></li>
<li>采用 <strong>启发法</strong> 合理缩短求解的时间</li>
<li>采用 <strong>分治法</strong> 求解难题</li>
<li><strong>动态地</strong> 识别重复问题，避免浪费资源</li>
<li>对问题 <strong>定界</strong> 缩小求解范围</li>
</ul>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   ┌──────┐循环(每一步操作就被称为迭代)</span><br><span class="line">   │      │                           满足条件 </span><br><span class="line">求解过程 ────────────────────────────────────────────&gt; 目标</span><br><span class="line">   ↑      │</span><br><span class="line">   └──────┘</span><br></pre></td></tr></table></figure>
<p>例：合并两个排好序的数组</p>
<p>比如将 <code>[1, 3, 5, 7]</code> 与 <code>[2, 4, 6, 8]</code> 合并为 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">while</span> (list1.has_item || list2.has_item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list1.top_item &gt; list2.top_item) &#123;</span><br><span class="line">      temp = list1.remove_top_item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp = list2.remove_top_item</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(fish)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：嵌套循环与幂集</p>
<blockquote>
<p>对于给定对象 S 的集合，其幂集是 S 的全部子集构成的集合</p>
</blockquote>
<p>比如有几种花，花可以调配香水，我们需要求出能调配的所有可能的香水。</p>
<p>使用迭代的思维：</p>
<ul>
<li>若没有花，一种无味的香水，记做0。</li>
<li>若有一种花：0、A</li>
<li>若有两种花：0、A、0+B、A+B</li>
<li>若有三种花：0、A、0+B、A+B、0+C、A+C、0+B+C、A+B+C</li>
</ul>
<p>不难发现，多加一种花，就是把之前的复制一遍，再给复制之后的每种香水加上新的花。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">powerSet</span>(<span class="params">flowers</span>) </span>&#123;</span><br><span class="line">  fragrances = <span class="built_in">Set</span>.new</span><br><span class="line">  fragrances.add(<span class="built_in">Set</span>.new)</span><br><span class="line">  <span class="keyword">for</span> (flower <span class="keyword">in</span> flowers) &#123;</span><br><span class="line">    <span class="comment">// 复制已有的香水</span></span><br><span class="line">    new_fragrances = copy(fragrances)</span><br><span class="line">    <span class="keyword">for</span> (fragrance <span class="keyword">in</span> new_fragrances) &#123;</span><br><span class="line">      <span class="comment">// 给复制之后的香水加上新的花</span></span><br><span class="line">      fragrance.add(flower)</span><br><span class="line">    &#125;</span><br><span class="line">    fragrances = fragrances + new_fragrances</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragrances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种构建幂集的方式时间复杂度为 $O(n^2)$，每增加一次循环，时间将会增加一倍。这种方法也可以用于构建真值表，每种花是否加入用布尔值进行表示。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>函数自己调用自己</p>
</blockquote>
<p>例：判断回文字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (word.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (word.first_char != word.last_char) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  w = word.remove_first_and_last_char</span><br><span class="line">  <span class="keyword">return</span> isPalindrome(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归与迭代：递归算法通常更短，但由于其执行时大量调用自身，从而引入计算开销。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">迭代：</span><br><span class="line">START &#x3D;&gt; 1 &#x3D;&gt; 2 &#x3D;&gt; 3 &#x3D;&gt; END</span><br><span class="line"></span><br><span class="line">递归：</span><br><span class="line">START &#x3D;&gt; 1 &#x3D;&gt; 2 &#x3D;&gt; 3</span><br><span class="line">                   ↓</span><br><span class="line">  END &lt;&#x3D; 1 &lt;&#x3D; 2 &lt;&#x3D; 3</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 简单上手</title>
    <url>/hais-notebook/2021/04/24/Flutter-Intro/</url>
    <content><![CDATA[<p>这几天简单了解了一下 Flutter，以下笔记是阅读文档的笔记。</p>
<a id="more"></a>
<h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Widget 像其他 Web 框架的 Component、Template、DOM，用来描述 UI。</p>
<blockquote>
<p>当 widget 的状态改变时，它会重新构建其描述（展示的 UI），框架则会对比前后变化的不同，以确定底层渲染树从一个状态转换到下一个状态所需的最小更改。</p>
</blockquote>
<h3 id="Root-Widget"><a href="#Root-Widget" class="headerlink" title="Root Widget"></a>Root Widget</h3><p>往 <code>runApp()</code> 里面传入一个 Widget 就可构建一个最小的 Flutter 应用，传入的这个 Widget 叫做 <code>Root Widegt</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    Center(</span><br><span class="line">      child: Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>Root Widget 会被强制指定铺满整个屏幕。</p>
          </div>
<h2 id="一些基础-Widget"><a href="#一些基础-Widget" class="headerlink" title="一些基础 Widget"></a>一些基础 Widget</h2><ul>
<li><code>Text</code>：创建带样式的文本</li>
<li><code>Row</code>, <code>Column</code>：用于在水平和垂直方向进行创建类似 flex box 的东西以进行布局</li>
<li><code>Stack</code>：类似于 CSS 层叠上下文，是按照绘制顺序将 Widget 堆叠在一起。可以将 <code>Positioned</code> 作为 child，将其相对于 <code>Stack</code> 进行定位。</li>
<li><code>Container</code>：类似于 <code>&lt;div&gt;&lt;/div&gt;</code> 创建一个矩形，可以用 <code>BoxDecoration</code> 来加背景、边框、阴影等，还可以指定 margin、padding、变换等。</li>
<li><code>GestureDetector</code>：本身不可见，但是可以探测到内部组件的手势事件，比如点击、拖动、缩放。</li>
</ul>
<h2 id="创建一个自己的-Widget"><a href="#创建一个自己的-Widget" class="headerlink" title="创建一个自己的 Widget"></a>创建一个自己的 Widget</h2><p>可以创建一个 class，他继承了 <code>StatelessWidget</code>，这个 class 就是一个 Widget。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyAppBar(&#123;required <span class="keyword">this</span>.title&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fields in a Widget subclass are always marked "final".</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">56.0</span>, <span class="comment">// in logical pixels</span></span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">8.0</span>),</span><br><span class="line">      decoration: BoxDecoration(color: Colors.blue[<span class="number">500</span>]),</span><br><span class="line">      <span class="comment">// Row is a horizontal, linear layout.</span></span><br><span class="line">      child: Row(</span><br><span class="line">        <span class="comment">// &lt;Widget&gt; is the type of items in the list.</span></span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(Icons.menu),</span><br><span class="line">            tooltip: <span class="string">'Navigation menu'</span>,</span><br><span class="line">            onPressed: <span class="keyword">null</span>, <span class="comment">// null disables the button</span></span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// Expanded expands its child</span></span><br><span class="line">          <span class="comment">// to fill the available space.</span></span><br><span class="line">          Expanded(</span><br><span class="line">            child: title,</span><br><span class="line">          ),</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(Icons.search),</span><br><span class="line">            tooltip: <span class="string">'Search'</span>,</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="StatelessWidget-和-StatefulWidget"><a href="#StatelessWidget-和-StatefulWidget" class="headerlink" title="StatelessWidget 和 StatefulWidget"></a><code>StatelessWidget</code> 和 <code>StatefulWidget</code></h2><ul>
<li><code>StatelessWidget</code>：无状态 widget。接收的参数来自于它的父 widget，这些参数被储存在 final 成员变量中。当 widget 需要被 build() 时，就是用这些存储的变量为创建的 widget 生成新的参数。</li>
<li><code>StatefulWidget</code>：有状态 widget。他有一些自己管理的状态，可以自行做出一些响应用户操作的变化。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个 class 是用来接收父级传过来的属性的（就像无状态 Widget 一样，他们通常被以 final 的形式存储）</span></span><br><span class="line">  <span class="comment">// 在这个例子中，这个 class 没有接收任何参数</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterState createState() =&gt; _CounterState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Counter</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _increment() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// 调用 setState 会告诉 Flutter：State 发生了变化。</span></span><br><span class="line">      <span class="comment">// 这会调用下面的 build 函数来更新视图</span></span><br><span class="line">      <span class="comment">// 如果不调用 setState，视图将不会更新</span></span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 每次 setState 的时候都会调用这个函数</span></span><br><span class="line">    <span class="comment">// Flutter 已经对 build 过程进行了优化，所以可以直接重新调用 build，而不必关心局部 Widget 的更新</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"build"</span>);</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        ElevatedButton(</span><br><span class="line">          <span class="comment">// 点击按钮的时候调用 _increment</span></span><br><span class="line">          onPressed: _increment,</span><br><span class="line">          child: Text(<span class="string">'Increment'</span>),</span><br><span class="line">        ),</span><br><span class="line">        SizedBox(width: <span class="number">16</span>),</span><br><span class="line">        Text(<span class="string">'Count: <span class="subst">$_counter</span>'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="父子-Widget-的状态传递"><a href="#父子-Widget-的状态传递" class="headerlink" title="父子 Widget 的状态传递"></a>父子 Widget 的状态传递</h2><blockquote>
<p>简单来说，就像 React。</p>
</blockquote>
<p>父 -&gt; 子：值<br>子 -&gt; 父：回调函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个用于展示 count 的无状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterDisplay</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  CounterDisplay(&#123;required <span class="keyword">this</span>.count&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'Count: <span class="subst">$count</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用于增加 count 的无状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterIncrementor</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  CounterIncrementor(&#123;required <span class="keyword">this</span>.onPressed&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> VoidCallback onPressed;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ElevatedButton(</span><br><span class="line">      onPressed: onPressed,</span><br><span class="line">      child: Text(<span class="string">'Increment'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterState createState() =&gt; _CounterState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件的状态管理部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Counter</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _increment() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      ++_counter;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 这是刚刚定义的用于增加 count 的无状态组件，通过回调函数将事件发给父级控制</span></span><br><span class="line">        CounterIncrementor(onPressed: _increment),</span><br><span class="line">        SizedBox(width: <span class="number">16</span>),</span><br><span class="line">        <span class="comment">// 这是刚刚定义的用于显示 count 的无状态组件，传给他 _count，让他只负责显示</span></span><br><span class="line">        CounterDisplay(count: _counter),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看 <a href="https://flutter.cn/docs/development/ui/widgets-intro#bringing-it-all-together" target="_blank" rel="noopener">官方文档的购物车例子</a></p>
<h2 id="状态的生命周期"><a href="#状态的生命周期" class="headerlink" title="状态的生命周期"></a>状态的生命周期</h2><ul>
<li><p><code>initState()</code>：在 StatefulWidget 上调用 createState() 之后，框架将新的状态对象插入到树中，然后在状态对象上调用 initState()。 State 的子类可以重写 initState 来完成只需要发生一次的工作。例如，重写 initState 来配置动画或订阅平台服务。实现 initState 需要调用父类的 super.initState 方法来开始。</p>
</li>
<li><p><code>dispose()</code>：当不再需要状态对象时，框架会调用状态对象上的 dispose() 方法。可以重写dispose 方法来清理状态。例如，重写 dispose 以取消计时器或取消订阅平台服务。实现 dispose 时通常通过调用 super.dispose 来结束。</p>
</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Flutter 中的布局也是使用 Widget 实现的。可以在 <a href="https://flutter.cn/docs/development/ui/widgets/layout" target="_blank" rel="noopener">Flutter 布局 Widget</a> 中找。</p>
<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><h2 id="声明式-UI"><a href="#声明式-UI" class="headerlink" title="声明式 UI"></a>声明式 UI</h2><ul>
<li>命令式（比如 Web）：如果我们要操作 UI，通常需要通过 <code>getElementBuyId</code> 之类的 API 先获取 DOM 中元素的实例和操作权，然后再调用相关的方法来修改他的颜色等属性。</li>
<li>声明式（Flutter）：视图本身（Widget）是不可变的，通常在配置好之后，我们不能改变 Widget，如果需要改变 UI，需要通过 <code>setState()</code> 之类的方法构建一个新的 Widget。</li>
</ul>
<h2 id="短时状态（Ephemeral-State）与应用状态（App-State）"><a href="#短时状态（Ephemeral-State）与应用状态（App-State）" class="headerlink" title="短时状态（Ephemeral State）与应用状态（App State）"></a>短时状态（Ephemeral State）与应用状态（App State）</h2><ul>
<li>状态<ul>
<li>广义：这个应用运行时存在于内存中的所有内容。包括应用中用到的资源，所有 Flutter 框架中有关用户界面、动画状态、纹理、字体以及其他等等的变量。</li>
<li>狭义：是当任何时候需要<strong>重建你的用户界面</strong>时所需要的<strong>数据</strong>。因为很多广义的状态不需要我们管理（比如纹理），框架本身会替我们管理。</li>
</ul>
</li>
<li>短时状态：有时也称 <em>用户界面(UI)状态</em> 或者 <em>局部状态</em>。是可以完全包含在 <strong>一个独立 widget</strong> 中的状态。<ul>
<li>一个 PageView 组件中的当前页面</li>
<li>一个复杂动画中当前进度</li>
<li>一个 BottomNavigationBar 中当前被选中的 tab</li>
</ul>
</li>
<li>应用状态：有时也称 <strong>共享状态</strong>。是指在应用的多个部分之间共享的一个非短时状态，并且在用户会话期间会保留这个状态。<ul>
<li>用户选项</li>
<li>登录信息</li>
<li>一个社交应用中的通知</li>
<li>一个电商应用中的购物车</li>
<li>一个新闻应用中的文章已读/未读状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单来说。<br>短时状态：用 setState 管理，别人不需要关心你的状态，类似于 React 中的 setState。<br>应用状态：可以用状态管理框架（比如 Redux）来管理，多个部分会共享这个状态。</p>
</blockquote>
<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Provider 可以用于进行管理应用状态。</p>
<h3 id="ChangeNotifier"><a href="#ChangeNotifier" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h3><div class="note warning">
            <p>ChangeNotifier 实际上是在 <code>flutter:foundation</code> 中的，不依赖其他的库，也不一定要与 Provider 一起使用。</p>
          </div>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">创建一个类，他继承 ChangeNotifier，负责管理状态</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">这里的例子是用来管理购物车中的商品</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">内部的私有变量，用来保存数据</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Item&gt; _items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">向外界暴露出一个不可更改的 ListView</span></span></span><br><span class="line">  UnmodifiableListView&lt;Item&gt; <span class="keyword">get</span> items =&gt; UnmodifiableListView(_items);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">向外界暴露出我们计算出的商品总价</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> totalPrice =&gt; _items.length * <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">暴露出 add 函数，用于往购物车增加商品</span></span></span><br><span class="line">  <span class="keyword">void</span> add(Item item) &#123;</span><br><span class="line">    _items.add(item);</span><br><span class="line">    <span class="comment">// 关键！调用 notifyListeners() 告诉正在监听这个 model 的 widget，让他们 rebuild</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">暴露出 removeAll 函数，用于清空所有商品</span></span></span><br><span class="line">  <span class="keyword">void</span> removeAll() &#123;</span><br><span class="line">    _items.clear();</span><br><span class="line">    <span class="comment">// 关键！调用 notifyListeners() 告诉正在监听这个 model 的 widget，让他们 rebuild</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h3><p><code>ChangeNotifierProvider</code> widget 可以向其子孙节点暴露一个 <code>ChangeNotifier</code> 实例。它属于 provider package。</p>
<p>需要将 <code>ChangeNotifierProvider</code> 放在所有需要访问他的 widget 之上。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    ChangeNotifierProvider(</span><br><span class="line">      <span class="comment">/// <span class="markdown">定义了一个 builder 来创建 CartModel 实例，ChangeNotifierProvider 不会重复实例化 CartModel</span></span></span><br><span class="line">      <span class="comment">/// <span class="markdown">如果该实例已经不会再被调用， ChangeNotifierProvider 也会自动调用 CartModel 的 dispose() 方法。</span></span></span><br><span class="line">      create: (context) =&gt; CartModel(),</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>MultiProvider</code> 来提供多个状态：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        ChangeNotifierProvider(create: (context) =&gt; CartModel()),</span><br><span class="line">        Provider(create: (context) =&gt; SomeOtherClass()),</span><br><span class="line">      ],</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>可以通过 Consumer 来获取到数据</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 通过 Consumer 来获取到数据</span></span><br><span class="line">  <span class="keyword">return</span> Consumer&lt;CartModel&gt;(</span><br><span class="line">  <span class="comment">/// <span class="markdown">当 ChangeNotifier 发生变化（调用 notifyListener()）的时候会调用 builder。</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">builder 的第一个参数是 context，跟其他的 build 方法一样</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">builder 的第二个参数是 ChangeNotifier 的实例，也就是 CartModel 的实例</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">builder 的第三个参数是 child，用于优化目的。</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">如果 Consumer 下面有一个庞大的子树（SomeExpensiveWidget），当 Model 发生改变的时候，该子树（SomeExpensiveWidget） 并不会 改变，那么你就可以仅仅创建它一次，然后通过 builder 获得该实例。</span></span></span><br><span class="line">    builder: (context, cart, child) =&gt; Stack(</span><br><span class="line">        children: [</span><br><span class="line">          <span class="comment">// 不需要每次都 rebuild 的庞大子树</span></span><br><span class="line">          child,</span><br><span class="line">          Text(<span class="string">"Total price: <span class="subst">$&#123;cart.totalPrice&#125;</span>"</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    <span class="comment">// 不需要每次都 rebuild 的庞大子树</span></span><br><span class="line">    child: SomeExpensiveWidget(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来讲我们需要把 Consumer 放到尽可能低的位置，这样每次 Model 的变化就不会引起过量的 rebuild</p>
<h3 id="Provider-of"><a href="#Provider-of" class="headerlink" title="Provider.of"></a>Provider.of</h3><p>有时候我们不需要页面更新，又想要用到新的数据，这时候就可以不用 <code>Consumer</code>，而是 <code>Provider.of</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 并且需要将 listen 设置为 false，这样当 notifyListeners 被调用的时候，并不会使 widget 被重构</span></span><br><span class="line">  Provider.of&lt;CartModel&gt;(context, listen: <span class="keyword">false</span>).removeAll();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>跨端</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeORM</title>
    <url>/hais-notebook/2021/04/11/NodeJS-TypeORM/</url>
    <content><![CDATA[<p>TypeORM 是一个 Node 中对 TypeScript 支持比较好的关系对象映射，支持关联、事务、数据库迁移，同类产品还有 Sequelize。<br>Mac 和 Linux 可以用 &amp; 同时执行两个命令，Windows 可以用 concurrently 这个 npm 库。</p>
<a id="more"></a>
<h1 id="启动-Postgresql-数据库"><a href="#启动-Postgresql-数据库" class="headerlink" title="启动 Postgresql 数据库"></a>启动 Postgresql 数据库</h1><p>在项目目录里面新增 <code>blog-data</code> 目录，并将其添加进 <code>.gitignore</code> 中。</p>
<p>然后启动 postgresql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v <span class="string">"<span class="variable">$PWD</span>/blog-data"</span>:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_USER=blog -e POSTGRES_HOST_AUTH_METHOD=trust -d postgres</span><br></pre></td></tr></table></figure>
<p>将上述命令的 <code>-e POSTGRES_HOST_AUTH_METHOD=trust</code> 替换成 <code>-e POSTGRES_PASSWORD=123456</code> 就可以设置密码</p>
<p>然后可以这样进入 postgresql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it id bash</span><br><span class="line">psql -U username -W</span><br></pre></td></tr></table></figure>
<p>然后可以执行 psql 的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\l <span class="comment"># list databases</span></span><br><span class="line">\c <span class="comment"># connect to a databases</span></span><br><span class="line">\dt <span class="comment"># display tables</span></span><br></pre></td></tr></table></figure>
<h1 id="创建-database"><a href="#创建-database" class="headerlink" title="创建 database"></a>创建 database</h1><p>由于 TypeORM 没有为我们提供单纯创建数据库的 API，我们需要进入数据库用 SQL 语句来进行创建：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> blog_production <span class="keyword">ENCODING</span> <span class="string">'UTF8'</span> LC_COLLATE <span class="string">'en_US.utf8'</span> LC_CTYPE <span class="string">'en_US.utf8'</span>;</span><br></pre></td></tr></table></figure>
<p>一般来说需要创建三个数据库：development、test、production</p>
<h1 id="安装-TypeORM"><a href="#安装-TypeORM" class="headerlink" title="安装 TypeORM"></a>安装 TypeORM</h1><p><a href="https://typeorm.io/#/" target="_blank" rel="noopener">官方文档在这里</a>。</p>
<p>注意！当按照官方文档操作，运行命令 <code>typeorm init --database postgres</code> 之后，<code>.gitignore</code> 、 <code>package.json</code> 和 <code>tsconfig.json</code> 将会被更改，这时需要检查他的更改并酌情处理！</p>
<p>比如当我们在使用 Next 搭配 TypeORM 的时候，会遇到问题是 Next 使用 Babel 处理 TypeScript，而 TypeORM 则推荐使用 ts-node，这样就冲突了：</p>
<ol>
<li>先从 <code>package.json</code> 中删除命令擅自添加的 <code>ts-node</code></li>
<li>再想办法运行 <code>src/index.ts</code></li>
</ol>
<h2 id="自行使用-babel-来进行编译，然后再用-node-运行编译好的-js"><a href="#自行使用-babel-来进行编译，然后再用-node-运行编译好的-js" class="headerlink" title="自行使用 babel 来进行编译，然后再用 node 运行编译好的 js"></a>自行使用 babel 来进行编译，然后再用 node 运行编译好的 js</h2><p>TypeORM 想要我们直接运行 <code>src/index.ts</code>，但是我们需要安装 <code>@babel/cli</code> 之后使用命令 <code>npx babel ./src --out-dir dist --extensions &quot;.ts,.tsx&quot;</code> 来运行。</p>
<p>这时可能会遇到报错 <code>Support for the experimental syntax &#39;decorators-legacy&#39; isn&#39;t currently enabled</code>。</p>
<p>解决方案可以看<a href="https://stackoverflow.com/questions/52262084/syntax-error-support-for-the-experimental-syntax-decorators-legacy-isnt-cur" target="_blank" rel="noopener">这篇文章</a>。<br>同时可以参考<a href="https://nextjs.org/docs/advanced-features/customizing-babel-config" target="_blank" rel="noopener">next 文档</a>来配置 <code>.babelrc</code></p>
<p>然后我们就可以在 dist 里面找到编译好的 <code>index.js</code>，用 node 直接运行他，但是注意需要修改 <code>ormconfig.json</code> 里面的配置，尤其是这一部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"entities"</span>: [</span><br><span class="line">    <span class="string">"dist/entity/**/*.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="让-Next-帮我们编译，帮我们运行"><a href="#让-Next-帮我们编译，帮我们运行" class="headerlink" title="让 Next 帮我们编译，帮我们运行"></a>让 Next 帮我们编译，帮我们运行</h2><p>我们可以将上面 TypeORM 生成的 <code>src/index.ts</code> 放到 <code>pages</code> 目录下，这样 Next 就会在 请求(开发)/打包(生产) 的时候帮我们编译并执行。同样需要注意修改 <code>ormconfig.json</code>。</p>
<h1 id="synchronize-功能"><a href="#synchronize-功能" class="headerlink" title="synchronize 功能"></a>synchronize 功能</h1><p>同步功能可以在 <code>ormconfig.json</code> 里面的 <code>synchronize</code> 项进行配置。</p>
<p>如果打开 synchronize，每次 <code>createConnection</code> 的时候都会将 entity 里面的表同步到我们的数据库中，这样就很可能导致我们在修改 User 的时候把数据删掉，这在生产环境肯定是不允许的。因此我们可以在一开始就把这个功能给关掉。</p>
<h1 id="通过-migration-创建表"><a href="#通过-migration-创建表" class="headerlink" title="通过 migration 创建表"></a>通过 migration 创建表</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:create -n CreatePost</span><br></pre></td></tr></table></figure>
<p>然后对其创建的 <code>/src/migration/[timestamp]-CreatePosts.ts</code> 进行修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MigrationInterface, QueryRunner, Table &#125; <span class="keyword">from</span> <span class="string">"typeorm"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreatePosts1620523637192 <span class="keyword">implements</span> MigrationInterface &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> up(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 升级数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> queryRunner.createTable(<span class="keyword">new</span> Table(&#123;</span><br><span class="line">      name: <span class="string">"posts"</span>,</span><br><span class="line">      columns: [</span><br><span class="line">        &#123; name: <span class="string">"id"</span>, <span class="keyword">type</span>: <span class="string">"int"</span>, isPrimary: <span class="literal">true</span>, isGenerated: <span class="literal">true</span>, generationStrategy: <span class="string">"increment"</span> &#125;,</span><br><span class="line">        &#123; name: <span class="string">"title"</span>, <span class="keyword">type</span>: <span class="string">"varchar"</span> &#125;,</span><br><span class="line">        &#123; name: <span class="string">"content"</span>, <span class="keyword">type</span>: <span class="string">"text"</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> down(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 降级数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> queryRunner.dropTable(<span class="string">"posts"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后同样的，我们需要将其编译成 js，然后配置 <code>ormconfig.json</code> 中的 <code>migrations</code> 路径，然后再执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:run</span><br></pre></td></tr></table></figure>
<p>他会执行 <code>up</code> 中的代码，于是就创建了一个表。</p>
<p>当发生错误需要撤销这次 migration 的时候，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm migration:revert</span><br></pre></td></tr></table></figure>
<p>他会执行 <code>down</code> 中的代码，在这里就会删除这个表。</p>
<h1 id="将数据映射到实体从而操作他"><a href="#将数据映射到实体从而操作他" class="headerlink" title="将数据映射到实体从而操作他"></a>将数据映射到实体从而操作他</h1><p>在数据库中创建一个表之后，如果想操作他，我们通常需要他映射到 实体(Entity) 上，可以通过这个命令达成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx typeorm entity:create -n Post</span><br></pre></td></tr></table></figure>
<p>需要将 Entity Post 对应上数据库里面的信息：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Column, Entity, PrimaryGeneratedColumn &#125; <span class="keyword">from</span> <span class="string">"typeorm"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span>(<span class="string">"posts"</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Post &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PrimaryGeneratedColumn</span>(<span class="string">"increment"</span>)</span><br><span class="line">  id: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(<span class="string">"varchar"</span>)</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(<span class="string">"text"</span>)</span><br><span class="line">  content: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <a href="https://typeorm.io/#/entity-manager-api" target="_blank" rel="noopener">EntityManager</a> 和 <a href="https://typeorm.io/#/repository-api" target="_blank" rel="noopener">Repository</a> 这两种使用实体的方式，他们只是封装思路不同而已。</p>
<h1 id="Seed"><a href="#Seed" class="headerlink" title="Seed"></a>Seed</h1><p>也叫数据填充，我们可以通过 seed 脚本来构造数据。</p>
<h1 id="创建数据表关联"><a href="#创建数据表关联" class="headerlink" title="创建数据表关联"></a>创建数据表关联</h1><p>可以参考 <a href="https://typeorm.io/#/relations" target="_blank" rel="noopener">这篇文档</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> User &#123;</span><br><span class="line">  <span class="comment">//... 其他字段</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToMany</span>(<span class="function"><span class="params">type</span> =&gt;</span> Post, <span class="function"><span class="params">post</span> =&gt;</span> post.author)</span><br><span class="line">  posts: Post[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Next</title>
    <url>/hais-notebook/2021/04/07/NodeJS-Next/</url>
    <content><![CDATA[<p>NodeJS WEB 框架之 Next。<br>Tip：如何保存密码？</p>
<ol>
<li>存在环境变量中：用 <code>export xxx=</code> 设置环境变量，用 <code>process.env.xxx</code> 使用环境变量</li>
<li>或者参考 <a href="https://nextjs.org/docs/basic-features/environment-variables" target="_blank" rel="noopener">这篇文章</a></li>
</ol>
<a id="more"></a>
<h1 id="开始一个-Next-js-项目"><a href="#开始一个-Next-js-项目" class="headerlink" title="开始一个 Next.js 项目"></a>开始一个 Next.js 项目</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app next-demo</span><br></pre></td></tr></table></figure>
<h1 id="Next-的一些特性"><a href="#Next-的一些特性" class="headerlink" title="Next 的一些特性"></a>Next 的一些特性</h1><h2 id="使用-Link-快速导航"><a href="#使用-Link-快速导航" class="headerlink" title="使用 Link 快速导航"></a>使用 Link 快速导航</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来这样写</span></span><br><span class="line">&lt;a href=<span class="string">"xxx"</span>&gt;点击跳转&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 现在这样写</span></span><br><span class="line"><span class="regexp">&lt;Link href="xxx"&gt;&lt;a&gt;点击跳转&lt;/</span>a&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>页面不会刷新，用 AJAX 请求新页面的内容</li>
<li>不会请求重复的 HTML、CSS、JS</li>
<li>自动在页面插入新内容、删除旧内容</li>
<li>省去了很多请求和解析的过程、速度极快</li>
</ul>
<h2 id="同构代码"><a href="#同构代码" class="headerlink" title="同构代码"></a>同构代码</h2><p>同一份代码，在浏览器和 Node 两端都执行了，比如在组件里面写一个 console.log，会发现 Node 控制台和 Chrome 中都会有 log。</p>
<p>但：</p>
<ul>
<li>不是所有的代码都会在两端运行，比如需要用户触发的操作，就不会在 Node 中运行</li>
<li>不是所有的 API 都能用，比如 <code>window</code> 就会报错，因为在 Node 中不存在</li>
</ul>
<h2 id="lt-Head-gt"><a href="#lt-Head-gt" class="headerlink" title="&lt;Head&gt;"></a><code>&lt;Head&gt;</code></h2><p>可以用 <code>&lt;Head&gt;</code> 标签书写 <code>title</code> <code>meta:viewport</code> 等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以在 <code>pages/_app.js</code> 中进行全局配置：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;My Blog&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Head&gt;</span><br><span class="line">      &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyApp</span></span><br></pre></td></tr></table></figure>
<p>切换页面的时候 MyApp 不会被销毁，MyApp 里面的代码会重新执行，但是里面的状态会保留。</p>
<h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><p>在 <code>_app.js</code> 中还可以用 <code>import</code> 直接引入全局生效的 <code>global.css</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../styles/globals.css'</span></span><br></pre></td></tr></table></figure>
<p>默认情况下都是相对路径引入，用配置指定根目录，可以参考 <a href="https://nextjs.org/docs/advanced-features/module-path-aliases" target="_blank" rel="noopener">这篇文档</a></p>
<p>也可以在组件中书写局部的 <code>&lt;style&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">  h1 &#123; </span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>&#125;&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>官方推荐静态资源放在 public 中，但在这里面的资源不能加 hash。 因此不推荐这样用，可以另外新建 <code>asstes/images</code> 文件夹来存放图片静态资源。<br>但直接这样就需要自己配置 file-loader，也就是自定义 webpack 配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: <span class="function">(<span class="params">config, options</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module.rules.push(&#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpg|jpeg|gif|svg)$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: <span class="string">"file-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">"[name].[contenthash].[ext]"</span>,</span><br><span class="line">          outputPath: <span class="string">"static"</span>,</span><br><span class="line">          publicPath: <span class="string">"_next/static"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <a href="https://github.com/twopluszero/next-images#readme" target="_blank" rel="noopener">next-images 插件</a> 来引入图片</p>
<h1 id="Next-js-API-模式"><a href="#Next-js-API-模式" class="headerlink" title="Next.js API 模式"></a>Next.js API 模式</h1><p>在 api 目录下创建文件 <code>v1/post.tsx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; NextApiHandler &#125; from &quot;next&quot;</span><br><span class="line">import p from &quot;path&quot;</span><br><span class="line">import fs, &#123; promises as fsPromise &#125; from &quot;fs&quot;</span><br><span class="line">import matter from &quot;gray-matter&quot;</span><br><span class="line"></span><br><span class="line">export const getPosts &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  const markdownDir &#x3D; p.join(process.cwd(), &quot;markdown&quot;)</span><br><span class="line">  const fileNames &#x3D; await fsPromise.readdir(markdownDir)</span><br><span class="line">  const posts &#x3D; fileNames.map((name) &#x3D;&gt; &#123;</span><br><span class="line">    const id &#x3D; name.replace(&quot;&#x2F;.md$&#x2F;&quot;, &quot;&quot;)</span><br><span class="line">    const filePath &#x3D; p.join(markdownDir, name)</span><br><span class="line">    const text &#x3D; fs.readFileSync(filePath, &quot;utf-8&quot;)</span><br><span class="line">    const &#123; data: &#123; title, date &#125;, content &#125; &#x3D; matter(text)</span><br><span class="line">    return &#123;</span><br><span class="line">      id, title, date,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return posts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意这里跟 express 和 koa 不同，没有将 next 直接暴露给我们，但是由于 next 基于 express，他其实也支持 express 类似的中间件，具体请查阅文档</span><br><span class="line">const Posts: NextApiHandler &#x3D; async (request, response) &#x3D;&gt; &#123;</span><br><span class="line">  const posts &#x3D; await getPosts()</span><br><span class="line">  response.statusCode &#x3D; 200</span><br><span class="line">  response.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)</span><br><span class="line">  response.write(JSON.stringify(posts))</span><br><span class="line">  response.end()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Posts</span><br></pre></td></tr></table></figure>
<p>可以试着访问 <code>/api/v1/posts</code>，这段代码只会运行在 node，不会运行在浏览器中</p>
<h1 id="Next-js-三种渲染方式"><a href="#Next-js-三种渲染方式" class="headerlink" title="Next.js 三种渲染方式"></a>Next.js 三种渲染方式</h1><h2 id="客户端渲染（BSR）"><a href="#客户端渲染（BSR）" class="headerlink" title="客户端渲染（BSR）"></a>客户端渲染（BSR）</h2><p>在浏览器上执行的渲染（Browser Side Render），类似用 JS（Vue、React）去创建 HTML</p>
<p>缺点：</p>
<ul>
<li>白屏，而且在拿到响应之前都需要显示 loading 状态</li>
<li>SEO 不友好，搜索引擎拿不到具体的数据；搜索引擎也不会执行 JS，因此看到的 HTML 信息量极少</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;posts&#x2F;index.tsx</span><br><span class="line">import &#123; NextPage &#125; from &quot;next&quot;</span><br><span class="line">import axios from &quot;axios&quot;</span><br><span class="line">import &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">type Post &#x3D; &#123;</span><br><span class="line">  id: string</span><br><span class="line">  date: string</span><br><span class="line">  title: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const PostsIndex: NextPage &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [posts, setPosts] &#x3D; useState&lt;Post[]&gt;([])</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    axios.get(&quot;&#x2F;api&#x2F;v1&#x2F;posts&quot;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">      setPosts(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;clicked&quot;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;&#x2F;* 静态内容 *&#x2F;&#125;</span><br><span class="line">      &lt;h1 onClick&#x3D;&#123;handleClick&#125;&gt;文章列表&lt;&#x2F;h1&gt;</span><br><span class="line">      &#123;&#x2F;* 动态内容 *&#x2F;&#125;</span><br><span class="line">      &#123;</span><br><span class="line">        posts.map((item) &#x3D;&gt; &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;&#x2F;div&gt;)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PostsIndex</span><br></pre></td></tr></table></figure>
<p>实际上上述的静态内容是先由服务器渲染出来，然后再在浏览器上增加事件绑定的，可以看 <a href="https://zh-hans.reactjs.org/docs/react-dom-server.html#rendertostring" target="_blank" rel="noopener">这篇文档</a>：</p>
<p>服务端调用 <code>ReactDOMServer.renderToString(element)</code>，将 React 元素渲染为初始 HTML。<br>再在前端调用 <code>ReactDOM.hydrate()</code>，会在标记过的节点上绑定事件。</p>
<p>但事实上，前端也会渲染一次，检查一下前端跟服务端渲染的内容是否一致（前端渲染的目的是为了检查一致性，而不是为了替换）。<br>如果我们在函数组件最开始打一个 debugger，然后趁 debugger 的时间在页面上把服务端渲染出来的 HTML 改一下，再继续执行，会发现报错：</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-1.png" alt="如果前后端渲染不一致，会报错"></p>
<h2 id="静态页面生成（SSG）"><a href="#静态页面生成（SSG）" class="headerlink" title="静态页面生成（SSG）"></a>静态页面生成（SSG）</h2><p>静态页面生成（Static Site Generation）是预渲染（Pre-rendering）的一种，类似于把 PHP 提前渲染成 HTML。</p>
<p>时机：</p>
<ul>
<li>生产环境中，静态化是在 <code>yarn build</code> 的时候实现的<br>优点：</li>
<li>能解决白屏问题</li>
<li>解决 SEO 问题</li>
<li>前端重复渲染相同内容的问题（可以将动态内容静态化，将需要客户端渲染的动态内容提前由服务端渲染好，然后作为静态内容发给前端）<br>缺点： </li>
<li>无法生成用户相关内容（每个人看到的都是一样的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; GetStaticProps, NextPage &#125; from &quot;next&quot;</span><br><span class="line">import axios from &quot;axios&quot;</span><br><span class="line">import &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;</span><br><span class="line">import &#123; getPosts &#125; from &quot;..&#x2F;..&#x2F;lib&#x2F;posts&quot;</span><br><span class="line"></span><br><span class="line">type Post &#x3D; &#123;</span><br><span class="line">  id: string</span><br><span class="line">  date: string</span><br><span class="line">  title: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Props &#x3D; &#123;</span><br><span class="line">  posts: Post[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const PostsIndex: NextPage&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这个 props 其实前后端都能拿到</span><br><span class="line">  const &#123; posts &#125; &#x3D; props</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;文章列表&lt;&#x2F;h1&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        posts.map((item) &#x3D;&gt; &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;&#x2F;div&gt;)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意这里不要忘了 export，如果不写的话，这段代码会被前端执行，会报错</span><br><span class="line">&#x2F;&#x2F; 在生产环境中，是在 build 的时候执行的</span><br><span class="line">export const getStaticProps: GetStaticProps &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 服务端显然没必要通过 AJAX 去拿数据，直接去文件系统或者数据库拿</span><br><span class="line">  const posts &#x3D; await getPosts()</span><br><span class="line">  return &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts: JSON.parse(JSON.stringify(posts)),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PostsIndex</span><br></pre></td></tr></table></figure>
<p>前端也能拿到 props，因为 Next 会将这些数据放在 HTML 中给前端：</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-2.png" alt="Next 会将数据放在 HTML 中给前端"></p>
<h3 id="同构代码的好处"><a href="#同构代码的好处" class="headerlink" title="同构代码的好处"></a>同构代码的好处</h3><p>将数据放在 HTML 中之后，前端也能很方便地使用了，其实其他后端语言也能做到，但 Next.js 更加方便，因为：</p>
<ul>
<li>Next 支持 jsx，写出来的代码可以与 React 无缝对接，可以只写一份代码</li>
<li>Next 写出来的对象都是 JavaScript 对象，无需类型转换，如果是其他语言就需要进行额外的类型转换</li>
</ul>
<h3 id="yarn-build"><a href="#yarn-build" class="headerlink" title="yarn build"></a>yarn build</h3><p><code>yarn build</code> 的时候会提示你页面的类型：</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-3.png" alt=""></p>
<p>比如空心圆代表静态页面，而实心圆代表使用了 getStaticProps 进行静态化。</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-3.png" alt=""></p>
<p>可以看到编译之后，一个 SSG 页面（实心圆）变成了三个文件：</p>
<ul>
<li>html 是用户拿到的静态页面</li>
<li>js 里面也含有静态内容，是快速导航（Link）需要用到的，因为快速导航实际上是使用 js + json 做的，而不是再去请求一次 html</li>
<li>json 是 getStaticProps 得到的数据，为了方便 js 接入不同的数据，因此 js 和 json 需要分开</li>
</ul>
<h3 id="根据路径创建静态页面"><a href="#根据路径创建静态页面" class="headerlink" title="根据路径创建静态页面"></a>根据路径创建静态页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;posts&#x2F;[id].tsx</span><br><span class="line">import &#123; getPost, getPostIds &#125; from &quot;..&#x2F;..&#x2F;lib&#x2F;posts&quot;</span><br><span class="line">import &#123; GetStaticPaths, GetStaticProps, NextPage &#125; from &quot;next&quot;</span><br><span class="line">type Props &#x3D; &#123;</span><br><span class="line">  post: Post</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Params &#x3D; &#123;</span><br><span class="line">  id: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const PostShow: NextPage&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; post &#125; &#x3D; props</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;article&gt;</span><br><span class="line">        &#123;post.content&#125;</span><br><span class="line">      &lt;&#x2F;article&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PostShow</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明路由：用这个来穷举静态页面的不同路径</span><br><span class="line">export const getStaticPaths: GetStaticPaths &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  const idList &#x3D; await getPostIds()</span><br><span class="line">  const paths &#x3D; idList.map((id) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      params: &#123; id &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return &#123;</span><br><span class="line">    paths,</span><br><span class="line">    &#x2F;&#x2F; false：当请求的 id 不再 path 里面，直接返回 404</span><br><span class="line">    &#x2F;&#x2F; true：若不存在，则依然渲染页面</span><br><span class="line">    fallback: false,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过 context 中的 params 拿到上一个函数穷举出的路径，也就是我们的 id，然后借由 id 去获取内容并生成静态文件</span><br><span class="line">export const getStaticProps: GetStaticProps&lt;Props, Params&gt; &#x3D; async (context) &#x3D;&gt; &#123;</span><br><span class="line">  const id &#x3D; context.params!.id</span><br><span class="line">  const post &#x3D; await getPost(id)</span><br><span class="line">  return &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      post,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/next-5.png" alt=""></p>
<p>可以看到生成来的文件中只有一个 JS，但是有两个 JSON 和两个 HTML 文件，这就是根据不同路由的到的不同页面和数据。</p>
<h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><p>服务端渲染（Server Side Render）也是预渲染的一种，类似于 PHP、Python、Ruby、Java 后台的基本功能。<br>比如当需要通过不同的用户 id 等渲染不同的内容，这时候就较难提前做静态化，这个时候就可以使用 SSR，由服务端渲染好首屏，再下拉刷新。</p>
<p>时机：</p>
<ul>
<li>无论是在开发环境还是生产环境，都是每次请求来到之后运行的<br>优点：</li>
<li>能解决白屏问题</li>
<li>解决 SEO 问题</li>
<li>可以生成跟用户有关系的内容<br>缺点：</li>
<li>无法获取客户端信息，比如浏览器窗口大小等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; GetServerSideProps, NextPage &#125; from &quot;next&quot;</span><br><span class="line">import &#123; IBrowser, UAParser &#125; from &quot;ua-parser-js&quot;</span><br><span class="line">import &#123; useEffect, useState &#125; from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">type Props &#x3D; &#123;</span><br><span class="line">  browser: IBrowser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Home: NextPage&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; browser &#125; &#x3D; props</span><br><span class="line">  const [clientWidth, setClientWidth] &#x3D; useState(0)</span><br><span class="line">  &#x2F;&#x2F; 如果想要获取浏览器窗口的大小，不能使用 SSR，只能使用客户端渲染，这样的写法保证了下面的代码只会在浏览器中运行，防止 node 报错</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    setClientWidth(document.documentElement.clientWidth)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;你的浏览器是 &#123;browser.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h1&gt;你的窗口宽度是 &#123;clientWidth&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次请求的时候才会执行</span><br><span class="line">export const getServerSideProps: GetServerSideProps &#x3D; async (context) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; context 中有 req 和 res，一般只需要 req</span><br><span class="line">  const ua &#x3D; context.req.headers[&quot;user-agent&quot;]</span><br><span class="line">  const result &#x3D; new UAParser(ua).getResult()</span><br><span class="line">  return &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      browser: result.browser,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三种渲染应该如何选择"><a href="#三种渲染应该如何选择" class="headerlink" title="三种渲染应该如何选择"></a>三种渲染应该如何选择</h2><ol>
<li>有动态内容吗？<ul>
<li>有，跳到 2</li>
<li>没有，直接写 HTML 即可</li>
</ul>
</li>
<li>跟客户端相关（比如获取窗口大小等）吗？<ul>
<li>相关，BSR</li>
<li>无关，跳到 3</li>
</ul>
</li>
<li>我的响应跟用户或请求相关吗？<ul>
<li>相关，SSR（getServerSideProps）或 BSR</li>
<li>无关，SSG（getStaticProps） 或 SSR 或 BSR</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Cypress</title>
    <url>/hais-notebook/2021/04/07/NodeJS-Cypress/</url>
    <content><![CDATA[<p>使用 Cypress 进行自动化测试</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa</title>
    <url>/hais-notebook/2021/04/06/NodeJS-Koa/</url>
    <content><![CDATA[<p>NodeJS WEB 框架之 Koa</p>
<a id="more"></a>
<h1 id="Koa-与-Express-的区别"><a href="#Koa-与-Express-的区别" class="headerlink" title="Koa 与 Express 的区别"></a>Koa 与 Express 的区别</h1><ul>
<li>中间件模型不同：Koa 是 U 型，Express 是线型</li>
<li>语法特性不同，一般来说 NodeJS 7.6.0 之后才算完美支持 Koa</li>
<li>Koa 没有内置中间件</li>
</ul>
<h1 id="Koa-的中间件模型：U-型-洋葱型"><a href="#Koa-的中间件模型：U-型-洋葱型" class="headerlink" title="Koa 的中间件模型：U 型/洋葱型"></a>Koa 的中间件模型：U 型/洋葱型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求 -&gt; f1 -&gt; f2 -&gt; f3 -&gt; ...</span><br><span class="line">                           ↓</span><br><span class="line">响应 &lt;- f1 &lt;- f2 &lt;- f3 &lt;- ...</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的中间件使用示例，按照注释的顺序运行，可以看到一个以 <code>await next()</code> 为轴的 U 型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 什么也不做</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="comment">// 5. 读取 X-Response-Time 中的时间，打印出来</span></span><br><span class="line">  <span class="keyword">const</span> time = ctx.response.get(<span class="string">"X-Response-Time"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 2. 记录开始时间</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="comment">// 4. 计算第三个中间件写 "Hello World" 的时间，并写入 X-Response-Time 响应头中</span></span><br><span class="line">  <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">"X-Response-Time"</span>, <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 3. body = "Hello World"</span></span><br><span class="line">  ctx.body = <span class="string">"Hello World"</span></span><br><span class="line">  <span class="comment">// 最后一个中间件可以不写 await next()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="await-next"><a href="#await-next" class="headerlink" title="await next()"></a><code>await next()</code></h2><p><code>next()</code> 表示进入下一个函数，并返回一个 Promise，当下一个函数执行完成之后，会将 Promise 置为成功，然后 await 继续执行剩下的代码</p>
<p>实际上相当于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// 中间件需要返回一个 Promise 对象，使用 async 的写法将会自动 return 一个 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> next().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - start</span><br><span class="line">    ctx.set(<span class="string">"X-Response-Time"</span>, <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span>)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Koa-APIs"><a href="#Koa-APIs" class="headerlink" title="Koa APIs"></a>Koa APIs</h1><h2 id="app-xxx"><a href="#app-xxx" class="headerlink" title="app.xxx"></a>app.xxx</h2><ul>
<li><code>app.env</code> 获取环境变量</li>
<li><code>app.listen()</code></li>
<li><code>app.use()</code> 插入中间件</li>
<li><code>app.on(&quot;error&quot;, fn)</code> 错误处理</li>
<li><code>app.emit()</code> 触发事件</li>
</ul>
<h2 id="ctx-xxx"><a href="#ctx-xxx" class="headerlink" title="ctx.xxx"></a>ctx.xxx</h2><ul>
<li><code>ctx.req</code> NodeJS 封装的请求</li>
<li><code>ctx.request</code> Koa 封装的请求</li>
<li><code>ctx.res</code></li>
<li><code>ctx.response</code></li>
<li><code>ctx.state</code> 跨中间件分享数据</li>
<li><code>ctx.cookies.get</code> <code>ctx.cookies.set</code></li>
<li><code>ctx.throw</code></li>
<li><code>ctx.assert</code></li>
</ul>
<h3 id="Request-和-Response-委托"><a href="#Request-和-Response-委托" class="headerlink" title="Request 和 Response 委托"></a>Request 和 Response 委托</h3><p><code>ctx</code> 是 Request 和 Response 的委托，比如写 <code>ctx.body =</code> 相当于写 <code>ctx.response.body =</code>。<br>如果要自己实现委托操作的话，可以这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(ctx, <span class="string">"body"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.response.body</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: (value) =&gt; &#123;</span><br><span class="line">    ctx.response.body = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="ctx-request-xxx-ctx-response-xxx"><a href="#ctx-request-xxx-ctx-response-xxx" class="headerlink" title="ctx.request.xxx ctx.response.xxx"></a><code>ctx.request.xxx</code> <code>ctx.response.xxx</code></h3><p>可以直接查看 <a href="https://koa.bootcss.com/" target="_blank" rel="noopener">相关文档</a></p>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Express</title>
    <url>/hais-notebook/2021/03/27/NodeJS-Express/</url>
    <content><![CDATA[<p>NodeJS WEB 框架之 Express</p>
<a id="more"></a>
<h1 id="Express-Generator"><a href="#Express-Generator" class="headerlink" title="Express Generator"></a>Express Generator</h1><p>express 脚手架。</p>
<h1 id="use"><a href="#use" class="headerlink" title="use"></a>use</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">"express"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(request.url)</span><br><span class="line">  response.write(<span class="string">"first hi\n"</span>)</span><br><span class="line">  <span class="comment">// 为了让他执行下一个 use，需要调用 next()，否则他不会执行下一个 use</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><br><span class="line">  response.write(<span class="string">"second hi\n"</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>express 就是这样通过一个个 <code>use</code> 的函数，最终到达结束程序。每一个函数可以读取 request、写入 response、调用 next()。</p>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p><code>use</code> 的那些函数就被称为 <strong>中间件</strong>。<br>可以看一下 <code>express-generator</code> 为我们创建的 <code>app.js</code> 文件的其中一部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(logger(<span class="string">"dev"</span>))</span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(cookieParser())</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">"public"</span>)))</span><br></pre></td></tr></table></figure>
<p>Express 这样的编程模型的优点就是模块化：每个功能都能通过一个函数实现，然后通过 app.use 将函数们整合起来。如果这些函数放到不同的文件或者 npm 包里，就实现了模块化。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>用 use 也可以很方便地实现路由：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.path === <span class="string">"/"</span> &amp;&amp; request.method === <span class="string">"get"</span>) &#123;</span><br><span class="line">    response.send(<span class="string">"ROOT"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由此衍生除了一些 API 糖：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">"/xxx"</span>, fn)</span><br><span class="line">app.get(<span class="string">"/xxx"</span>, fn)</span><br><span class="line">app.post(<span class="string">"/xxx"</span>, fn)</span><br><span class="line">app.route(<span class="string">"/xxx"</span>).all(f1).get(f2).post(f3)</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>next()</code> 可以传入一个错误/字符串，就会进入错误处理函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    <span class="comment">// 传给 next 一个错误，就会直接进入 errorHandler</span></span><br><span class="line">    <span class="keyword">return</span> next(<span class="string">"出错了！"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"如果没有错误，这里才会执行"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">error, request, response, next</span>) =&gt;</span> &#123;</span><br><span class="line">  response.write(error)</span><br><span class="line">  response.end()</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="子应用与挂载点"><a href="#子应用与挂载点" class="headerlink" title="子应用与挂载点"></a>子应用与挂载点</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> admin = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/admin"</span>, admin) <span class="comment">// admin 是子应用，/admin 是 admin 的挂载点</span></span><br></pre></td></tr></table></figure>
<h1 id="Express-APIs"><a href="#Express-APIs" class="headerlink" title="Express APIs"></a>Express APIs</h1><h2 id="express-xxx"><a href="#express-xxx" class="headerlink" title="express.xxx"></a>express.xxx</h2><ul>
<li><code>express.static()</code> 指定静态资源文件夹路径</li>
<li><code>express.json()</code> 解析 Content-Type 为 application/json（或类似）的内容</li>
<li><code>express.urlencoded()</code> 解析 Content-Type 为 application/x-www-form-urlencoded（或类似）的内容</li>
<li><code>express.text()</code> 解析 Content-Type 为 text/plain（或类似）的内容</li>
<li><code>express.raw()</code> 解析 Content-Type 为 application/octet-stream （或类似）的内容</li>
</ul>
<h2 id="app-xxx"><a href="#app-xxx" class="headerlink" title="app.xxx"></a>app.xxx</h2><ul>
<li><code>app.set()</code> set 一个值，不过有一些特殊值，比如 <code>case sensitive routing</code> <code>env</code> <code>views</code> <code>view engine</code>，而且一般这些特殊值放在所有的中间件之前才会生效</li>
<li><code>app.get()</code> 可以获取到你 set 的东西</li>
<li><code>app.get()</code> <code>app.post()</code> <code>app.put()</code> <code>app.delete()</code> <code>app.patch()</code> <code>app.all()</code> 这些都是 <code>app.use()</code> 的 API 糖 </li>
<li><code>app.locals</code> 设置一些局部变量，比如 <code>app.locals.title = &quot;My Title&quot;</code>，然后就可以在其他地方进行读取</li>
<li><code>app.mountpath</code> 挂载路径</li>
</ul>
<h2 id="request-xxx"><a href="#request-xxx" class="headerlink" title="request.xxx"></a>request.xxx</h2><ul>
<li><code>request.app</code> 获取到全局的 app</li>
<li><code>request.get()</code> 获取请求头</li>
<li><code>request.param()</code> 获取某个参数</li>
<li><code>request.range()</code><ol>
<li>用 HEAD 请求某个资源，如果资源支持分片下载，就可以得到类似于 <code>Accept-Ranges: bytes</code>（支持以字节为分片下载） 的响应头。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests" target="_blank" rel="noopener">可以参阅这里</a></li>
<li>然后用请求头 <code>Range</code> 就可以设置分片下载</li>
<li><code>request.range</code> 则是用于解析 <code>Range</code> 这个请求头的</li>
</ol>
</li>
</ul>
<h2 id="response-xxx"><a href="#response-xxx" class="headerlink" title="response.xxx"></a>response.xxx</h2><ul>
<li><code>response.app</code> 获取到全局的 app</li>
<li><code>response.headersSent</code> 是否已经发送响应头</li>
<li><code>response.set()</code> 设置响应头（覆盖之前的）</li>
<li><code>response.append()</code> 设置请求头（不覆盖之前的）</li>
<li><code>response.status()</code> 设置状态码</li>
<li><code>repoonse.cookie()</code> 设置 cookie</li>
<li><code>response.download()</code> 提供下载</li>
<li><code>response.format()</code> 根据请求的不同 <code>Accept</code> 值返回不同的类型</li>
<li><code>response.json()</code> 类似于 <code>JSON.stringify()</code></li>
<li><code>response.location()</code> 一般用于 301/302/307 跳转，设置响应头 <code>Location</code></li>
<li><code>response.redirect()</code> 相当于 <code>response.location()</code> + <code>response.status()</code></li>
<li><code>response.write()</code> 写入消息体（流式操作）</li>
<li><code>response.end()</code> 写入消息体（一次性），不能跟 <code>response.write</code> 同时使用</li>
</ul>
<h2 id="router-xxx"><a href="#router-xxx" class="headerlink" title="router.xxx"></a>router.xxx</h2><p><code>router</code> 相当于一个小型的 <code>app</code>，是一个单独的用于路由的实例，需要这样声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = express.Router()</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">userRouter.get(<span class="string">"/:id"</span>, <span class="function">(<span class="params">request, response, next</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">app.use(<span class="string">"/users"</span>, userRouter) <span class="comment">// 将 userRouter 挂载到 app 上</span></span><br></pre></td></tr></table></figure>
<p><code>router</code> 有这些 API，基本被 <code>app</code> 包含。</p>
<ul>
<li><code>router.all()</code></li>
<li><code>router.METHOD()</code></li>
<li><code>router.param()</code></li>
<li><code>router.route()</code></li>
<li><code>router.use()</code></li>
</ul>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Child Process</title>
    <url>/hais-notebook/2021/03/26/NodeJS-ChildProcess/</url>
    <content><![CDATA[<p>进程、线程，进程控制与线程控制。</p>
<a id="more"></a>
<h1 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h1><p><strong>进程</strong>是<strong>程序</strong>（比如 exe）的执行实例。<strong>程序</strong>在CPU上执行的活动叫做<strong>进程</strong>。</p>
<p>一个进程可以创建另一个进程（父进程与子进程）。</p>
<h2 id="多程序并发执行"><a href="#多程序并发执行" class="headerlink" title="多程序并发执行"></a>多程序并发执行</h2><p>单核 CPU 在一个时刻，只能做一件事情，为了让用户在同一时刻可以做多件事，就需要在不同进程中快速切换。</p>
<p>也就是“多程序并发执行”——多个程序在宏观上并行，微观上串行。多个进程之间会出现抢资源（比如打印机就很明显）的现象。</p>
<h2 id="进程的两个状态"><a href="#进程的两个状态" class="headerlink" title="进程的两个状态"></a>进程的两个状态</h2><p>进程有 <strong>非运行态</strong> 与 <strong>运行态</strong>。分派程序将 CPU 分配给非运行态的进程，进程从而进入运行态；过一段时间之后进程暂停，又进入非运行态。</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>在进程队列中等待执行的进程都处于 <strong>非运行态</strong>，一些进程(A)在等待 CPU 资源，一些进程(B)在等待 I/O 完成（比如文件读取）。如果这时候把 CPU 分配给 B 进程，B 进程并不会使用 CPU，而是继续等 I/O——我们把 B 称为 <strong>阻塞进程</strong>。为了避免资源的浪费，分派程序只会把 CPU 分配给 <strong>非阻塞进程</strong>。</p>
<h1 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程 Thread"></a>线程 Thread</h1><p>早期的面向进程设计的操作系统中，进程是程序的基本执行实体。现在的面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。</p>
<p>进程是执行的基本实体，也是资源分配的基本实体——这就导致进程的创建、切换、销毁太消耗 CPU 的时间了。因此引入线程，线程作为执行的基本实体，而进程作为资源分配的基本实体。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>CPU 调度和执行的最小单元</li>
<li>一个进程中可以有一个或多个线程</li>
<li>一个进程中的线程共享该进程的所有资源</li>
<li>进程的第一个线程叫做初始化线程</li>
<li>线程的调度可以由操作系统负责，也可以由用户自己负责</li>
</ul>
<h1 id="使用-NodeJS-操作进程"><a href="#使用-NodeJS-操作进程" class="headerlink" title="使用 NodeJS 操作进程"></a>使用 NodeJS 操作进程</h1><p>使用 <code>child_process</code> 模块可以创建子进程。<br>子进程的运行结果存在系统缓存之中（最大 200kb），等到子进程结束之后，主进程再用回调函数读取子进程的运行结果。</p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p><code>exec(command[, options][, callback])</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="comment">// exec 可以执行命令行命令，从而开启一个子进程，子进程如果有输出，会存在缓存之中，等子进程结束之后输出给 stdout</span></span><br><span class="line">exec(<span class="string">"ls ../"</span>, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error, stdout, stderr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面这段简单的代码表示使用 exec 可以执行命令行命令，使用命令行我们就可以开启一个子进程。</p>
<p>exec 也会返回一个包含流的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> streams = exec(<span class="string">"ls ../"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// streams.stdout 是一个流</span></span><br><span class="line">streams.stdout.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"getData"</span>, chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// stream.stderror 也是一个流</span></span><br><span class="line">streams.stderr.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"getError"</span>, chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此外，还可以用 <code>util.promisify</code> 将其包裹为一个 Promise，避免回调地狱：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = child_process</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promisifiedExec = util.promisify(exec)</span><br><span class="line"></span><br><span class="line">promisifiedExec(<span class="string">"ls ../"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"success"</span>, data.stdout)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>注意！如果 <code>exec</code> 执行的命令行命令可以被用户指定，就会存在注入的风险，所以通常我们不使用 <code>exec</code>。</p>
<h2 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h2><p><code>execFile(file[, args][, options][, callback])</code></p>
<p>跟 exec 用法基本相同，也可以以流的方式使用，但命令行参数需要用数组的形式传入，无法注入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; execFile &#125; = child_process</span><br><span class="line"></span><br><span class="line">execFile(<span class="string">"ls"</span>, [<span class="string">"-la"</span>, <span class="string">"."</span>], (error, stdout) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">  <span class="built_in">console</span>.log(stdout)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>options 可传可不传，他有一些比较重要的参数：</p>
<ul>
<li>cwd: 在哪个目录执行，默认是当前目录</li>
<li>env: 环境变量，默认是 process.env</li>
<li>maxBuffer: 用于暂存 stdout 和 stderr 的最大缓存区大小，默认 1024 * 1024 Byte</li>
<li>shell: 指定运行的 shell</li>
</ul>
<h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>用法跟 execFile 基本一样，但没有回调函数，只能通过流事件来获取结果，也没有最大的缓存限制（因为是流，并没有暂存 stdout 和 stderr）。</p>
<p>一般用 spawn，不用 execFile，因为流比较方便，且不会占用太多内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> streams = spawn(<span class="string">"ls"</span>, [<span class="string">"-la"</span>, <span class="string">"."</span>])</span><br><span class="line"></span><br><span class="line">streams.stdout.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>创建一个执行 Node 脚本的子进程，可以监听他的 message 事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** main.js */</span></span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = child_process</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实类似于 execFile("node", ["./child.js"])</span></span><br><span class="line"><span class="keyword">const</span> childProcess = fork(<span class="string">"./child.js"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程监听子进程传来的消息</span></span><br><span class="line">childProcess.on(<span class="string">"message"</span>, (message) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"父进程得到 message"</span>, message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">childProcess.send(&#123; <span class="attr">age</span>: <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** child.js */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"This is child.js"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程监听父进程传来的消息</span></span><br><span class="line">process.on(<span class="string">"message"</span>, (message) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"子进程得到 message"</span>, message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  process.send(&#123; <span class="attr">name</span>: <span class="string">"harvey"</span> &#125;)</span><br><span class="line">  <span class="comment">// 如果没有这句话，node 会因为父子进程相互监听而无法退出</span></span><br><span class="line">  process.exit()</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h1 id="使用-NodeJS-操作线程"><a href="#使用-NodeJS-操作线程" class="headerlink" title="使用 NodeJS 操作线程"></a>使用 NodeJS 操作线程</h1><p>操作线程需要使用 <code>new Worker</code>，而这个 API 非常新，在 v10.5.0 才加入，并且在 v11.7.0 之前使用都需要 <code>--experimental-worker</code> 来开启，因此用得会比较少，并且效率也不高。</p>
<blockquote>
<p>Workers (threads) are useful for performing CPU-intensive JavaScript operations. They do not help much with I/O-intensive work. The Node.js built-in asynchronous I/O operations are more efficient than Workers can be.</p>
</blockquote>
<p>具体内容可以参考 <a href="https://nodejs.org/api/worker_threads.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream</title>
    <url>/hais-notebook/2021/03/21/NodeJS-Stream/</url>
    <content><![CDATA[<p>数据流叫 Stream，每次写的小数据叫 chunk，产生数据的一段叫 source，得到数据的一段叫 sink。</p>
<a id="more"></a>
<h1 id="NodeJS-中的-Stream"><a href="#NodeJS-中的-Stream" class="headerlink" title="NodeJS 中的 Stream"></a>NodeJS 中的 Stream</h1><h2 id="用-Stream-写文件"><a href="#用-Stream-写文件" class="headerlink" title="用 Stream 写文件"></a>用 Stream 写文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> stream = fs.createWriteStream(<span class="string">"./big_file.txt"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  stream.write(<span class="string">`这是第 <span class="subst">$&#123;i&#125;</span> 行的内容，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\n`</span>)</span><br><span class="line">&#125;</span><br><span class="line">stream.end()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="不用-Stream-读文件"><a href="#不用-Stream-读文件" class="headerlink" title="不用 Stream 读文件"></a>不用 Stream 读文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, (request, response) =&gt; &#123;</span><br><span class="line">  fs.readFile(<span class="string">"./big_file.txt"</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    response.end(data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"done"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到 Nodejs 进程的内存占用非常大。</p>
<h2 id="用-Stream-读文件"><a href="#用-Stream-读文件" class="headerlink" title="用 Stream 读文件"></a>用 Stream 读文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stream = fs.createReadStream(<span class="string">"./big_file.txt"</span>)</span><br><span class="line">  stream.pipe(response) <span class="comment">// response 也是 stream，文件 stream 和 response stream 通过管道连接</span></span><br><span class="line">  stream.on(<span class="string">"end"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"done"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>使用 Stream，Nodejs 的内存占用会更低。</p>
<p>管道也可以通过这样来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream1 有数据就塞给 stream2</span></span><br><span class="line">stream1.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  stream2.write(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// stream1 停了，就停掉 steam2</span></span><br><span class="line">stream1.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  stream2.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Stream-的原型链"><a href="#Stream-的原型链" class="headerlink" title="Stream 的原型链"></a>Stream 的原型链</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s = fs.createReadStream(path)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s -&gt; fs.ReadStream -&gt; stream.Readable -&gt; stream.Stream -&gt; event.EventEmitter -&gt; Object</span><br></pre></td></tr></table></figure>
<h2 id="支持的事件和方法"><a href="#支持的事件和方法" class="headerlink" title="支持的事件和方法"></a>支持的事件和方法</h2><h3 id="stream-Readable"><a href="#stream-Readable" class="headerlink" title="stream.Readable"></a>stream.Readable</h3><ul>
<li><p>事件：data, end, error, close, readable, pause, resume …</p>
</li>
<li><p>方法：</p>
<ul>
<li>pipe()</li>
<li>unpipe()</li>
<li>wrap()</li>
<li>destroy()</li>
<li>read()</li>
<li>unshift()</li>
<li>resume()</li>
<li>pause()</li>
<li>isPaused()</li>
<li>setEncoding()</li>
</ul>
</li>
</ul>
<h3 id="stream-Writable"><a href="#stream-Writable" class="headerlink" title="stream.Writable"></a>stream.Writable</h3><ul>
<li><p>事件：drain, finish, error, close, pipe, unpipe …</p>
</li>
<li><p>方法：</p>
<ul>
<li>write()</li>
<li>destroy()</li>
<li>end()</li>
<li>cork()</li>
<li>uncork()</li>
<li>setDefaultEncoding()</li>
</ul>
</li>
</ul>
<h1 id="Stream-的分类"><a href="#Stream-的分类" class="headerlink" title="Stream 的分类"></a>Stream 的分类</h1><ul>
<li>Readable，可读，数据的生产者</li>
<li>Writable，可写，数据的消费者</li>
<li>Duplex，可读可写（双向，读和写的内容无关）</li>
<li>Transform，可读可写（变化，比如先把内容读出来，再写到别的地方）</li>
</ul>
<h2 id="Readable-Stream"><a href="#Readable-Stream" class="headerlink" title="Readable Stream"></a>Readable Stream</h2><ul>
<li>paused 静止态</li>
<li>flowing 流动态</li>
</ul>
<p>默认处于 paused；添加 data 事件监听，就会变成 flowing；删掉 data 事件监听就又变成 paused。<br>pause() 可以让他变为 paused，resume() 可以让他变为 flowing。</p>
<h2 id="Writable-Stream"><a href="#Writable-Stream" class="headerlink" title="Writable Stream"></a>Writable Stream</h2><ul>
<li>drain：writable.write(chunk) 将会返回一个 boolean，如果 boolean 为 false，这个 stream 堵车了，这个时候就需要等待。当 writable 监听到 drain 事件，表示不堵车了，可以继续传输数据。</li>
<li>finish：调用 stream.end() 方法，并且缓冲区的数据都已经传给底层系统后会触发。</li>
</ul>
<h2 id="Transform-Stream"><a href="#Transform-Stream" class="headerlink" title="Transform Stream"></a>Transform Stream</h2><p>NodeJS 内置了一些 Transform Stream，可以看这个使用 gzip 压缩的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">"zlib"</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">"crypto"</span>)</span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reportProgress = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">"."</span>)</span><br><span class="line">    <span class="comment">// 可以将 chunk push 进去</span></span><br><span class="line">    <span class="comment">// this.push(chunk)</span></span><br><span class="line">    <span class="comment">// 也可以把 chunk 给 callback</span></span><br><span class="line">    callback(<span class="literal">null</span>, chunk)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(crypto.createCipher(<span class="string">"aes-192-gcm"</span>, <span class="string">"123456"</span>))</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  <span class="comment">// 可以用 on 来进行监听并作出副作用（不会影响原来的数据）</span></span><br><span class="line">  <span class="comment">// .on("data", () =&gt; process.stdout.write("."))</span></span><br><span class="line">  <span class="comment">// 也可以插入一个 TransformStream</span></span><br><span class="line">  .pipe(reportProgress)</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">".gz"</span>))</span><br><span class="line">  .on(<span class="string">"finish"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"Done"</span>))</span><br></pre></td></tr></table></figure>
<h1 id="创建一个-Stream"><a href="#创建一个-Stream" class="headerlink" title="创建一个 Stream"></a>创建一个 Stream</h1><h2 id="创建一个-Writable-Stream"><a href="#创建一个-Writable-Stream" class="headerlink" title="创建一个 Writable Stream"></a>创建一个 Writable Stream</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> consumer = <span class="keyword">new</span> Writable(&#123;</span><br><span class="line">  write(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk.toString())</span><br><span class="line">    <span class="comment">// callback 调用这句必须要写，否则就会卡住</span></span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户的输入 stream -&gt; consumer</span></span><br><span class="line">process.stdin.pipe(consumer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写：</span></span><br><span class="line"><span class="comment">// process.stdin.on("data", (chunk) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   consumer.write(chunk)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="创建一个-Readable-Stream"><a href="#创建一个-Readable-Stream" class="headerlink" title="创建一个 Readable Stream"></a>创建一个 Readable Stream</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> producer = <span class="keyword">new</span> Readable()</span><br><span class="line"></span><br><span class="line">producer.push(<span class="string">"HAHAHA"</span>)</span><br><span class="line">producer.push(<span class="string">"XIXIXI"</span>)</span><br><span class="line"><span class="comment">// push null 必须写，表示已经结束了</span></span><br><span class="line">producer.push(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">producer.pipe(process.stdout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="comment">// producer.on("data", (chunk) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   process.stdout.write(chunk)</span></span><br><span class="line"><span class="comment">//   console.log("WRITE")</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<p>上面的写法是先将所有的数据 push 进流里面，那么有没有办法让他边读边写呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> producer = <span class="keyword">new</span> Readable(&#123;</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="built_in">String</span>.fromCharCode(<span class="keyword">this</span>.currentCharCode++))</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentCharCode &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="comment">// push null 表示终止</span></span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">producer.currentCharCode = <span class="string">"A"</span>.charCodeAt()</span><br><span class="line"></span><br><span class="line">producer.pipe(process.stdout)</span><br></pre></td></tr></table></figure>
<p>上述的代码就是在 <code>process.stdout</code> 要数据的时候（调用 <code>read</code> 的时候），<code>producer</code> 才往里面 push 一个字符。 </p>
<h2 id="创建一个-Duplex-Stream"><a href="#创建一个-Duplex-Stream" class="headerlink" title="创建一个 Duplex Stream"></a>创建一个 Duplex Stream</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> duplex = <span class="keyword">new</span> Duplex(&#123;</span><br><span class="line">  write(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk.toString())</span><br><span class="line">    callback()</span><br><span class="line">  &#125;,</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="built_in">String</span>.fromCharCode(<span class="keyword">this</span>.currentCharCode++))</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentCharCode &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">duplex.currentCharCode = <span class="number">65</span></span><br><span class="line"></span><br><span class="line">process.stdin.pipe(duplex).pipe(process.stdout)</span><br></pre></td></tr></table></figure>
<p>简单来说就是把 Readable 和 Writable Stream 写在一起，就成了一个双向的 Stream，它既可写又可读，既可以消费信息、又可以生产信息。他的生产和消费过程彼此相互独立、互不影响。</p>
<h2 id="Transform-Stream-1"><a href="#Transform-Stream-1" class="headerlink" title="Transform Stream"></a>Transform Stream</h2><p>Transform 虽然也被称为“双向流”，但跟 Duplex 不同，他是先读数据，转换之后再写数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upperCaseTransformer = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(chunk.toString().toUpperCase())</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.stdin.pipe(upperCaseTransformer).pipe(process.stdout)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基本知识 2</title>
    <url>/hais-notebook/2021/03/20/DataBase-Base/</url>
    <content><![CDATA[<p>范式、表设计、缓存字段、事务、存储引擎</p>
<a id="more"></a>
<h1 id="关系型数据库的范式"><a href="#关系型数据库的范式" class="headerlink" title="关系型数据库的范式"></a>关系型数据库的范式</h1><h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><blockquote>
<p><strong>字段不可再分</strong>。</p>
</blockquote>
<p>比如我们需要存储体检者的双眼视力，那么左右眼视力应该分别存在两个字段中。</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><blockquote>
<p>在第一范式的基础上，要有 <strong>键</strong>（键可由多个字段组合）。<br>所有字段分别 <strong>完全依赖</strong> 于键。<br>如果键是多个字段的组合，则 <strong>不允许部分依赖</strong> 于该键。</p>
<p>依赖关系：给出键，就能确定唯一字段的值。</p>
</blockquote>
<p>比如给出“学号”，就能唯一确定“姓名”，反之则不行，则称“姓名”依赖于“学号”。</p>
<p>比如有一个表中有“学号”“姓名”“课名”“分数”，分数依赖于“学号+课名”，因此将“学号+课名”作为键，但字段“姓名”不依赖于“课名”却依赖于“学号”（“姓名”部分依赖于“学号+课名”）这就不满足第二范式。</p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><blockquote>
<p>一个表里面不能有两层依赖。</p>
</blockquote>
<p>比如一个表中有“学号”“姓名”“系名”“系主任”，“姓名”依赖于“学号”，而“系主任”依赖于“系名”，这就不满足第三范式。</p>
<h2 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h2><blockquote>
<p>键中的属性也不存在间接依赖。</p>
</blockquote>
<h1 id="数据库设计经验"><a href="#数据库设计经验" class="headerlink" title="数据库设计经验"></a>数据库设计经验</h1><blockquote>
<p>高内聚、低耦合。</p>
</blockquote>
<h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>把相关的字段放到一起，不相关的字段分开建表。</p>
<p>如果两个字段能单独建表，那就单独建表。</p>
<h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>如果两个表中有弱关系，采取低耦合</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>假设一个学生只能加入一个班级，一个班级里面只能有一个学生。</p>
<ul>
<li><p>可以把班级放在学生表里面：<br>学生表：学生 id、学生姓名、班级 id<br>班级表：班级 id、班级名称</p>
</li>
<li><p>也可以单独建立关联表：<br>学生表：学生 id、学生姓名<br>关联表：学生 id、班级 id<br>班级表：班级 id、班级名称</p>
</li>
</ul>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>假设一个作者可以写多本数。</p>
<p>若 DBMS 支持数组，可以存两个 id 到一个字段：作者 id、姓名、书（书的 id 数组）</p>
<p>但一般推荐单独建立关系表：</p>
<p>作者表：id、姓名<br>关联表：作者 id、书 id<br>书表：id、书名</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>假设一个学生可以加入多个班级，一个班级也可以有多个学生。</p>
<p>仍然推荐建立关联表：</p>
<p>学生表：学生 id、学生姓名<br>关联表：学生 id、班级 id、有效期<br>班级表：班级 id、班级名称</p>
<h3 id="什么时候建立关联表"><a href="#什么时候建立关联表" class="headerlink" title="什么时候建立关联表"></a>什么时候建立关联表</h3><p>当关联自身存在属性时，比如上表的有效期。或者管理多对多这种比较复杂的关系的时候也推荐建立关联表。</p>
<h1 id="用-JOIN-将表连接起来"><a href="#用-JOIN-将表连接起来" class="headerlink" title="用 JOIN 将表连接起来"></a>用 JOIN 将表连接起来</h1><p>有时候我们需要拆表、建立关联表等，这时候怎样将数据连起来查询呢？使用 JOIN。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="JOIN"></p>
<h2 id="INNER-JOIN-JOIN"><a href="#INNER-JOIN-JOIN" class="headerlink" title="INNER JOIN (JOIN)"></a>INNER JOIN (JOIN)</h2><p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，但是只显示 columnA、columnB 两列中有交集的部分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA=table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-inner.html" target="_blank" rel="noopener">这里</a></p>
<h2 id="LEFT-JOIN-LEFT-OUTER-JOIN"><a href="#LEFT-JOIN-LEFT-OUTER-JOIN" class="headerlink" title="LEFT JOIN (LEFT OUTER JOIN)"></a>LEFT JOIN (LEFT OUTER JOIN)</h2><p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证左边的表（table1，或者说 columnA）数据显示完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA=table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-left.html" target="_blank" rel="noopener">这里</a></p>
<h2 id="RIGHT-JOIN-RIGHT-OUTER-JOIN"><a href="#RIGHT-JOIN-RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT JOIN (RIGHT OUTER JOIN)"></a>RIGHT JOIN (RIGHT OUTER JOIN)</h2><p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证右边的表（table2，或者说 columnB）数据显示完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA=table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-right.html" target="_blank" rel="noopener">这里</a></p>
<h2 id="FULL-JOIN-FULL-OUTER-JOIN"><a href="#FULL-JOIN-FULL-OUTER-JOIN" class="headerlink" title="FULL JOIN (FULL OUTER JOIN)"></a>FULL JOIN (FULL OUTER JOIN)</h2><blockquote>
<p>MySQL 中不支持 FULL OUTER JOIN</p>
</blockquote>
<p>借助两个表中含义相同的列（table 1 中的 columnA、table2 中的 columnB），将两个表关联起来，保证两边的数据都完整，不存在的记录设为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.columnA=table2.columnB;</span><br></pre></td></tr></table></figure>
<p>例子可以看<a href="https://www.runoob.com/sql/sql-join-full.html" target="_blank" rel="noopener">这里</a></p>
<h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><h2 id="缓存字段"><a href="#缓存字段" class="headerlink" title="缓存字段"></a>缓存字段</h2><p>一个例子：一个 blog 包含多个 comments，如何获取博客的评论数？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> comments <span class="keyword">WHERE</span> blog_id=<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>这样会比较慢，可以在 blog 表上加一个 comment_count 字段，每次添加 comment 就 +1，删除就 -1</p>
<h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 Transaction"></a>事务 Transaction</h2><p>在上述例子的解决办法中有个问题，用户的评论操作产生了两件事：1. comments 表新增记录；2. blog 表的 comment_count 字段 +1。</p>
<p>这样不能保证两边的数据同步，因为有可能其中一步失败了，这就需要用到事务。如果其中有一条语句失败了，则全部不执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">语句1; 2; 3;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>可以看<a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">这个教程</a></p>
<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>可以通过 <code>show engines</code> 查看 MySQL 支持的存储引擎。</p>
<ul>
<li>InnoDB，默认，一般认为是事务性数据库的首选</li>
<li>MyISAM，拥有较高的插入、查询速度，但不支持事务</li>
<li>Memory，内存中快速访问数据</li>
<li>Archive，只支持 insert 和 select</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure>
<p>可以看<a href="https://www.runoob.com/sql/sql-create-index.html" target="_blank" rel="noopener">这个教程</a></p>
<p>索引可以提高查询数据的效率，但更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。</p>
<p>因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>
]]></content>
      <categories>
        <category>全栈</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基本知识</title>
    <url>/hais-notebook/2021/03/14/DataBase-Docker/</url>
    <content><![CDATA[<p>数据库的基本知识以及用 Docker 来安装数据库。</p>
<a id="more"></a>
<h1 id="用-Docker-来安装数据库"><a href="#用-Docker-来安装数据库" class="headerlink" title="用 Docker 来安装数据库"></a>用 Docker 来安装数据库</h1><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><ul>
<li>进入 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub 官方网站</a> 注册并下载</li>
<li>确保 <code>docker --version</code> 返回版本号</li>
<li>在 Docker Engine 中设置国内镜像，<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html" target="_blank" rel="noopener">可以点这里查看教程</a><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://docker.mirrors.ustc.edu.cn"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Docker-安装-MySQL"><a href="#Docker-安装-MySQL" class="headerlink" title="Docker 安装 MySQL"></a>Docker 安装 MySQL</h2><ul>
<li>进入 Docker 上面 <a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">MySQL 的主页</a></li>
<li>运行命令创建容器：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="comment"># -d 表示守护进程形式，不会随意关掉</span></span><br><span class="line"><span class="comment"># -p 用来设置端口映射 本机端口号:虚拟机端口号</span></span><br><span class="line">docker run --name mysql-demo1 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:latest</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>常见的 docker 命令：</p>
<ul>
<li><code>docker run</code> 启动新容器</li>
<li><code>docker ps -a</code> 查看所有的容器（Containers）</li>
<li><code>docker kill &lt;id|name&gt;</code> 关闭对应的容器</li>
<li><code>docker restart &lt;id|name&gt;</code> 重启关闭的容器</li>
<li><code>docer rm &lt;id|name&gt;</code> 删除对应的容器</li>
<li><code>docker container prune</code> 删除无用的容器，以节省空间</li>
</ul>
<p>注意：用 docker 运行的容器，默认不会持久化，容器被删掉，数据也就没了</p>
<h2 id="Docker-连接-MySQL"><a href="#Docker-连接-MySQL" class="headerlink" title="Docker 连接 MySQL"></a>Docker 连接 MySQL</h2><ol>
<li>进入 Docker 容器，相当于一个 Linux 虚拟机：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-demo1 bash</span><br></pre></td></tr></table></figure></li>
<li>使用 MySQL 命令进入数据库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -u root：以 ROOT 用户进入</span></span><br><span class="line"><span class="comment"># -p 直接回车，然后输入密码</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li>
<li>使用 SQL 语句操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment"># 进入其中一个数据库</span></span><br><span class="line"><span class="keyword">use</span> &lt;数据库名称&gt;;</span><br><span class="line"><span class="comment"># 看有哪些表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment"># 查看表内容</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名称&gt;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="数据库的基本知识"><a href="#数据库的基本知识" class="headerlink" title="数据库的基本知识"></a>数据库的基本知识</h1><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><h3 id="数据库-Database"><a href="#数据库-Database" class="headerlink" title="数据库 Database"></a>数据库 Database</h3><blockquote>
<p>将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合称为数据库</p>
</blockquote>
<p>根据数据保存的格式不同，数据库一般被分为：</p>
<ul>
<li>关系型数据库</li>
<li>面向对象数据库、XML 数据库、键值存储系统（Redis）、层次数据库</li>
</ul>
<h3 id="数据库管理系统-DBMS"><a href="#数据库管理系统-DBMS" class="headerlink" title="数据库管理系统 DBMS"></a>数据库管理系统 DBMS</h3><blockquote>
<p>用来管理数据库的系统被称为数据库管理系统</p>
</blockquote>
<ul>
<li>比如 MySQL、PostgreSQL、SQL Server、DB2、Oracle</li>
</ul>
<p>DBMS 大概结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库（硬盘&#x2F;内存中存数据的地方）</span><br><span class="line">           ↑ 读&#x2F;写</span><br><span class="line">Server 服务端（数据提供者）</span><br><span class="line"> 请求的数据 ↓ ↑ SQL语句 </span><br><span class="line">Client 客户端（数据使用者）</span><br></pre></td></tr></table></figure>
<p>我们使用的 MySQL 命令，就是一个客户端，MySQL 背后其实还有一个 Server 在 24 小时不间断运行着</p>
<h1 id="用-Node-js-连接数据库"><a href="#用-Node-js-连接数据库" class="headerlink" title="用 Node.js 连接数据库"></a>用 Node.js 连接数据库</h1><p>可以使用 <a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">mysqljs 库</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>)</span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">"localhost"</span>,</span><br><span class="line">  user: <span class="string">"root"</span>,</span><br><span class="line">  password: <span class="string">"123456"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.connect()</span><br><span class="line"></span><br><span class="line">connection.query(<span class="string">"CREATE DATABASE IF NOT EXISTS harvey DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"创建数据库"</span>, results)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.query(<span class="string">"USE harvey;"</span>)</span><br><span class="line"></span><br><span class="line">connection.query(<span class="string">`CREATE TABLE IF NOT EXISTS user(</span></span><br><span class="line"><span class="string">  name text,</span></span><br><span class="line"><span class="string">  age int</span></span><br><span class="line"><span class="string">);`</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"创建表"</span>, results)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connection.end()</span><br></pre></td></tr></table></figure>
<h1 id="常见的-SQL-命令"><a href="#常见的-SQL-命令" class="headerlink" title="常见的 SQL 命令"></a>常见的 SQL 命令</h1><h2 id="操作-database-table"><a href="#操作-database-table" class="headerlink" title="操作 database/table"></a>操作 database/table</h2><ul>
<li>增：<code>CREATE DATABASE IF NOT EXISTS harvey DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;</code> （MySQL 才需要使用 utf8mb4，并且在后面写 COLLATE）</li>
<li>删：<code>DROP DATABSE;</code></li>
</ul>
<h2 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h2><ul>
<li>增：<code>INSERT INTO user (name, age) VALUES (&#39;harvey&#39;, 20);</code></li>
<li>删：<code>DELETE FROM user WHERE name=&#39;harvey&#39;;</code></li>
<li>改：<code>UPDATE user SET age=24 WHERE name=&#39;harvey&#39;;</code></li>
<li>查：<code>SELECT * FROM user LIMIT 10;</code></li>
</ul>
<h1 id="MySQL-的数据类型"><a href="#MySQL-的数据类型" class="headerlink" title="MySQL 的数据类型"></a>MySQL 的数据类型</h1><p>五大类：数字、字符串、时间和日期、JSON（5.7.8 以上）、其他特殊类型</p>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><ul>
<li><p>bit、tinyint、bool/boolean、smallint、mediumint、int、bigint、decimal、float、double</p>
</li>
<li><p>serial：一个自增长的非负大整数（BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE）</p>
</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/numeric-type-syntax.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li>char(100)、varchar(100)、binary(1024)、varbinary(1024)、blob、text、enum(‘v1’,’v2’)、set(‘v1’,’v2’)</li>
</ul>
<p>varchar 长度可变，可以节省空间</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/string-type-syntax.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><ul>
<li>date、time、datetime、timestamp、year</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-type-syntax.html" target="_blank" rel="noopener">官方文档</a></p>
<p>一般传给前端需要转换为 ISO 8601 格式</p>
<h1 id="Sequelize-js"><a href="#Sequelize-js" class="headerlink" title="Sequelize.js"></a>Sequelize.js</h1>]]></content>
      <categories>
        <category>全栈</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译：RxJS 中的错误处理</title>
    <url>/hais-notebook/2021/03/03/Tools-RxJS-ErrorHandling/</url>
    <content><![CDATA[<p>本文是 <a href="https://blog.angular-university.io/rxjs-error-handling/" target="_blank" rel="noopener">RxJS Error Handling</a> 的翻译。<br>主要介绍了 catchError、throwError、Finalize、retryWhen、delayWhen 等操作符，以及捕获并替代策略、捕获并重抛策略、重试策略等错误处理方法。</p>
<a id="more"></a>
<h1 id="Observable-中的约定与错误处理"><a href="#Observable-中的约定与错误处理" class="headerlink" title="Observable 中的约定与错误处理"></a>Observable 中的约定与错误处理</h1><p>为了理解 RxJS 中的错误处理，我们需要先知道尽管数据流可以不发送值，也可以发送多个值，但 <strong>一个数据流（stream）只能输出一次错误</strong>。我们做出如此的约定，因为在实践中我们所观察（observe）的所有的流都是这样工作的，比如可能发生错误的网络请求等。</p>
<p>一个流可以顺利完成（complete），这意味着：</p>
<ul>
<li>一个流结束了他的生命周期，在此期间没有发生任何错误</li>
<li>结束之后，这个流将不会再发出别的值</li>
</ul>
<p>一个流也可以报错（error out）：</p>
<ul>
<li>流带着一个错误结束了他的生命周期</li>
<li>当错误被抛出之后，这个流将不会再发出别的值</li>
</ul>
<p>注意 <strong>完成</strong> 和 <strong>报错</strong> 是互斥的：</p>
<ul>
<li>当流完成之后，他不能再报错</li>
<li>当流报错之后，他不能再完成</li>
</ul>
<p>同样需要注意流没有义务去“完成”或者“报错”，这两种可能性均是可选的，但是他们中只有一种情况会出现（是不是有点像薛定谔的猫，你永远不知道一个异步请求会成功还是报错(笑)）。</p>
<p>这意味着，根据 Observable 的约定，当某个流报错之后，我们就不能再使用它了。现在，你一定在考虑一个问题——那么如何来让他从错误中恢复过来呢？</p>
<h1 id="RxJS-中的-subscribe-方法与-error-回调"><a href="#RxJS-中的-subscribe-方法与-error-回调" class="headerlink" title="RxJS 中的 subscribe 方法与 error 回调"></a>RxJS 中的 subscribe 方法与 error 回调</h1><p>现在，我们首先来创建一个流并订阅（subscribe）他。记住 subscribe 方法接受 3 个可选的参数：</p>
<ul>
<li>一个处理成功的函数，每当流发送一个值时就会调用这个函数</li>
<li>一个处理错误的函数，只有当错误发生的时候才会调用，这个函数将会接受错误（error）本身作为参数</li>
<li>一个处理完成的函数，只有当流完成的时候才会调用</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'home'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./home.component.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomeComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">    http$.subscribe(</span><br><span class="line">      res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">      err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">      () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完成行为的举例"><a href="#完成行为的举例" class="headerlink" title="完成行为的举例"></a>完成行为的举例</h2><p>当这个流没有报错，你可以在控制台看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP response &#123; payload: Array(9) &#125;</span><br><span class="line">HTTP HTTP request completed.</span><br></pre></td></tr></table></figure>
<p>这个 HTTP 流只发送了一个值，随即结束，这意味着他没有发生错误。</p>
<p>但如果他抛出一个错误会怎么样呢？在这种情况下，我们可以在控制台中看到这样的东西：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-1.png" alt=""></p>
<p>此时流并没有发出任何值，并且立即报错。在报错之后，他没有执行完成回调。</p>
<h2 id="subscribe-方法中的-error-回调函数的局限性"><a href="#subscribe-方法中的-error-回调函数的局限性" class="headerlink" title="subscribe 方法中的 error 回调函数的局限性"></a>subscribe 方法中的 error 回调函数的局限性</h2><p>有时候给 subscribe 传递 error 回调已经满足了我们处理错误的需求，但这种错误处理的方法是有局限性的。比如我们不能从错误信息中恢复过来，也不能发送另一个备用的值（fallback value）来替代我们原先希望从后端获取的值。</p>
<h1 id="catchError-操作符"><a href="#catchError-操作符" class="headerlink" title="catchError 操作符"></a>catchError 操作符</h1><p>在同步编程中，我们可以使用 <code>try</code> 语句来包裹代码，用 <code>catch</code> 来获取并处理可能发生的错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  <span class="keyword">const</span> httpResponse = getHttpResponseSync(<span class="string">'/api/courses'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个机制非常强大，这样我们就可以在一个地方处理 <code>try/catch</code> 代码块中发生的任何错误了。</p>
<p>但问题在于，Javascript 中很多操作都是异步的，HTTP 请求就是其中的一个。</p>
<p>RxJS 则通过 <code>catchError</code> 操作符提供了一些类似的功能。</p>
<h2 id="catchError-是如何工作的？"><a href="#catchError-是如何工作的？" class="headerlink" title="catchError 是如何工作的？"></a>catchError 是如何工作的？</h2><p>与其他的 RxJS 运算符一样，<code>catchError</code> 只是一个输入 Observable，然后输出 Observable 的函数。</p>
<p>每次调用 <code>catchError</code> 的时候，需要传给他一个错误处理函数（error handling function）。</p>
<p><code>catchError</code> 操作符将可能报错的 Observable 作为输入，然后开始在他输出的 Observable 中发出输入的 Observable 的值。</p>
<p>如果没有错误发生，他输出的 Observable 跟输入的 Observable 将以同样的方式工作。</p>
<h2 id="当错误发生时会怎样？"><a href="#当错误发生时会怎样？" class="headerlink" title="当错误发生时会怎样？"></a>当错误发生时会怎样？</h2><p>然而，当错误发生时，<code>catchError</code> 逻辑开始生效。<code>catchError</code> 操作符将会拿到这个错误，并将其传递给错误处理函数。</p>
<p>这个函数需要返回一个 Observable，他返回的 Observable 将会代替出错的流。</p>
<p>显然根据 Observable 约定，我们不能在使用已经出错的输入 <code>catchError</code> 的那个流。</p>
<p>错误处理函数返回的替代的 Observable 将会随即被订阅（subscribe）并且它发出的值将会代替已经报错的输入的 Observable。</p>
<h1 id="捕获并替代策略（The-Catch-and-Replace-Strategy）"><a href="#捕获并替代策略（The-Catch-and-Replace-Strategy）" class="headerlink" title="捕获并替代策略（The Catch and Replace Strategy）"></a>捕获并替代策略（The Catch and Replace Strategy）</h1><p>来看一个 <code>catchError</code> 用来提供替代的 Observable 并发出备用值的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们可以将「捕获并替代策略」分解如下：</p>
<ul>
<li>传递给 <code>catchError</code> 操作符一个错误处理函数</li>
<li>这个错误处理函数并不会立即调用，通常也不会调用</li>
<li>只有输入 <code>catchError</code> 的 Observable 发生错误时，才会调用错误处理函数</li>
<li>如果输入的流发生错误，错误处理函数将会返回一个用 <code>of([])</code> 构造的 Observable</li>
<li>这个 <code>of()</code> 函数只会返回一个值（<code>[]</code>），然后完成</li>
<li>错误处理函数返回的恢复 Observable（<code>of([])</code>）将会被 <code>catchError</code> 操作符订阅（subscribe）</li>
<li><code>catchError</code> 将会把恢复 Observable 的值作为替代值发出</li>
</ul>
<p>最终，<code>http$</code> Observable 将不会报错，我们可以在控制台看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP response []</span><br><span class="line">HTTP request completed.</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>subscribe()</code> 中的错误处理回调不再被调用，而是发生了下面的操作：</p>
<ul>
<li>一个空数组 <code>[]</code> 被发出</li>
<li><code>http$</code> Observable 随即结束</li>
</ul>
<p>尽管最初的 <code>https$</code> 确实报错了，但替代的 Observable 为 <code>http$</code> 的订阅者（subscriber）提供了一个默认的备用值（<code>[]</code>）。</p>
<p>注意我们也可以在返回替代的 Observable 之前做一些其他的错误处理。</p>
<p>这就是「捕获并替代策略」，接下来我们看看如何使用 <code>catchError</code> 来重新抛出一个错误，而不是提供替代的值。</p>
<h1 id="捕获并重抛策略（The-Catch-and-Rethrow-Strategy）"><a href="#捕获并重抛策略（The-Catch-and-Rethrow-Strategy）" class="headerlink" title="捕获并重抛策略（The Catch and Rethrow Strategy）"></a>捕获并重抛策略（The Catch and Rethrow Strategy）</h1><p>注意上面我们通过 <code>catchError</code> 提供的替代 Observable 也可能会报错——就像其他任何 Observable 一样。</p>
<p>此时，错误将会被广播给 <code>catchError</code> 输出的 Observable 的订阅者。</p>
<p>这种错误广播的行为给了我们一种在本地处理错误之后，重新抛出被 <code>catchError</code> 捕获的错误的机制。我们可以这样搞：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Handling error locally and rethrowing it...'</span>, err)</span><br><span class="line">      <span class="keyword">return</span> throwError(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="拆解捕获并重抛策略"><a href="#拆解捕获并重抛策略" class="headerlink" title="拆解捕获并重抛策略"></a>拆解捕获并重抛策略</h2><p>来一步步拆解这个「捕获并重抛策略」：</p>
<ul>
<li>像之前一样，我们正在捕获一个错误，并且返回一个替代的 Observable</li>
<li>但这次，我们在 <code>catchError</code> 函数中对这个错误进行本地处理，而不是提供一个像 <code>[]</code> 这样的替代值</li>
<li>在这个案例中，我们只是简单地在控制台输出错误，但是我们也可以增加任何我们需要的错误处理逻辑，比如向用户展示错误信息等</li>
<li><code>throwError</code> 创建了一个不会发出任何值的 Observable，并且会立即报出与 <code>catchError</code> 捕获的错误一样的错</li>
<li>这意味着 <code>catchError</code> 输出的 Observable 也会报与输入的 Observable 一样的错</li>
<li>这意味着我们终于成功地将 <code>catchError</code> 输入的 Observable 的最初的报错 <strong>重新抛给</strong> 输出的 Observable</li>
</ul>
<p>我们可以在控制台得到：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-2.png" alt=""></p>
<h1 id="在-Observable-链条中使用多次-catchError"><a href="#在-Observable-链条中使用多次-catchError" class="headerlink" title="在 Observable 链条中使用多次 catchError"></a>在 Observable 链条中使用多次 catchError</h1><p>注意我们可以在 Observable 链条中的不同节点根据需要多次使用 catchError，他们可以使用不同的策略。</p>
<p>比如我们可以在 Observable 链条上游中捕获错误，处理并且重抛他，然后在下游捕获同样的错误（这次我们提供一个替代的值，不再重抛他）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="string">'payload'</span>]),</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Handling error locally and rethrowing it...'</span>, err)</span><br><span class="line">      <span class="keyword">return</span> throwError(err)</span><br><span class="line">    &#125;),</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'caught rethrown error, providing fallback value'</span>)</span><br><span class="line">      <span class="keyword">return</span> of([])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-3.png" alt=""></p>
<p>我们可以看到，错误事实上最开始被重抛了，但错误并没有到达 subscribe 的错误处理函数，而是发出了 <code>[]</code> 这个替代值。</p>
<h1 id="Finalize-操作符"><a href="#Finalize-操作符" class="headerlink" title="Finalize 操作符"></a>Finalize 操作符</h1><p>除了错误处理中的 <code>catch</code> 代码块之外，同步 Javascript 语法还提供了 <code>finally</code> 代码块来包裹一定会被执行的代码。</p>
<p><code>finally</code> 代码块在释放昂贵资源的时候特别有用，比如关闭网络请求或释放内存。</p>
<p>与 <code>catch</code> 代码块中的代码不同，<code>finally</code> 代码块中的的执行不受报错的影响。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 同步操作</span></span><br><span class="line">  <span class="keyword">const</span> httpResponse =  getHttpResponseSync(<span class="string">'/api/courses'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// 处理错误，只有当错误发生的时候才会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 不管什么情况下都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RxJS 也提供了像 <code>finally</code> 一样功能的操作符——<code>finalize</code> 操作符。</p>
<blockquote>
<p>由于是 <code>finally</code> 是保留字，因此不能使用。</p>
</blockquote>
<h2 id="Finalize-操作符的例子"><a href="#Finalize-操作符的例子" class="headerlink" title="Finalize 操作符的例子"></a>Finalize 操作符的例子</h2><p>就像 <code>catchError</code> 操作符一样，为了让不同的资源正确释放，我们可以在 Observable 链条中的不同位置添加多个 <code>finalize</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    map(<span class="function"><span class="params">res</span> =&gt;</span> res[<span class="string">'payload'</span>]),</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'caught mapping error and rethrowing'</span>, err)</span><br><span class="line">      <span class="keyword">return</span> throwError(err)</span><br><span class="line">    &#125;),</span><br><span class="line">    finalize(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'first finalize() block executed'</span>)),</span><br><span class="line">    catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'caught rethrown error, providing fallback value'</span>)</span><br><span class="line">      <span class="keyword">return</span> of([])</span><br><span class="line">    &#125;),</span><br><span class="line">    finalize(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'second finalize() block executed'</span>))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-4.png" alt=""></p>
<p>注意 <code>finalize</code> 代码块在 subscribe 成功回调和完成回调之后执行</p>
<h1 id="重试策略（The-Retry-Strategy）"><a href="#重试策略（The-Retry-Strategy）" class="headerlink" title="重试策略（The Retry Strategy）"></a>重试策略（The Retry Strategy）</h1><p>除了重抛错误与提供备用值以外，我们还可以重试已经报错的 Observable。</p>
<p>我们知道，一旦流报错，我们不能再恢复他，但我们可以重新从流的源头订阅一次，并创建一个新的流。</p>
<p>它是这样工作的：</p>
<ul>
<li>我们拿到一个输入的 Observable，然后订阅（subscribe）他，创建一个新的流</li>
<li>如果流没有报错，我们让他的结果在输出的时候展现</li>
<li>但如果流报错了，我们需要去重新订阅这个输入的 Observable，然后创建一个新的流</li>
</ul>
<h2 id="什么时候重试？"><a href="#什么时候重试？" class="headerlink" title="什么时候重试？"></a>什么时候重试？</h2><p>一个大问题是，我们什么时候重新订阅这个输入的 Observable，然后重新执行？</p>
<ul>
<li>马上重试？</li>
<li>等一小会儿，期待着这个问题被解决，然后再重试？</li>
<li>只重试限定的次数，然后报错？</li>
</ul>
<p>为了解决这些问题，我们需要一个辅助的 Observable，我们叫他「通知者」（Notifier Observable），他会决定什么时候重试。</p>
<p>作为整个「重试策略」的核心 <code>retryWhen</code> 将会使用这个「通知者」。</p>
<h1 id="RxJS-retryWhen-操作符的子弹图"><a href="#RxJS-retryWhen-操作符的子弹图" class="headerlink" title="RxJS retryWhen 操作符的子弹图"></a>RxJS retryWhen 操作符的子弹图</h1><p>为了理解 <code>retryWhen</code> Observable 的工作机制，我们可以看看他的子弹图：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-5.png" alt=""></p>
<p>注意被重试的 Observable 是第二条线的 Observable 1-2，而不是第一条线的 Observable。</p>
<p>第一条线的发出 r-r 值的 Observable 是「通知者」，他会决定什么时候重试。</p>
<h2 id="拆解-retryWhen-是如何工作的"><a href="#拆解-retryWhen-是如何工作的" class="headerlink" title="拆解 retryWhen 是如何工作的"></a>拆解 retryWhen 是如何工作的</h2><ul>
<li>Observable 1-2 被订阅，然后他的值被立即反射在 <code>retryWhen</code> 的输出 Observable 中</li>
<li>甚至在 Observable 1-2 结束之后，他仍然可以被重试</li>
<li>订阅者在 Observable 1-2 结束之后发出值 <code>r</code></li>
<li>订阅者发出的值可以是任何形式的（在这里就是 <code>r</code>）</li>
<li>重要的是 <code>r</code> 发出的时机，因为这就是 Observable 1-2 重试的时机</li>
<li>Observable 1-2 被 <code>retryWhen</code> 重新订阅，他的值又会被重新反射到 <code>retryWhen</code> 的输出 Observable 中</li>
<li>然后，订阅者最终还是结束了</li>
<li>在这个时候，正在进行中的 Observable 1-2 重试也被提早结束，意味着只发出了 1，而不会发出 2</li>
</ul>
<p>我们可以看到，<code>retryWhen</code> 只是在观察着发出值的时候重试输入的 Observable。</p>
<p>既然我们理解了 <code>retryWhen</code> 是如何工作的，我们现在来创建一个「通知者」</p>
<h1 id="创建一个通知者（Notification-Observable）"><a href="#创建一个通知者（Notification-Observable）" class="headerlink" title="创建一个通知者（Notification Observable）"></a>创建一个通知者（Notification Observable）</h1><p>我们需要在传递给 <code>retryWhen</code> 操作符的函数中直接创建一个通知者。这个函数将一个 Errors Observable（发出输入的 Observable 的错误的 Observable）作为参数。</p>
<p>然后通过订阅这个 Errors Observable，我们可以准确地知道什么时候发生了错误。我们现在来看看如何实施一个「立即重试策略」</p>
<h1 id="立即重试策略（Immediate-Retry-Strategy）"><a href="#立即重试策略（Immediate-Retry-Strategy）" class="headerlink" title="立即重试策略（Immediate Retry Strategy）"></a>立即重试策略（Immediate Retry Strategy）</h1><p>为了在错误发生之后立即重试，我们只需要返回这个 Errors Observable 即可。</p>
<p>在这个案例中，我们使用 <code>tap</code> 操作符来打 log，因此 Errors Observable 还是不变的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"HTTP request executed"</span>)),</span><br><span class="line">    map(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">Object</span>.values(res[<span class="string">'payload'</span>])),</span><br><span class="line">    shareReplay(),</span><br><span class="line">    retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors</span><br><span class="line">        .pipe(</span><br><span class="line">          tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'retrying...'</span>))</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们从 <code>retryWhen</code> 函数返回的 Observable 就是「通知者」（Notification Observable）。</p>
<p>他发出的值并不重要，重要的是只有他发出的时机，因为这就是重试的时机。</p>
<h2 id="立即重试策略的控制台输出内容"><a href="#立即重试策略的控制台输出内容" class="headerlink" title="立即重试策略的控制台输出内容"></a>立即重试策略的控制台输出内容</h2><p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-6.png" alt=""></p>
<p>我们可以看到，HTTP 请求最开始错误了，但是后来尝试了一次，并且第二次的请求成功了。</p>
<p>可以看看两次尝试之间的延迟：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-7.png" alt=""></p>
<h1 id="延迟重试策略（Delayed-Retry-Strategy）"><a href="#延迟重试策略（Delayed-Retry-Strategy）" class="headerlink" title="延迟重试策略（Delayed Retry Strategy）"></a>延迟重试策略（Delayed Retry Strategy）</h1><p>让我们来实施另一个错误恢复策略，比如在错误发生之后等待 2 秒再重试。</p>
<p>这个策略在一些从一些特定的错误（比如服务器拥塞导致的请求失败）上恢复的时候特别有效。</p>
<p>在某些错误间歇性发生的案例中，我们可以简单地在一小段延迟之后重试，然后第二次请求可能就没问题了。</p>
<h1 id="计时器（Timer-Observable）创建函数"><a href="#计时器（Timer-Observable）创建函数" class="headerlink" title="计时器（Timer Observable）创建函数"></a>计时器（Timer Observable）创建函数</h1><p>为了实施延迟重试策略，我们需要创建一个错误发生之后 2 秒再发出值的通知者。</p>
<p>接下来我们来尝试用 <code>timer</code> 来创建一个通知者，这个 <code>timer</code> 函数接受两个值：</p>
<ul>
<li>一个在第一个值发出之前的初始延迟</li>
<li>一个我们希望周期性发出值时的周期性延迟</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-8.png" alt=""></p>
<p>我们可以看到，第一个值 0 在 3 秒之后才发出，然后每隔 1 秒发出一个值。</p>
<p>注意第二个参数是可选的，比如在我们希望在只发出一个值 0 之后就结束。</p>
<p>接下来我们来看看如何如何结合 <code>retryWhen</code> 和 <code>delayWhen</code> 操作符。</p>
<h1 id="delayWhen-操作符"><a href="#delayWhen-操作符" class="headerlink" title="delayWhen 操作符"></a>delayWhen 操作符</h1><p>一件很重要的事情就是，定义通知者的函数只会被调用一次，因此我们只有一次机会来定义这个确定何时重试的通知者。</p>
<p>我们将要获取 Errors Observable，然后应用在 <code>delayWhen</code> 操作符上来定义通知者。</p>
<p>来在这张子弹图上想一想，源 Observable a-b-c 是 Errors Observable，会随着时间发出失败的 HTTP 错误：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-9.png" alt=""></p>
<h2 id="delayWhen-操作符的拆解"><a href="#delayWhen-操作符的拆解" class="headerlink" title="delayWhen 操作符的拆解"></a>delayWhen 操作符的拆解</h2><p>我们通过这张图来学习一下：</p>
<ul>
<li>输入的 Errors Observable 的每个值都会被延迟之后展示在输出 Observable 中</li>
<li>每个值的延迟可以不同，并且将会被用非常灵活的方式创建</li>
<li>为了确定延迟，我们将会每个输入的 Errors Observable 的值调用传递给 <code>delayWhen</code> 的函数（也叫作持续时间选择函数，duration selector function））</li>
<li>这个函数将会发出一个将会决定每个值发出之后的延迟</li>
<li>a-b-c 中的每一个值都有自己的持续时间选择器（duration selector Observable），他最终会发出一个值（可以是任何值），然后结束</li>
<li>当三个持续时间选择器中的每个发出值的时候，对应的输入值 a-b-c 就会在最后的输出中展示</li>
<li>注意值 <code>b</code> 在 <code>c</code> 之后出现，这是很正常的</li>
<li>因为 <code>b</code> 持续时间选择器在 <code>c</code> 持续时间选择器之后发出值</li>
</ul>
<h2 id="实施延迟重试策略"><a href="#实施延迟重试策略" class="headerlink" title="实施延迟重试策略"></a>实施延迟重试策略</h2><p>让我们现在来把这些都放到一起，看看我们怎样按顺序在 2 秒后重试每一个发生错误的 HTTP 请求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http$ = <span class="keyword">this</span>.http.get&lt;Course[]&gt;(<span class="string">'/api/courses'</span>)</span><br><span class="line">http$</span><br><span class="line">  .pipe(</span><br><span class="line">    tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"HTTP request executed"</span>)),</span><br><span class="line">    map(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">Object</span>.values(res[<span class="string">'payload'</span>])),</span><br><span class="line">    shareReplay(),</span><br><span class="line">    retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors</span><br><span class="line">        .pipe(</span><br><span class="line">          delayWhen(<span class="function"><span class="params">()</span> =&gt;</span> timer(<span class="number">2000</span>)),</span><br><span class="line">          tap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'retrying...'</span>)),</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP response'</span>, res),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP Error'</span>, err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'HTTP request completed.'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>来拆解一下：</p>
<ul>
<li>传给 <code>retryWhen</code> 的函数只会调用一次</li>
<li>我们在那个函数中返回一个 Observable，他在任何需要重试的时候就会发送值</li>
<li>每当出现一个错误，<code>delayWhen</code> 操作符就会通过调用 <code>timer</code> 函数来创建一个持续时间选择器（duration selector Observable）</li>
<li>这个持续时间选择器将会在 2 秒后发出 0，然后结束</li>
<li>每当这发生的时候，delayWhen Observable 就会知道输入的错误的延迟已经结束了</li>
<li>只有当延迟结束之后，错误才会在通知者的输出中出现</li>
<li>一旦通知者中的值发出，<code>retryWhen</code> 操作符就会执行重试</li>
</ul>
<h2 id="延迟策略的控制台输出内容"><a href="#延迟策略的控制台输出内容" class="headerlink" title="延迟策略的控制台输出内容"></a>延迟策略的控制台输出内容</h2><p>下面是某个 HTTP 请求，重试了 5 次，并且其中 4 次报错的情况：</p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-10.png" alt=""></p>
<p><img src="https://s3-us-west-1.amazonaws.com/angular-university/blog-images/rxjs-error-handling/rxjs-error-handling-11.png" alt=""></p>
<p>可以看到与预期一样，重试在错误发生 2 秒之后才会进行。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>RxJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 核心原理</title>
    <url>/hais-notebook/2021/03/03/Tools-Webpack-Core/</url>
    <content><![CDATA[<p>我们可以通过 Babel 提供的 Parser、Traverse、Generator 转换代码、分析依赖。<br>Webpack 的核心就是通过 Babel 将 ESModule 的语法转变为 CommonJS，使得浏览器支持，并将所有的文件打包成一个 js。</p>
<a id="more"></a>
<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><strong>Parse</strong>(<code>@babel/parser</code>): 把代码变成 AST</li>
<li><strong>Traverse</strong>(<code>@babel/traverse</code>)：遍历 AST 进行修改，或者遍历 AST 找到源代码的依赖</li>
<li><strong>Generate</strong>(<code>@babel/generator</code>)：把新的 AST 变成另外的代码</li>
</ol>
<p><code>@babel/core</code> 包含了前三者，<code>@babel/preset-env</code> 中有很多内置的规则</p>
<blockquote>
<p>为什么要用 AST？<br>因为显然用正则表达式是不太科学的，需要识别到每个单词的意思</p>
</blockquote>
<h2 id="示例：把-let-变成-var"><a href="#示例：把-let-变成-var" class="headerlink" title="示例：把 let 变成 var"></a>示例：把 let 变成 var</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"@babel/parser"</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"@babel/traverse"</span></span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"@babel/generator"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = "let"; let b = 2`</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code, &#123; sourceType: <span class="string">"module"</span> &#125;)</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 进入时执行的钩子</span></span><br><span class="line">  enter: <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">type</span>, kind &#125; = item.node</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">"VariableDeclaration"</span> &amp;&amp; kind === <span class="string">"let"</span>) &#123;</span><br><span class="line">      item.node.kind = <span class="string">"var"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = generate(ast, &#123;&#125;, code)</span><br><span class="line"><span class="built_in">console</span>.log(result.code)</span><br></pre></td></tr></table></figure>
<p>可使用命令执行上述 DEMO：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -r --inspect-brk ts-node/register [filename]</span><br></pre></td></tr></table></figure>
<h2 id="示例：把代码转变为-ES5"><a href="#示例：把代码转变为-ES5" class="headerlink" title="示例：把代码转变为 ES5"></a>示例：把代码转变为 ES5</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"@babel/parser"</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">"@babel/core"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = "let"; const b = 2`</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code, &#123; sourceType: <span class="string">"module"</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> result = babel.transformFromAstSync(ast, code, &#123;</span><br><span class="line">  presets: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="示例：依赖分析"><a href="#示例：依赖分析" class="headerlink" title="示例：依赖分析"></a>示例：依赖分析</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter: <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.node.type === <span class="string">"ImportDeclaration"</span>) &#123;</span><br><span class="line">      <span class="comment">// import 后面的路径，往往是一个相对路径</span></span><br><span class="line">      <span class="built_in">console</span>.log(item.node.source.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>可以用一个 hash 表来存放依赖关系</li>
<li>可以用递归实现嵌套依赖分析</li>
<li>可以记住以前分析过的依赖，如果发现分析过就直接 return，这样就能实现对循环依赖的静态分析（不执行代码，只进行字面理解）</li>
</ol>
<h1 id="Webpack-核心原理"><a href="#Webpack-核心原理" class="headerlink" title="Webpack 核心原理"></a>Webpack 核心原理</h1><h2 id="让浏览器支持-import-export"><a href="#让浏览器支持-import-export" class="headerlink" title="让浏览器支持 import / export"></a>让浏览器支持 import / export</h2><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">MDN 上的描述</a>，在浏览器中，import 语句只能在声明了 type=”module” 的 script 的标签中使用。并且 IE 是不支持这个特性的。</p>
<ul>
<li>兼容策略 1：把代码全部放在 <code>&lt;script type=&quot;module&quot;&gt;</code> 中，这样会导致 IE 不兼容，并且会导致文件请求过多，因为每个被依赖的文件都需要被单独发出请求</li>
<li>兼容策略 2：把关键字转译为普通的代码，并且把所有的文件打包成一个文件</li>
</ul>
<h2 id="babel-core-帮助我们转义-import-和-export"><a href="#babel-core-帮助我们转义-import-和-export" class="headerlink" title="@babel/core 帮助我们转义 import 和 export"></a>@babel/core 帮助我们转义 import 和 export</h2><p>babel 会帮助我们将 ESModule 的语法按照 CommonJS 的规则书写：import 关键字会变成 require 函数，export 关键字会变成 exports 对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">"@babel/core"</span></span><br><span class="line"><span class="keyword">const</span> es5Code = babel.transform(code, &#123;</span><br><span class="line">  presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  getB: <span class="function"><span class="params">()</span> =&gt;</span> b.value,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel 转译之后的 es5 代码</span></span><br><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;); <span class="comment">// 给当前模块添加 __esModule 属性，方便与 CommonJS 分开</span></span><br><span class="line">exports[<span class="string">"default"</span>] = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _b = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"./b.js"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实是为了给这个模块增加 default，因为 CommonJS 模块没有默认导出，这样是方便兼容，大部分 _interop 开头的代码都是为了兼容旧代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">"default"</span>: obj &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  getB: <span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _b[<span class="string">"default"</span>].value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _default = a;</span><br><span class="line">exports[<span class="string">"default"</span>] = _default;</span><br></pre></td></tr></table></figure>
<h2 id="将所有文件打包成一个文件"><a href="#将所有文件打包成一个文件" class="headerlink" title="将所有文件打包成一个文件"></a>将所有文件打包成一个文件</h2><blockquote>
<p>这个文件<strong>包含</strong>了所有的模块，并且能<strong>执行</strong>所有的模块</p>
</blockquote>
<p>思路：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最终文件应该长这个样子</span></span><br><span class="line"><span class="keyword">var</span> depRelation = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">"index.js"</span>, <span class="attr">deps</span>: [<span class="string">"a.js"</span>, <span class="string">"b.js"</span>], <span class="attr">code</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">"a.js"</span>, <span class="attr">deps</span>: [<span class="string">"c.js"</span>], <span class="attr">code</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">"b.js"</span>, <span class="attr">deps</span>: [<span class="string">"d.js"</span>], <span class="attr">code</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125; &#125;,</span><br><span class="line">] <span class="comment">// 这样一个 depRelation 数组存放了依赖关系，他的第一项就是入口文件</span></span><br><span class="line"><span class="comment">// 通过 execute 执行第一个文件，这样就会自动执行依赖中的其他文件</span></span><br><span class="line">excute(depRelation[<span class="number">0</span>].key)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> item = depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)</span><br><span class="line">  item.code() <span class="comment">// 我们要执行依赖中的代码，因此上面的 code 最好是一个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题一：如何收集依赖？"><a href="#问题一：如何收集依赖？" class="headerlink" title="问题一：如何收集依赖？"></a>问题一：如何收集依赖？</h3><p>这个问题在上面已经讨论过了，可以借助 AST 来分析依赖</p>
<h3 id="问题二：如何将文件中的-code-变为一个函数方便我们执行？"><a href="#问题二：如何将文件中的-code-变为一个函数方便我们执行？" class="headerlink" title="问题二：如何将文件中的 code 变为一个函数方便我们执行？"></a>问题二：如何将文件中的 code 变为一个函数方便我们执行？</h3><p>我们可以这样将文件里面的 code 变为函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">code = <span class="string">`</span></span><br><span class="line"><span class="string">  var b = require("./b.js")</span></span><br><span class="line"><span class="string">  exports.default = "a"</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// require、module、exports 是 commonJS 2 规范所定</span></span><br><span class="line">code2 = <span class="string">`function(require, module, exports) &#123;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"><span class="comment">// 这样做最后写到文件中之后就是函数了</span></span><br></pre></td></tr></table></figure>
<h3 id="问题三：execute-函数应该怎么写？"><a href="#问题三：execute-函数应该怎么写？" class="headerlink" title="问题三：execute 函数应该怎么写？"></a>问题三：execute 函数应该怎么写？</h3><p>下面是基本实现思路：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = &#123;&#125; <span class="comment">// modules 用于缓存所有模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (modules[key]) &#123; <span class="keyword">return</span> modules[key] &#125;</span><br><span class="line">  <span class="keyword">var</span> item = depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)</span><br><span class="line">  <span class="comment">// require 其实就是 excute，区别在于 require 后面接的是一个路径，我们需要把它转成 key</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">require</span> = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> execute(pathToKey(path))</span><br><span class="line">  &#125;</span><br><span class="line">  modules[key] = &#123; <span class="attr">__esModule</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: modules[key] &#125;</span><br><span class="line">  <span class="comment">// 为了这个 item.code 在执行完成之后把自己的导出挂在 module.exports 上</span></span><br><span class="line">  item.code(<span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">module</span>.exports)</span><br><span class="line">  <span class="keyword">return</span> modules[key] <span class="comment">// 其实就是 module.exports</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个简易的打包器"><a href="#一个简易的打包器" class="headerlink" title="一个简易的打包器"></a>一个简易的打包器</h2><p>copy 过来的代码，仅供自己学习使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"@babel/parser"</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"@babel/traverse"</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync, readFileSync &#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">'@babel/core'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">'project_1'</span>)</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">type</span> DepRelation = &#123; key: <span class="built_in">string</span>, deps: <span class="built_in">string</span>[], code: <span class="built_in">string</span> &#125;[]</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = [] <span class="comment">// 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">'index.js'</span>))</span><br><span class="line"></span><br><span class="line">writeFileSync(<span class="string">'dist_3.js'</span>, generateCode())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> code = <span class="string">''</span></span><br><span class="line">  code += <span class="string">'var depRelation = ['</span> + depRelation.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, deps, code &#125; = item</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      key: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span>, </span></span><br><span class="line"><span class="string">      deps: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(deps)&#125;</span>,</span></span><br><span class="line"><span class="string">      code: function(require, module, exports)&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">  &#125;).join(<span class="string">','</span>) + <span class="string">'];\n'</span></span><br><span class="line">  code += <span class="string">'var modules = &#123;&#125;;\n'</span></span><br><span class="line">  code += <span class="string">`execute(depRelation[0].key)\n`</span></span><br><span class="line">  code += <span class="string">`</span></span><br><span class="line"><span class="string">  function execute(key) &#123;</span></span><br><span class="line"><span class="string">    if (modules[key]) &#123; return modules[key] &#125;</span></span><br><span class="line"><span class="string">    var item = depRelation.find(i =&gt; i.key === key)</span></span><br><span class="line"><span class="string">    if (!item) &#123; throw new Error(\`\$&#123;item&#125; is not found\`) &#125;</span></span><br><span class="line"><span class="string">    var pathToKey = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      var dirname = key.substring(0, key.lastIndexOf('/') + 1)</span></span><br><span class="line"><span class="string">      var projectPath = (dirname + path).replace(\/\\.\\\/\/g, '').replace(\/\\\/\\\/\/, '/')</span></span><br><span class="line"><span class="string">      return projectPath</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var require = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      return execute(pathToKey(path))</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    modules[key] = &#123; __esModule: true &#125;</span></span><br><span class="line"><span class="string">    var module = &#123; exports: modules[key] &#125;</span></span><br><span class="line"><span class="string">    item.code(require, module, module.exports)</span></span><br><span class="line"><span class="string">    return modules[key]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath) <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="keyword">if</span> (depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)) &#123;</span><br><span class="line">    <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString()</span><br><span class="line">  <span class="keyword">const</span> &#123; code: es5Code &#125; = babel.transform(code, &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123; key, deps: [], code: es5Code &#125;</span><br><span class="line">  depRelation.push(item)</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; sourceType: <span class="string">'module'</span> &#125;)</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">'ImportDeclaration'</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(dirname(filepath), path.node.source.value)</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath)</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        item.deps.push(depProjectPath)</span><br><span class="line">        collectCodeAndDeps(depAbsolutePath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">'/'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Webpack-Loader-原理"><a href="#Webpack-Loader-原理" class="headerlink" title="Webpack Loader 原理"></a>Webpack Loader 原理</h1><h2 id="加载-CSS"><a href="#加载-CSS" class="headerlink" title="加载 CSS"></a>加载 CSS</h2><p>思路：</p>
<ol>
<li>我们的打包器只能加载 JS</li>
<li>我们想要加载 CSS</li>
<li>如果能把 CSS 变成 JS，就能加载 CSS 了</li>
</ol>
<p>在获取文件内容的时候，可以通过文件路径来判断是否是 css 文件，并稍作处理加载进 JS 中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code = readFileSync(filePath).toString()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filePath)) &#123;</span><br><span class="line">  code = <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment('style')</span></span><br><span class="line"><span class="string">      style.innerHTML = str</span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS-Loader"><a href="#CSS-Loader" class="headerlink" title="CSS Loader"></a>CSS Loader</h2><p>可以将上述代码变为 loader 的形式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment('style')</span></span><br><span class="line"><span class="string">      style.innerHTML = str</span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundler.ts</span></span><br><span class="line"><span class="keyword">let</span> code = readFileSync(filePath).toString()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filePath)) &#123;</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">'css-loader'</span>)(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尝试对-CSS-Loader-进行优化"><a href="#尝试对-CSS-Loader-进行优化" class="headerlink" title="尝试对 CSS Loader 进行优化"></a>尝试对 CSS Loader 进行优化</h2><blockquote class="blockquote-center"><p>单一职责原则：每个 Loader 只做一件事情</p>
</blockquote>
<p>我们的 Loader 做了两件事情，第一是将 CSS 变为 JS 字符串，第二是将 JS 字符串放到了 style 标签里面，现在要对其进行拆分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">    const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    export default str</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style-loader.ts</span></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">    if (document) &#123;</span></span><br><span class="line"><span class="string">      const style = document.createElment('style')</span></span><br><span class="line"><span class="string">      style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">      document.head.appendChild(style)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transform</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bunlder.ts</span></span><br><span class="line"><span class="keyword">let</span> code = readFileSync(filePath).toString()</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filePath)) &#123;</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">'css-loader'</span>)(code)</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">'style-loader'</span>)(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是有问题的。最终得到的文件将不是我们想要的文件。</p>
<p>Loader 有不同的类型，像 sass-loader、less-loader 是将代码从一种语言转译为另外一种，这样的 loader 可以直接连接起来。但 style-loader 是插入代码而不是转译，所以需要寻找恰当的插入时机和位置——比如 css-loader 拿到结果之后。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 的项目搭建</title>
    <url>/hais-notebook/2021/02/13/Rails-Demo/</url>
    <content><![CDATA[<p>Rails 的一个项目是如何搭建起来的。</p>
<a id="more"></a>
<h1 id="Gem-和-Bundle"><a href="#Gem-和-Bundle" class="headerlink" title="Gem 和 Bundle"></a>Gem 和 Bundle</h1><p>类似于 npm，gem 用于全局安装依赖，bundle 用于局部安装依赖。</p>
<p>如果 <code>gem install</code> 安装很慢，按照 <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">RubyChina</a> 的方法进行操作。</p>
<h1 id="创建-Rails-项目"><a href="#创建-Rails-项目" class="headerlink" title="创建 Rails 项目"></a>创建 Rails 项目</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install rails</span><br><span class="line">rails new [ProjectName] --database=postgresql --skip-action-mailbox --skip-action-text --skip-sprockets --skip-javascript --skip-turbolinks --skip-system-test --skip-test --api --skip-webpack-install</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>bin/rails server</code> 命令启动服务器，但是这时会报错，因为我们还没有数据库。</p>
<h1 id="创建-docker-容器"><a href="#创建-docker-容器" class="headerlink" title="创建 docker 容器"></a>创建 docker 容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v [容器路径]:/var/lib/postgresql/data -p 5001:5432 -e POSTGRES_USER=[用户名] -e POSTGRES_PASSWORD=[密码] -d postgres:[版本号 也可以不指定]</span><br></pre></td></tr></table></figure>
<p>如果速度太慢，需要使用镜像，按照 <a href="http://guide.daocloud.io/dcs/daocloud-9153151.html" target="_blank" rel="noopener">此教程</a> 进行配置。<br>可将镜像地址配置为中科大镜像地址：<a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p>
<h2 id="其他的-docker-命令"><a href="#其他的-docker-命令" class="headerlink" title="其他的 docker 命令"></a>其他的 docker 命令</h2><ul>
<li><code>docker ps -a</code> 查看所有的容器（Containers）</li>
<li><code>docker kill &lt;id|name&gt;</code> 关闭对应的容器</li>
<li><code>docker restart &lt;id|name&gt;</code> 重启关闭的容器</li>
<li><code>docer rm &lt;id|name&gt;</code> 删除对应的容器</li>
<li><code>docker container prune</code> 删除无用的容器，以节省空间</li>
</ul>
<h1 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h1><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>数据库需要在 <code>config/database.yml</code> 中进行配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span> <span class="string">&amp;default</span> <span class="comment"># 默认公共配置</span></span><br><span class="line">  <span class="attr">adapter:</span> <span class="string">postgresql</span></span><br><span class="line">  <span class="attr">encoding:</span> <span class="string">unicode</span></span><br><span class="line">  <span class="attr">pool:</span> &lt;%=<span class="ruby"> ENV.fetch(<span class="string">"RAILS_MAX_THREADS"</span>) &#123; <span class="number">5</span> &#125; </span>%&gt;</span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">username:</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">xxx_development</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">xxx_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">morney_rails_1_production</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">morney_rails_1</span></span><br><span class="line">  <span class="attr">password:</span> &lt;%=<span class="ruby"> ENV[<span class="string">'MORNEY_RAILS_1_DATABASE_PASSWORD'</span>] </span>%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rials db:create</span><br></pre></td></tr></table></figure>
<h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入虚拟机并运行 bash：</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名&gt; bash</span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">psql -U &lt;用户名&gt;</span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">\c &lt;数据库名称&gt;</span><br><span class="line"><span class="comment"># display tables</span></span><br><span class="line">\dt</span><br><span class="line"><span class="comment"># 查看某一个表的内容</span></span><br><span class="line">select * from &lt;表名称&gt; <span class="built_in">limit</span> 10;</span><br></pre></td></tr></table></figure>
<h1 id="Hello-Rails"><a href="#Hello-Rails" class="headerlink" title="Hello Rails"></a>Hello Rails</h1><h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><p>路由需要在 <code>config/routes.rb</code> 中进行配置。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  get <span class="string">'/hello'</span>, <span class="symbol">to:</span> <span class="string">'first#hello'</span> <span class="comment"># get 请求路径 /hello 的时候，会去找 FirstController 上的 hello 方法 </span></span><br><span class="line">  get <span class="string">'/hi'</span>, <span class="symbol">to:</span> <span class="string">'first#hi'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>bin/rails routes</code> 命令查看所有的路由。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="手动创建-controller"><a href="#手动创建-controller" class="headerlink" title="手动创建 controller"></a>手动创建 controller</h3><p>controller 需要在 <code>app/controllers</code> 中进行配置。<br>比如如上面 routes 中的配置所说，我们需要一个 <code>app/controllers/first_controller.rb</code> 文件，里面有一个 <code>FirstController</code> class，其中对应有 <code>hello</code> 和 <code>hi</code> 方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承自 ApplicationController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="通过命令创建-controller"><a href="#通过命令创建-controller" class="headerlink" title="通过命令创建 controller"></a>通过命令创建 controller</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller users</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">### 渲染 JSON</span></span><br><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">class FirstController &lt; ApplicationController</span><br><span class="line">  def hello</span><br><span class="line">    render json: &#123; name: <span class="string">'harvey'</span> &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h3 id="渲染-HTML"><a href="#渲染-HTML" class="headerlink" title="渲染 HTML"></a>渲染 HTML</h3><p>一般前后端分离的情况下，不是由 rails 来渲染 HTML，当然 rails 也可以用于渲染 HTML，这时我们需要建立一个新的文件 <code>app/views/first/hello.html</code>，然后在 FirstController 中这样写：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    render <span class="string">'first/hello'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>注意，如果使用 API 模式，默认是不支持渲染 html 的，我们需要在 <code>app/controllersapplication_controller.rb</code> 中进行引入：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="keyword">include</span> ActionView::Layouts</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Layout</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">erb 可以使用 `</span>&lt;% %&gt;<span class="string">` 来包裹语句：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>html</span><br><span class="line">&lt;% a = <span class="number">5</span> %&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> a &lt; <span class="number">10</span> %&gt;</span><br><span class="line">  a 小于 <span class="number">10</span></span><br><span class="line">&lt;% <span class="keyword">end</span> %&gt;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>&lt;%= %&gt;</code> 来表示需要渲染的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%=</span> @<span class="attr">dataInController</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外很多 html 有公共的部分，我们可以将其放在 <code>views/layoutsapplication.html.erb</code> 中，然后在其中空出类似插槽的东西：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">yield</span> %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> <span class="attr">content_for</span>? <span class="attr">:footer</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">yield</span> <span class="attr">:footer</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">end</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后略 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>普通内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">content_for</span> <span class="attr">:footer</span> <span class="attr">do</span> %&gt;</span></span><br><span class="line">  页脚内容</span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">end</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h1><h2 id="第一步：创建-Model-与数据表"><a href="#第一步：创建-Model-与数据表" class="headerlink" title="第一步：创建 Model 与数据表"></a>第一步：创建 Model 与数据表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g model User</span><br><span class="line"><span class="comment"># 也可以像下面这样写，他会在数据库迁移脚本中多两个字段</span></span><br><span class="line">bin/rails g model User email:string password_digest:string</span><br></pre></td></tr></table></figure>
<p>执行此命令后，会创建一个数据库迁移脚本，和一个新文件 <code>app/model/user.rb</code>。</p>
<p>数据库迁移脚本形式如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUsers</span> &lt; ActiveRecord::Migration[6.1]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span></span></span><br><span class="line">    create_table <span class="symbol">:users</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">      t.string <span class="symbol">:email</span></span><br><span class="line">      t.string <span class="symbol">:password_digest</span></span><br><span class="line"></span><br><span class="line">      t.timestamps</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后需要运行迁移脚本，创建 User 表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails db:migrate</span><br></pre></td></tr></table></figure>
<p>然后可以在 rubyMine 中查看数据库、User 表。</p>
<h2 id="第二步：配置路由"><a href="#第二步：配置路由" class="headerlink" title="第二步：配置路由"></a>第二步：配置路由</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  get <span class="string">'/users'</span>, <span class="symbol">to:</span> <span class="string">'users#index'</span></span><br><span class="line">  get <span class="string">'/users/:id'</span>, <span class="symbol">to:</span> <span class="string">'users#show'</span></span><br><span class="line">  post <span class="string">'/users'</span>, <span class="symbol">to:</span> <span class="string">'users#create'</span></span><br><span class="line">  delete <span class="string">'/users/:id'</span>, <span class="symbol">to:</span> <span class="string">'users#destroy'</span></span><br><span class="line">  patch <span class="string">'/users/:id'</span>, <span class="symbol">to:</span> <span class="string">'users#update'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>简单的增删改查我们不需要配置如上的路由，只需要下面这一句，他就会帮我们自动创建路由：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">resources <span class="symbol">:users</span></span><br></pre></td></tr></table></figure>
<h2 id="第三步：在-Rails-Console-中尝试进行增删改查"><a href="#第三步：在-Rails-Console-中尝试进行增删改查" class="headerlink" title="第三步：在 Rails Console 中尝试进行增删改查"></a>第三步：在 Rails Console 中尝试进行增删改查</h2><p>可以在 Rails Console 中先体验一下增删改查是如何进行的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails console</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u = User.new</span><br><span class="line">u.email = <span class="string">'1@qq.com'</span></span><br><span class="line">u.password_digest = <span class="string">'123456'</span></span><br><span class="line">u.save</span><br></pre></td></tr></table></figure>
<p>就会自动执行一个 SQL 语句，<strong>创建</strong> 一个新用户。</p>
<p>可以通过 <code>User.first</code> <code>User.second</code> 来 <strong>查看</strong> 已有的用户。</p>
<p>输入 <code>exit</code> 或者按 <code>Ctrl</code>+<code>D</code> 可以退出 Rails Console。</p>
<h2 id="第四步：存储密码"><a href="#第四步：存储密码" class="headerlink" title="第四步：存储密码"></a>第四步：存储密码</h2><p>我们平时的 User 表中不会存储密码的明文，而是存储一个 <code>password_digest</code> 字段，这可以通过 has_secure_password 来实现。</p>
<p>放开 <code>Gemfile</code> 中 <code>bcrypt</code> 的注释，通过 <code>bundle install</code> 安装依赖。</p>
<p>然后需要在 <code>app/modles/user.rb</code> 中加上 <code>has_secure_password</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_secure_password</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这时在 Rails Console 中执行以下代码试试：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u = User.new</span><br><span class="line">u.email = <span class="string">'1@qq.com'</span></span><br><span class="line">u.password = <span class="string">'123456'</span></span><br><span class="line">u.password_confirmation = <span class="string">'123456'</span></span><br><span class="line">u.save</span><br></pre></td></tr></table></figure>
<p>这样就会自动在表中 <code>password_digest</code> 中存一段密文。</p>
<p>然后可以通过这样来比对用户的密码是否正确：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">u.authenticate(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="第五步：创建与配置-Controller"><a href="#第五步：创建与配置-Controller" class="headerlink" title="第五步：创建与配置 Controller"></a>第五步：创建与配置 Controller</h2><p>我们可以通过如下命令创建 Controller，得到 <code>app/controllers/users_controller.rb</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller users</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">class UsersController &lt; ApplicationController</span><br><span class="line">  def create</span><br><span class="line">    user = User.new create_params</span><br><span class="line">    user.save</span><br><span class="line">    <span class="comment"># new + save 可以简写为 User.create</span></span><br><span class="line">    render_resource user</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def create_params</span><br><span class="line">    params.permit(:email, :password, :password_confirmation)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def render_resource(resource)</span><br><span class="line">    <span class="comment"># 也可以用 resource.valid?，不过据说会触发重新校验</span></span><br><span class="line">    <span class="keyword">if</span> resource.errors.empty?</span><br><span class="line">      render json: &#123; resource: resource &#125;, status: 200</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      render json: &#123; errors: resource.errors &#125;, status: 400</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="模拟请求进行调试"><a href="#模拟请求进行调试" class="headerlink" title="模拟请求进行调试"></a>模拟请求进行调试</h3><h4 id="使用-RubyMine-中的-HTTP-Client"><a href="#使用-RubyMine-中的-HTTP-Client" class="headerlink" title="使用 RubyMine 中的 HTTP Client"></a>使用 RubyMine 中的 HTTP Client</h4><p><code>Double Shift</code> - <code>HTTP Client</code>，然后可以通过 examples 看看如何使用。</p>
<h4 id="使用-Postman-测试"><a href="#使用-Postman-测试" class="headerlink" title="使用 Postman 测试"></a>使用 Postman 测试</h4><h3 id="第六步：在-Model-中进行数据校验"><a href="#第六步：在-Model-中进行数据校验" class="headerlink" title="第六步：在 Model 中进行数据校验"></a>第六步：在 Model 中进行数据校验</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_secure_password</span><br><span class="line"></span><br><span class="line">  validates_presence_of <span class="symbol">:email</span> <span class="comment"># email 必须存在</span></span><br><span class="line">  validates_presence_of <span class="symbol">:password</span> <span class="comment"># password 必须存在</span></span><br><span class="line">  validates_presence_of <span class="symbol">:password_confirmation</span>, <span class="symbol">on:</span> [<span class="symbol">:create</span>] <span class="comment"># 在创建时，确认输入密码必须存在</span></span><br><span class="line"></span><br><span class="line">  validates_format_of <span class="symbol">:email</span>, <span class="symbol">with:</span> /.+@.+<span class="regexp">/, if: :email # 在 email 存在时校验邮箱格式</span></span><br><span class="line"><span class="regexp">  validates_length_of :password, minimum: 6, on: [:create], if: :password # 在创建时，校验密码格式</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure>
<h3 id="第七步：错误信息汉化"><a href="#第七步：错误信息汉化" class="headerlink" title="第七步：错误信息汉化"></a>第七步：错误信息汉化</h3><p>首先需要在 <code>config/initializers/local.rb</code> 中添加：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">I18n.available_locales = [<span class="symbol">:en</span>, <span class="string">'zh-CN'</span>]</span><br><span class="line">I18n.default_locale = <span class="string">'zh-CN'</span></span><br></pre></td></tr></table></figure>
<p>然后按照提示在 <code>config/locales/zh-CN.yml</code> 中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zh-CN:</span></span><br><span class="line">  <span class="attr">activerecord:</span></span><br><span class="line">    <span class="attr">errors:</span></span><br><span class="line">      <span class="attr">models:</span></span><br><span class="line">        <span class="attr">user:</span></span><br><span class="line">          <span class="attr">attributes:</span></span><br><span class="line">            <span class="attr">password:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">密码不能为空</span></span><br><span class="line">              <span class="attr">too_short:</span> <span class="string">密码不能少于6个字符</span></span><br><span class="line">            <span class="attr">email:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">邮箱不能为空</span></span><br><span class="line">              <span class="attr">invalid:</span> <span class="string">邮箱必须含有</span> <span class="string">@</span> <span class="string">字符</span></span><br><span class="line">            <span class="attr">password_confirmation:</span></span><br><span class="line">              <span class="attr">blank:</span> <span class="string">请添加确认密码</span></span><br><span class="line">              <span class="attr">confirmation:</span> <span class="string">两次密码不匹配</span></span><br></pre></td></tr></table></figure>
<h2 id="第八步：发送邮件"><a href="#第八步：发送邮件" class="headerlink" title="第八步：发送邮件"></a>第八步：发送邮件</h2><p>可以通过 <code>mailer</code> 来发送邮件，点击 <a href="https://ruby-china.github.io/rails-guides/action_mailer_basics.html" target="_blank" rel="noopener">这里查看官方文档</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails generate mailer UserMailer</span><br></pre></td></tr></table></figure>
<p>这个命令会创建文件 <code>app/mailers/user_mailer</code>，详细请看 <a href="https://github.com/Hyuain/ruby-demo/commits/master" target="_blank" rel="noopener">相关 commit</a></p>
<p>通过 <code>dotenv-rails</code> 和 <code>.env</code> <code>.env.local</code> 文件来抽出环境变量，注意 <code>.env.local</code> 需要被加入 <code>.gitignore</code> 中，防止将密码提交到 Git 记录中。</p>
<h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><h2 id="第一步：配置路由"><a href="#第一步：配置路由" class="headerlink" title="第一步：配置路由"></a>第一步：配置路由</h2><p>按照惯例我们需要先配置路由：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  resources <span class="symbol">:sessions</span>, <span class="symbol">only:</span> %i[create destroy]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="第二步：创建-Model"><a href="#第二步：创建-Model" class="headerlink" title="第二步：创建 Model"></a>第二步：创建 Model</h2><p>Session 不需要写入数据库，故而不需要创建一个完整的 Model（继承于 ActiveRecord），而是一个轻量的 Model（继承于/include ActiveModel）。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:email</span>, <span class="symbol">:password</span></span><br><span class="line"></span><br><span class="line">  validates <span class="symbol">:email</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line">  validates <span class="symbol">:password</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  validates_format_of <span class="symbol">:email</span>, <span class="symbol">with:</span> /.+@.+<span class="regexp">/, if: :email</span></span><br><span class="line"><span class="regexp">  validates_length_of :password, minimum: 6, if: :password</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure>
<h3 id="attr-accessor"><a href="#attr-accessor" class="headerlink" title="attr_accessor"></a>attr_accessor</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:xxx</span></span><br></pre></td></tr></table></figure>
<ol>
<li>会声明一个对象的属性：<code>@xxx</code></li>
<li>会定义一个方法：<code>xxx</code>，用于获取 <code>@xxx</code> 的值</li>
<li>会定义一个方法：<code>xxx=</code>，用于给 <code>@xxx</code> 赋值</li>
</ol>
<h2 id="第三步：创建-Controller"><a href="#第三步：创建-Controller" class="headerlink" title="第三步：创建 Controller"></a>第三步：创建 Controller</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g controller sessions</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    s = Session.new create_params</span><br><span class="line">    s.validate</span><br><span class="line">    render_resource s</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">destroy</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_params</span></span></span><br><span class="line">    params.permit(<span class="symbol">:email</span>, <span class="symbol">:password</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="第四步：自定义校验，校验账号密码"><a href="#第四步：自定义校验，校验账号密码" class="headerlink" title="第四步：自定义校验，校验账号密码"></a>第四步：自定义校验，校验账号密码</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:email</span>, <span class="symbol">:password</span>, <span class="symbol">:email</span></span><br><span class="line"></span><br><span class="line">  validate <span class="symbol">:check_email</span>, <span class="symbol">if:</span> <span class="symbol">:email</span></span><br><span class="line">  validate <span class="symbol">:check_email_password_matched</span>, <span class="symbol">if:</span> Proc.new&#123; <span class="params">|s|</span> s.email.present? <span class="keyword">and</span> s.password.present? &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_email</span></span></span><br><span class="line">    @user <span class="params">||</span>= User.find_by <span class="symbol">email:</span> email</span><br><span class="line">    <span class="keyword">if</span> user.<span class="literal">nil</span>?</span><br><span class="line">      errors.add <span class="symbol">:email</span>, <span class="symbol">:unregistered</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_email_password_matched</span></span></span><br><span class="line">    @user <span class="params">||</span>= User.find_by <span class="symbol">email:</span> email</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">and</span> !user.authenticate(password)</span><br><span class="line">      errors.add <span class="symbol">:password</span>, <span class="symbol">:mismatch</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="第五步：使用中间件，记录-session（cookie）"><a href="#第五步：使用中间件，记录-session（cookie）" class="headerlink" title="第五步：使用中间件，记录 session（cookie）"></a>第五步：使用中间件，记录 session（cookie）</h2><p><code>config/application.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.session_store <span class="symbol">:cookie_store</span>, <span class="symbol">key:</span> <span class="string">'rails_demo_session_id'</span></span><br><span class="line">config.middleware.use ActionDispatch::Cookies</span><br><span class="line">config.middleware.use config.session_store, config.session_options</span><br></pre></td></tr></table></figure>
<p><code>session_controller.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    s = Session.new create_params</span><br><span class="line">    s.validate</span><br><span class="line">    render_resource s</span><br><span class="line">    session[<span class="symbol">:current_user_id</span>] = s.user.id <span class="comment"># 将 id 记录起来</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样前端在发送请求之后将会得到一个 cookie，RubyMine 可以在 <code>http-client.cookies</code> 中查看</p>
<h2 id="第六步：获取当前用户的信息"><a href="#第六步：获取当前用户的信息" class="headerlink" title="第六步：获取当前用户的信息"></a>第六步：获取当前用户的信息</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_user</span></span></span><br><span class="line">  <span class="comment"># 如果找不到，会返回 nil，ruby 这样会默认返回 current_user</span></span><br><span class="line">  @current_user <span class="params">||</span>= User.find_by_id session[<span class="symbol">:current_user_id</span>]</span><br><span class="line">  <span class="comment"># 如果找不到，会报错</span></span><br><span class="line">  <span class="comment"># User.find user_id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="第七步：注销登录"><a href="#第七步：注销登录" class="headerlink" title="第七步：注销登录"></a>第七步：注销登录</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">destroy</span></span></span><br><span class="line">    session[<span class="symbol">:current_user_id</span>] = <span class="literal">nil</span></span><br><span class="line">    head <span class="symbol">:ok</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>将 session 中对应 id 的值删掉即可。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>使用 RSpec 进行单元测试，详情查看 <a href="https://github.com/rspec/rspec-rails" target="_blank" rel="noopener">RSpec For Rails 文档</a>。</p>
<p>详细请看 <a href="https://github.com/Hyuain/ruby-demo/commits/master" target="_blank" rel="noopener">相关 commit</a></p>
<ul>
<li>Model 需要测试：validation 和 public 方法</li>
<li>Controller 需要测试：响应体和响应头（status、body、cookie），一般要测试正反两种情况（成功和不成功）</li>
</ul>
<h2 id="自动生成文档"><a href="#自动生成文档" class="headerlink" title="自动生成文档"></a>自动生成文档</h2><p>使用 <code>rspec_api_documentation</code> 可以直接通过单元测试生成 API 文档，详细内容可以 <a href="https://github.com/zipmark/rspec_api_documentation" target="_blank" rel="noopener">查看这里</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rake docs:generate</span><br><span class="line">start doc/api/index.html</span><br></pre></td></tr></table></figure>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ol>
<li>可以在 <code>rspec_helper.rb</code> 中定义一些常用的工具函数</li>
<li>可以使用 <code>rspec_api_documentation</code> 直接生成 API 文档</li>
</ol>
<h1 id="后端分页"><a href="#后端分页" class="headerlink" title="后端分页"></a>后端分页</h1><p>使用 <code>kaminari</code> gem</p>
<h1 id="使用中间表关联两个表"><a href="#使用中间表关联两个表" class="headerlink" title="使用中间表关联两个表"></a>使用中间表关联两个表</h1><p>比如我们需要建立 tagging 来关联 record 和 tag</p>
<h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a>创建 Model</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/rails g model tagging</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateTaggings</span> &lt; ActiveRecord::Migration[6.1]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span></span></span><br><span class="line">    create_table <span class="symbol">:taggings</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">      t.references <span class="symbol">:tag</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">      t.references <span class="symbol">:record</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      t.timestamps</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于我们加了 <code>reference</code>，可以看到在 <code>schema.rb</code> 中多了一些东西：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">create_table <span class="string">"taggings"</span>, <span class="symbol">force:</span> <span class="symbol">:cascade</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">  t.bigint <span class="string">"tag_id"</span>, <span class="symbol">null:</span> <span class="literal">false</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.bigint <span class="string">"record_id"</span>, <span class="symbol">null:</span> <span class="literal">false</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.datetime <span class="string">"created_at"</span>, <span class="symbol">precision:</span> <span class="number">6</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  t.datetime <span class="string">"updated_at"</span>, <span class="symbol">precision:</span> <span class="number">6</span>, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  t.index [<span class="string">"record_id"</span>], <span class="symbol">name:</span> <span class="string">"index_taggings_on_record_id"</span> <span class="comment"># 多了这一行</span></span><br><span class="line">  t.index [<span class="string">"tag_id"</span>], <span class="symbol">name:</span> <span class="string">"index_taggings_on_tag_id"</span> <span class="comment"># 多了这一行</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后需要调整 <code>model/tagging.rb</code> <code>model/record.rb</code> <code>model/tag.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tagging</span> &lt; ApplicationRecord</span></span><br><span class="line">  belongs_to <span class="symbol">:record</span></span><br><span class="line">  belongs_to <span class="symbol">:tag</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:taggings</span></span><br><span class="line">  has_many <span class="symbol">:records</span>, <span class="symbol">through:</span> <span class="symbol">:taggings</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:taggings</span></span><br><span class="line">  has_many <span class="symbol">:tags</span>, <span class="symbol">through:</span> <span class="symbol">:taggings</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="使用-Factory-Bot-加速测试"><a href="#使用-Factory-Bot-加速测试" class="headerlink" title="使用 Factory Bot 加速测试"></a>使用 Factory Bot 加速测试</h1><p>可以使用 <a href="https://github.com/thoughtbot/factory_bot" target="_blank" rel="noopener">factory-bot</a> 来帮助我们自动化一些流程，比如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spec/factories/user_factory.rb</span></span><br><span class="line">FactoryBot.define <span class="keyword">do</span></span><br><span class="line">  factory <span class="symbol">:user</span> <span class="keyword">do</span></span><br><span class="line">    email &#123; <span class="string">"test_email@qq.com"</span> &#125;</span><br><span class="line">    password &#123; <span class="string">"123456"</span> &#125;</span><br><span class="line">    password_confirmation &#123; <span class="string">"123456"</span> &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spec/requests/record.rb</span></span><br><span class="line">user = create(<span class="symbol">:user</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>Ruby</category>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 的对象与类</title>
    <url>/hais-notebook/2021/02/13/Ruby-Object/</url>
    <content><![CDATA[<p>Ruby 的简单的面向对象与类的相关知识。</p>
<a id="more"></a>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="Class-可以被重复定义"><a href="#Class-可以被重复定义" class="headerlink" title="Class 可以被重复定义"></a>Class 可以被重复定义</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_words</span></span></span><br><span class="line">    <span class="keyword">self</span>.gsub(<span class="regexp">/[^\da-zA-z\s]/</span>, <span class="string">''</span>) <span class="comment"># self. 可以省略</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在重复定义的过程中，相同名字的 Class 会合并。 此处相当于打开 String 类（open class String），并添加 to_words 方法。</p>
<h2 id="Class-里面可以写任何语句"><a href="#Class-里面可以写任何语句" class="headerlink" title="Class 里面可以写任何语句"></a>Class 里面可以写任何语句</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    puts <span class="string">'Hello'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 Class 里面写的语句都会被执行</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>```ruby<br>class MyClass</p>
<h1 id="初始化方法-initialize，在-new-的时候会自动调用"><a href="#初始化方法-initialize，在-new-的时候会自动调用" class="headerlink" title="初始化方法 initialize，在 new 的时候会自动调用"></a>初始化方法 initialize，在 new 的时候会自动调用</h1><p>  def initialize</p>
<pre><code># 相当于 this.@var
@var = 1
</code></pre><p>  end</p>
<p>  def my_method<br>    @var += 1</p>
<pre><code># 会自动 return @var
</code></pre><p>  end<br>end</p>
<p>obj = MyClass.new<br>p obj.class<br>p obj.my_method<br>p obj.instance_variables # 打印出所有变量</p>
<h1 id="obj-v-会报错，因为没有定义-方法"><a href="#obj-v-会报错，因为没有定义-方法" class="headerlink" title="obj[:@v] 会报错，因为没有定义 [] 方法"></a>obj[:@v] 会报错，因为没有定义 [] 方法</h1><p>p obj.methods # 打印出所有方法<br>p obj.methods.grep(/my/) # 打印出包含 my 的方法<br>p Class.instance_methods.grep(/my/)</p>
<h1 id="类实例化之后，实例变量存在对象上，实例方法存在类上"><a href="#类实例化之后，实例变量存在对象上，实例方法存在类上" class="headerlink" title="类实例化之后，实例变量存在对象上，实例方法存在类上"></a>类实例化之后，实例变量存在对象上，实例方法存在类上</h1><p>```<em>__</em></p>
]]></content>
      <categories>
        <category>全栈</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 基础</title>
    <url>/hais-notebook/2021/02/13/Ruby-Intro/</url>
    <content><![CDATA[<p>Ruby 的介绍与基础。</p>
<a id="more"></a>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="运行-Ruby-的方式"><a href="#运行-Ruby-的方式" class="headerlink" title="运行 Ruby 的方式"></a>运行 Ruby 的方式</h2><ul>
<li><code>irb</code> 可交互式命令行</li>
<li><code>ruby</code> + 文件路径</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>没有 <code>var</code> <code>const</code> <code>let</code> 等关键字</li>
<li>局部变量：小写字母开头或 <code>_</code> 开头</li>
<li>全局变量：<code>$</code> 开头</li>
<li>类变量：<code>@@</code> 开头</li>
<li>实例变量：<code>@</code> 开头</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>全大写，且默认为全局，比如 <code>RUBY_VERSION</code></li>
</ul>
<h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h2><ul>
<li><code>a,b,c = 1,2,3</code></li>
<li><code>a,b = [1,2]</code></li>
<li><code>a,b,*c = 1,2,3,4,5</code></li>
<li><code>a,*b,c = 1,2,3,4,5</code></li>
<li><code>a,b = b,a</code></li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>单引号，没有转义，写 <code>&#39;\n&#39;</code> 里面就是 <code>\n</code></li>
<li>双引号，有转义</li>
<li>多行字符串</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s = &lt;&lt;eos</span><br><span class="line">dfa123</span><br><span class="line">fad</span><br><span class="line">eos</span><br></pre></td></tr></table></figure>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><ul>
<li><code>print</code></li>
<li><code>puts</code> put string</li>
<li><code>p</code></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行注释 <code>#</code></li>
<li>多行注释</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure>
<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> p <span class="string">'大'</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> p <span class="string">'大'</span> <span class="keyword">else</span> p <span class="string">'小'</span> <span class="keyword">end</span></span><br><span class="line">p(<span class="keyword">if</span> a &gt; <span class="number">3</span> <span class="keyword">then</span> <span class="string">'大'</span> <span class="keyword">else</span> <span class="string">'小'</span> <span class="keyword">end</span>)</span><br><span class="line">p(<span class="keyword">if</span> a &gt; <span class="number">4</span></span><br><span class="line">  <span class="string">'大'</span></span><br><span class="line">  elseif a &gt; <span class="number">2</span></span><br><span class="line">  <span class="string">'中'</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="string">'小'</span></span><br><span class="line">  <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> error</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> <span class="keyword">not</span> success</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">unless</span> success</span><br></pre></td></tr></table></figure>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>类似 <code>switch-case</code> 单不需要 <code>break</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">case</span> a</span><br><span class="line"><span class="keyword">when</span> <span class="number">1</span></span><br><span class="line">  <span class="string">'1'</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">2</span></span><br><span class="line">  <span class="string">'2'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="string">'others'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="times"><a href="#times" class="headerlink" title="times"></a>times</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>.times <span class="keyword">do</span></span><br><span class="line">  p <span class="string">'哈哈'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.times &#123; p <span class="string">'哈哈'</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>times</code> 是函数，<code>do end</code> 和 <code>{}</code> 是代码块，作为 <code>times</code> 函数的最后的参数，一般多行用 <code>do end</code>，单行用 <code>{}</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>.times <span class="keyword">do</span> <span class="params">|i|</span> p <span class="string">"<span class="subst">#&#123;i&#125;</span> time"</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>|i|</code> 相当于给你的参数，表示第几次</p>
<h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each <span class="keyword">do</span> <span class="params">|item|</span> p item <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">7</span>).each <span class="keyword">do</span> <span class="params">|n|</span> p n <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">7</span> <span class="keyword">do</span> p i <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="while-until"><a href="#while-until" class="headerlink" title="while/until"></a>while/until</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> &lt; <span class="number">3</span></span><br><span class="line">  p i</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> j &gt;= <span class="number">3</span></span><br><span class="line">  p j</span><br><span class="line">  j += <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p>一直循环</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">loop</span><br><span class="line">  p <span class="string">'ruby'</span></span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">10</span> <span class="keyword">then</span> <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h2><p><code>break</code> 和 <code>next</code> 对应 <code>break</code> 和 <code>continue</code></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ruby 中只有对象，可以用 <code>.class</code> 查看类</p>
<ul>
<li><code>Integer</code> <code>Numeric</code> 整数</li>
<li><code>Float</code> 浮点数</li>
<li><code>String</code> 字符串</li>
<li><code>Array</code> 数组</li>
<li><code>Regexp</code> 正则</li>
<li><code>Time</code> 时间</li>
<li><code>File</code> 文件</li>
<li><code>Symbol</code> 符号</li>
<li><code>Exception</code> 异常</li>
<li><code>Hash</code> 散列</li>
</ul>
<p>每个对象都有唯一的 <code>object_id</code> 属性</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p><code>arr.methods</code> 可以看到有什么 api</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me = &#123; <span class="symbol">name:</span> <span class="string">'Harvey'</span>, <span class="symbol">age:</span> <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>name</code> 和 <code>age</code> 不是字符串，是 symbol，相当于</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me = &#123; <span class="symbol">:name</span> =&gt; <span class="string">'Harvey'</span>, <span class="symbol">:age</span> =&gt; <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>最初的写法相当于上面写法的在 ruby 2 以后的语法糖</p>
<p>symbol 相当于轻量的字符串，功能更少，可以通过 <code>.to_s</code> 得到字符串，通过 <code>.to_sym</code> 得到 symbol</p>
<h3 id="散列的遍历"><a href="#散列的遍历" class="headerlink" title="散列的遍历"></a>散列的遍历</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">me.each <span class="keyword">do</span> <span class="params">|key, value|</span> p key, value <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="与-JS-对象的区别"><a href="#与-JS-对象的区别" class="headerlink" title="与 JS 对象的区别"></a>与 JS 对象的区别</h3><ul>
<li>不能用 <code>me.name</code> 拿到属性，要用 <code>me[:name]</code><ul>
<li><code>&#39;name&#39;</code> 和 <code>:name</code> 是不一样的</li>
</ul>
</li>
<li>要给对象声明一个属性为函数，比较麻烦</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span></span></span><br><span class="line">  p <span class="string">'hi'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样写是不行的，他等价于 me[:say_hi] = say_hi()</span></span><br><span class="line">me[<span class="symbol">:say_hi</span>] = say_hi</span><br><span class="line"><span class="comment"># 要用 lambda 表达式</span></span><br><span class="line">me[<span class="symbol">:say_hi</span>] = lambda&#123; p <span class="string">'hi'</span> &#125;</span><br><span class="line">me[<span class="symbol">:say_hi</span>].call</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>长列表优化：小程序虚拟列表</title>
    <url>/hais-notebook/2020/05/13/SourceCode-Work-VirtualList/</url>
    <content><![CDATA[<p>借助小程序的 createIntersectionObserver 来实现虚拟列表。</p>
<a id="more"></a>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot;&gt;</span><br><span class="line">    &lt;!-- 通过 overRenderScreenCount 控制当前实际渲染在页面中的项数 --&gt;</span><br><span class="line">    &lt;virtual-list-item overRenderScreenCount&#x3D;&quot;&#123;&#123;2&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;view slot&#x3D;&quot;skeleton&quot;&gt;</span><br><span class="line">            ...skeleton template</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;virtual-list-item&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>微信小程序提供了 <code>createIntersectionObserver</code> API，这个 API 可以监听元素的相交情况。利用此 API，我们可以知道元素何时进入（需要被渲染出来的）可视区域，何时退出可视区域，从而控制其是否渲染。<br>此外，还需要记录每个元素的高度，并在元素不被渲染出来的时候，提供一个 minHeight，防止高度塌陷。</p>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 当元素没有实际渲染出来的时候，需要提供最小高度，防止高度塌陷 --&gt;</span><br><span class="line">&lt;view class&#x3D;&quot;.virtual-item&quot; style&#x3D;&quot;minHeight: &#123;&#123;isShow ? 0 : virtualHeight&#125;&#125;px&quot;&gt;</span><br><span class="line">    &lt;block wx:if&#x3D;&quot;&#123;&#123;isShow&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;block&gt;</span><br><span class="line">    &lt;block wx:else&gt;</span><br><span class="line">        &lt;slot name&#x3D;&quot;skeleton&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;block&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersectionObserver</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ready = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> margin = props.overRenderScreenCount * windowHeight</span><br><span class="line">  intersectionObserver = wx.createIntersectionObserver(&#123; initialRatio: <span class="number">0</span> &#125;)</span><br><span class="line">    .relativeToViewPort(&#123; top: margin, bottom: margin &#125;)</span><br><span class="line">    .observe(<span class="string">".virtual-item"</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      data.isShow = res.intersectionRatio &gt; <span class="number">0</span></span><br><span class="line">      data.virtualHeight = res.boundingClientRect.height</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> detached = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  intersectionObserver?.disonnect?.()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
        <category>工作</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>抄袭</tag>
        <tag>优化</tag>
        <tag>长列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular：Observables</title>
    <url>/hais-notebook/2020/03/25/Angular-Observables/</url>
    <content><![CDATA[<ul>
<li>提供了 publishers 和 subscribers 之间传递数据的方式</li>
<li>在 subscribe 的时候才会执行，而不是 define 的时候</li>
<li>可以传递多个任意类型的数据</li>
</ul>
<a id="more"></a>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Observable 实例，他定义了一个 subscriber 函数</span></span><br><span class="line"><span class="comment">// 这个函数在 subscribe() 的时候才会执行</span></span><br><span class="line"><span class="comment">// 这个函数定义了如何获取数据、生成 values 和 messages</span></span><br><span class="line"><span class="keyword">const</span> locations = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> watchId: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    watchId = navigator.geolocation.watchPosition(<span class="function">(<span class="params">position: Position</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.next(position);</span><br><span class="line">    &#125;, <span class="function">(<span class="params">error: PositionError</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.error(error);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observer.error(<span class="string">'Geolocation not available'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    unsubscribe() &#123;</span><br><span class="line">      navigator.geolocation.clearWatch(watchId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 subscribe() 方法之后</span></span><br><span class="line"><span class="comment">// 并传入一个定义了 handler（next、error、complete，其中 next 是必须的）的对象（observer）</span></span><br><span class="line"><span class="comment">// 返回一个 Subscription 对象，其中有一个 unsubscribe() 方法</span></span><br><span class="line"><span class="keyword">const</span> locationSubscription = locations.subscribe(&#123;</span><br><span class="line">  next(position) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Current Position: '</span>, position);</span><br><span class="line">  &#125;,</span><br><span class="line">  error(message) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error Getting Location: '</span>, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  locationSubscription.unsubscribe();</span><br><span class="line">&#125;, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>observable 可以表示任意数据类型，我们将 observable 发布（publish）出来的数据称为流（stream）</p>
<h2 id="custom-fromEvent-function"><a href="#custom-fromEvent-function" class="headerlink" title="custom fromEvent function"></a>custom fromEvent function</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">target, eventName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> observer.next(e);</span><br><span class="line">    target.addEventListener(eventName, handler);  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      target.removeEventListener(eventName, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ESC_KEY = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>) <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"><span class="keyword">const</span> subscription = fromEvent(nameInput, <span class="string">'keydown'</span>)</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === ESC_KEY) &#123;</span><br><span class="line">      nameInput.value = <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Multicasting"><a href="#Multicasting" class="headerlink" title="Multicasting"></a>Multicasting</h2><p>通常一个 observable 会为每一个调用了 subscribe() 的 observer 创建一次新的、独立的执行。当 observer 调用 subscribe() 的时候，observable 会连接上一个 event handler 并将值传递给 observer。</p>
<p>但是在有的时候，我们可能会想要每个 subscription 都拿到同样的值，这就叫 multicasting。下面是一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">arr, idx</span>) </span>&#123;</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      observer.next(arr[idx]);</span><br><span class="line">      <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        observer.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doSequence(arr, ++idx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  doSequence(seq, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    unsubscribe() &#123;</span><br><span class="line">      clearTimeout(timeoutId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</span><br><span class="line"></span><br><span class="line">sequence.subscribe(&#123;</span><br><span class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe'</span> + num); &#125;,</span><br><span class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 subscribe 两次，那么就会产生两个不同的 stream</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  sequence.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe'</span> + num); &#125;,</span><br><span class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(at 1 second): 1st subscribe: 1</span><br><span class="line">(at 1.5 seconds): 2nd subscribe: 1</span><br><span class="line">(at 2 seconds): 1st subscribe: 2</span><br><span class="line">(at 2.5 seconds): 2nd subscribe: 2</span><br><span class="line">(at 3 seconds): 1st subscribe: 3</span><br><span class="line">(at 3 seconds): 1st sequence finished</span><br><span class="line">(at 3.5 seconds): 2nd subscribe: 3</span><br><span class="line">(at 3.5 seconds): 2nd sequence finished</span><br></pre></td></tr></table></figure>
<p>将其转换为 multicasting observer：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">const</span> observers = [];</span><br><span class="line">  <span class="comment">// 只会产生一组值，被广播给每个 subscriber，因此只有一个 timerId</span></span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 subscriber function，当执行 subscribe() 的之后被调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    observers.push(observer);</span><br><span class="line">    <span class="comment">// 如果是第一个 subscription，开始这个 sequence</span></span><br><span class="line">    <span class="keyword">if</span> (observers.length === <span class="number">1</span>) &#123;</span><br><span class="line">      timeoutId = doSequence(&#123;</span><br><span class="line">        next(val) &#123;</span><br><span class="line">          <span class="comment">// 遍历所有的 observers 并通知所有的 subscriptions</span></span><br><span class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</span><br><span class="line">        &#125;,</span><br><span class="line">        complete() &#123;</span><br><span class="line">          observers.slice(<span class="number">0</span>).forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, seq, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      unsubscribe() &#123;</span><br><span class="line">        observers.splice(observers.indexOf(observer), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (observers.length === <span class="number">0</span>) &#123;</span><br><span class="line">          clearTimeout(timeoutId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">observer, arr, idx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(arr[idx]);</span><br><span class="line">    <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      observer.complete()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doSequence(observer, arr, ++idx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multicastSequence = <span class="keyword">new</span> Observable(multicastSequenceSubscriber());</span><br><span class="line"></span><br><span class="line">multicastSequence.subscribe(&#123;</span><br><span class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe: '</span> + num); &#125;,</span><br><span class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.5s 后再次 subscribe，不会发送第一个值</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  multicastSequence.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe: '</span> + num); &#125;,</span><br><span class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1500</span>);</span><br></pre></td></tr></table></figure>
<h1 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h1><p>RxJS ( Reactive Extensions for JavaScript ) 是一个响应式编程（一种考虑异步数据流和数据变化）库</p>
<h2 id="Create-Observable"><a href="#Create-Observable" class="headerlink" title="Create Observable"></a>Create Observable</h2><p>RxJS 提供多种函数，可以通过多种方法从事件、Promise、计时器等创建 observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">from</span>(fetch(<span class="string">'/api/endpoint'</span>));</span><br><span class="line">data.subscribe(&#123;</span><br><span class="line">  next(response) &#123; <span class="built_in">console</span>.log(response); &#125;,</span><br><span class="line">  error(err) &#123; <span class="built_in">console</span>.error(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>); &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// interval</span></span><br><span class="line"><span class="keyword">const</span> secondsCounter = interval(<span class="number">1000</span>);</span><br><span class="line">secondsCounter.subscribe(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`It's been <span class="subst">$&#123;n&#125;</span> seconds since subscribing!`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// fromEvent</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>);</span><br><span class="line"><span class="keyword">const</span> mouseMoves = fromEvent(el, <span class="string">'mousemove'</span>);</span><br><span class="line"><span class="keyword">const</span> subscription = mouseMoves.subscribe(<span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Coords: <span class="subst">$&#123;event.clientX&#125;</span> X <span class="subst">$&#123;event.clientY&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.clientX &lt; <span class="number">40</span> &amp;&amp; event.clientY &lt; <span class="number">40</span>) &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax</span></span><br><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</span><br><span class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>);</span><br><span class="line">apiData.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res.status, res.response));</span><br></pre></td></tr></table></figure>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>操作符执行操作，转换原来的 observable 值，并且返回一个包含转换后的值的 observable：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareValues = map(<span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val * val);</span><br><span class="line"><span class="keyword">const</span> squareNums = squareValues(nums);</span><br><span class="line"></span><br><span class="line">squareNums.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>pipe</code> 将操作符连接在一起，我们将一组被应用在 observable 上的操作符称为一个 recipe，需要调用 <code>subscribe()</code> 来生成这个 recipe 操作之后的结果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareOddVals = pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</span><br><span class="line">  map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareOdd = squareOddVals(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写：</span></span><br><span class="line"><span class="comment">// const squareOdd = nums.pipe(</span></span><br><span class="line"><span class="comment">//   filter((n: number) =&gt; n % 2 !== 0),</span></span><br><span class="line"><span class="comment">//   map(n =&gt; n * n)</span></span><br><span class="line"><span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">squareOdd.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>除了 subscription 中的 error handler 之外，还可以使用 <code>catchError</code> 操作符来处理错误，通过这个操作符可以提供一个备用的解决方案，并且不中断运行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</span><br><span class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.response) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.response;</span><br><span class="line">  &#125;),</span><br><span class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">apiData.subscribe(&#123;</span><br><span class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'data: '</span>, x); &#125;,</span><br><span class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'errors already caught and this will not run'</span>); &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>catchError</code> 可以让错误快速恢复，搭配 <code>retry</code> 还可以进行多次重试：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</span><br><span class="line">  retry(<span class="number">3</span>),</span><br><span class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.response) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.response;</span><br><span class="line">  &#125;),</span><br><span class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</span><br><span class="line">);</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Angular 中的 Observables</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 组件间传值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Angular 提供了 `</span>EventEmitter<span class="string">` API，通过 `</span><span class="meta">@Output</span>()<span class="string">` 就可以发布数据，`</span>EventEmitter<span class="string">` 就是基于 RxJS Subject 的。</span></span><br><span class="line"><span class="string">当 `</span>emit()<span class="string">` 的时候，他会将值传递给任意订阅了的 observer 的 `</span>next()<span class="string">` 方法。下面是一个例子：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>html</span><br><span class="line">&lt;!-- 在父组件监听自定义的 open 和 close 事件 --&gt;</span><br><span class="line">&lt;zippy (open)=<span class="string">"onOpen($event)"</span> (close)=<span class="string">"onClose($event)"</span>&gt;&lt;<span class="regexp">/zippy&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子组件 emit 这两个自定义事件，并传递值</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'zippy'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class="zippy"&gt;</span></span><br><span class="line"><span class="string">    &lt;div (click)="toggle()"&gt;Toggle&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div [hidden]="!visible"&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-content&gt;&lt;/ng-content&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZippyComponent &#123;</span><br><span class="line">  visible = <span class="literal">true</span>;</span><br><span class="line">  <span class="meta">@Output</span>() open = <span class="keyword">new</span> EventEmmiter&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line">  <span class="meta">@Output</span>() close = <span class="keyword">new</span> EventEmmiter&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line">  toggle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.visible = !<span class="keyword">this</span>.visible;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visible) &#123;</span><br><span class="line">      <span class="keyword">this</span>.open.emit(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.close.emit(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Angular 的 <code>HttpClient</code> API 也将会返回 observables，这有一些优点：</p>
<ul>
<li>Observables 不会修改从服务端获取的数据</li>
<li>可以通过 <code>unsubscribe()</code> 方法取消请求</li>
<li>可以配制请求</li>
</ul>
<h2 id="Async-pipe"><a href="#Async-pipe" class="headerlink" title="Async pipe"></a>Async pipe</h2><p>AsyncPipe 会 subscribe 一个 observable 或 promise，并且返回他发出的最新值</p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><code>Router.events</code> 也是以 observables 的形式提供事件的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router, NavigationStart &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; filter &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> RoutableComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  navStart: Observable&lt;NavigationStart&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.navStart = router.events.pipe(</span><br><span class="line">      filter(<span class="function"><span class="params">event</span> =&gt;</span> event <span class="keyword">instanceof</span> NavigationStart)</span><br><span class="line">    ) <span class="keyword">as</span> Observable&lt;NavigationStart&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.navStart.subscribe(<span class="function"><span class="params">event</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Navigation Started!'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区分-Observables-和其他技术"><a href="#区分-Observables-和其他技术" class="headerlink" title="区分 Observables 和其他技术"></a>区分 Observables 和其他技术</h1><h2 id="Observables-和-Promises"><a href="#Observables-和-Promises" class="headerlink" title="Observables 和 Promises"></a>Observables 和 Promises</h2><ul>
<li>Observables 是 declarative，当调用 <code>subscribe()</code> 的时候才会执行，而 Promise 在定义后会马上执行</li>
<li>Observables 提供多个值，而 Promises 值提供一个值</li>
<li>Observables 有链式调用和 subscribe()</li>
</ul>
<h3 id="创建与订阅"><a href="#创建与订阅" class="headerlink" title="创建与订阅"></a>创建与订阅</h3><ul>
<li>Observables 在 consumer subscribe 的时候才会执行，并且每个 subscription 都拥有自己独立的计算</li>
<li>Promises 在创建的时候执行，并且在创建的时候就已经开始计算结果了，每个 then 分享同样的结果，并且不能中断或者重启</li>
</ul>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><ul>
<li>Observables 将转换数据与最终获取（订阅）的过程分开了，只有订阅（subscription）才会让 subscriber 函数开始计算结果</li>
<li>Promises 并不会区分中间与最后的 then</li>
</ul>
<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><ul>
<li>Observables 可以在 subscriber 函数中返回 unsubscribe 方法，并可使用 <code>subscription.unsubscribe()</code> 进行调用</li>
<li>Promises 则无法取消</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>Observables 会将错误传递给 subscriber 的 error handler（在调用 <code>subscribe()</code> 的时候定义）</li>
<li>Promises 将错误传递给子 Promises</li>
</ul>
<h2 id="Observables-与-EventHandlers"><a href="#Observables-与-EventHandlers" class="headerlink" title="Observables 与 EventHandlers"></a>Observables 与 EventHandlers</h2><ul>
<li>都定义了通知处理方法（notification handlers），并且通过他们来随着时间变化的处理多个值</li>
<li>subscribe 一个 observables 相当于添加一个事件监听，不同在于 observables 可以在传递给 handler 之前对数据进行转换和处理</li>
<li>可以在比如 HTTP 请求之类的异步操作中使用 Observables 来处理事件，这样可以增加上下文的紧密度</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   都需要定义 handlers</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Clicked'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Events API</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建并开始监听</span></span><br><span class="line">buttonEl.addEventListener(<span class="string">'click'</span>, handler);</span><br><span class="line"><span class="comment">// 取消监听</span></span><br><span class="line">buttonEl.removeEventListener(<span class="string">'click'</span>, handler);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Observable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> clicks$ = fromEvent(buttonEl, <span class="string">'click'</span>);</span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="keyword">const</span> subscription = clicks$.subscribe(handler)</span><br><span class="line"><span class="comment">// 取消监听</span></span><br><span class="line">subscription.unsubscribe()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular：HttpClient</title>
    <url>/hais-notebook/2020/03/25/Angular-HttpClient/</url>
    <content><![CDATA[<p>HttpClient 是 Angular 用来与服务器通过 HTTP 交流的装置。</p>
<a id="more"></a>
<h1 id="引入-HttpClient"><a href="#引入-HttpClient" class="headerlink" title="引入 HttpClient"></a>引入 HttpClient</h1><p>可以在 <code>app.module.ts</code> 中引入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    HttpClientModule,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在需要使用的 service 中注入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpHeaders &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HeroService &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> http: HttpClient </span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">getHeroes(): Observable&lt;Hero[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;Hero[]&gt;(<span class="string">'/someurl'</span>) <span class="comment">// 他会返回一个 Observable 对象，里面具体的类型是 Hero[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular：Routing</title>
    <url>/hais-notebook/2020/03/25/Angular-Routing/</url>
    <content><![CDATA[<p>抄一下 Angular 的文档。</p>
<a id="more"></a>
<h1 id="AppRoutingModule"><a href="#AppRoutingModule" class="headerlink" title="AppRoutingModule"></a>AppRoutingModule</h1><p>在 Angular 中，我们通过一个分离的、顶级的模块来用于导航，通常我们将其命名为 <code>AppRoutingModule</code>，他通常在 <code>src/app</code> 文件夹的 <code>app-routing.module.ts</code> 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ng generate module app-routing --flat --module=app</span><br><span class="line"><span class="comment"># --flat 是他不会再在 src/app 中新建其他的文件夹</span></span><br><span class="line"><span class="comment"># --module=app 则使得其被写在 AppModule 的 imports 中</span></span><br></pre></td></tr></table></figure>
<p>通常我们需要将这个文件改造成这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroesComponent &#125; <span class="keyword">from</span> <span class="string">'./heroes/heroes.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DashboardComponent &#125; <span class="keyword">from</span> <span class="string">'./dashboard/dashboard.component'</span></span><br><span class="line"><span class="keyword">import</span> &#123; HeroDetailComponent &#125; <span class="keyword">from</span> <span class="string">'./hero-detail/hero-detail.component'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; path: <span class="string">''</span>, redirectTo: <span class="string">'/dashboard'</span>, pathMatch: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; path: <span class="string">'dashboard'</span>, component: DashboardComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'detail/:id'</span>, component: HeroDetailComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'heroes'</span>, component: HeroesComponent &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  <span class="comment">// 由于我们是在应用的 root level 定义路由，因此需要使用 forRoot</span></span><br><span class="line">  <span class="comment">// forRoot 方法提供了路由中需要的 service providers 和 directives</span></span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后需要在 html 模板中这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/dashboard"</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/heroes"</span>&gt;</span>Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>+this.route.snapshot.paramMap.get(&#39;id&#39;)</code> 这样的方法来从当前的地址中获取到 params</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular：Basic</title>
    <url>/hais-notebook/2020/03/24/Angular-Basic/</url>
    <content><![CDATA[<p>抄一下 Angular 的文档。</p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Angular 里面有自己的模块化系统，也就是 NgModule，他与 ES6 的模块系统不同，又互为补充。每个 Angular 应用中都有一个 <strong>根模块（AppModule）</strong>，并且位于 <code>app.module.ts</code> 中，可以通过引导这个模块来启动整个应用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;      <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports:      [ BrowserModule ], <span class="comment">// 这个模块中的 component templates 需要使用到的模块</span></span><br><span class="line">  providers:    [ Logger ],        <span class="comment">// 这个模块中全局 services 的 creators</span></span><br><span class="line">  declarations: [ AppComponent ],  <span class="comment">// 包括了这个 NgModule 下的 components、directives、pipes</span></span><br><span class="line">  exports:      [ AppComponent ],  <span class="comment">// 包括了可能在其他模块使用的东西</span></span><br><span class="line">  bootstrap:    [ AppComponent ]   <span class="comment">// 应用的主视图，也就是 root component，只有根模块才有这个属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>模块可以为其中的组件提供一个编译上下文环境（compilation context），根模块一定会有一个根视图</p>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>每个应用都至少一个组件，也就是 root component，Angular 的组件一般长这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123; <span class="comment">// @Component 装饰器指出接下来的这个类是个组件类，并且指定元数据，组件的元数据将告诉 Angular 怎样将模板与组件关联起来并构成视图</span></span><br><span class="line">  selector:    <span class="string">'app-hero-list'</span>, <span class="comment">// 一个 CSS 选择器，告诉 Angular 在哪个标签插入组件实例</span></span><br><span class="line">  templateUrl: <span class="string">'./hero-list.component.html'</span>, <span class="comment">// 该组件 HTML 模板文件相对于这个组件文件的地址</span></span><br><span class="line">  providers:  [ HeroService ] <span class="comment">// 当前组件所需的 services 的 providers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HeroListComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Angular 采用形如这样的模板语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hero List<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>Pick a hero from the list<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let hero of heroes"</span> (<span class="attr">click</span>)=<span class="string">"selectHero(hero)"</span>&gt;</span></span><br><span class="line">    &#123;&#123;hero.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">"selectedHero"</span> [<span class="attr">hero</span>]=<span class="string">"selectedHero"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>@Component</code> 元数据会告诉 Angular 模板从哪里找：</p>
<ul>
<li>可以直接将模板写在 <code>@Component</code> 元数据的 <code>template</code> 中</li>
<li>可以将模板文件的地址告诉 <code>@Component</code> 元数据的 <code>template</code> </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认将模板文件单独放置</span></span><br><span class="line">ng generate component hero</span><br><span class="line"><span class="comment"># -t 是 inlineTemplate=true 的简写</span></span><br><span class="line">ng generate component hero -t</span><br></pre></td></tr></table></figure>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>与 Vue 比较类似，Angular 这样几种数据绑定方式：</p>
<ul>
<li>从组件到 DOM <code></code> <code>[property]=&quot;value&quot;</code> <code>bind-property=&quot;value&quot;</code></li>
<li>从 DOM 到组件 <code>(event)=&quot;handler&quot;</code> <code>on-event=&quot;value&quot;</code></li>
<li>双向数据绑定 <code>[(ng-model)]=&quot;property&quot;</code> <code>bindon-target=&quot;expression&quot;</code></li>
</ul>
<p><img src="https://angular.cn/generated/images/guide/architecture/component-databinding.png" alt="Angular 的数据绑定1"></p>
<p>在父子组件中也是如此：</p>
<p><img src="https://angular.cn/generated/images/guide/architecture/parent-child-binding.png" alt="Angular 的数据绑定2"></p>
<p>其插值语法、表达式、<code>on</code>、<code>bind</code>、<code>bindon</code> 等于 Vue 类似</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>Angular 自带了一些管道，可以帮助我们将输入值转换为对应的输出值，<code>|</code> 被称为 <strong>管道操作符</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default format: output 'Jun 15, 2015'--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Today is &#123;&#123;today | date&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- fullDate format: output 'Monday, June 15, 2015'--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The date is &#123;&#123;today | date:'fullDate'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shortTime format: output '9:43 AM'--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The time is &#123;&#123;today | date:'shortTime'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>Angular 自带了一些指令，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 结构型指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let hero of heroes"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">"selectedHero"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 属性型指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"hero.name"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Service-and-Dependency-Injection"><a href="#Service-and-Dependency-Injection" class="headerlink" title="Service and Dependency Injection"></a>Service and Dependency Injection</h2><p>组件可以把诸如获取数据、验证用户输入、往控制台写日志等等委托给各种服务，可以在需要时将服务 <strong>注入</strong> 到组件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Logger &#123;</span><br><span class="line">  log(msg: <span class="built_in">any</span>)   &#123; <span class="built_in">console</span>.log(msg); &#125;</span><br><span class="line">  error(msg: <span class="built_in">any</span>) &#123; <span class="built_in">console</span>.error(msg); &#125;</span><br><span class="line">  warn(msg: <span class="built_in">any</span>)  &#123; <span class="built_in">console</span>.warn(msg); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HeroService &#123;</span><br><span class="line">  <span class="keyword">private</span> heroes: Hero[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> backend: BackendService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> logger: Logger</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  getHeroes() &#123;</span><br><span class="line">    <span class="keyword">this</span>.backend.getAll(Hero).then( <span class="function">(<span class="params">heroes: Hero[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.log(<span class="string">`Fetched <span class="subst">$&#123;heroes.length&#125;</span> heroes.`</span>);</span><br><span class="line">      <span class="keyword">this</span>.heroes.push(...heroes); <span class="comment">// fill cache</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heroes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript：进阶</title>
    <url>/hais-notebook/2020/03/21/TS-Advanced/</url>
    <content><![CDATA[<p>TypeScript 的高级类型以及其他的用法。</p>
<a id="more"></a>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型是将多个类型合并为一个类型，比较常见的是用在 JavaScript 的混入模式（从两个对象中刚创建一个新对象）中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IAnyObject &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">IAnyObject</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">IAnyObject</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = mixin(&#123;a: <span class="string">'hello'</span>&#125;, &#123;b: <span class="number">42</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = x.a;</span><br><span class="line"><span class="keyword">const</span> b = x.b;</span><br></pre></td></tr></table></figure>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">'string'</span>) &#123;</span><br><span class="line">    line = command.trim();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.join(<span class="string">' '</span>).trim();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> a = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123;value: T&#125;</span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  left: Tree&lt;T&gt;;</span><br><span class="line">  right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>type 与 interface？</strong></p><ul><li>interface 只能用于定义 <strong>对象类型</strong></li><li>type 还可以定义 <strong>原始类型</strong>、<strong>交叉类型</strong> 和 <strong>联合类型</strong> 等，用途更加广泛</li><li>但是 interface 可以实现 extends 和 implements，也可以实现接口合并声明</li></ul>
          </div>
<h1 id="可辨识联合类型"><a href="#可辨识联合类型" class="headerlink" title="可辨识联合类型"></a>可辨识联合类型</h1><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>字面量类型（Literal Type）主要分为 <strong>真值字面量类型（Boolean Literal Type）</strong>、<strong>数字字面量类型（Numeric Literal Type）</strong>、<strong>枚举字面量类型（Enum Literal Type）</strong>、<strong>大整数字面量类型（BigInt Literal Type）</strong> 和 <strong>字符串字面量类型（String Literal Type）</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="string">'xiaoming'</span> = <span class="string">'xiaoming'</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="string">'xiaoming'</span> = <span class="string">'xiaohong'</span>; <span class="comment">// Initializer type "xiaohong" is not assignable to variable type "xiaoming"</span></span><br></pre></td></tr></table></figure>
<p>字面量类型有时候可以模拟一个类似枚举的效果：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction = <span class="string">'North'</span> | <span class="string">'East'</span> | <span class="string">'South'</span> | <span class="string">'West'</span></span><br></pre></td></tr></table></figure>
<h2 id="类型字面量"><a href="#类型字面量" class="headerlink" title="类型字面量"></a>类型字面量</h2><p>类型字面量（Type Literal）则跟 JavaScript 中的对象字面量语法很相似：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  baz: [</span><br><span class="line">    <span class="built_in">number</span>,</span><br><span class="line">    <span class="string">'xiaoming'</span></span><br><span class="line">  ];</span><br><span class="line">  toString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h2><p>有时候会出现这样的需求，有两个 <code>action</code>，一个是创建用户 <code>create</code>，一个是删除用户 <code>delete</code>，我们在创建用户的时候不需要 id，在删除用糊的时候需要，因此我们可能会这样写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserAction &#123;</span><br><span class="line">  id?: <span class="built_in">number</span></span><br><span class="line">  action: <span class="string">'create'</span> | <span class="string">'delete'</span></span><br><span class="line">  info: Info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样并不能区分开创建用户和删除用户操作，我们就需要使用类型字面量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserAction = &#123;</span><br><span class="line">  id: <span class="built_in">number</span></span><br><span class="line">  action: <span class="string">'delete'</span></span><br><span class="line">  info: Info</span><br><span class="line">&#125; | &#123;</span><br><span class="line">  action: <span class="string">'create'</span></span><br><span class="line">  info: Info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userReducer = <span class="function">(<span class="params">userAction: UserAction</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (userAction.action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'delete'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(userAction.id);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在输入 <code>userAction.</code> 之后，IDE 会有所提示，因为我们通过 <code>userAction.action</code> 分开了不同的情况，<code>userAction.action</code> 就是我们识别的关键，被称为 <strong>可辨识的标签</strong>。</p>
<p>要想达成这样的效果，需要实现这样几个要素：</p>
<ul>
<li>具有普通的单例类型属性，也就是要有可辨识的特征，比如 <code>delete</code> 和 <code>create</code></li>
<li>一个包含 <strong>联合类型</strong> 的类型别名</li>
<li>类型守卫的特征，比如使用 <code>if</code> 或 <code>switch</code> 等来进行判断</li>
</ul>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器的主要作用是给已有的方法或类扩展一些新的行为，而不是修改他本身</p>
<p>需要在 <code>tsconfig.json</code> 中添加一些选项使其支持装饰器：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"experimentalDecorators": true</span><br></pre></td></tr></table></figure>
<p>装饰器本质上是一个函数，<code>@expression</code> 的形式其实是一个语法糖，<code>expression</code> 求值后也必须是一个函数，他会在运行时被调用，被装饰的声明信息作为参数传入</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@addAge</span><br><span class="line">class Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'xiaoming'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>constructor</code> 是 <code>Person</code></p>
<h2 id="属性-方法装饰器"><a href="#属性-方法装饰器" class="headerlink" title="属性/方法装饰器"></a>属性/方法装饰器</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prop'</span> + propertyKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'desc'</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">'\n\n'</span>);</span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'xiaoming'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@method</span> <span class="comment">// 其实是相当于使用了 Object.defineProperty 来修改方法和属性</span></span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'instance method'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@method</span></span><br><span class="line">  <span class="keyword">static</span> run() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'static method'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xm = <span class="keyword">new</span> Person();</span><br><span class="line">xm.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// Cannot assign to read only property 'say' of object '#&lt;Person&gt;'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'edit'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>target</code> 是当前对象的原型 <code>Person.prototype</code></p>
<h2 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h2><p>参数装饰器在 Angular 和 Nestjs 中都有运用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, propertyKey, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  greet(<span class="meta">@logParameter</span> message: <span class="built_in">string</span>, <span class="meta">@logParameter</span> name:<span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;message&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.greet(<span class="string">'hi'</span>, <span class="string">'xiaoming'</span>)</span><br></pre></td></tr></table></figure>
<p>其中 <code>target</code> 是当前对象的原型 <code>Person.prototype</code>，<code>propertyKey</code> 是 <code>greet</code>，在这里装饰器起到的作用主要是能够提供一系列的信息（元数据）</p>
<h2 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h2><p>可以使用装饰器工厂封装不同的装饰器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethod</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (args.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> logClass.apply(<span class="keyword">this</span>, args); <span class="comment">// 需要将 --strictBindCallApply 关掉</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> logProperty.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> args[<span class="number">2</span>] === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> logParameter.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> logMethod.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Decorators are not valid here!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">class</span> Person &#123; </span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="keyword">public</span> greet(<span class="meta">@log</span> message : <span class="built_in">string</span>) : <span class="built_in">string</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> say: <span class="subst">$&#123;message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h2><p>可以同时应用多个装饰器，装饰器可以写在一行或多行上，执行的步骤是：</p>
<ol>
<li>从上到下依次对装饰器表达式求值</li>
<li>求值的结果会被当做函数，从下到上一次调用</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f(): evaluated"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"f(): called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"g(): evaluated"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"g(): called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类中的各种装饰器调用顺序：</p>
<ol>
<li>参数装饰器、方法装饰器、访问符装饰器、属性装饰器应用到每个实例成员</li>
<li>参数装饰器、方法装饰器、访问符装饰器、属性装饰器应用到每个静态成员</li>
<li>参数装饰器应用到静态函数</li>
<li>类装饰器应用到类</li>
</ol>
<h1 id="Reflect-Metadata"><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h1><p>属于 ES7 的一个提案，主要作用是在声明的时候读取和添加元数据，不再需要手动在属性上添加元数据，目前需要先引入 npm 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>
<p>而且需要在 <code>tsconfig.json</code> 中配置 <code>emitDecoratorMetadata</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">  <span class="keyword">public</span> hello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reflect.getMetadata(<span class="string">'name'</span>, A);</span><br><span class="line">Reflect.getMetadata(<span class="string">'hello'</span>, <span class="keyword">new</span> A());</span><br></pre></td></tr></table></figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="设置-获取元数据"><a href="#设置-获取元数据" class="headerlink" title="设置/获取元数据"></a>设置/获取元数据</h3><p>可以使用 <code>metadata</code> API，利用装饰器给目标添加元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">metadata</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  metadataKey: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  metadataValue: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  (target: <span class="built_in">Function</span>): <span class="built_in">void</span>;</span><br><span class="line">  (target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>defineMetadata</code> 添加元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Reflect.defineMetadata(metadataKey, metadataValue, target);</span><br><span class="line">Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br></pre></td></tr></table></figure>
<p>可以这样使用他：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'xiaomimg'</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'time'</span>, <span class="string">'2019/10/10'</span>)</span><br><span class="line">  <span class="keyword">public</span> say(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">'name'</span>, Person)); <span class="comment">// xiaomimg</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">'time'</span>, <span class="keyword">new</span> Person, <span class="string">'say'</span>)); <span class="comment">// 2019/10/10</span></span><br></pre></td></tr></table></figure>
<p>注意取出 <code>say</code> 上的元数据时需要先实例化，因为元数据是被添加在实例方法上的，要想不实例化的话，则需要添加在静态方法上</p>
<h3 id="内置元数据"><a href="#内置元数据" class="headerlink" title="内置元数据"></a>内置元数据</h3><p>可以获取一些 TypeScript 本身内置的一些元数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = Reflect.getMetadata(<span class="string">'design:type'</span>, <span class="keyword">new</span> Person, <span class="string">'say'</span>);</span><br><span class="line"><span class="keyword">const</span> typeParam = Reflect.getMetadata(<span class="string">'design:paramtypes'</span>, <span class="keyword">new</span> Person, <span class="string">'say'</span>);</span><br><span class="line"><span class="keyword">const</span> typeReturn = Reflect.getMetadata(<span class="string">'design:returntype'</span>, <span class="keyword">new</span> Person, <span class="string">'say'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="明确赋值断言"><a href="#明确赋值断言" class="headerlink" title="明确赋值断言"></a>明确赋值断言</h1><p><code>--strictPropertyInitialization</code> 可以保证变量声明和实例属性都会有初始值，但有时候我们需要提醒编译器 ”这里不需要一个初始值“ 或者 ”这里稍后将会有值，你别管“，这是加上 <code>!</code> 即可</p>
<h1 id="is-关键字"><a href="#is-关键字" class="headerlink" title="is 关键字"></a>is 关键字</h1><p>作用是为了判断类型，看一个栗子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">test: <span class="built_in">any</span></span>): <span class="title">test</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> test === <span class="string">'string'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isString(foo)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>如果将 <code>test is string</code> 改成 <code>boolean</code>，就会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Property &#39;length&#39; does not exist on type &#39;string | number&#39;.</span><br><span class="line">  Property &#39;length&#39; does not exist on type &#39;number&#39;.(2339)</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>is</code> 将类型的范围给缩小了</p>
<h1 id="可调用类型注解"><a href="#可调用类型注解" class="headerlink" title="可调用类型注解"></a>可调用类型注解</h1><p>想让一个 interface 被注解为可执行的、可实例化的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ToString &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> somethingToString: ToString;</span><br><span class="line"></span><br><span class="line">somethingToString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// This expression is not callable.</span></span><br><span class="line"><span class="comment">//    Type 'ToString' has no call signatures.</span></span><br></pre></td></tr></table></figure>
<p>可以这样修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ToString1 &#123;</span><br><span class="line">  (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> somethingToString1: ToString1;</span><br><span class="line"></span><br><span class="line">somethingToString1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ToString2 &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> somethingToString2: ToString2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> somethingToString2();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/hais-notebook/2020/03/16/React-Hooks/</url>
    <content><![CDATA[<p>关于 React Hooks。</p>
<a id="more"></a>
<h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><div class="note warning">
            <p>注意与 class 组件的 setState 不同，他是 <strong>不能</strong> 只更新对象的某个部分的；<br>并且，如果对象修改前后的地址不变，则不会触发重新渲染，因此，最好使用函数</p>
          </div>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="尝试自己实现一个-useState"><a href="#尝试自己实现一个-useState" class="headerlink" title="尝试自己实现一个 useState"></a>尝试自己实现一个 useState</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state = []</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> myUseState = <span class="function">(<span class="params">initialValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentIndex = index</span><br><span class="line">  _state[currentIndex] = _state[currentIndex] === <span class="literal">undefined</span> ? initialValue : _state[currentIndex]</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    _state[currentIndex] = newValue</span><br><span class="line">    render() <span class="comment">// 在这里做一个简化</span></span><br><span class="line">  &#125;</span><br><span class="line">  index ++</span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  index = <span class="number">0</span> <span class="comment">// 这句话很关键，每次渲染之后 index 变成 0</span></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是使用数组来实现 state，导致其对顺序依赖非常大，Hook 在每次渲染中必须以 <strong>完全一样的顺序来调用</strong>，比如 React 中不允许使用这种代码：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">  [m, setM] = React.useState(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个函数组件对应一个 React 节点，每个节点将会保存 state（<code>memorizedState</code>） 和 index（链表）</p>
<h2 id="实现一个贯穿始终的状态"><a href="#实现一个贯穿始终的状态" class="headerlink" title="实现一个贯穿始终的状态"></a>实现一个贯穿始终的状态</h2><p>使用 useState 的话每次重新渲染会产生不同的 state，如果非要实现一个贯穿始终状态，除了使用全局变量 <code>window</code> 以外，还有这两种方法：</p>
<h3 id="使用-useRef"><a href="#使用-useRef" class="headerlink" title="使用 useRef"></a>使用 useRef</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nRef = React.useRef(<span class="number">0</span>) <span class="comment">// &#123;current: 0&#125;</span></span><br><span class="line"><span class="comment">// 之后使用 nRef.current</span></span><br></pre></td></tr></table></figure>
<p>但是修改 <code>nRef.current</code> 不会让组件重新渲染，因此页面上的数据不会同步改变（但是 Vue 3 可以）</p>
<p>可以像这样手动让他更新：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = React.useState(<span class="literal">null</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 这样修改 nRef.current</span></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  nRef.current += <span class="number">1</span></span><br><span class="line">  update(nRef.current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-useContext"><a href="#使用-useContext" class="headerlink" title="使用 useContext"></a>使用 useContext</h3><p>详见 React Advanced 中的 Context 部分</p>
<h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建初始状态</span></span><br><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line">  n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">n</span>: state.n + action.number&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'multi'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">n</span>: state.n * <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unknown type'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 useReducer</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initial)</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'add'</span>, <span class="attr">number</span>: <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="attr">n</span>: state.n&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-useReducer-替代-redux"><a href="#使用-useReducer-替代-redux" class="headerlink" title="使用 useReducer 替代 redux"></a>使用 useReducer 替代 redux</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数据初始状态</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  user: <span class="literal">null</span>,</span><br><span class="line">  books: <span class="literal">null</span>,</span><br><span class="line">  movies: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setUser'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.user&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setBooks'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.user&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'setMovies'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">user</span>: action.user&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Context</span></span><br><span class="line"><span class="keyword">const</span> Context = createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建对数据的读写 API</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, store)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 将读写 API 放到 Context 里面，并使用 Context.Provider 将 Context 提供给组件</span></span><br><span class="line">    &lt;Context.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt;</span><br><span class="line">      &lt;User/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const User = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const &#123;state, dispatch&#125; = useContext(Context)</span></span><br><span class="line"><span class="regexp">  useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过 AJAX 获取数据，并 dispatch(&#123;type: 'setUser', user&#125;)</span></span><br><span class="line"><span class="regexp">  &#125;,[])</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;个人信息&lt;/</span>h1&gt;</span><br><span class="line">      &lt;div&gt;name: &#123;state.name ? state.user.name : <span class="string">''</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 context</span></span><br><span class="line"><span class="keyword">const</span> C = createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 圈定作用域并给初始值（初始值通常是一个读接口和写接口）</span></span><br><span class="line">    &lt;C.Provider value=&#123;&#123;n, setN&#125;&#125;&gt;</span><br><span class="line">      &lt;Child/&gt;</span><br><span class="line">    &lt;<span class="regexp">/C.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Child = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 子组件拿到读接口和写接口</span></span><br><span class="line"><span class="regexp">  const &#123;n, setN&#125; = useContext(C)</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p>若同时有多个 useEffect，则他们将会依次执行</p>
<h2 id="什么是副作用"><a href="#什么是副作用" class="headerlink" title="什么是副作用"></a>什么是副作用</h2><p>对环境的改变就是副作用，比如改变 <code>document.title</code></p>
<h2 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h2><ul>
<li>模拟 <code>componentDidMount</code>（第一次渲染）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li>
<li>模拟 <code>componentDidUpdate</code>（更新时执行）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [n])</span><br><span class="line"><span class="comment">// 这样的话第一次渲染也会执行，可以使用自定义 Hook 来解决</span></span><br><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">(<span class="params">fn, dep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [updateCount, setUpdateCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUpdateCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [dep])</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (updateCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [updateCount, fn])</span><br><span class="line">&#125;</span><br><span class="line">useUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, n)</span><br></pre></td></tr></table></figure></li>
<li>模拟 <code>componentWillUnmount</code>（将要销毁时执行）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>useEffect 将会在渲染完成之后被执行，因此有时候可能会出现闪烁，而 useLayoutEffect 将会在渲染完成之前（生成 DOM 之后）被执行</p>
<p>但是因为很多很时候我们不需要直接操作 DOM，不需要改变最后渲染的结果（外观），而且 useLayoutEffect 可能会延迟用户看到渲染完成结果的时间，因此优先使用 useEffect</p>
<h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p>使用 React.memo 封装函数组件，使得其只在 props 变化的时候执行，但是有时候会出现这样的情况：给子组件添加一个事件监听，并传一个回调函数，因为父组件重新执行的时候，这个函数地址会改变，因此子组件还是会执行，使用 useMemo 解决</p>
<h2 id="useMemo-1"><a href="#useMemo-1" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onClick = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这个返回值是才我想要缓存的那个函数，也可以返回一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []) <span class="comment">// 同样可以设置依赖</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Child onClick=&#123;onClick&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个其实很像 Vue 2 的 computed</p>
<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p>其实跟 useMemo 一样，只是不是在返回值中写：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是你想缓存的函数</span></span><br><span class="line">  &#125;, []) <span class="comment">// 同样可以设置依赖</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Child onClick=&#123;onClick&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>可以通过 useRef 获得一个贯穿全局的状态</p>
<h2 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h2><p>由于 props 不包含 ref，所以需要 forwardRef，他实现了 ref 的传递</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> buttonRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button ref=&#123;buttonRef&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Button = React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button ref=&#123;ref&#125; &#123;...props&#125;&gt;&lt;/</span>button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><p>相当于 “setRef”，可以定义一个 ref 的封装</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      realButton.current.remove()</span><br><span class="line">    &#125;,</span><br><span class="line">    realButton: realButton</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h1><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState(<span class="literal">null</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">'/list'</span>).then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      setList(list)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    list,</span><br><span class="line">    setList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Stale-Closure"><a href="#Stale-Closure" class="headerlink" title="Stale Closure"></a>Stale Closure</h1>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS 入门</title>
    <url>/hais-notebook/2020/03/09/NodeJS-Intro/</url>
    <content><![CDATA[<p>关于 NodeJS 的一些东西。</p>
<a id="more"></a>
<h1 id="一些有用的工具"><a href="#一些有用的工具" class="headerlink" title="一些有用的工具"></a>一些有用的工具</h1><ul>
<li>commander：可以很方便地写出命令行，有多种语言的版本。</li>
<li>node-dev：文件更新时自动重启的 node，不宜在生产环境使用。</li>
<li>ts-node：让 node 支持直接运行 TypeScript 代码，不宜在生产环境使用。</li>
<li>ts-node-dev：node-dev + ts-node，不宜在生产环境使用。</li>
<li>注意用 ts 开发时，需要安装 @types/node</li>
<li>tsc —init 命令会自动创建 <code>tsconfig.json</code> 文件</li>
</ul>
<h1 id="Node-js-简介"><a href="#Node-js-简介" class="headerlink" title="Node.js 简介"></a>Node.js 简介</h1><h2 id="Node-js-是什么"><a href="#Node-js-是什么" class="headerlink" title="Node.js 是什么"></a>Node.js 是什么</h2><ul>
<li>不是 web 框架，不能把 Node.js 与 Flask 或 Spring 对比</li>
<li>不是编程语言，不能与 Python 或 PHP 对比</li>
<li>是一个平台，将多种技术组合起来，让 JavaScript 也能调用系统接口、开发后端应用<ul>
<li>V8 引擎</li>
<li>libuv</li>
<li>C/C++ 实现的 c-ares、http-parser、OpenSSL、zlib 等</li>
</ul>
</li>
</ul>
<h2 id="Node-js-技术架构"><a href="#Node-js-技术架构" class="headerlink" title="Node.js 技术架构"></a>Node.js 技术架构</h2><h3 id="第三层：Node-js-API"><a href="#第三层：Node-js-API" class="headerlink" title="第三层：Node.js API"></a>第三层：Node.js API</h3><h3 id="第二层：Node-js-bindings、C-C-插件"><a href="#第二层：Node-js-bindings、C-C-插件" class="headerlink" title="第二层：Node.js bindings、C/C++ 插件"></a>第二层：Node.js bindings、C/C++ 插件</h3><h4 id="bindings"><a href="#bindings" class="headerlink" title="bindings"></a>bindings</h4><p>沟通 Node.js 与 C/C++，比如 C/C++ 实现了 http-parsers 库，bindings 帮助我们调用这个库，比如将 C++ 编译成 .node，然后 JS require 他。</p>
<h4 id="C-C-插件"><a href="#C-C-插件" class="headerlink" title="C/C++ 插件"></a>C/C++ 插件</h4><p>自己写其他能力。</p>
<h3 id="第一层：V8、libuv、c-ares、OpenSSL、zlib、http-parser、zlib-等"><a href="#第一层：V8、libuv、c-ares、OpenSSL、zlib、http-parser、zlib-等" class="headerlink" title="第一层：V8、libuv、c-ares、OpenSSL、zlib、http-parser、zlib 等"></a>第一层：V8、libuv、c-ares、OpenSSL、zlib、http-parser、zlib 等</h3><h4 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h4><ul>
<li>每个操作系统上有不同的异步处理模块，比如 FreeBSD 上的 kqueue、Linux 上的 epoll、Windows 上的 IOCP</li>
<li>libuv 是一个跨平台的异步 I/O 库，他会根据系统选择合适的方案</li>
<li>可以用于 TCP/UDP/DNS/文件 等异步操作</li>
</ul>
<h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><ul>
<li>将 JS 源代码变成本地代码（机器代码）执行</li>
<li>维护调用栈</li>
<li>内存管理</li>
<li>垃圾回收，重复利用无用的内存</li>
<li>实现 JS 的标准库</li>
</ul>
<p>注意：</p>
<ul>
<li>V8 不提供 DOM API，DOM API 是浏览器提供的</li>
<li>V8 是多线程的，比如垃圾回收为单独的线程，但执行 JS 是单线程的</li>
<li>可以开启两个线程来执行 JS，但这两个线程之间没什么关系</li>
<li>V8 自带 event loop，但 Node.js 基于 libuv 自己做了一个 event loop</li>
</ul>
<h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><ul>
<li>Event：包括内部事件（计时器到期了）、外部事件（文件可以读取了、socket 有内容了）</li>
<li>Loop：事件是有优先级的，处理顺序是有先后的，Node.js 要按顺序轮询每种事件，这种轮询往往都是循环的</li>
</ul>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">官方文档</a></p>
<p>重点阶段：</p>
<ul>
<li>timers 检查计时器</li>
<li>poll 轮询，大部分时间会停留在这个阶段，大部分事件将在 poll 得到处理，比如文件读取、网络请求</li>
<li>check 检查 setImmediate 回调</li>
</ul>
<blockquote>
<p>setTimout 与 setImmediate 谁先执行？<br>不确定，大多数情况是 setImmediate 先执行，但有时刚进入的时候，会先执行 setTimout </p>
</blockquote>
<h1 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultDbPath = p.join(__dirname, <span class="string">".todo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  read(path = defaultDbPath) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(path, &#123;</span><br><span class="line">        flag: <span class="string">"a+"</span></span><br><span class="line">      &#125;, (error, data) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  write(content = <span class="string">"defaultContent"</span>, path = defaultDbPath) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.writeFile(path, content, (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="HTTP-模块"><a href="#HTTP-模块" class="headerlink" title="HTTP 模块"></a>HTTP 模块</h1><p>一个最简单的服务器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">"http"</span></span><br><span class="line"><span class="keyword">import</span> &#123; IncomingMessage, ServerResponse &#125; <span class="keyword">from</span> <span class="string">"http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"request.method"</span>, request.method)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"request.url"</span>, request.url)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"request.headers"</span>, request.headers)</span><br><span class="line">  <span class="comment">// 监听 data 事件才能拿到 post 的请求体，用户每上传一点内容，就会触发一次 data 事件</span></span><br><span class="line">  <span class="keyword">const</span> array = []</span><br><span class="line">  request.on(<span class="string">"data"</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    array.push(chunk)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当流中没有数据了，会触发 end 事件</span></span><br><span class="line">  request.on(<span class="string">"end"</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = Buffer.concat(array)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"body"</span>, body.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 response</span></span><br><span class="line">    response.statusCode = <span class="number">400</span></span><br><span class="line">    response.setHeader(<span class="string">"x-harvey"</span>, <span class="string">"WOW"</span>)</span><br><span class="line">    response.write(<span class="string">"1\n"</span>)</span><br><span class="line">    response.write(<span class="string">"2\n"</span>)</span><br><span class="line">    response.end(<span class="string">"request end"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<p>可以配合 <a href="https://nodejs.org/api/http.html#http_event_request" target="_blank" rel="noopener">文档</a> 食用</p>
<h2 id="根据-url-返回不同的文件"><a href="#根据-url-返回不同的文件" class="headerlink" title="根据 url 返回不同的文件"></a>根据 url 返回不同的文件</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">"http"</span></span><br><span class="line"><span class="keyword">import</span> &#123; IncomingMessage, ServerResponse &#125; <span class="keyword">from</span> <span class="string">"http"</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">"fs"</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> p <span class="keyword">from</span> <span class="string">"path"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"><span class="keyword">const</span> publicDir = p.resolve(__dirname, <span class="string">"public"</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; method, url, headers &#125; = request</span><br><span class="line">  <span class="keyword">switch</span> (url) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"/index.html"</span>:</span><br><span class="line">    fs.readFile(p.resolve(publicDir, <span class="string">"index.html"</span>), <span class="function">(<span class="params">(<span class="params">err, data</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">err</span>) &#123; <span class="keyword">throw</span> err &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      response.end(<span class="params">data.toString(<span class="params"></span>)</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span>))</span></span><br><span class="line"><span class="function">    <span class="params">break</span></span></span><br><span class="line"><span class="function">  <span class="params">case</span> "/<span class="params">style</span>.<span class="params">css</span>":</span></span><br><span class="line"><span class="function">    <span class="params">response</span>.<span class="params">setHeader</span>(<span class="params">"Content-Type", "text/css; charset=utf-8"</span>)</span></span><br><span class="line"><span class="function">    <span class="params">fs</span>.<span class="params">readFile</span>(<span class="params">p.resolve(<span class="params">publicDir, "style.css"</span>), (<span class="params">(<span class="params">err, data</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">if</span> (<span class="params">err</span>) &#123; <span class="keyword">throw</span> err &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      response.end(<span class="params">data.toString(<span class="params"></span>)</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span>)</span></span><br><span class="line"><span class="function">    <span class="params">break</span></span></span><br><span class="line"><span class="function">  <span class="params">case</span> "/<span class="params">index</span>.<span class="params">js</span>":</span></span><br><span class="line"><span class="function">    <span class="params">response</span>.<span class="params">setHeader</span>(<span class="params">"Content-Type", "text/javascript; charset=utf-8"</span>)</span></span><br><span class="line"><span class="function">    <span class="params">fs</span>.<span class="params">readFile</span>(<span class="params">p.resolve(<span class="params">publicDir, "index.js"</span>), (<span class="params">(<span class="params">err, data</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">if</span> (<span class="params">err</span>) &#123; <span class="keyword">throw</span> err &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      response.end(<span class="params">data.toString(<span class="params"></span>)</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span>)</span></span><br><span class="line"><span class="function">    <span class="params">break</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">server</span>.<span class="params">listen</span>(<span class="params">8888</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; pathname, searchParams &#125; = <span class="keyword">new</span> URL(requestUrl, <span class="string">"http://localhost:8888"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="匹配任意文件"><a href="#匹配任意文件" class="headerlink" title="匹配任意文件"></a>匹配任意文件</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">"request"</span>, <span class="function">(<span class="params">request: IncomingMessage, response: ServerResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; method, url: requestUrl, headers &#125; = request</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = <span class="keyword">new</span> URL(requestUrl, <span class="string">"http://localhost:8888"</span>)</span><br><span class="line">  <span class="keyword">const</span> filename = pathname.substr(<span class="number">1</span>) || <span class="string">"index.html"</span></span><br><span class="line">  fs.readFile(p.resolve(publicDir, filename), <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.errno === <span class="number">-4058</span>) &#123;</span><br><span class="line">        response.statusCode = <span class="number">404</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.statusCode = <span class="number">500</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response.end()</span><br><span class="line">    &#125;</span><br><span class="line">    response.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="处理非-get-请求"><a href="#处理非-get-请求" class="headerlink" title="处理非 get 请求"></a>处理非 get 请求</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (method !== <span class="string">"GET"</span>) &#123;</span><br><span class="line">  response.statusCode = <span class="number">405</span></span><br><span class="line">  <span class="keyword">return</span> response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">`public, max-age=<span class="subst">$&#123;cacheAge&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：Canvas</title>
    <url>/hais-notebook/2020/03/05/JS-Canvas/</url>
    <content><![CDATA[<p>介绍 Canvas。</p>
<a id="more"></a>
<h1 id="什么是-Canvas"><a href="#什么是-Canvas" class="headerlink" title="什么是 Canvas"></a>什么是 Canvas</h1><blockquote>
<p><code>&lt;canvas&gt;</code> 是 HTML 5 新增的元素，可用于通过使用 JavaScript 的脚本来绘制图形。例如，他可以用于绘制图形、制作照片、创建动画，甚至可以进行实时视频处理和渲染</p>
</blockquote>
<p>简单来说，<code>&lt;canvas&gt;</code> 提供了一块画布，在上面可以使用 JavaScript 动态渲染图像</p>
<h2 id="Canvas-与-SVG"><a href="#Canvas-与-SVG" class="headerlink" title="Canvas 与 SVG"></a>Canvas 与 SVG</h2><blockquote>
<p>SVG（Scalable Vector Graphics）是基于 XML，用于描述二维矢量图形的一种图片格式，由 W3C 指定，是一个开放标准</p>
</blockquote>
<p>Canvas 在绘制结束之后不能被保存到内存中，每次都需要重新绘制，是实时绘制的；svg 则在绘制完之后会被保存在内存中，当需要修改这个对象信息的时候，直接修改就可以了</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Canvas</th>
<th>SVG</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖分辨率（位图）</td>
<td>不依赖分辨率（矢量图）</td>
</tr>
<tr>
<td>单个 HTML 元素</td>
<td>每个图形都是一个 DOM 元素</td>
</tr>
<tr>
<td>只能通过脚本语言绘制</td>
<td>CSS、脚本语言都可以用来绘制</td>
</tr>
<tr>
<td>不支持事件处理程序</td>
<td>支持事件处理程序</td>
</tr>
<tr>
<td>弱的文本渲染恩能够力</td>
<td>最适合带有大型渲染区域的应用程序，比如谷歌地图</td>
</tr>
<tr>
<td>图面较小，对象数量较大时（&gt;10k）性能最佳</td>
<td>对象数量较小（&lt;10k）、图面更大时性能更佳</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Canvas-的应用场景"><a href="#Canvas-的应用场景" class="headerlink" title="Canvas 的应用场景"></a>Canvas 的应用场景</h1><ol>
<li><strong>绘制图表</strong>，比如 EChats 之类的数据可视化库都是使用 Canvas 实现的</li>
<li><strong>小游戏</strong>，基本上所有的 HTML 5 游戏都是基于 Canvas 开发的，因为不需要借助其他任何插件</li>
<li><strong>活动页面</strong>，比如转转轮、刮奖</li>
<li><strong>特效、背景</strong></li>
</ol>
<h1 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h1><h2 id="设置宽高"><a href="#设置宽高" class="headerlink" title="设置宽高"></a>设置宽高</h2><p>可以通过 HTML 或 JS 来设置，不能通过 CSS 设置，这会导致不可预料的缩放</p>
<h2 id="获取-Canvas-对象"><a href="#获取-Canvas-对象" class="headerlink" title="获取 Canvas 对象"></a>获取 Canvas 对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.getContext(contextType, contextAttributes)</span><br></pre></td></tr></table></figure>
<p><code>contextType</code> 是上下文类型，有这样几种：</p>
<ul>
<li><code>2d</code>：代表一个二维渲染上下文</li>
<li><code>webgl</code> 或 <code>experimental-webgl</code>：代表一个三维渲染上下文</li>
<li><code>webgl2</code> 或 <code>experimental-webgl2</code>：代表一个三维渲染上下文，并且只能在浏览器中实现 WebGL 版本 2（OpenGL ES 3.0）</li>
</ul>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fill()</code></td>
<td>填充路径</td>
</tr>
<tr>
<td><code>stroke()</code></td>
<td>描边</td>
</tr>
<tr>
<td><code>arc()</code></td>
<td>创建圆弧</td>
</tr>
<tr>
<td><code>rect()</code></td>
<td>创建矩形</td>
</tr>
<tr>
<td><code>fillRect()</code></td>
<td>绘制矩形路径区域</td>
</tr>
<tr>
<td><code>strokeRect()</code></td>
<td>绘制矩形路径描边</td>
</tr>
<tr>
<td><code>clearRect()</code></td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
<tr>
<td><code>arcTo()</code></td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr>
<td><code>beginPath()</code></td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td><code>moveTo()</code></td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td><code>lineTo()</code></td>
<td>添加一个新点，然后画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td><code>closePath()</code></td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td><code>clip()</code></td>
<td>从原始画布剪切任意形状和尺寸的区域</td>
</tr>
<tr>
<td><code>quadraticCurveTo()</code></td>
<td>创建二次方贝塞尔曲线</td>
</tr>
<tr>
<td><code>bezierCurveTo()</code></td>
<td>创建三次方贝塞尔曲线</td>
</tr>
<tr>
<td><code>isPointInPath()</code></td>
<td>如果指定的点位于当前路径中，则返回 true，否则返回 false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h3><h4 id="arc"><a href="#arc" class="headerlink" title="arc()"></a>arc()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.arc(x, y, sAngle, eAangle, counterCloseWise)</span><br></pre></td></tr></table></figure>
<p><code>x</code> 和 <code>y</code> 指定了圆心坐标，<code>sAngle</code> 和 <code>eAngle</code> 分别为起始角和结束角，<code>counterCloseWise</code> 设置为 <code>true</code> 表示逆时针绘制</p>
<h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">moveTo(x, y) <span class="comment">// 把路径移动到画布中的指定点，不创建线条</span></span><br><span class="line">lineTo(x, y) <span class="comment">// 添加一个新点，然后在画布中创建从该点到最后指定点的线条</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>如果没有 <code>moveTo</code>，那么第一次 <code>lineTo</code> 就视为 <code>moveTo</code></p>
          </div>
<p>可以给绘制的直线添加样式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lineCap</code></td>
<td>设置或返回线条的结束端点样式</td>
</tr>
<tr>
<td><code>lineJoin</code></td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td><code>lineWidth</code></td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td><code>miterLimit</code></td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fillRect(x, y, width, height) <span class="comment">// 绘制一个实心矩形</span></span><br><span class="line">strokeRect(x, y, width, height) <span class="comment">// 绘制一个空心矩形</span></span><br></pre></td></tr></table></figure>
<h3 id="颜色、样式和阴影"><a href="#颜色、样式和阴影" class="headerlink" title="颜色、样式和阴影"></a>颜色、样式和阴影</h3><p>创建路径之后，可以设置样式属性，再使用 <code>fill()</code> 和 <code>stroke()</code> 进行填充或描边</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影距形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影距形状的垂直距离</td>
</tr>
</tbody>
</table>
</div>
<h3 id="设置渐变"><a href="#设置渐变" class="headerlink" title="设置渐变"></a>设置渐变</h3><p>有这样几个方法可以设置渐变：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody>
</table>
</div>
<p>主要使用到下面这个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> grd = context.createLinerGradient(x0, y0, x1, y1)</span><br><span class="line">grd.addColorStop(stop, color) <span class="comment">// stop 是介于 0.0 ~ 1.0 之间的值</span></span><br></pre></td></tr></table></figure>
<h3 id="图形转换"><a href="#图形转换" class="headerlink" title="图形转换"></a>图形转换</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵，然后运行 transform()</td>
</tr>
</tbody>
</table>
</div>
<p>注意旋转实际上是对画布旋转，旋转之后所有的都会旋转</p>
<h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">drawImage(img, sx, sy, swidth, sheight, x, y, width, height)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>img</code>：规定要使用的图像、画布或视频</li>
<li><code>sx</code>：可选。开始剪切的 x 坐标位置</li>
<li><code>sy</code>：可选。开始剪切的 y 坐标位置</li>
<li><code>swidth</code>：可选。被剪切图像的宽度</li>
<li><code>sheight</code>：可选。被剪切图像的高度</li>
<li><code>x</code>：在画布上放置图像的 x 坐标位置</li>
<li><code>y</code>：在画布上放置图像的 y 坐标位置</li>
<li><code>width</code>：可选。要使用的图像的宽度（伸展或缩小图像）</li>
<li><code>height</code>：可选。要使用的图像的高度（伸展或缩小图像）</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础</title>
    <url>/hais-notebook/2020/03/03/CS-Network/</url>
    <content><![CDATA[<p>主要是关于计算机网络基础的一些东西。</p>
<a id="more"></a>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-基本介绍"><a href="#HTTP-基本介绍" class="headerlink" title="HTTP 基本介绍"></a>HTTP 基本介绍</h2><h3 id="HTTP-历史"><a href="#HTTP-历史" class="headerlink" title="HTTP 历史"></a>HTTP 历史</h3><ul>
<li>HTTP 0.9：1991，只有 GET、只能传HTML，没有 CSS、JS，每个HTTP请求都是短连接</li>
<li>HTTP 1.0：1996，有了 POST、HEAD……</li>
<li>HTTP 1.1：1997，目前为止最常用的版本</li>
<li>HTTP 2.0：2015，HTTP 1.1 的扩展，于2015年5月提出</li>
<li>HTTP 3.0：QUIC 协议（一种传输层协议，TCP的效率比较低，QUIC 为了减小 TCP 的延迟和带宽开销）</li>
</ul>
<h3 id="TCP-IP-与-HTTP"><a href="#TCP-IP-与-HTTP" class="headerlink" title="TCP/IP 与 HTTP"></a>TCP/IP 与 HTTP</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul>
<li>应用层：FTP、DNS、HTTP</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP</li>
<li>链路层：网络</li>
</ul>
<h4 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h4><ul>
<li>系统在 HOST 文件中找 IP 地址</li>
<li>系统向本地 DNS 服务器请求：114.114.114.114（国内移动、电信和联通通用的DNS），8.8.8.8（GOOGLE 公司提供的 DNS，该地址是全球通用）</li>
<li>本地 DNS 服务器一层层向上请求，直到根 DNS 服务器</li>
</ul>
<h2 id="HTTP-协议结构和通讯原理"><a href="#HTTP-协议结构和通讯原理" class="headerlink" title="HTTP 协议结构和通讯原理"></a>HTTP 协议结构和通讯原理</h2><h3 id="HTTP-协议特点"><a href="#HTTP-协议特点" class="headerlink" title="HTTP 协议特点"></a>HTTP 协议特点</h3><ul>
<li><strong>支持客户/服务器模式</strong></li>
<li><strong>简单快速</strong><ul>
<li>客户向服务器请求服务时，只需要传送请求方法和路径</li>
<li>GET、HEAD、POST</li>
<li>HTTP服务器程序规模小，因此通信速度块</li>
</ul>
</li>
<li><strong>灵活</strong><ul>
<li>允许传输任意类型的数据对象</li>
<li>正在传输的类型由 Content-Type 加以标记</li>
</ul>
</li>
<li><strong>无连接</strong><ul>
<li>无连接的含义是限制 <strong>每次连接只处理一个请求</strong></li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接——keep alive 功能使得连接（TCP）不断开，有规定的超时时间</li>
<li>采用这种方式可以节省传输时间</li>
</ul>
</li>
<li><strong>无状态</strong><ul>
<li>协议对事务的处理能力 <strong>没有记忆能力</strong>，每个请求都是 <strong>独立的</strong></li>
<li>如果后续处理需要前面的信息，则必须重传，导致每次连接的数据量增大</li>
<li>另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
</li>
</ul>
<h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><blockquote>
<p>问题：我们在浏览器的 Web 地址应该叫 URL 还是 URI？</p>
<ul>
<li>URI：可以分为 URL 和 URN，或同时具备 locators 和 names 特性的一个东西</li>
<li>URN 像一个人的名字，URL 像一个人的地址；URN 确定了东西的身份，URL 提供了找到它的方式（提供了访问机制，比如说协议）</li>
</ul>
</blockquote>
<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【请求行】POST（请求方法） &#x2F;webTours&#x2F;login.pl（请求 URI） HTTP&#x2F;1.1（HTTP 协议及版本）</span><br><span class="line">【请求头】用键值对来传递参数，包括 Host、Accept、Content-Type 等</span><br><span class="line"></span><br><span class="line">【请求体】</span><br></pre></td></tr></table></figure>
<p>可以用 curl 构造请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X -POST <span class="comment"># 设置请求动词</span></span><br><span class="line">curl -H <span class="string">'Accept: text/html'</span> <span class="comment"># -H 也可以写成 --header</span></span><br><span class="line">curl -H <span class="string">'Content-Type: text/plain;charset=utf-8'</span> -d <span class="string">'请求体内容'</span> <span class="comment"># -d 也可以写成 --data</span></span><br></pre></td></tr></table></figure>
<p>可以用 Node.js 读取请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.method</span><br><span class="line">request.url <span class="comment">// 路径，带参数</span></span><br><span class="line">request.path <span class="comment">// 纯路径</span></span><br><span class="line">request.query <span class="comment">// 只有查询参数</span></span><br><span class="line">request.headers[<span class="string">'Accept'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【响应行】HTTP&#x2F;1.1（报文协议及版本） 200 Ok（状态码及状态描述）</span><br><span class="line">【响应头】</span><br><span class="line"></span><br><span class="line">【响应体】</span><br></pre></td></tr></table></figure>
<p>可以用 Node.js 设置响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.statusCode = <span class="number">200</span></span><br><span class="line">response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">response.write(<span class="string">'内容'</span>) <span class="comment">// 内容可以追加</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>注意 <code>path</code> 都是以 <code>/</code> 开头的</p>
          </div>
<h4 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h4><ul>
<li><strong>Accept</strong>：浏览器端可以接收的媒体类型<ul>
<li><strong>Accept: text/html</strong>，代表浏览器可以接收服务器回发的类型为 text/html 类型的数据，如果服务器无法返回此类型，应该返回一个 406 错误（Non Acceptable）</li>
<li><strong>Accept: <em>/</em></strong>，代表浏览器可以处理所有类型</li>
<li>可以设置优先级（权重值q，取0~1.000）</li>
</ul>
</li>
<li><strong>Accept-Encoding</strong>：浏览器申明自己接收的编码（压缩）方法（gzip、deflate）</li>
<li><strong>Accept-Language</strong>：浏览器申明自己接收的语言<ul>
<li><strong>Accept-Language</strong>: zh-cn,zh;q=0.7,en-us,en;q=0.3 </li>
</ul>
</li>
<li><strong>Connection</strong><ul>
<li><strong>Connection: keep-alive</strong>，TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>
<li><strong>Connection: close</strong>，一个 Request 完成后，TCP 连接关闭</li>
</ul>
</li>
<li><strong>Host</strong>：指定被请求资源的 Internet 主机和端口号，通常从 URL 中提取出来</li>
<li><strong>Referer</strong>：一般会带上此字段，告诉服务器是从哪个页面链接过来的</li>
<li><strong>User-Agent</strong>：告诉 HTTP 服务器，客户端使用的操作系统和浏览器名称和版本</li>
<li><strong>Content-Type</strong>：说明了报文体对象的媒体类型<br>  <strong>text/html</strong>：HTML<br>  <strong>text/plain</strong>：纯文本<br>  <strong>text/xml</strong>：XML<br>  <strong>image/gif</strong>：GIF图像<br>  <strong>image/jpeg</strong>：JPG图像<br>  <strong>image/png</strong>：PNG图像<br>  <strong>application/xhtml+xml</strong>：XHTML<br>  <strong>application/xml</strong>：XML<br>  <strong>application/atom+xml</strong>：Atom XML<br>  <strong>application/json</strong>：JSON<br>  <strong>application/pdf</strong>：PDF<br>  <strong>application/msword</strong>：WORD<br>  <strong>application/octet-stream</strong>：二进制数据流<br>  <strong>application/x-www-form-urlencoded</strong>：表单提交</li>
</ul>
<h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><ul>
<li><strong>GET</strong>：请求访问已被 URI 识别的资源<ul>
<li>提交的内容是 URL 的一部分，长度限制、安全性</li>
</ul>
</li>
<li><strong>POST</strong>：与 GET 功能类似，一般用来传输实体的主体，主要目的是提交数据，不是获取响应主体的内容</li>
<li><strong>PUT</strong>：与 POST 最大的不同是，PUT 是幂等（不管重复多少次操作，都是实现相同的结果）的，POST 是不幂等的，因此一般创建对象用 POST，更新对象用 PUT，但是 PUT 没有验证机制，有安全性问题，所以一般还是用 POST</li>
<li><strong>HEAD</strong>：类似于GET，只不过返回的响应中没有具体的内容，用于获取报头（测试超链接的有效性）</li>
<li><strong>DELETE</strong>：请求删除资源，与 PUT 相反，并且没有验证机制，因此现在一般不用</li>
<li><strong>OPTIONS</strong>：用来查询针对请求 URI 指定的资源支持的方法<ul>
<li>服务器返回一个<code>Allow: GET, HEAD, POST</code>等等</li>
</ul>
</li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断，但容易受到 XST 攻击，一般不用</li>
<li><strong>CONNECT</strong>：开启客户端与所请求资源之间的双向沟通的通道，可以用来创建隧道，一般用于 HTTP 代理</li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-StatusCode.png" alt="HTTP状态码"></p>
<ul>
<li><strong>200 Ok</strong>，请求已成功，并且所希望的响应头或数据体已经随此响应返回</li>
<li><strong>202 Accepted</strong>，已接收，但处理未完成</li>
<li><strong>206 Partial Content</strong>，部分内容，处理器成功处理了部分 GET 请求——断点续传</li>
<li><strong>301 Moved Permanently</strong>，永久移动，请求的资源已被永久移动到新的 URI，以后任何新的请求都应使用新的 URI 代替</li>
<li><strong>302 Found</strong>，临时移动，客户端应继续使用原有 URI</li>
<li><strong>400 Bad Request</strong>，客户端请求的语法错误，服务器无法理解</li>
<li><strong>401 Unauthorized</strong>，请求要求用户的身份验证</li>
<li><strong>403 Forbidden</strong>，服务器理解客户端的请求，但是拒绝执行此请求</li>
<li><strong>404 Not Found</strong>，服务器无法根据请求找到资源（网页）</li>
<li><strong>500 Internal Server Error</strong>，服务器内部错误，无法完成请求</li>
<li><strong>502 Bad Gateway</strong>，充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
</ul>
<h3 id="HTTP-状态管理：Cookie-和-Session"><a href="#HTTP-状态管理：Cookie-和-Session" class="headerlink" title="HTTP 状态管理：Cookie 和 Session"></a>HTTP 状态管理：Cookie 和 Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>W3C 推行的一种机制，客户端请求服务器，如果服务器需要记录该用户的状态，就向客户端浏览器颁发一个Cookie，<br>客户端浏览器会把Cookie保存起来，浏览器再请求的时候，就会把请求的网址连同Cookie一同提交给服务器</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>另一种记录客户状态的机制，服务器把客户端信息以某种形式记录在服务器上<br>客户端可以以 Cookie、URL 重写或隐藏表单的形式保存 Session ID</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Session-Cookie.png" alt="Session与Cookie"></p>
<h4 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h4><ul>
<li>有效期不同<ul>
<li>Cookie 的有效时间久，或者可以设置到永远</li>
<li>Session 的有效期<ul>
<li>超时自动失效，通常不长</li>
<li>程序调用 HttpSession.invalidate() 主动失效（退出、注销等操作）</li>
<li>服务器进程被终止</li>
</ul>
</li>
<li>存放位置不同，Cookie 在客户端，Session 在服务器端</li>
<li>安全性（隐私策略）不同，用户可以更改 Cookie</li>
<li>对服务器压力不同</li>
</ul>
</li>
</ul>
<h2 id="HTTP-协议的特性"><a href="#HTTP-协议的特性" class="headerlink" title="HTTP 协议的特性"></a>HTTP 协议的特性</h2><h3 id="HTTP-协议中的编码和解码"><a href="#HTTP-协议中的编码和解码" class="headerlink" title="HTTP 协议中的编码和解码"></a>HTTP 协议中的编码和解码</h3><blockquote>
<p>码 = 字符集+编码</p>
</blockquote>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><ul>
<li>字库表：里面存储了所有的字符</li>
<li>字符集：字符对应的二进制地址的集合</li>
<li>编码方式：一套编码规范可以有多种不同的编码方式（比如 UTF-8，对应的编码规范是 Unicode），一种算法来节约空间</li>
</ul>
<p>常见的编码规范：</p>
<ul>
<li>ASCII 码：7 位码，128 个字符，1 个字节</li>
<li>GBK：汉字内码扩展规范，2 个字节</li>
<li>ISO-8859-1：加了希腊语等，把其他所有的当做 ISO-8859-1 来解都没问题，没有中文，8 位码，1 个字节</li>
<li>Unicode：包含全世界所有的字符，最多 4 个字节</li>
</ul>
<h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>乱码的由来：解码过程、编码过程都可能导致乱码</p>
<h4 id="URL-的编码与解码"><a href="#URL-的编码与解码" class="headerlink" title="URL 的编码与解码"></a>URL 的编码与解码</h4><p>URL 是采用 ASCII 字符集进行编码的</p>
<p><code>%</code> 编码规范：</p>
<ul>
<li>对 URL 中属于 ASCII 字符集的非保留字不做编码</li>
<li>对 URL 中的保留字需要取其 ASCII 内码，然后加上%的前缀对该字符进行编码</li>
<li>对 URL 中非 ASCII 字符需要取其 Unicode 内码，然后加上 <code>%</code> 的前缀对该字符进行编码</li>
</ul>
<blockquote>
<p>Fiddler</p>
</blockquote>
<h3 id="HTTP-协议的基本认证"><a href="#HTTP-协议的基本认证" class="headerlink" title="HTTP 协议的基本认证"></a>HTTP 协议的基本认证</h3><h4 id="常见的认证方式"><a href="#常见的认证方式" class="headerlink" title="常见的认证方式"></a>常见的认证方式</h4><h4 id="BASIC"><a href="#BASIC" class="headerlink" title="BASIC"></a>BASIC</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/BASIC.png" alt="BASIC"></p>
<p>不便捷灵活，且不安全（Base64实际上就是明文传输）</p>
<h4 id="DIGEST"><a href="#DIGEST" class="headerlink" title="DIGEST"></a>DIGEST</h4><p>同样采用质询 / 响应方式，但不会明文传输密码</p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/DIGEST.png" alt="DIGEST"></p>
<p>默认使用md5加密：<br>客户端发送响应摘要 = MD5(HA1:nonce:HA2)<br>其中，HA1 = MD5(username:realm:password), HA2 = MD5(method:digestURI)<br>虽然以前认为是不可逆的加密，但是仍然存在字典攻击、用户被冒充等风险</p>
<h4 id="SSL-客户端"><a href="#SSL-客户端" class="headerlink" title="SSL 客户端"></a>SSL 客户端</h4><p>凭借客户端证书认证</p>
<h4 id="FormBase"><a href="#FormBase" class="headerlink" title="FormBase"></a>FormBase</h4><p>不是在 HTTP 协议中定义的，是使用 Web 应用各自实现的基于表单的认证，通过 Cookie 和 Session 来保持用户登录状态</p>
<h3 id="HTTP-中的长连接和短链接"><a href="#HTTP-中的长连接和短链接" class="headerlink" title="HTTP 中的长连接和短链接"></a>HTTP 中的长连接和短链接</h3><p>HTTP 中的长连接和短链接本质上是 TCP 的长连接和短链接</p>
<ul>
<li>HTTP/1.0 中，默认是短链接，每遇到一个外部资源就建立一个对话</li>
<li>HTTP/1.1 起，默认是长连接</li>
</ul>
<h3 id="中介代理与中介网关"><a href="#中介代理与中介网关" class="headerlink" title="中介代理与中介网关"></a>中介代理与中介网关</h3><h4 id="中介代理"><a href="#中介代理" class="headerlink" title="中介代理"></a>中介代理</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Proxy.png" alt="中介代理"></p>
<p>代理的作用：抓包、匿名访问、过滤器</p>
<h4 id="中介网关"><a href="#中介网关" class="headerlink" title="中介网关"></a>中介网关</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP-Getway.png" alt="中介网关"></p>
<p>扮演协议转换器的角色：</p>
<ul>
<li>(HTTP/) 服务器端网关，通过 HTTP 协议与客户端对话，通过其他协议与服务器通信</li>
<li>(/HTTP) 客户端网关，通过其他协议与客户端对话，通过 HTTP 协议与服务器通信</li>
</ul>
<p>常见网关类型：</p>
<ul>
<li>HTTP/*：服务器端 Web 网关</li>
<li>HTTP/HTTPS：服务器端安全网关</li>
<li>HTTPS/HTTP：客户端安全加速网关（SSL 卸载）</li>
<li>资源网关</li>
</ul>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>缓存的内容：CSS、JS、图片等更新频率不大的静态资源文件</p>
<h4 id="HTTP-缓存头部字段"><a href="#HTTP-缓存头部字段" class="headerlink" title="HTTP 缓存头部字段"></a>HTTP 缓存头部字段</h4><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>请求/响应头，缓存控制字段</p>
</blockquote>
<ul>
<li>no-store：所有内容都不缓存</li>
<li>no-cache：缓存，但浏览器会请求服务器判断资源是否更新</li>
<li>max-age=x：请求缓存后 x 秒不再发起请求</li>
<li>s-maxage=x：类似，但只对 CDN 缓存有效</li>
<li>public：客户端和代理服务器（CDN）都可以缓存</li>
<li>private：只有客户端可以缓存</li>
</ul>
<h5 id="其他头部字段"><a href="#其他头部字段" class="headerlink" title="其他头部字段"></a>其他头部字段</h5><p>响应头，服务器返回：</p>
<ul>
<li><strong>Expires</strong>：代表资源过期时间，是 HTTP/1.0 的属性，比 HTTP/1.1 的 <strong>Cache-Control:max-age=x</strong> 优先级低</li>
<li><strong>Last-Modified</strong>：资源最新修改时间</li>
<li><strong>Etag</strong>：缓存资源标识</li>
</ul>
<p>请求头，服务器提供：</p>
<ul>
<li><strong>if-Modified-Since</strong>：资源最新修改时间，与 <strong>Last-Modified</strong> 是一对，他们会进行对比</li>
<li><strong>if-None-Match</strong>：缓存资源标识，与 <strong>Etag</strong> 是一对（其实就是上次服务器给的 Etag），他们会进行对比</li>
</ul>
<h4 id="HTTP-缓存工作方式"><a href="#HTTP-缓存工作方式" class="headerlink" title="HTTP 缓存工作方式"></a>HTTP 缓存工作方式</h4><h5 id="场景一：让服务器与浏览器约定一个文件过期时间-Expires"><a href="#场景一：让服务器与浏览器约定一个文件过期时间-Expires" class="headerlink" title="场景一：让服务器与浏览器约定一个文件过期时间 Expires"></a>场景一：让服务器与浏览器约定一个文件过期时间 Expires</h5><p>服务器给浏览器一个 Expires，后续请求浏览器会对比当前 <strong>本地时间</strong> 是否已经大于 Expires，超过过期时间再请求。</p>
<p>问题：即使超过过期时间之后，文件可能仍然没有变化</p>
<h5 id="场景二：约定-Expires-的基础上，再通过文件的最新修改时间进行对比-Last-Modified-与-if-Modified-Since"><a href="#场景二：约定-Expires-的基础上，再通过文件的最新修改时间进行对比-Last-Modified-与-if-Modified-Since" class="headerlink" title="场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since"></a>场景二：约定 Expires 的基础上，再通过文件的最新修改时间进行对比 Last-Modified 与 if-Modified-Since</h5><p>服务器给浏览器 Expires 和 Last-Modified，后续若超过 Expires 后，浏览器请求时会带上 if-Modified-Since，服务器进行对比，如果文件未修改，就返回 304 Not Modified，让浏览器使用缓存</p>
<p>问题：浏览器可以随意修改本地时间，而且 Last-Modified 只能精确到秒</p>
<h5 id="场景三：在上面的基础上加上-Etag-If-None-Match，再使用-max-age"><a href="#场景三：在上面的基础上加上-Etag-If-None-Match，再使用-max-age" class="headerlink" title="场景三：在上面的基础上加上 Etag/If-None-Match，再使用 max-age"></a>场景三：在上面的基础上加上 Etag/If-None-Match，再使用 max-age</h5><p>max-age 使用的是 <strong>相对时间</strong>，因此浏览器不能通过修改本地时间的方式来影响缓存，优先级高于 Expires；<br>Etag 优先级也高于 Last-Modified，因为文件只要修改过，Etag 就会发生变化</p>
<p>至此其实 Last-Modified 和 Expires 其实已经没什么用了，但很多时候还是会加上</p>
<p>问题：max-age 或者 Expires 未过期的情况下，若改动文件，应该怎样让浏览器知道？</p>
<h5 id="缓存改进方案"><a href="#缓存改进方案" class="headerlink" title="缓存改进方案"></a>缓存改进方案</h5><h6 id="md5-hash-缓存"><a href="#md5-hash-缓存" class="headerlink" title="md5/hash 缓存"></a>md5/hash 缓存</h6><p>不缓存 html，为静态文件添加 MD5 或者 hash 标识，比如将静态资源的文件名改为 <code>f-hash1.js</code>，若文件修改了，文件名也会改变为 <code>f-hash2.js</code></p>
<h6 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h6><blockquote>
<p>CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p>
</blockquote>
<p>CDN 的作用：</p>
<ol>
<li>减少源站压力</li>
<li>解决跨区域访问问题</li>
</ol>
<p>CDN缓存的工作方式：</p>
<ol>
<li>第一次请求，CDN 和 浏览器同时缓存</li>
<li>浏览器缓存过期后，找 CDN 进行对比，CDN 看自己的过期没有，若自己没过期，就给发给浏览器</li>
</ol>
<h4 id="浏览器操作对-HTTP-缓存的影响"><a href="#浏览器操作对-HTTP-缓存的影响" class="headerlink" title="浏览器操作对 HTTP 缓存的影响"></a>浏览器操作对 HTTP 缓存的影响</h4><div class="table-container">
<table>
<thead>
<tr>
<th>用户操作</th>
<th>Expires/Cache-Control</th>
<th>Last-Modified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址栏回车</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>页面链接跳转</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>新开窗口</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>前进、后退</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>F5 刷新</td>
<td><em>无效</em></td>
<td>有效</td>
</tr>
<tr>
<td>Ctrl+F5 刷新</td>
<td><em>无效</em></td>
<td><em>无效</em></td>
</tr>
</tbody>
</table>
</div>
<h3 id="HTTP-内容协商机制"><a href="#HTTP-内容协商机制" class="headerlink" title="HTTP 内容协商机制"></a>HTTP 内容协商机制</h3><blockquote>
<p>指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以相应资源的语言、字符集、编码方式等作为判断的基准</p>
</blockquote>
<h4 id="内容协商的方式"><a href="#内容协商的方式" class="headerlink" title="内容协商的方式"></a>内容协商的方式</h4><ul>
<li><strong>客户端驱动</strong>：客户端发起请求，服务器发送可选项列表，客户端做出选择后再发送第二次请求</li>
<li><strong>服务器驱动</strong>：服务器检查客户端的请求头部集并决定提供哪个版本的页面<ul>
<li>客户端发送：Accept、Accept-Language、Accept-Charset、Accept-Encoding<ul>
<li><code>Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0</code></li>
</ul>
</li>
<li>服务器返回：Content-Type、Content-Language、Content-Type、Content-Encoding</li>
</ul>
</li>
<li><strong>透明协商</strong>：某个中间设备（通常是缓存代理）代表客户端进行协商</li>
</ul>
<h3 id="HTTP-断点续传和多线程下载"><a href="#HTTP-断点续传和多线程下载" class="headerlink" title="HTTP 断点续传和多线程下载"></a>HTTP 断点续传和多线程下载</h3><p>主要是通过请求头中的 <strong>Range</strong> 和响应头中的 <strong>Content-Range</strong> 实现的，并且若使用断点续传模式返回的状态码都是 206 Partial Content</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>用于请求头中，指定第一个字节的位置和最后一个字节的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range:(unit&#x3D;first byte pos)-[last byte pos]</span><br><span class="line">Range:bytes&#x3D;0-499</span><br><span class="line">Range:bytes&#x3D;-500</span><br><span class="line">Range:bytes&#x3D;500-</span><br><span class="line">Range:bytes&#x3D;500-600,601-999</span><br></pre></td></tr></table></figure>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p>用于响应头中，返回当前接受的范围和文件总大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Range:bytes(unit first byte pos)-[last byte pos]&#x2F;[entity length]</span><br></pre></td></tr></table></figure>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Encryption.png" alt="对称加密"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/AsymEncryption.png" alt="非对称加密"></p>
<p>对称加密效率高，但在密钥分发时存在安全隐患，容易被截获；非对称加密安全性高，但性能低下；因此我们可以先用非对称加密传输对称加密的密钥，之后再用对称加密来传输数据</p>
<h4 id="数字签名与数字证书"><a href="#数字签名与数字证书" class="headerlink" title="数字签名与数字证书"></a>数字签名与数字证书</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-1.png" alt="数字签名"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Signature-2.png" alt="数字签名"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-1.png" alt="数字证书"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Digital-Certificate-2.png" alt="数字证书"></p>
<h3 id="HTTPS-协议概述"><a href="#HTTPS-协议概述" class="headerlink" title="HTTPS 协议概述"></a>HTTPS 协议概述</h3><blockquote>
<p>HTTPS 可以认为是 HTTP + TLS，TLS 是传输层加密协议，他的前身是 SSL 协议</p>
</blockquote>
<p>可以认为 TLS 建立在传输层和应用层之间（会话层），目前常用的版本有 TLS/1.0、1.1、1.2、1.3 和 SSL/3.0，但是 SSL/3.0 可能会存在 ‎POODLE 攻击，TSL/1.0 也存在一些漏洞</p>
<p>HTTPS 功能：</p>
<pre><code>- **内容加密**（非对称加密协商密钥 + 对称加密传输数据）
- **数据完整性**（数字签名）
- **身份认证**（数字证书）
</code></pre><h3 id="HTTPS-使用成本"><a href="#HTTPS-使用成本" class="headerlink" title="HTTPS 使用成本"></a>HTTPS 使用成本</h3><ul>
<li>证书费用以及更新维护</li>
<li>降低用户的访问速度</li>
<li>消耗 CPU 资源</li>
</ul>
<p>HTTPS 对性能的影响：</p>
<ul>
<li>协议交互所增加的网络往返时延（Round-Trip Time）<ul>
<li>有可能用户访问 HTTP，服务器需要返回 302 使其跳转到 HTTPS</li>
<li>TLS 完全握手阶段 1 和 2，以及与 CA 服务器进行连接与验证</li>
</ul>
</li>
<li>加解密相关的计算耗时<ul>
<li>浏览器计算耗时</li>
<li>服务端计算耗时</li>
</ul>
</li>
</ul>
<div class="note warning">
            <p>HTTPS 并不能解决所有的劫持问题</p>
          </div>
<h2 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h2><h3 id="HTTP-协议的瓶颈"><a href="#HTTP-协议的瓶颈" class="headerlink" title="HTTP 协议的瓶颈"></a>HTTP 协议的瓶颈</h3><ul>
<li>单路连接、请求低效，一条连接上只可发送 <strong>一个</strong> 请求，并且严格先入先出（非关键资源阻塞问题）</li>
<li>请求只能 <strong>从客户端开始</strong>，客户端不可以接受除了响应以外的指令，没办法让服务器一更新，客户端就立即更新</li>
<li>头部冗余，请求/响应头部 <strong>不经压缩</strong> 就发送</li>
<li>每次相互发送 <strong>相同的头部</strong> 造成浪费</li>
<li>不强制使用加密</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote>
<p>是为了解决 HTTP 长连接问题而做出的改良协议，与 HTTP 协议有交集</p>
</blockquote>
<p>HTTP 的生命周期是由 Request/Response 确定的，一个 Request 与 一个 Response 对应，且 Response 是被动的。</p>
<p>WebSocket 是持久化协议，</p>
<p>一个典型的 WebSocket 握手：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;   浏览器随机生成的 Base64</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat  用来区分同一个 URL 下不同的服务所需要的协议 </span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>
<p>传统的轮询方式：</p>
<ul>
<li>AJAX 轮询：浏览器每隔几秒发一次请求，询问服务器有没有新消息</li>
<li>长轮询（Long Poll）：采取阻塞的方式，客户端发起连接，如果没有消息，服务器就一直不返回，直到有消息再返回</li>
</ul>
<blockquote>
<p>传统方式问题：太占用资源了，AJAX 轮询需要很高的处理速度，长轮询则需要能容纳很高的并发数</p>
</blockquote>
<p>WebSocket：</p>
<ul>
<li>一次连接，长期有效，服务器有消息的时候再推送（回调）</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebSocket.png" alt="WebSocket"></p>
<p>WebSocket 的主要特点：</p>
<ul>
<li>真正的 <strong>全双工方式</strong>，允许服务器向客户端主动推送数据</li>
<li>减少 <strong>通信量</strong></li>
</ul>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><blockquote>
<p>是谷歌开发的基于 TCP 的应用层协议，为了降低网络延迟，优化用户体验，也是对 HTTP 协议的增强</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SPDY.png" alt="SPDY"></p>
<p>SPDY 的改进：</p>
<ul>
<li>多路复用、请求优化，允许多个请求共用一个 TCP 连接，并且可以设置优先级（避免非关键资源阻塞）</li>
<li>支持服务器推送技术，主要是资源类的推送（比如若浏览器请求了 <code>style.css</code>，服务器就主动再预推送一个 <code>style.js</code>），跟 WebSocket 不同</li>
<li>压缩了 HTTP 头</li>
<li>强制使用 SSL 传输协议</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><blockquote>
<p>可以理解为 SPDY 的升级版</p>
</blockquote>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><blockquote>
<p>HTTP/2.0 性能增强的核心</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Binary-Framing.png" alt="二进制分帧"></p>
<p>在二进制分帧层上，会将原来传输的信息分成更小的帧，并且采用二进制编码；HTTP/2.0 的通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，每个数据流都以消息的形式发送，这些消息由一个或多个帧组成，帧可以乱序发送，最后会根据每个帧上面的流标识符重新组装</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Header-Compression.png" alt="首部压缩"></p>
<p>使用 <strong>首部表</strong> 来跟踪和存储键值对，相同的数据不再通过每次响应和请求发送，通讯期间几乎不会改变 <strong>通用的键值对</strong>，每次只会发送新增或改变的部分头部，首部表在整个连接中有效，会不断更新</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Multiplex.png" alt="多路复用"></p>
<p>所有通信都在一个 TCP 连接上完成，将 HTTP 协议通信的基本单位缩小为帧，让多个数据流共用一个连接，提高利用率</p>
<p>单链接多资源的优势：</p>
<ul>
<li>可以 <strong>减少服务器连接压力</strong>，内存占用少了，连接吞吐量大了</li>
<li>由于 TCP 连接减少而使 <strong>网络拥塞状况</strong> 得以改观</li>
<li>慢启动时间减少，<strong>拥塞</strong> 和 <strong>丢包</strong> 恢复速度更快</li>
</ul>
<h4 id="并行双向字节流"><a href="#并行双向字节流" class="headerlink" title="并行双向字节流"></a>并行双向字节流</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-1.png" alt="并行双向字节流"></p>
<ul>
<li>并行交错地发送请求，请求之间互不影响</li>
<li>并行交错地发送响应，相应之间互不影响</li>
<li>只使用一个连接即可并行发送多个请求和响应</li>
<li>消除不必要的延迟，减少页面加载的时间</li>
</ul>
<h4 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h4><p>高优先级的流都应该优先发送，但也不是绝对的，不同优先级混合发送也是必须的（为了避免首部阻塞等情况）</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/HTTP2-2.png" alt="服务器推送"></p>
<p>服务器可以向客户端额外推送资源</p>
<h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><blockquote>
<p>基于万维网的分布式创作和版本控制，用于管理 Web 服务器的文件</p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/WebDAV.png" alt="WebDAV"></p>
<h3 id="QUIC-和-HTTP-3-0"><a href="#QUIC-和-HTTP-3-0" class="headerlink" title="QUIC 和 HTTP/3.0"></a>QUIC 和 HTTP/3.0</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-HTTP3.0.png" alt="QUIC和HTTP/3.0"></p>
<p>HTTP/2.0 的问题：</p>
<ul>
<li>队头阻塞，如果出现丢包，整个 TCP 连接都需要停下来重传，因为 HTTP/1.1 是建立多个 TCP 连接，所以不会全部都需要停下来</li>
<li>建立连接的握手延迟大，TCP 需要握手，对于短连接场景影响大</li>
</ul>
<p>QUIC 的特性：</p>
<ul>
<li><strong>0 RTT</strong><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-1.png" alt="QUIC建立连接的过程"></li>
<li><strong>没有队头阻塞的多路复用</strong><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Blocking.png" alt="TCP队头阻塞"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-No-Blocking.png" alt="QUIC没有队头阻塞"></li>
<li><strong>前向纠错</strong>，会多发一些冗余的包（校验包），虽然产生了多的包，但是减少了重传带来的损失<br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/QUIC-Error-Correcting.png" alt="前向纠错"></li>
</ul>
<h1 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a>Web 安全</h1><h2 id="Web-安全概述"><a href="#Web-安全概述" class="headerlink" title="Web 安全概述"></a>Web 安全概述</h2><h3 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h3><ul>
<li>由动态脚本、编译过的代码等组合而成</li>
<li>通常架设在 Web 服务器上，用户在 Web 浏览器上发送请求</li>
<li>这些请求使用 HTTP 协议，由 Web 应用和企业后台数据库及其他动态内容通信</li>
</ul>
<h3 id="Web-应用三层架构"><a href="#Web-应用三层架构" class="headerlink" title="Web 应用三层架构"></a>Web 应用三层架构</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Web-Application.png" alt="Web 应用三层架构"></p>
<h3 id="WASC-的定义"><a href="#WASC-的定义" class="headerlink" title="WASC 的定义"></a>WASC 的定义</h3><blockquote>
<p>WASC（Web Application Security Consortium）是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，负责为 WWW 指定广为接受的应用安全标准</p>
</blockquote>
<p>WASC 将应用安全威胁分为六大类：</p>
<ol>
<li>Authentication（验证）</li>
<li>Authorization（授权）</li>
<li>Client-Side Attacks（客户侧攻击）</li>
<li>Command Execution（命令执行）</li>
<li>Information Disclosure（信息暴露）</li>
<li>Logical Attacks（逻辑性攻击）</li>
</ol>
<h3 id="OWASP-的定义"><a href="#OWASP-的定义" class="headerlink" title="OWASP 的定义"></a>OWASP 的定义</h3><blockquote>
<p>OWASP（Open Web Application Security Project）致力于发现和解决不安全 Web 应用的根本原因</p>
</blockquote>
<ol>
<li>Injection（注入）</li>
<li>Broken Authentication（失效的身份认证）</li>
<li>Sensitive Data Exposure（敏感信息泄露）</li>
<li>XXE, XML External Entities（XML 外部实体）</li>
<li>Broken Access Control（失效的访问控制）</li>
<li>Security Misconfiguration（安全配置错误）</li>
<li>XSS, Cross-Site Scripting（跨站脚本）</li>
<li>Insecure Deserialization（不安全的反序列化）</li>
<li>Using Components with Known Vulnerabilities（使用含有已知漏洞的组件）</li>
<li>Insufficient Logging &amp; Monitoring（不足的日志记录和监控）</li>
</ol>
<h2 id="验证机制安全"><a href="#验证机制安全" class="headerlink" title="验证机制安全"></a>验证机制安全</h2><h3 id="什么是验证机制"><a href="#什么是验证机制" class="headerlink" title="什么是验证机制"></a>什么是验证机制</h3><ul>
<li>验证机制是 Web 应用中最简单的一种安全机制。一般来说，应用程序 <strong>必须用户提交的用户名和密码，判断是否允许登录</strong></li>
<li>验证机制是应用程序防御恶意攻击的 <strong>核心机制</strong>，处于安全防御的最前沿，如果缺乏安全有效的验证机制，其他核心安全机制（会话管理和访问控制）都无法实施</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Login-Process.webp" alt="典型的用户登陆流程"></p>
<p>有这样几种常用的验证技术：</p>
<ul>
<li>基于 HTML 表单的验证</li>
<li>多元机制</li>
<li>客户端 SSL 证书</li>
</ul>
<h3 id="验证机制存在的安全隐患"><a href="#验证机制存在的安全隐患" class="headerlink" title="验证机制存在的安全隐患"></a>验证机制存在的安全隐患</h3><h4 id="弱密码"><a href="#弱密码" class="headerlink" title="弱密码"></a>弱密码</h4><p>许多 Web 应用程序没有或很少对用户密码强度进行控制：</p>
<ul>
<li>非常短或空白密码</li>
<li>以常用字典词汇为密码</li>
<li>密码与用户名完全相同</li>
<li>长时间使用默认密码</li>
</ul>
<h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>登陆功能的公开性会诱使攻击者视图猜测用户名和密码，有诸如 Burp Suite 等工具提供了一些常用的字典</p>
<p>为了防止暴力破解，可以使用验证码，而验证码也需要注意几个问题：</p>
<ul>
<li>验证码是否真实有效</li>
<li>验证码的复杂度</li>
<li>应对当前诸如 OCR、打码等技术</li>
</ul>
<p>也可以设置 Cookie 和会话检测，增加失败计数器，当然 Cookie 在客户端可以随意修改</p>
<p>此外现在常用双因子认证（你知道的 + 你拥有的）</p>
<h4 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h4><p>包括问题的答案、邮箱、手机验证码用明文或简单的 MD5 加密等</p>
<h4 id="多阶登录机制"><a href="#多阶登录机制" class="headerlink" title="多阶登录机制"></a>多阶登录机制</h4><p>多次验证检查可能会提高登录机制的安全性，但在这个过程中可能也存在更多的执行缺陷：</p>
<ul>
<li>可能会认为到达第三阶段的用户已经通过了第一二阶段</li>
<li>可能认为每个阶段用户的身份不会变化</li>
<li>有些问题的细节或答案没有保存在服务器上，而是放在隐藏的 HTML 字段中</li>
</ul>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="什么是会话管理"><a href="#什么是会话管理" class="headerlink" title="什么是会话管理"></a>什么是会话管理</h3><ul>
<li>会话管理在用户通过请求提交他们的证书后，<strong>持续</strong> 向应用程序保证用户身份的真实性</li>
<li>由于会话管理机制发挥关键作用，且比较难以发现其漏洞，因此成为针对应用程序的恶意攻击的主要目标，攻击者若能破坏应用程序的会话管理，就能轻易避开验证机制</li>
</ul>
<h3 id="会话管理的安全隐患"><a href="#会话管理的安全隐患" class="headerlink" title="会话管理的安全隐患"></a>会话管理的安全隐患</h3><h4 id="会话令牌生成漏洞"><a href="#会话令牌生成漏洞" class="headerlink" title="会话令牌生成漏洞"></a>会话令牌生成漏洞</h4><p>通过简单的用户名、电子邮件经过简单的编码、加密生成的，不安全</p>
<h5 id="令牌可预测"><a href="#令牌可预测" class="headerlink" title="令牌可预测"></a>令牌可预测</h5><p>令牌有一定的模式和规则、时间依赖</p>
<h5 id="随机数强度不足"><a href="#随机数强度不足" class="headerlink" title="随机数强度不足"></a>随机数强度不足</h5><p>计算机中的数据极少完全随机，一般通过软件使用各种技巧生成伪随机数</p>
<h4 id="会话传输漏洞"><a href="#会话传输漏洞" class="headerlink" title="会话传输漏洞"></a>会话传输漏洞</h4><p>尽可能缩短一个会话的寿命可以降低攻击者截获、猜测或滥用有效会话的风险</p>
<h5 id="会话终止攻击"><a href="#会话终止攻击" class="headerlink" title="会话终止攻击"></a>会话终止攻击</h5><p>有一些应用程序没有有效的会话终止功能，他的有效期非常长</p>
<p>有些时候，退出功能并不能帮助服务器终止会话，比如只是简单地删除客户端的 Cookie，我们需要让服务端的会话失效</p>
<h5 id="会话劫持攻击"><a href="#会话劫持攻击" class="headerlink" title="会话劫持攻击"></a>会话劫持攻击</h5><p>攻击者通过网络嗅探、XSS 攻击等方式截获令牌</p>
<h3 id="会话管理漏洞的防御"><a href="#会话管理漏洞的防御" class="headerlink" title="会话管理漏洞的防御"></a>会话管理漏洞的防御</h3><ul>
<li><strong>令牌传输过程</strong>：令牌只能通过 HTTPS 传送，让浏览器不能通过 HTTP 传送令牌</li>
<li><strong>增加软硬会话过期</strong><ul>
<li>软会话过期：一定时间没有交互之后，Session 失效</li>
<li>应会话过期：经过一定时间之后，不管用户做什么，会话都会过期</li>
</ul>
</li>
<li><strong>提供完善的注销功能</strong></li>
</ul>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>Web 程序经常会建立用户提交数据的 SQL 语句，但如果建立 SQL 语句的方法不安全，则容易造成 SQL 注入漏洞</p>
<h3 id="SQL-注入危害"><a href="#SQL-注入危害" class="headerlink" title="SQL 注入危害"></a>SQL 注入危害</h3><ul>
<li><strong>探知数据库的具体结构</strong>，为进一步攻击做准备</li>
<li><strong>泄露数据</strong>，尤其是机密信息、账户信息等</li>
<li><strong>获得更高权限</strong>，来修改数据甚至是内部结构</li>
</ul>
<h3 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h3><ul>
<li><strong>参数化查询</strong>：最根本性的防御<ul>
<li>指定查询结构，用户输入预留占位符</li>
<li>指定占位符的内容</li>
</ul>
</li>
</ul>
<h2 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h2><p>攻击者通常通过注入 HTML 或 JS 脚本发动攻击，攻击成功后，攻击者可以得到私密网页内容和 Cookie 等</p>
<h3 id="XSS-攻击危害"><a href="#XSS-攻击危害" class="headerlink" title="XSS 攻击危害"></a>XSS 攻击危害</h3><ul>
<li><strong>盗号</strong></li>
<li><strong>控制数据</strong>，读取、篡改、添加、删除敏感数据</li>
<li><strong>非法转账</strong></li>
<li><strong>网站挂马</strong></li>
<li><strong>控制肉鸡</strong></li>
</ul>
<h3 id="XSS-攻击分类"><a href="#XSS-攻击分类" class="headerlink" title="XSS 攻击分类"></a>XSS 攻击分类</h3><h4 id="反射式-XSS-攻击"><a href="#反射式-XSS-攻击" class="headerlink" title="反射式 XSS 攻击"></a>反射式 XSS 攻击</h4><p>又称非永久性 XSS，是目前最流行的 XSS 攻击</p>
<p>出现在服务器直接使用客户端提交的数据，比如 URL 数据、HTML 表单等，并且没有对数据进行无害化处理，这些数据中藏着一些可执行脚本，最常见的方式就是恶意连接，其中包含了 XSS 攻击脚本</p>
<h4 id="存储式-XSS-攻击"><a href="#存储式-XSS-攻击" class="headerlink" title="存储式 XSS 攻击"></a>存储式 XSS 攻击</h4><p>又称永久性 XSS，危害更大</p>
<p>攻击者将脚本上传到 Web 服务器上，使得所有访问该页面的用户都面临信息泄露的可能</p>
<p>多发生在个人信息字段、文档或上传的文件及其他数据的名称、提交给应用程序管理员的反馈或问题、向其他用户传送的信息、在用户之间共享的上传文件内容</p>
<h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击仅仅通过 JavaScript 执行，常发生在应用程序每次返回相同的静态 HTML，而客户端 JavaScript 动态生成信息，并不会跟服务端交互获取的时候</p>
<h3 id="XSS-攻击载荷"><a href="#XSS-攻击载荷" class="headerlink" title="XSS 攻击载荷"></a>XSS 攻击载荷</h3><ul>
<li><strong>会话令牌</strong>：XSS 攻击最普遍的方式，截取受害者的会话令牌，劫持他的会话</li>
<li><strong>虚拟置换</strong>：向 Web 应用程序页面注入恶意数据（修改页面），没有修改保存在服务器上保存的内容，而是通过程序处理来显示置换</li>
<li><strong>注入木马</strong>：比如突然弹出一个对话框（木马登录表单），诱导你输入用户密码</li>
</ul>
<h3 id="XSS-防御措施"><a href="#XSS-防御措施" class="headerlink" title="XSS 防御措施"></a>XSS 防御措施</h3><ul>
<li><strong>输入验证</strong><ul>
<li>数据不是太长</li>
<li>数据仅包含合法字符</li>
<li>数据与正则表达式匹配</li>
<li>对不同的数据类型（比如账号、邮箱等）设置不同的规则</li>
</ul>
</li>
<li><strong>输出编码</strong><ul>
<li>对数据进行 HTML 编码，使用 HTML 实体代替字面量字符，净化可能的恶意字符</li>
</ul>
</li>
</ul>
<h2 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h2><p>典型的流程如下：</p>
<ol>
<li>受害者登录 <code>a.com</code>，并且保留了登录凭证（Cookie）</li>
<li>攻击者诱使受害者访问 <code>hack.com</code></li>
<li><code>hack.com</code> 向 <code>a.com</code> 发送请求：<code>a.com/act=xx</code> 浏览器默认会携带上 <code>a.com</code> 的 <code>Cookie</code></li>
<li><code>a.com</code> 收到请求后，确认是受害者的凭证，误认为是受害者自己发送的请求</li>
<li><code>a.com</code> 以受害者的名义执行了 <code>act=x</code></li>
</ol>
<h3 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h3><h4 id="GET-类型的-CSRF"><a href="#GET-类型的-CSRF" class="headerlink" title="GET 类型的 CSRF"></a>GET 类型的 CSRF</h4><p>这个类型非常简单，一般只需要一个 HTTP 请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bank.example/withraw?amount=10000&amp;for=hacker"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在受害者访问有这个 img 的页面之后，浏览器会自动向 <code>http://bank.example/withraw?amount=10000&amp;for=hacker</code> 发送请求</p>
<h4 id="POST-类型的-CSRF"><a href="#POST-类型的-CSRF" class="headerlink" title="POST 类型的 CSRF"></a>POST 类型的 CSRF</h4><p>这类攻击通常是使用一个自动提交的表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://bank.example/withdraw"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"xiaoming"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"for"</span> <span class="attr">value</span>=<span class="string">"hacker"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="链接类型的-CSRF"><a href="#链接类型的-CSRF" class="headerlink" title="链接类型的 CSRF"></a>链接类型的 CSRF</h4><p>需要用户点击链接才会触发：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://bank.example/withraw?amount=10000&amp;for=hacker"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSRF-的特点"><a href="#CSRF-的特点" class="headerlink" title="CSRF 的特点"></a>CSRF 的特点</h3><ul>
<li>攻击一般发起在 <strong>第三方网站</strong>，而不是被攻击的网站（通常是 <strong>跨域</strong> 的），因此被攻击的网站无法防止攻击的发生</li>
<li>攻击者利用受害者的登陆凭证，而不是直接盗取数据</li>
<li>攻击者仅仅是 <strong>利用</strong> 受害者的登录凭证，而 <strong>不能获取</strong> 到这个凭证</li>
<li>跨站请求可以用各种方式：图片、超链接、CORS、Form 表单等，部分请求可以直接嵌入第三方论坛、文章中，难以进行追踪</li>
<li>通常是跨域的，但有时候也可以在 <strong>本域</strong> 进行，比如在论坛和评论区可以发图和连接，这种攻击更加危险</li>
</ul>
<h3 id="CSRF-防御措施"><a href="#CSRF-防御措施" class="headerlink" title="CSRF 防御措施"></a>CSRF 防御措施</h3><p>针对 CSRF 通常是跨域请求，并且攻击者只是冒用、而无法真正获得 Cookie 的特点，可以采取以下策略：</p>
<ul>
<li><strong>阻止不明外域的访问</strong><ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
</li>
<li><strong>提交时要求附加本域才能获得的信息</strong><ul>
<li>CSRF Token</li>
<li>双重 Cookie 验证</li>
</ul>
</li>
</ul>
<h4 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h4><p>可以通过 <strong>Origin Header</strong> 和 <strong>Referer Header</strong> 来判断请求是否来自外域</p>
<p>对于 Origin 有两个问题：</p>
<ul>
<li>IE 11 不会在 CORS 请求上添加 Origin 标头</li>
<li>302 重定向之后，Origin 不再包含在重定向之后的请求中</li>
</ul>
<p>对于 Referer 也有问题：</p>
<ul>
<li>每个浏览器对于 Referer 的实现可能有差别，不能保证浏览器自身没有安全漏洞</li>
<li>攻击请求可能隐藏 Referer</li>
</ul>
<p>当 Origin 和 Referer 都不存在的时候，建议直接阻止访问</p>
<p>，同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这有时候也有问题，比如搜索引擎来的请求也会被当做疑似 CSRF 攻击，并且安全性并不是很高</p>
<h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h4><ol>
<li><strong>将 CSRF Token 输出到页面中</strong>，用户打开页面时，需要给用户生成一个 Token，可以将这个 Token 保存在 Session 中，同时给页面上所有的 a 标签 和 form 标签后面加入这个 Token</li>
<li><strong>页面提交的请求携带这个 Token</strong></li>
<li><strong>服务器验证 Token 是否正确</strong></li>
</ol>
<h4 id="分布式校验"><a href="#分布式校验" class="headerlink" title="分布式校验"></a>分布式校验</h4><p>使用一种计算出来的结果而不是随机生成的字符串作为 Token，这样在校验的时候就无需读取存储的 Token，只需要再计算一次即可</p>
<h4 id="双重-Cookie-验证"><a href="#双重-Cookie-验证" class="headerlink" title="双重 Cookie 验证"></a>双重 Cookie 验证</h4><p>因为攻击者实际上无法知道 Cookie 里面的内容，所以只需要让 AJAX 和表单请求中携带一个 Cookie 中的值，后端接口验证 Cookie 中的字段与请求参数中的字段是否相同，这样可以减小后端服务器 Session 存储的压力</p>
<p>但是也有一些问题：</p>
<ol>
<li>如果用户访问 <code>www.a.com</code>，后端域名为 <code>api.a.com</code>，那么在 <code>www.a.com</code> 下就拿不到 <code>api.a.com</code> 的 Cookie</li>
<li>于是这个认证必须种在 <code>a.com</code> 下</li>
<li>于是任意子域名都可以修改 <code>a.com</code> 下的 Cookie</li>
<li>如果某个子域名存在漏洞被 XSS 攻击，那么攻击者就可以修改 <code>a.com</code> 下的 Cookie</li>
<li>攻击者就可以使用自己配置的 Cookie，对用户在 <code>www.a.com</code> 下发起 CSRF 攻击</li>
</ol>
<h4 id="Samesite-Cookie"><a href="#Samesite-Cookie" class="headerlink" title="Samesite Cookie"></a>Samesite Cookie</h4><p>Google 起草了一份草案来改进 HTTP 协议，就是为 <code>Set-Cookie</code> 响应头增加 <code>Samesite</code> 属性，表明这个 Cookie 是个 <strong>同站 Cookie</strong></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><blockquote>
<p>TCP 面向连接、可靠、面向字节流；UDP 面向无连接</p>
</blockquote>
<ol>
<li><strong>面向连接</strong>。TCP 需要三次握手建立连接，UDP 则不需要</li>
<li><strong>可靠</strong>。TCP <strong>有状态</strong>，会记录哪些数据发送了，哪些数据对方接受了，哪些数据丢失了，不允许差错；TCP <strong>可控制</strong>，会根据丢包的情况或者状态，调整自己的行为，比如控制速度或者重发</li>
<li><strong>面向字节流</strong>。UDP 的数据传输是面向数据报的，TCP 为了维护状态，将 IP 包变成了字节流。</li>
</ol>
<p>所谓 <strong>面向数据报</strong> 是指，应用层交给 UDP 多长的 <strong>报文</strong>，UDP 就照样发送，一次发送一个报文；而面向字节流是指，TCP 虽然一次接收应用层来的一个数据块（大小不等），但 TCP 把应用程序看成一连串无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就会把它划分得短一些再发送；如果应用程序一次只发送一个字节，TCP 也可以等待积累足够多的字节后再构成报文段发送出去。</p>
<h2 id="TCP-的三次握手与四次挥手"><a href="#TCP-的三次握手与四次挥手" class="headerlink" title="TCP 的三次握手与四次挥手"></a>TCP 的三次握手与四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>三次握手是需要确认双方的 <strong>发送能力</strong> 和 <strong>接收能力</strong></p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Handshake.png" alt="TCP三次握手"></p>
<h4 id="三次握手的过程中可以携带数据吗？"><a href="#三次握手的过程中可以携带数据吗？" class="headerlink" title="三次握手的过程中可以携带数据吗？"></a>三次握手的过程中可以携带数据吗？</h4><p>前两次不能，第三次可以，此时客户端已经处于 ESTABLISHED 状态，确认了服务器发送、接受信息的能力正常</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Wavehand.png" alt="TCP四次挥手"></p>
<p>服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN。因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN。这就造成了四次挥手。</p>
<h3 id="半连接队列与-SYN-Flood"><a href="#半连接队列与-SYN-Flood" class="headerlink" title="半连接队列与 SYN Flood"></a>半连接队列与 SYN Flood</h3><p>三次握手之前，在服务器状态从 CLOSED 变为 LISTEN 的时候，还在内部创建了两个队列：<strong>半连接队列</strong> 和 <strong>全连接队列</strong></p>
<h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>又称 <strong>SYN 队列</strong>，当客户端发送 SYN 到服务端，服务端收到后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 <strong>半连接队列</strong></p>
<h4 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h4><p>又称 <strong>ACCEPTED 队列</strong>，当客户端返回 ACK，服务端接收后，三次握手完成，连接等待被某个具体的应用取走，在被取走之前，会被推入 <strong>全连接队列</strong></p>
<h4 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h4><p>属于典型的 Dos/DDos 攻击，用客户端在短时间内伪造大量不存在的 IP 地址，疯狂发送 SYN，使得服务器：</p>
<ol>
<li>处理大量 SYN 包并返回 ACK，使得 <strong>半连接队列爆满</strong></li>
<li>由于是不存在的 IP，服务端长时间 <strong>收不到客户端的 ACK</strong>，就会疯狂重发数据，直到耗尽服务器资源</li>
</ol>
<h5 id="如何应对-SYN-Flood-攻击？"><a href="#如何应对-SYN-Flood-攻击？" class="headerlink" title="如何应对 SYN Flood 攻击？"></a>如何应对 SYN Flood 攻击？</h5><ol>
<li><strong>增加半连接队列容量</strong></li>
<li><strong>减少 SYN + ACK 的重试次数</strong></li>
<li><strong>利用 SYN Cookie 技术</strong>，在服务端接收到 SYN 后不立即分配链接资源，而是根据 SYN 计算出一个 Cookie，连通第二次握手一同发给客户端，客户端回复 ACK 的时候带上 Cookie，服务端验证合法后才分配链接资源</li>
</ol>
<h2 id="TCP-报文"><a href="#TCP-报文" class="headerlink" title="TCP 报文"></a>TCP 报文</h2><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header.png" alt="TCP报文头"></p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>即 Sequence Number，指的是本报文段的第一个字节的序列号，长度为 4 个字节，可以：</p>
<ol>
<li>在 SYN 报文中交换彼此的初始序列号</li>
<li>保证数据包按照正确的顺序组装</li>
</ol>
<h5 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h5><p>即 Initial Sequence Number，在三次握手的过程中，双方会通过 SYN 报文来交换彼此的 ISN，ISN 会动态增长，每 4ms 就加 1，溢出则回到 0。动态增长的 ISN 增加了猜测 ISN 的难度</p>
<h4 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h4><p>即 ACK（Acknowledgement Number），用来告知对方下一个期望接收的序列号，小于 ACK 的所有字节已经全部接收到</p>
<h4 id="标记位"><a href="#标记位" class="headerlink" title="标记位"></a>标记位</h4><p>占用一个字节，常见的标记位有 SYN、ACK、FIN、RST、PSH。</p>
<ul>
<li>SYN：Synchronize，表示同步，用来开始请求</li>
<li>ACK：Acknowledge，表示确认</li>
<li>FIN：Finish，表示发送方准备断开连接</li>
<li>RST：Reset，用来强制断开连接</li>
<li>PSH：Push，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存</li>
</ul>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>占用两个字节，但实际上不够用，因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因此可以将窗口值扩大为原来的 2 ^ n 倍</p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃、等待重传</p>
<h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Header-Options.png" alt="可选项"></p>
<p>常用的可选项有：</p>
<ul>
<li>Timestamp：TCP 时间戳</li>
<li>MSS：TCP 允许的从对方接收的最大报文段</li>
<li>SACK：选择确认选项</li>
<li>Window Scale：窗口缩放</li>
</ul>
<h5 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h5><p>Timestamp 一共占 10 个字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind(1 Byte) + length(1 Byte) + info(8 Bytes)</span><br></pre></td></tr></table></figure>
<p>其中 <code>kind=8</code> <code>length=10</code>，<code>info</code> 由 <code>timestamp</code> 和 <code>timestamp echo</code> 两部分构成，各占四个字节</p>
<p>TCP 的时间戳主要解决两个问题：</p>
<ul>
<li>计算往返时延（RTT, Round-Trip Time）</li>
<li>防止序列号回绕</li>
</ul>
<h6 id="计算-RTT"><a href="#计算-RTT" class="headerlink" title="计算 RTT"></a>计算 RTT</h6><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Timestamp-RTT.png" alt="计算RTT"></p>
<h6 id="防止序列号回绕"><a href="#防止序列号回绕" class="headerlink" title="防止序列号回绕"></a>防止序列号回绕</h6><p>因为序列号的长度是有限的，若超出容纳的范围，就会回到 0，时间戳使得两个序列号相同的报文也能得以区分</p>
<h2 id="TFO"><a href="#TFO" class="headerlink" title="TFO"></a>TFO</h2><blockquote>
<p>TCP Fast Open，优化后的 TCP 三次握手流程，也是基于 SYN Cookie 技术</p>
</blockquote>
<h3 id="TFO-流程"><a href="#TFO-流程" class="headerlink" title="TFO 流程"></a>TFO 流程</h3><p>首轮的三次握手：</p>
<ol>
<li>客户端发送 <strong>SYN</strong> 给服务端</li>
<li>服务端计算得到一个 <strong>SYN Cookie</strong>，将这个 Cookie 放到 TCP 报文的 Fast Open 选项中，再继续三次握手</li>
<li>客户端把 <strong>Cookie</strong> 缓存下来，继续三次握手</li>
</ol>
<p>后续的三次握手：</p>
<ol>
<li>客户端将之前缓存的 <strong>Cookie、SYN 和 HTTP 请求</strong> 发送给服务端</li>
<li>服务端验证 Cookie 的合法性，如果合法就正常返回 <strong>SYN + ACK</strong>，同时可以给客户端发 <strong>HTTP 响应</strong></li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TFO.png" alt="TFO"></p>
<h2 id="TCP-超时重传"><a href="#TCP-超时重传" class="headerlink" title="TCP 超时重传"></a>TCP 超时重传</h2><blockquote>
<p>在间隔一段时间没有等到这个数据包回复时，将会重传这个数据包</p>
</blockquote>
<h3 id="超时重传时间的计算"><a href="#超时重传时间的计算" class="headerlink" title="超时重传时间的计算"></a>超时重传时间的计算</h3><p>重传的间隔被称为超时重传时间（RTO, Retransmission TimeOut），他的计算跟 RTT 密切相关，有两种主要的方法：经典方法和标准方法</p>
<h4 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h4><blockquote>
<p>平滑往返时间（SRTT, Smoothed Round-Trip Time）是根据 RTT 和之前的 SRTT 计算出来的一个值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRTT &#x3D; (α * SRTT) + ((1 - α) * RTT)</span><br><span class="line">初始的 SRTT 为 0</span><br></pre></td></tr></table></figure>
<p>α 即为 <strong>平滑因子</strong>，建议值是 0.8，范围是 0.8 ~ 0.9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTO &#x3D; min(ubound, max(lbound, β * SRTT))</span><br></pre></td></tr></table></figure>
<p>其中，β 是 <strong>加权因子</strong>，一般为 1.3 ~ 2.0，<strong>lbound 是 下界</strong>，<strong>ubound 是上界</strong></p>
<p>在 RTT 变化较大的地方不太适用，因为 RTT 对 RTO 影响太小</p>
<h4 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h4><p>又称 Jacobson / Karels 算法</p>
<ol>
<li><strong>计算 SRTT</strong>：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRTT &#x3D; (α * SRTT) + ((1 - α) * RTT)</span><br></pre></td></tr></table></figure>
<p>α 的建议值是 <strong>0.125</strong></p>
<ol>
<li>**计算中间变量 RTTVAR（Round-Trip Time Variation）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTTVAR &#x3D; (1 - β) * RTTVAR + β * (|RTT - SRTT|)</span><br></pre></td></tr></table></figure>
<p>β 的建议值是 <em>0.25*</em></p>
<ol>
<li>计算 RTO</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTO &#x3D; µ * SRTT + ∂ * RTTVAR</span><br></pre></td></tr></table></figure>
<p>µ 建议值取 1, ∂ 建议值取 4</p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>TCP 会把需要发送的数据放到 <strong>发送缓存区</strong>，需要接收的数据放到 <strong>接收缓存区</strong></p>
<p>流量控制则是通过 <strong>控制接收缓存区的大小</strong>，来控制发送端的发送，如果接收方的接收缓存区满了，就不能再发送了</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 滑动窗口分为 <strong>发送窗口</strong> 和 <strong>接收窗口</strong></p>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window.png" alt="TCP发送窗口"></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Send-Window-2.png" alt="TCP发送窗口"></p>
<p>SND 即为 send，WND 即为 window，UNA 即为 unacknowledged，NXT 即为 next</p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/TCP-Receive-Window.png" alt="TCP接收窗口"></p>
<p>REV 即为 receive</p>
<p>简单来说，接受端如果处理能力不够用了，想让发送端少发点，就会将自己的接收窗口大小（相当于缓冲队列，也就是还可以装的部分）在 ACK 报文首部加上，发给发送端，发送端收到之后调解自己发送窗口的大小</p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>流量控制主要是考虑到 <strong>发送端</strong> 和 <strong>接受端</strong> 的情况，而没有考虑到整个网络环境的影响，拥塞控制则是考虑整体网络环境的好坏</p>
<p>对于拥塞控制，TCP 每条连接都需要维护两个核心状态：</p>
<ul>
<li>拥塞窗口（CWND, Congestion Window）</li>
<li>慢启动阈值（SSThresh, Slow Start Threshold）</li>
</ul>
<p>涉及这几个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传和快速恢复</li>
</ul>
<h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>指的是目前自己还能传输的数据量大小，与上面的接收窗口不同，是 <strong>发送端</strong> 的限制</p>
<p>发送窗口最终的大小取 <strong>接收窗口</strong> 和 <strong>拥塞窗口</strong> 中的小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送窗口大小 &#x3D; min(RWND, CWND)</span><br></pre></td></tr></table></figure>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>由于刚接入网络传输数据的时候，并不知道网络的状态，所以不能操之过急，拥塞控制会采用保守的算法来慢慢适应网络</p>
<ul>
<li>首先，三次握手，双方宣告自己 <strong>接收窗口（RWND）</strong> 的大小</li>
<li>双方初始化自己 <strong>拥塞窗口（CWND）</strong> 的大小</li>
<li>在开始传输的一段时间，发送端每收到 1 个 ACK，拥塞窗口大小 <strong>+ 1</strong>，也就是说，每经过 1 个 RTT，CWND 翻倍，直到 CWND 达到 <strong>慢启动阈值</strong></li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当 CWND 达到慢启动阈值时，CWND 每次只能 <strong>+ 1 / CWND</strong>，也就是说，1 个 RTT 之后，CWND 只能增加 1</p>
<h3 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h3><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>解决的是 <strong>是否需要重传</strong> 的问题</p>
<p>当接受端发现丢包后，后续 ACK 一律回复为最后一个好包，因此当发送端发现接收到重复的 ACK，意识到丢包，就马上重传，而不是等一个 RTO</p>
<p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传</p>
<h4 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h4><p>解决的是 <strong>如何重传的问题</strong></p>
<p>接受端会回复一个 ACK 报文，在首部可选项中有 <strong>SACK</strong> 属性，通过 <strong>left edge</strong> 和 <strong>right edge</strong> 告知发送端已经接收到了哪些区间的数据包，进行 <strong>选择性重传（SACK, Selective Acknowledgement）</strong>，比如上面的例子，不会再传第 6、7 个包</p>
<h4 id="快速回复"><a href="#快速回复" class="headerlink" title="快速回复"></a>快速回复</h4><p>当发送端知道丢包之后，觉得网络可能有点拥塞，即会进入 <strong>快速恢复</strong> 阶段，发送端会做出如下改变：</p>
<ul>
<li>拥塞阈值降为 CWND 的一半</li>
<li>CWND 的大小变为拥塞阈值</li>
<li>CWND 线性增加</li>
</ul>
<h2 id="Nagle-算法与延迟确认"><a href="#Nagle-算法与延迟确认" class="headerlink" title="Nagle 算法与延迟确认"></a>Nagle 算法与延迟确认</h2><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><blockquote>
<p>为了避免频繁发送小包而诞生</p>
</blockquote>
<ul>
<li>第一次发送数据的时候不用等待，即使是再小的包也马上发送</li>
<li>后面发送的包需要满足下面条件之一：<ul>
<li>数据包大小达到最大子段大小（MSS, Max Segment Size）</li>
<li>之前所有包的 ACK 都已经接受到</li>
</ul>
</li>
</ul>
<h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><blockquote>
<p>为了避免频繁回复小包而诞生</p>
</blockquote>
<p>TCP 要求延迟的时延必须小于 500ms，一般的操作系统都不会超过 200ms</p>
<p>一些场景收到之后会马上回复：</p>
<ul>
<li>收到了大于一个 frame 的报文，且需要调整窗口大小</li>
<li>TCP 处于 quickack 模式（通过 <code>tcp_in_quickack_mode</code> 设置）</li>
<li>发现了乱序包</li>
</ul>
<h2 id="TCP-的-keep-alive"><a href="#TCP-的-keep-alive" class="headerlink" title="TCP 的 keep-alive"></a>TCP 的 keep-alive</h2><p>由于 TCP 不是一个轮询的协议，他无法获知对端连接失效的情况（比如对端网络故障或宕机），<strong>keep-alive</strong> 则是用于探测对端的连接是否失效，但是因为探测的时间比较长，所以一般不怎么用</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>概念</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小问题：排序</title>
    <url>/hais-notebook/2020/02/28/CS-Algorithm-QA-sort/</url>
    <content><![CDATA[<p>介绍几种简单的排序方法。</p>
<p>可以看 <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener">这个网站</a> 的动图</p>
<a id="more"></a>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次从剩下的部分选择最小的排到前面来，O(n^2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> minIndex = <span class="function"><span class="params">numbers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[i] &lt; numbers[index]) &#123;</span><br><span class="line">      index = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="params">numbers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = minIndex(numbers.slice(i))</span><br><span class="line">    <span class="keyword">if</span> (i !== index) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = numbers[index]</span><br><span class="line">      numbers[index] = numbers[i]</span><br><span class="line">      numbers[i] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>找出 Pivot，把小于 Pivot 的放左边，大于 Pivot 的放右边，最好 O(nlogn)，最坏 O(n^2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">numbers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) <span class="keyword">return</span> numbers</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(numbers.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> pivot = numbers.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[i] &lt;= pivot) &#123;</span><br><span class="line">      left.push(numbers[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(numbers[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>两两比较，如果后者比前者小，则交换，最终每次循环使得最大数冒泡到最后去（O(n^2)，最好 O(n)）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">numbers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> length = numbers.length</span><br><span class="line">  <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (numbers[i + <span class="number">1</span>] &lt; numbers[i]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = numbers[i + <span class="number">1</span>]</span><br><span class="line">        numbers[i + <span class="number">1</span>] = numbers[i]</span><br><span class="line">        numbers[i] = temp</span><br><span class="line">        swapped = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!swapped) <span class="keyword">break</span></span><br><span class="line">    length--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES6 的新玩意儿</title>
    <url>/hais-notebook/2020/02/28/JS-ES6/</url>
    <content><![CDATA[<p>关于 ES6 新增的一些东西，这里的 ES6 泛指 ES6 及之后出现的各种新语法。</p>
<a id="more"></a>
<h1 id="ES6-常用语法"><a href="#ES6-常用语法" class="headerlink" title="ES6 常用语法"></a>ES6 常用语法</h1><p>作用域、箭头函数、默认参数、展开运算符、模板字符串、解构赋值、import export、class、for of、Generator、新的数据类型（Symbol、Map、Set）</p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h2 id="生成器执行流程"><a href="#生成器执行流程" class="headerlink" title="生成器执行流程"></a>生成器执行流程</h2><p>生成器是一个带星号的“函数”（其实他并不是真正的函数），可以通过 yield 关键字暂停执行和恢复执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter'</span>)</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>gen()</code> 之后，程序会阻塞住，不会执行任何语句</li>
<li>调用 <code>g.next()</code> 之后，程序会继续执行，直到遇到 <code>yield</code></li>
<li><code>next</code> 方法会返回一个对象，有 <code>value</code> 和 <code>done</code> 属性，<code>value</code> 为 当前 <code>yield</code> 后面的结果，<code>done</code> 表示是否执行完，遇到 <code>return</code> 后，<code>done</code> 变为 <code>true</code></li>
</ol>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* gen2()</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会按 1 2 3 4 的顺序执行</span></span><br></pre></td></tr></table></figure>
<h2 id="生成器的实现机制：协程"><a href="#生成器的实现机制：协程" class="headerlink" title="生成器的实现机制：协程"></a>生成器的实现机制：协程</h2><p>一个线程可以存在多个协程，协程不受操作系统的管理，而是被具体的应用程序代码所控制，因此没有进程的上下文切换的开销，性能高。</p>
<p>一个线程一次只能执行一个协程，可以通过 <code>yield</code> 暂停当前协程，并将 JS 线程的控制权转移给另一个协程。</p>
<h2 id="Generator-与异步"><a href="#Generator-与异步" class="headerlink" title="Generator 与异步"></a>Generator 与异步</h2><h3 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h3><p>thunk 函数即偏函数，核心是接受一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能，相当于一群函数的抽象和封装</p>
<h3 id="Generator-与异步-1"><a href="#Generator-与异步-1" class="headerlink" title="Generator 与异步"></a>Generator 与异步</h3><h4 id="thunk"><a href="#thunk" class="headerlink" title="thunk"></a>thunk</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFileThunk = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="comment">// value 值即为 thunk 生成的定制化函数</span></span><br><span class="line">g.next().value(<span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到上一次的结果，调用 next，将结果作为参数传入</span></span><br><span class="line">  g.next(data1).value(<span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    g.next(data2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将上面的代码进行封装，减少嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.next(data)</span><br><span class="line">    <span class="keyword">if</span> (res.done) <span class="keyword">return</span></span><br><span class="line">    res.value(next)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line">run(g)</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>也可以用 Promise 来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFilePromise(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFilePromise(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGenPromise</span>(<span class="params">gem ,data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.next(data).value</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(g).then(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data1)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 实现部分 API</title>
    <url>/hais-notebook/2020/02/23/JS-SourceCode/</url>
    <content><![CDATA[<p>实现一些常见的 API。</p>
<a id="more"></a>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot read property "map" of null or undefined'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callback) !== <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">'is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 草案中提到要先转换为对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> T = thisArg</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 右移 0 位，可以把前面的空位用 0 填充，实际上是为了保证 len 为数字且为整数，因为位运算会丢弃小数</span></span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Array</span>(len)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k]</span><br><span class="line">      A[k] = callback.call(T, kValue, k, O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot read property "reduce" of null or undefined'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callback) !== <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">'is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k]</span><br><span class="line">        k++</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Each element of array is empty'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callback.call(<span class="literal">undefined</span>, accumulator, O[k], k, O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myPush = <span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> argCount = items.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="comment">// 2 ** 53 - 1 是 JS 能表示的最大整数</span></span><br><span class="line">  <span class="keyword">if</span> (len + argCount &gt; <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The number of array is over the max value restricted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; argCount; i++) &#123;</span><br><span class="line">    O[len + i] = items[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newLength = len + argCount</span><br><span class="line">  O.length = newLength</span><br><span class="line">  <span class="keyword">return</span> newLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myPop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  len--</span><br><span class="line">  <span class="keyword">let</span> value = O[len]</span><br><span class="line">  <span class="keyword">delete</span> O[len]</span><br><span class="line">  O.length = len</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot read property "filter" of null or undefined'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callback) !== <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">'is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(thisArg)</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i]</span><br><span class="line">      <span class="keyword">if</span> (callback.call(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceDeleteElements = <span class="function">(<span class="params">array, startIndex, deleteCount, deleteArray</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      deleteArray[i] = array[index]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果增加与删除一样多，就不动</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.length) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果删除比新增多，就左移</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; addElements.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i</span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.length)</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除因为挪动而空出来的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.length - deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果删除比新增少，就右移</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; addElements.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i</span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.length - deleteCount)</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeStartIndex = <span class="function">(<span class="params">startIndex, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len : startIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeDeleteCount = <span class="function">(<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认 startIndex 及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) <span class="keyword">return</span> len - startIndex</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) <span class="keyword">return</span> len - startIndex</span><br><span class="line">  <span class="keyword">return</span> deleteCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.mySplice = <span class="function"><span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="built_in">arguments</span>.length</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.length</span><br><span class="line">  <span class="keyword">let</span> deleteArray = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数清洗，如果用户传来非法值怎么办</span></span><br><span class="line">  startIndex = computeStartIndex(startIndex, len)</span><br><span class="line">  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 seal 对象和 frozen 对象</span></span><br><span class="line">  <span class="comment">// 密封对象不可扩展，不能添加、删除方法和属性，但可以修改属性值</span></span><br><span class="line">  <span class="comment">// 冻结对象还不能修改属性值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.isSealed(array) &amp;&amp; deleteCount !== addElements.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a sealed object'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.isFrozen(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a frozen object'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArray)</span><br><span class="line">  <span class="comment">// 移动原来的数组中的元素</span></span><br><span class="line">  movePostElements(array, startIndex, len, deleteCount, addElements)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.length; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i]</span><br><span class="line">  &#125;</span><br><span class="line">  array.length = len - deleteCount + addElements.length</span><br><span class="line">  <span class="keyword">return</span> deleteArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>在 V8 引擎中</p>
<ul>
<li>n &lt;= 10 时，采用插入排序</li>
<li>n &gt; 10 时，采用三路快速排序<ul>
<li>10 &lt; n &lt;= 1000，采用中位数作为哨兵元素</li>
<li>n &gt; 1000，每隔 200~215 个元素选出一个元素，放到一个新数组，然后对他排序，找到中间位置的数，以此作为中位数</li>
</ul>
</li>
</ul>
<h3 id="插入排序及其优化"><a href="#插入排序及其优化" class="headerlink" title="插入排序及其优化"></a>插入排序及其优化</h3><p>原来的插入排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; arr[j]; j--) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">      arr[j - <span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用变量覆盖的方式替代交换元素：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/3/16e3124af5479387?imageslim" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找哨兵元素"><a href="#寻找哨兵元素" class="headerlink" title="寻找哨兵元素"></a>寻找哨兵元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getPivotIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tempArr = []</span><br><span class="line">  <span class="comment">// 递增量在 200~215 之间</span></span><br><span class="line">  <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>)</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">from</span> += <span class="number">1</span></span><br><span class="line">  to -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">    tempArr[j] = [i, a[i]]</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">  tempArr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> tempArr[tempArr.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完成快排"><a href="#完成快排" class="headerlink" title="完成快排"></a>完成快排</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _sort = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [a, b, c]</span><br><span class="line">  innsetSort(arr, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 为了确保 pivot 不是最值，将他和 from to 一起排序</span></span><br><span class="line">  [a[<span class="keyword">from</span>], a[pivotIndex], a[to - <span class="number">1</span>]] = _sort(a[<span class="keyword">from</span>], a[pivotIndex], a[to - <span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> pivot = a[pivotIndex]</span><br><span class="line">  <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> highStart = to - <span class="number">1</span></span><br><span class="line">  a[pivotIndex] = a[lowEnd]</span><br><span class="line">  a[lowEnd] = pivot</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="原版-Promise-的基本用法"><a href="#原版-Promise-的基本用法" class="headerlink" title="原版 Promise 的基本用法"></a>原版 Promise 的基本用法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'FULFILLED'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="第一步：创建-class-MyPromise"><a href="#第一步：创建-class-MyPromise" class="headerlink" title="第一步：创建 class MyPromise"></a>第一步：创建 class MyPromise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123; <span class="comment">// handle 即为 (resolve, reject) =&gt; &#123;...&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'MyPromise must accept a function as parameter'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步：处理-MyPromise-的状态和值"><a href="#第二步：处理-MyPromise-的状态和值" class="headerlink" title="第二步：处理 MyPromise 的状态和值"></a>第二步：处理 <code>MyPromise</code> 的状态和值</h2><p>原版 Promise 对象存在三种状态：<code>Pending</code> <code>Fulfilled</code> <code>Rejected</code></p>
<div class="note warning">
            <p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或 <code>Reject</code>，并且之后不能再变化</p>
          </div>
<p><code>resolve</code> 会将 Promise 对象的状态变为 <code>FulFilled</code>，而 <code>reject</code> 则会将其变为 <code>Pending</code></p>
<p>而原版 Promise 的值说的是状态改变时传递给回调函数的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'MyPromise must accept a function as parameter'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 执行 handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 resolve</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>._status = FULFILLED</span><br><span class="line">    <span class="keyword">this</span>._value = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 reject</span></span><br><span class="line">  _reject(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>._status = REJECTED</span><br><span class="line">    <span class="keyword">this</span>._value = err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三步：实现-then-方法"><a href="#第三步：实现-then-方法" class="headerlink" title="第三步：实现 then 方法"></a>第三步：实现 <code>then</code> 方法</h2><p><code>then</code> 方法支持链式调用，可以用两个数组来实现回调队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'MyPromise must accept a function as parameter'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._fulfilledQueues = []</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._rejectedQueues = []</span><br><span class="line">    <span class="comment">// 执行 handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 resolve</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>._status = FULFILLED</span><br><span class="line">    <span class="keyword">this</span>._value = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 reject</span></span><br><span class="line">  _reject(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>._status = REJECTED</span><br><span class="line">    <span class="keyword">this</span>._value = err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 then</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;_value, _status&#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 成功时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilledNext(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(value)</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              onFulfilledNext(next)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          onRejectedNext(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(onFulfilled)</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(onRejected)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          onFulfilled(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          onRejected(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h1><h2 id="模拟实现的思路"><a href="#模拟实现的思路" class="headerlink" title="模拟实现的思路"></a>模拟实现的思路</h2><p>我们有一个对象和一个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果我们把 <code>bar</code> 变成 <code>foo</code> 的一个属性，那么就可以不使用 <code>call</code> 了，<code>this</code> 会被隐式地传递过去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以借鉴这样的思路，我们先将函数加到对象的属性上，调用之后再删除掉即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.fn = bar</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.fn()</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.fn</span><br></pre></td></tr></table></figure>
<h2 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h2><h3 id="第一步：传递-this"><a href="#第一步：传递-this" class="headerlink" title="第一步：传递 this"></a>第一步：传递 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mayCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：传递-arguments"><a href="#第二步：传递-arguments" class="headerlink" title="第二步：传递 arguments"></a>第二步：传递 arguments</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步：解决其他问题"><a href="#第三步：解决其他问题" class="headerlink" title="第三步：解决其他问题"></a>第三步：解决其他问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call 可能传入原始类型，bug 是 falsy 都会变成 window</span></span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>  </span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 处理函数的返回值</span></span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="comment">// 这里不需要区分有没有 args，因为如果没有传值，他的值将会是空数组 []</span></span><br><span class="line">  <span class="comment">// 你仍然可以使用 ...[] 来展开</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照同样的思路我们也可以模拟 apply：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意这里要区分的原因是，如果没有传入 args，那么他的值就是 undefined</span></span><br><span class="line">  <span class="comment">// 你无法对 undefined 进行展开，而且他的报错是：</span></span><br><span class="line">  <span class="comment">// VM8558:1 Uncaught TypeError: context.fn is not iterable (cannot read property Symbol(Symbol.iterator))</span></span><br><span class="line">  <span class="comment">// 而不是 undefined is not iterable</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用 ES3 的写法来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">  <span class="comment">// eval 表示把里面的字符串当做 JS 代码来执行</span></span><br><span class="line">  <span class="comment">// 这句话相当于执行 context.fn( arguments[1], arguments[2], ...)</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="一个简单实现"><a href="#一个简单实现" class="headerlink" title="一个简单实现"></a>一个简单实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span> <span class="comment">// 存下这个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...newArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(context, args.concat(newArgs)) <span class="comment">// 支持柯里化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源于 MDN 上提供的 polyfill</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.proptotype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为 arguments 是伪数组，他没有 slice 方法</span></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 这是考虑到了要使用 new 来调用 bind 的返回值的情况</span></span><br><span class="line">          <span class="comment">// 如果使用 new 调用，new 具有最高优先级，函数的 this 由 new 确定，而不是 bind</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</span><br><span class="line">                 ? <span class="keyword">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">          <span class="comment">// 柯里化</span></span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下面这两句相当于 fBound.prototype = Object.create(this.prototype)，是比较古老的写法</span></span><br><span class="line">    <span class="comment">// 是为了让 this instanceof fNOP 变得有意义</span></span><br><span class="line">    <span class="comment">// 这样，如果使用 new 运算符</span></span><br><span class="line">    <span class="comment">// 那么 fBound 中的 this instanceof fBound === true</span></span><br><span class="line">    <span class="comment">// 同时也有 this instanceof fNOP === true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>在 <code>new</code> 的时候，做了这样几件事情：</p>
<ol>
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>构造函数.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(fun.prototype)</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    <span class="comment">// let newObj = &#123;&#125;</span></span><br><span class="line">    <span class="comment">// newObj.__proto__ = fun.prototype</span></span><br><span class="line">    <span class="keyword">const</span> result = fun.apply(newObj, args)</span><br><span class="line">    <span class="comment">// 原版的 new 中，如果构造函数返回一个对象，则 new 也返回一个对象；如果构造函数返回一个简单类型，则 new 返回刚刚创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：Webpack</title>
    <url>/hais-notebook/2020/02/14/Others-QA-Webpack/</url>
    <content><![CDATA[<p>关于 Webpack 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="如何提高构建速度？"><a href="#如何提高构建速度？" class="headerlink" title="如何提高构建速度？"></a>如何提高构建速度？</h1><ul>
<li>happypack 使用多线程打包</li>
<li>dllplugin</li>
</ul>
<h1 id="webpack-文件过大："><a href="#webpack-文件过大：" class="headerlink" title="webpack 文件过大："></a>webpack 文件过大：</h1><ul>
<li>提取通用模块文件</li>
<li>压缩 JS、CSS、图片</li>
<li>按需加载</li>
</ul>
<p>zhuanlan.zhihu.com/p/44438844</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/hais-notebook/2020/02/14/Collections-TS/</url>
    <content><![CDATA[<p>从各种地方收集来的关于 TypeScript 的话题。</p>
<a id="more"></a>
<h1 id="readonly-与-const"><a href="#readonly-与-const" class="headerlink" title="readonly 与 const"></a><code>readonly</code> 与 <code>const</code></h1><blockquote>
<p>The easiest way to remember whether to use readonly or const is to ask whether you’re using it on a variable or a property. Variables use const whereas properties use readonly.</p>
</blockquote>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <categories>
        <category>前端</category>
        <category>收集</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>这一秒是你的，下一秒就是我的</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：React</title>
    <url>/hais-notebook/2020/02/13/Others-QA-React/</url>
    <content><![CDATA[<p>关于 React 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="React-实现组件间通信？"><a href="#React-实现组件间通信？" class="headerlink" title="React 实现组件间通信？"></a>React 实现组件间通信？</h1><ol>
<li>父子组件：通过 props 直接传参（onChange、onClick）</li>
<li>爷孙组件：传两次 props</li>
<li>任意组件：Redux</li>
</ol>
<h1 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h1><h2 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h2><p>Reconciliation 直译为协调，即 React 的渲染机制，他有以下几步：</p>
<ol>
<li>props 或 state 改变</li>
<li>render 函数返回不同的元素树（虚拟 DOM）</li>
<li>新旧 DOM 对比（vDOM Diff）</li>
<li>针对差异的地方进行更新</li>
<li>渲染为真实的 DOM 树</li>
</ol>
<h2 id="DOM-Diff-原理"><a href="#DOM-Diff-原理" class="headerlink" title="DOM Diff 原理"></a>DOM Diff 原理</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol>
<li>永远只比较同层的节点，不会跨层级比较</li>
<li>不同的两个节点产生不同的树（两个类型不同的节点直接用新的全部替代旧的，包括其后代）</li>
<li>通过 key 判断哪些元素是相同的（比如列表如果没有 key，从头部插入元素会导致列表全部更新），因此 key 需要在列表中保持唯一（不需要全局唯一）</li>
</ol>
<h3 id="比较流程"><a href="#比较流程" class="headerlink" title="比较流程"></a>比较流程</h3><ul>
<li>若元素类型不相同：直接用新的树替换掉原来的树</li>
<li>若元素类型相同：<ul>
<li>若都是 DOM 节点：更新 DOM 属性，比如 <code>style</code>、<code>title</code> 等，再向下递归找</li>
<li>若都是组件节点：组件实例保持不变，更新 Props</li>
</ul>
</li>
</ul>
<h2 id="如何减少-Diff-过程"><a href="#如何减少-Diff-过程" class="headerlink" title="如何减少 Diff 过程"></a>如何减少 Diff 过程</h2><blockquote>
<p>利用 <code>shouldComponentUpdate</code></p>
</blockquote>
<p>默认的 <code>shouldComponentUpdate</code> 会在 props 或 state 发生变化的时候返回 true，表示组件会重新渲染，然后调用 render 函数，进行 vDOM Diff；相对的，我们也可以通过控制它的返回值来控制是否发生 vDOM Diff</p>
<h2 id="浅比较与深比较"><a href="#浅比较与深比较" class="headerlink" title="浅比较与深比较"></a>浅比较与深比较</h2><ul>
<li>类组件的 <code>shouldComponentUpdate</code> 中可以对 props 和 state 进行浅比较（使用 <code>pureComponent</code> API，比较一层 key 和 value，类似于浅拷贝），也可以进行深比较（递归）</li>
<li>函数组件使用 <code>memo</code> 方法可以进行肩比较，但是只比较了 props：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Component)</span><br></pre></td></tr></table></figure>
<h2 id="immutable-数据结构"><a href="#immutable-数据结构" class="headerlink" title="immutable 数据结构"></a>immutable 数据结构</h2><p>immutable 的意义：浅比较缺点很明显，深比较有时候又比较浪费性能</p>
<p>简单来说：</p>
<ol>
<li><strong>节省性能</strong>：immutable 内部采用多叉树结构，如果它里面有节点被改变，那么则更新 <strong>这个节点</strong> 和他有关的所有 <strong>上级节点</strong></li>
<li><strong>返回一个新的引用</strong>，即使是浅比较也能感知到数据的变化</li>
</ol>
<h3 id="一些-immutable-API"><a href="#一些-immutable-API" class="headerlink" title="一些 immutable API"></a>一些 immutable API</h3><h4 id="fromJS"><a href="#fromJS" class="headerlink" title="fromJS"></a>fromJS</h4><p>将 JS 对象转换为 immutable 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"><span class="keyword">const</span> immutableState = fromJS (&#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h4><p>将 immutable 对象转换为 JS 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsObj = immutableState.toJS()</span><br></pre></td></tr></table></figure>
<h4 id="get-getIn"><a href="#get-getIn" class="headerlink" title="get/getIn"></a>get/getIn</h4><p>用来获取 immutable 对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = fromJS(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.get(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.a.b</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = fromJS(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">// 传入一个数组</span></span><br></pre></td></tr></table></figure>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>用来给 immutable 对象的属性赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = fromJS(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.set(<span class="string">'a'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>新旧数据对比，旧数据中不存在的属性直接添加，存在的属性用新数据覆盖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = fromJS(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.merge(&#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：Vue</title>
    <url>/hais-notebook/2020/02/13/Others-QA-Vue/</url>
    <content><![CDATA[<p>关于 Vue 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="Vue-组件间的通信？"><a href="#Vue-组件间的通信？" class="headerlink" title="Vue 组件间的通信？"></a>Vue 组件间的通信？</h1><ol>
<li>父子组件：<code>$emit</code> 和 <code>$on</code></li>
<li>爷孙组件、兄弟组件：eventBus</li>
<li>Vuex</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：HTTP</title>
    <url>/hais-notebook/2020/02/13/Others-QA-HTTP/</url>
    <content><![CDATA[<p>关于 HTTP 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><blockquote>
<p>MD5</p>
</blockquote>
<p>实际上还是会发请求，命中了一般就是 304 Not Modified</p>
<h2 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h2><blockquote>
<p>日期</p>
</blockquote>
<p>时间点，可以通过修改本地时间改变</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><blockquote>
<p>max-age=600</p>
</blockquote>
<p>时间段，是相对时间；而且是无请求的</p>
<h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>浏览器缓存顺序</p>
<h1 id="GET-和-POST-的区别？"><a href="#GET-和-POST-的区别？" class="headerlink" title="GET 和 POST 的区别？"></a>GET 和 POST 的区别？</h1><ul>
<li>GET 不安全，POST 不安全（其实都不安全）</li>
<li>GET 是有长度限制的，POST 没有长度限制（但一般 GET 的长度不超过 1 KB，POST 上限 4M ~ 20M 左右）</li>
<li>GET 参数在 URL 中，POST 消息在消息体中</li>
<li>GET 只需要一个报文，POST 需要两个以上（因为有消息体）</li>
<li>GET 幂等，POST 不幂等</li>
<li>语义不同，GET 是为了获取数据，POST 是为了提交数据</li>
</ul>
<h1 id="HTTP-2-和-HTTP-1-的区别"><a href="#HTTP-2-和-HTTP-1-的区别" class="headerlink" title="HTTP/2 和 HTTP/1 的区别"></a>HTTP/2 和 HTTP/1 的区别</h1>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：DOM</title>
    <url>/hais-notebook/2020/02/13/Others-QA-DOM/</url>
    <content><![CDATA[<p>关于 DOM 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ul.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(e.target.tagName.toLowerCase() === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击了 li'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bindEvent = <span class="function">(<span class="params">element, eventType, selector, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  element.addEventListener(eventType, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> el = e.target</span><br><span class="line">    <span class="keyword">while</span> (!el.matches(selector)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (el === element) &#123;</span><br><span class="line">        el = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      el = el.parentNode</span><br><span class="line">    &#125;</span><br><span class="line">    el &amp;&amp; fn.call(el, e)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用-mouse-事件写一个可拖拽的-div"><a href="#用-mouse-事件写一个可拖拽的-div" class="headerlink" title="用 mouse 事件写一个可拖拽的 div"></a>用 mouse 事件写一个可拖拽的 div</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dragging = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> position = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'mousedown'</span>, (e) =&gt; &#123;</span><br><span class="line">  dragging = <span class="literal">true</span></span><br><span class="line">  position = [e.clientX, e.clientY]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragging) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> x = e.clientX</span><br><span class="line">  <span class="keyword">const</span> y = e.clientY</span><br><span class="line">  <span class="keyword">const</span> deltaX = x - position[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> deltaY = y - position[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> left = <span class="built_in">parseInt</span>(div.style.left || <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> top = <span class="built_in">parseInt</span>(div.style.top || <span class="number">0</span>)</span><br><span class="line">  div.style.left = left + deltaX + <span class="string">'px'</span></span><br><span class="line">  div.style.top = top + deltaY + <span class="string">'px'</span></span><br><span class="line">  position = [x, y]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mouseup'</span>, (e) =&gt; &#123;</span><br><span class="line">  dragging = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>简单算法：数组</title>
    <url>/hais-notebook/2020/02/11/CS-Algorithm-Array/</url>
    <content><![CDATA[<p>一些数组中涉及到的算法的题解。</p>
<a id="more"></a>
<h1 id="电话号码的组合（公式运算）"><a href="#电话号码的组合（公式运算）" class="headerlink" title="电话号码的组合（公式运算）"></a>电话号码的组合（公式运算）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</span><br><span class="line">给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> telComb = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = [<span class="string">''</span>, <span class="number">1</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  <span class="keyword">const</span> num = str.split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 保存键盘映射后的字母内容，比如 23 =&gt; ['abc', 'def']</span></span><br><span class="line">  <span class="keyword">const</span> code = []</span><br><span class="line">  num.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[item]) &#123;</span><br><span class="line">      code.push(map[item])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> combine = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">1</span>].length; j++) &#123;</span><br><span class="line">        result.push(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归的精髓，用临时结果 result 替换掉前面两项</span></span><br><span class="line">    arr.splice(<span class="number">0</span>, <span class="number">2</span>, result)</span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      combine(arr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> combine(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="卡牌分组-（归类运算）"><a href="#卡牌分组-（归类运算）" class="headerlink" title="卡牌分组 （归类运算）"></a>卡牌分组 （归类运算）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一副牌，每张牌上都写着一个整数。</span><br><span class="line">此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</span><br><span class="line">每组都有 X 张牌。</span><br><span class="line">组内所有的牌上都写着相同的整数。</span><br><span class="line">仅当你可选的 X &gt;&#x3D; 2 时返回 true。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; deck.length &lt;&#x3D; 10000</span><br><span class="line">0 &lt;&#x3D; deck[i] &lt; 10000</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<p>问题的核心是求最大公约数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">辗转相除： gcd(a, b) &#x3D; gcd(b, a % b)</span><br><span class="line">更相减损： gcd(a, b) &#x3D; a &gt; b ? gcd(a - b, b) : gcd(a, b - a)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cardGroup = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  <span class="keyword">const</span> str = arr.sort().join(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 再将相同的进行分组（多张或者单张为一组）</span></span><br><span class="line">  <span class="keyword">const</span> group = str.match(<span class="regexp">/(\d)\1+|\d/g</span>)</span><br><span class="line">  <span class="comment">// 求最大公约数</span></span><br><span class="line">  <span class="keyword">const</span> gcd = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进入处理之前检查，如果 group 为空或者 group.length === 1，就不找公约数</span></span><br><span class="line">  <span class="keyword">while</span> (group.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = group.shift().length</span><br><span class="line">    <span class="keyword">const</span> b = group.shift().length</span><br><span class="line">    <span class="keyword">const</span> v = gcd(a, b)</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      group.unshift(<span class="string">'0'</span>.repeat(v))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 group 为空，或者每组的数量小于 1，则为 false</span></span><br><span class="line">  <span class="keyword">return</span> group.length ? group[<span class="number">0</span>].length &gt; <span class="number">1</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="种花问题（筛选运算）"><a href="#种花问题（筛选运算）" class="headerlink" title="种花问题（筛选运算）"></a>种花问题（筛选运算）</h1><h1 id="格雷编码（二进制运算）"><a href="#格雷编码（二进制运算）" class="headerlink" title="格雷编码（二进制运算）"></a>格雷编码（二进制运算）</h1>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>慕课网</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：数据结构</title>
    <url>/hais-notebook/2020/02/10/Others-QA-DataStructure/</url>
    <content><![CDATA[<p>关于数据结构的一些问题与答案。</p>
<a id="more"></a>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>按照一定的规则（有很多种不同的规则，可以按实际情况选择）去存储数据，这样找数据的时候就会很快了。<br>有时候会出现冲突（不同的数据根据规则计算应该放到同样的地方），这个时候需要解决冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length = 1000) &#123;</span><br><span class="line">    <span class="keyword">this</span>.slots = <span class="built_in">Array</span>(length) <span class="comment">// slots 就是哈希表的这个数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算出要存的位置，这里的方法是：将这个字符串的每一位的 ASCII 码算出来，再把每一位的加起来，再%哈希表的总长度</span></span><br><span class="line">  hash(v) &#123;</span><br><span class="line">    <span class="comment">// 将字符串解构为一个个的数组</span></span><br><span class="line">    <span class="keyword">let</span> value =[...v.toString()].map(<span class="function"><span class="params">char</span> =&gt;</span> char.charCodeAt(<span class="number">0</span>)).reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item)</span><br><span class="line">    <span class="keyword">return</span> value%<span class="keyword">this</span>.slots.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存数据，因为 hash 值可能相同，所以用 push</span></span><br><span class="line">  add(value) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">this</span>.hash(value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.slots[key]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.slots[key].includes((value))) <span class="keyword">this</span>.slots[key].push[value]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.slots[key] = [value]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删数据</span></span><br><span class="line">  remove(value)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">this</span>.hash(value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.slots[key] &amp;&amp; <span class="keyword">this</span>.slots[key].includes(value)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.slots[key] = <span class="keyword">this</span>.slots[key].filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== value)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  search(value)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">this</span>.hash(value)</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="keyword">this</span>.slots[key] &amp;&amp; <span class="keyword">this</span>.slots[key].includes(value));</span><br><span class="line">  &#125;</span><br><span class="line">  show()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.slots)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>顶点：vertex<br>边：edge</p>
<p>可以这样表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[V1, V2, V4], [V0, V2, V3], [V0, V1], [V1], [V0]]</span><br></pre></td></tr></table></figure>
<p>每一个数组表示对应的顶点与那些点相邻</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vCount) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertexCount = vCount <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">this</span>.adjacencyList = [...Array(vCount)].map(<span class="function"><span class="params">v</span> =&gt;</span> []) <span class="comment">// 相邻顶点的列表，得到类似于数组 [[], [], [], []]</span></span><br><span class="line">    <span class="keyword">this</span>.verticesStatus = [...Array(vCount)].map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="literal">false</span>) <span class="comment">// 记录点是不是找过了</span></span><br><span class="line">  &#125;</span><br><span class="line">  addEdge(v1, v2) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adjacencyList[v1].push(v2)</span><br><span class="line">    <span class="keyword">this</span>.adjacencyList[v2].push(v1)</span><br><span class="line">  &#125;</span><br><span class="line">  showGraph() &#123;</span><br><span class="line">    <span class="keyword">this</span>.adjacencyList.forEach(<span class="function">(<span class="params">adjVertices, v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;v&#125;</span> -&gt; <span class="subst">$&#123;adjVertices.toString()&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  resetStatus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.verticesStatus = [...Array(<span class="keyword">this</span>.vertexCount)].map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 深度优先搜索</span></span><br><span class="line">  dfs(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.verticesStatus[v] = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`访问到：<span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// Array.isArray 判断传递进来的是否是一个 Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.adjacencyList[v])) &#123;</span><br><span class="line">      <span class="keyword">this</span>.adjacencyList[v].forEach(<span class="function"><span class="params">adjVertex</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.verticesStatus[adjVertex]) <span class="keyword">this</span>.dfs(adjVertex)      </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 广度优先搜索</span></span><br><span class="line">  bfs(v) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    queue.push(v)</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = queue.shift()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.verticesStatus[v]) <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">this</span>.verticesStatus[v] = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`访问到 <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">this</span>.adjacencyList[v].forEach(<span class="function"><span class="params">adjVertex</span> =&gt;</span> &#123;</span><br><span class="line">        queue.push(adjVertex)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件</title>
    <url>/hais-notebook/2020/02/09/Vue-Component/</url>
    <content><![CDATA[<p>记录 Vue Component 中的内容。</p>
<a id="more"></a>
<h1 id="Vue-组件的三种写法"><a href="#Vue-组件的三种写法" class="headerlink" title="Vue 组件的三种写法"></a>Vue 组件的三种写法</h1><ol>
<li>用 JS 对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 TS 类</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'source/_posts/Others-QA-Vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Component, Prop&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// components: &#123;...&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> MyComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  num: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Prop</span>(<span class="built_in">Number</span>) propA: <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">  add(num: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num ++;</span><br><span class="line">  &#125;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.propA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 JS 类</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Component, Prop&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  @Prop(<span class="built_in">Number</span>) propA</span><br><span class="line">  add(num) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num ++;</span><br><span class="line">  &#125;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.propA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 基本用法</title>
    <url>/hais-notebook/2020/02/06/TS-Trail/</url>
    <content><![CDATA[<p>TypeScript 三个好处： 1. 自动提示更智能；2. 不能随便写 .xxx()；3. 错误前移到编译时 </p>
<a id="more"></a>
<h1 id="TS-中的类型"><a href="#TS-中的类型" class="headerlink" title="TS 中的类型"></a>TS 中的类型</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>TS 中的原始类型包括 <code>boolean</code> <code>number</code> <code>string</code> <code>void</code> <code>undefined</code> <code>null</code> <code>symbol</code> <code>bigint</code>，与 JS 不同的是多了 <code>void</code> 和 <code>bigint</code> 这两个：</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>表示没有任何类型，相当于 <code>undfined | null</code>，通常用在一个函数没有返回值时（<code>undefiend</code>）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h3 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h3><p>主要是为了解决大数超过精度范围的问题的，需要注意的是 <code>bigint</code> 与 <code>number</code> 是两种类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max: bigint = BigInt(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> max1: bigint = max + <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">const</span> max2: bigint = max + <span class="number">2n</span>;</span><br><span class="line"></span><br><span class="line">max1 !== max2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><ul>
<li><p><strong>顶级类型</strong>：<code>any</code> <code>unknown</code><br>*计算机类型系统理论中的顶级类型（Top Type）通常是指某种包含了所有可能类型的类型，其他所有的类型都是其子类型</p>
</li>
<li><p><strong>底部类型</strong>：<code>never</code><br>*与顶级类型相反，底部类型（Bottom Type）又称为零类型（Zero）或空类型（Empty），表示什么都没有，他是任何类型的子类型，甚至连 <code>undefiend</code> 或者 <code>null</code> 都不能赋值给 <code>never</code></p>
</li>
<li><p><strong>非原始类型</strong>：<code>object</code> <code>array</code> <code>tuple</code> 等</p>
</li>
</ul>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>有些时候，我们在编程阶段还不知道某个变量的类型，比如来自用户的输入或者第三方代码库，我们用 <code>any</code> 可以让他通过类型检查</p>
<div class="note warning">
            <p>但是注意，尽量不用 <code>any</code>，因为会造成蝴蝶效应，可能导致很严重的问题</p>
          </div>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p><code>unknow</code> 是 TypeScript 3.0 引入的比 <code>any</code> 更加安全的类型，区别是有时候需要一些必要的检查：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = Symbol(<span class="string">'type'</span>);</span><br><span class="line">value = &#123;&#125;;</span><br><span class="line">value = [];</span><br></pre></td></tr></table></figure>
<p><code>unknown</code> 也可以是任何类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = Symbol(<span class="string">'type'</span>);</span><br><span class="line">value = &#123;&#125;;</span><br><span class="line">value = [];</span><br></pre></td></tr></table></figure>
<p>区别在于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value.foo.bar;</span><br><span class="line">value();</span><br><span class="line"><span class="keyword">new</span> value();</span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>而 <code>unknow</code> 则不能</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line">value.foo.bar; <span class="comment">// ERROR</span></span><br><span class="line">value();       <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">new</span> value();   <span class="comment">// ERROR</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>];   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<p>你得通过某种方式确认 <code>value</code> 的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value: unknown</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.toISOString()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code> 是任何类型的子类型，可以赋值给任何类型，然而没有别的类型可以赋值给 <code>never</code>，下面是一些例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出异常的函数不会有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，而且永远是空的</span></span><br><span class="line"><span class="keyword">const</span> empty: never[] = []</span><br></pre></td></tr></table></figure>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>有两种方式可以定义一个数组：</p>
<ul>
<li>使用泛型：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li>在元素后面加上 <code>[]</code><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元祖与数组的不同是，元素的各元素类型不必相同：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>, <span class="literal">false</span>]; <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="string">'hello'</span>];            <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>];        <span class="comment">// ERROR</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>];        <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>注意元祖元素的顺序不同也会报错，类型检查比数组严格；并且元祖还有越界问题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'a'</span>, <span class="number">1</span>];</span><br><span class="line">tuple.push(<span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple); <span class="comment">// 元素正常打印</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]); <span class="comment">// Tuple type '[string, number]' of length '2' has no element at index '2'</span></span><br></pre></td></tr></table></figure>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>事实上，普通对象、枚举、数组、元素都是 <code>object</code> 类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Center = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value: object;</span><br><span class="line"></span><br><span class="line">value = Direction;</span><br><span class="line">value = [<span class="number">1</span>];</span><br><span class="line">value = [<span class="number">1</span>, <span class="string">'hello'</span>];</span><br><span class="line">value = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>通常在某个变量只有几种可能的取值时，可以使用枚举类型</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>若没有赋值，默认就是从 0 开始的数字枚举：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Direction.Up === <span class="number">0</span>;   <span class="comment">// true</span></span><br><span class="line">Direction.Down === <span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>若给第一个赋值为数字，则后面则会累加：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">10</span>,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Direction.Up === <span class="number">10</span>;   <span class="comment">// true</span></span><br><span class="line">Direction.Down === <span class="number">11</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>枚举类型的值也可以是字符串类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">'Up'</span>,</span><br><span class="line">    Down = <span class="string">'Down'</span>,</span><br><span class="line">    Left = <span class="string">'Left'</span>,</span><br><span class="line">    Right = <span class="string">'Right'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>但是通常不这样写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举可以进行反向映射，因为他会被编译成诸如 <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code> 的语句，<em>而字符串枚举则不具备这样的特性</em>，并且也不推荐这样做（<code>Potentially invalid target of indexed property access</code>）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Direction[<span class="number">0</span>]); <span class="comment">// Up</span></span><br></pre></td></tr></table></figure>
<h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>我们可以将枚举使用 <code>const</code> 声明为常量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'Up'</span>,</span><br><span class="line">  Down = <span class="string">'Down'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = Direction.Up</span><br></pre></td></tr></table></figure>
<p>这时将会被编译为 <code>const a = &#39;Up&#39;</code>，而不是之前的 <code>const a = Direction.Up</code>——这可以提升性能，除非添加编译选项 <code>--preserveConstEnums</code> 使他保留对象 <code>Direction</code></p>
<h3 id="联合枚举"><a href="#联合枚举" class="headerlink" title="联合枚举"></a>联合枚举</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> a: Direction; <span class="comment">// 可以看成声明了联合类型 Direction.Up | Direction.Down | Direction.Left | Direction.Right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Animal &#123;</span><br><span class="line">  Dog,</span><br><span class="line">  Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = Direction.Up; <span class="comment">// OK</span></span><br><span class="line">a = Animal.Dog;   <span class="comment">// Assigned expression type Animal.Dog is not assignable to type Direction</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举合并"><a href="#枚举合并" class="headerlink" title="枚举合并"></a>枚举合并</h3><p>分开声明的枚举会自动合并，而不会发生冲突</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'Up'</span>,</span><br><span class="line">  Down = <span class="string">'Down'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Center = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>一个简单的栗子，包括只读属性、可选属性和函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  readonly isMale: <span class="built_in">boolean</span></span><br><span class="line">  say: <span class="function">(<span class="params">words: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性检查"><a href="#属性检查" class="headerlink" title="属性检查"></a>属性检查</h2><p>有时候会出现这样的情况：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">config: Config</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> square = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    square = config.width * config.width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> square</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = calc(&#123;x: <span class="number">5</span>&#125;) <span class="comment">// Argument type &#123;x: number&#125; is not assignable to parameter type Config</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>使用类型断言<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = calc(&#123;x: <span class="number">5</span>&#125; <span class="keyword">as</span> Config)</span><br></pre></td></tr></table></figure></li>
<li>添加字符串索引签名，这样 <code>Config</code> 就可以拥有任意数量的属性了<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>转化为 <code>any</code></li>
</ul>
<h2 id="可索引属性"><a href="#可索引属性" class="headerlink" title="可索引属性"></a>可索引属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> VIPUser <span class="keyword">extends</span> User, SuperUser &#123;</span><br><span class="line">  broadcast: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code> 关键字可以用于定义一个抽象类或在抽象类中定义抽象方法，抽象类是专门用来派生的，一般不会被实例化</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</span><br><span class="line">  move(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'roaming the earth...'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接使用 new Animal() 创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  makeSound() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'miaou~'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">cat.makeSound(); <span class="comment">// 'miaou~'</span></span><br><span class="line">cat.move(); <span class="comment">// 'roaming the earth...'</span></span><br></pre></td></tr></table></figure>
<h2 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h2><p>包括 public、private、protected</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>TS 中成员默认为 public，可以被外部访问：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">  <span class="keyword">public</span> run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start...'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">car.run(); <span class="comment">// 'start...'</span></span><br></pre></td></tr></table></figure>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private 成员只能被类的内部访问</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected 成员可以被类的内部以及子类访问</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123;</span><br><span class="line">  <span class="keyword">protected</span> run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start...'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GTR <span class="keyword">extends</span> Car &#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> gtr = <span class="keyword">new</span> GTR();</span><br><span class="line"></span><br><span class="line">car.run(); <span class="comment">// Protected member is not accessible</span></span><br><span class="line">gtr.init(); <span class="comment">// 'start...'</span></span><br><span class="line">gtr.run(); <span class="comment">// Protected member is not accessible</span></span><br></pre></td></tr></table></figure>
<h2 id="class-作为-interface"><a href="#class-作为-interface" class="headerlink" title="class 作为 interface"></a>class 作为 interface</h2><p>在 React 中比较常用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props 的类型</span></span><br><span class="line"><span class="keyword">class</span> Props &#123;</span><br><span class="line">  <span class="keyword">public</span> children: <span class="built_in">Array</span>&lt;React.ReactElment&lt;<span class="built_in">any</span>&gt;&gt; | React.ReactElment&lt;<span class="built_in">any</span>&gt; | never[] = [];</span><br><span class="line">  <span class="keyword">public</span> speed: <span class="built_in">number</span> = <span class="number">500</span>;</span><br><span class="line">  <span class="keyword">public</span> height: <span class="built_in">number</span> = <span class="number">160</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Carousel <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> defaultProps = <span class="keyword">new</span> Props()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h2><p>很多时候函数的类型并不需要刻意去定义，TypeScript 会自己进行类型推断：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b = 10, c?: <span class="built_in">number</span></span>) =&gt;</span> a + b + (c ? c : <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 当然也可以显式定义</span></span><br><span class="line"><span class="keyword">const</span> mul: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> a * b;</span><br></pre></td></tr></table></figure>
<p>当然也可以使用 <code>...</code> 来表示剩余参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) =&gt;</span> rest.reduce(<span class="function">(<span class="params">(<span class="params">a, b</span>) =&gt; a + b</span>), <span class="params">a</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="overload"><a href="#overload" class="headerlink" title="overload"></a>overload</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Direction &#123;</span><br><span class="line">  top: <span class="built_in">number</span>,</span><br><span class="line">  bottom?: <span class="built_in">number</span>,</span><br><span class="line">  left?: <span class="built_in">number</span>,</span><br><span class="line">  right?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">all: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">topAndBottom: <span class="built_in">number</span>, leftAndRight: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">top: <span class="built_in">number</span>, right: <span class="built_in">number</span>, bottom: <span class="built_in">number</span>, left: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span> (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span>, d?: <span class="built_in">number</span></span>) </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params">b === <span class="literal">undefined</span> &amp;&amp; c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">b</span> = <span class="title">c</span> = <span class="title">d</span> = <span class="title">a</span></span>;</span></span><br><span class="line"><span class="function">  &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params">c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    c = a;</span><br><span class="line">    d = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: a,</span><br><span class="line">    right: b,</span><br><span class="line">    bottom: c,</span><br><span class="line">    left: d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assigned(<span class="number">1</span>);</span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// Argument types do not match parameters </span></span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>接受不同个数的参数，实现函数的重载，但是需要对函数做三次类型声明，否则可能会在传入 3 个参数（代码事实上不允许传入 3 个参数）的时候不报错</p>
<h2 id="generics"><a href="#generics" class="headerlink" title="generics"></a>generics</h2><p>有些时候，我们在静态编写的时候并不确定传入的参数到底是什么类型，只有在运行时传入参数之后才能确定。那么就需要一个变量，用于表示类型，而这个类型变量，则称为 <strong>泛型（generics）</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函数名称后面声明泛型变量 &lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnItem</span>&lt;<span class="title">T</span>&gt;(<span class="params">para: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以同时有多个泛型变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">'seven'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h2><p>有时候我们可能会写出这样的代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// 类型 T 上不存在 length</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器并不知道 <code>T</code> 上有 <code>length</code> 这个属性，我们可以写成 <code>Array&lt;T&gt;</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log((arg <span class="keyword">as</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;).length);</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReturnItemFn&lt;T&gt; &#123;</span><br><span class="line">  (para: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> returnItem: ReturnItemFn&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型可以作用域类本身，也可以作用于成员函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> arr: T[] = [];</span><br><span class="line">  <span class="keyword">public</span> push(item: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> pop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Params = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stack&lt;T <span class="keyword">extends</span> Params&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> arr: T[] = [];</span><br><span class="line">  <span class="keyword">public</span> push(item: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> pop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束与索引类型"><a href="#泛型约束与索引类型" class="headerlink" title="泛型约束与索引类型"></a>泛型约束与索引类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">obj: object, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要这样修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: U</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型与-new"><a href="#泛型与-new" class="headerlink" title="泛型与 new"></a>泛型与 new</h2><p>我们需要这样声明一个泛型为构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span>&lt;<span class="title">T</span>&gt;(<span class="params">Constructor: &#123;<span class="keyword">new</span>(): T&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Constructor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型断言与类型守卫"><a href="#类型断言与类型守卫" class="headerlink" title="类型断言与类型守卫"></a>类型断言与类型守卫</h1><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125; <span class="keyword">as</span> Person;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'xiaoming'</span>; <span class="comment">// OK</span></span><br><span class="line">person.age = <span class="number">20</span>;          <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">'xiaoming'</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> Person;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h2><p>使用类型守卫可以缩小类型的范围</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name = <span class="string">'xiaoming'</span>;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name = <span class="string">'petty'</span>;</span><br><span class="line">  color = <span class="string">'pink'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSometing</span>(<span class="params">arg: Person | Animal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 类型细化为 Person</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.color); <span class="comment">// Error，因为arg被细化为Person，而Person上不存在 color属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.age); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类型细化为 Person</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.age); <span class="comment">// Error，因为arg被细化为Animal，而Animal上不存在 age 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.color); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name = <span class="string">'xiaoming'</span>;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name = <span class="string">'petty'</span>;</span><br><span class="line">  color = <span class="string">'pink'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSometing</span>(<span class="params">arg: Person | Animal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'age'</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.color); <span class="comment">// Error，因为arg被细化为Person，而Person上不存在 color属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.age); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'color'</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.age); <span class="comment">// Error，因为arg被细化为Animal，而Animal上不存在 age 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.color); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字面量类型守卫"><a href="#字面量类型守卫" class="headerlink" title="字面量类型守卫"></a>字面量类型守卫</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  kind: <span class="string">'foo'</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  foo: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  kind: <span class="string">'bar'</span>; <span class="comment">// 字面量类型</span></span><br><span class="line">  bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.kind === <span class="string">'foo'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// Error</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h1><h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h2><p>结构类型是一种只使用其成员来表示类型的方式，一个栗子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> weight: <span class="built_in">number</span>, <span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> born: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  weight: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Dog;</span><br><span class="line"></span><br><span class="line">x = <span class="keyword">new</span> Person(<span class="number">120</span>, <span class="string">'xx'</span>, <span class="string">'22-22-22'</span>) <span class="comment">// OK，多的可以赋值给少的</span></span><br></pre></td></tr></table></figure>
<p>这时我们说 <code>Dog</code> 兼容 <code>Person</code>， 因为 <code>Dog</code> 的属性 <code>Person</code> 都有，反之则不然。</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>首先查看参数列表（的类型）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Assigned expression type (b: number, s: string) =&gt; 0 is not assignable to type (a: number) =&gt; 0</span></span><br></pre></td></tr></table></figure>
<p>少的可以赋值给多的</p>
<h2 id="枚举类型的兼容性"><a href="#枚举类型的兼容性" class="headerlink" title="枚举类型的兼容性"></a>枚举类型的兼容性</h2><p>枚举与数字类型相互兼容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;</span><br><span class="line">  Ready,</span><br><span class="line">  Waiting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = Status.Ready;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">status = num;</span><br><span class="line">num = status;</span><br></pre></td></tr></table></figure>
<h2 id="类的类型兼容性"><a href="#类的类型兼容性" class="headerlink" title="类的类型兼容性"></a>类的类型兼容性</h2><p>只有实例成员和方法会被比较，构造函数和静态成员则不会被检查：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">meters: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s; <span class="comment">// OK</span></span><br><span class="line">s = a; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>而 private 和 protected 必须来自相同的类</p>
<h1 id="Vue-的-TS-组件"><a href="#Vue-的-TS-组件" class="headerlink" title="Vue 的 TS 组件"></a>Vue 的 TS 组件</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'source/_posts/Others-QA-Vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Component, Prop&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个装饰器，告诉 Vue 这是一个组件，Vue 会自动把下面的东西处理成 data、method 等</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="comment">// components: &#123;Child,...&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> MyComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  num = <span class="number">0</span>; <span class="comment">// 这就是 TS 组件的 data</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(<span class="built_in">Number</span>) propA: <span class="built_in">number</span> | <span class="literal">undefined</span>; <span class="comment">// 这是 vue-property-decorator 带来的 props 写法</span></span><br><span class="line">  <span class="comment">// @Prop 是装饰器，告诉 Vue，后面的东西不是 data，是 prop</span></span><br><span class="line">  <span class="comment">// 左边的 Number 是告诉 Vue，propsA 是 Number，是**运行时**的类型检查</span></span><br><span class="line">  <span class="comment">// 右边的 number 是告诉 TS propsA 的类型，是**编译时**的类型检查，比如说你没办法写 this.propA.xxx，会无法编译成功</span></span><br><span class="line"></span><br><span class="line">  add(num: <span class="built_in">number</span>) &#123; <span class="comment">// 这就是 TS 组件的 methods</span></span><br><span class="line">    <span class="keyword">this</span>.num = num ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.propA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译时与运行时"><a href="#编译时与运行时" class="headerlink" title="编译时与运行时"></a>编译时与运行时</h2><p>TypeScript —编译—&gt; JavaScript —运行—&gt; 浏览器</p>
<p>编译时：编译错误 -&gt; 无法得到 JS，会在编译的终端 Error<br>运行时：运行错误 -&gt; 控制台 Error（浏览器）</p>
<h1 id="TypeScript-的本质"><a href="#TypeScript-的本质" class="headerlink" title="TypeScript 的本质"></a>TypeScript 的本质</h1><blockquote class="blockquote-center"><p>JS: 类型</p>
</blockquote>
<p>TSC（TypeScriptCompiler）会利用类型来检查 JS 代码：</p>
<ul>
<li>若检查出错误，就会编译报错，但还是会编译成 JS</li>
<li>若没有检查出错误，就会删掉类型，然后编译成 JS（TSC 或者 Babel 都可以编译，有一点点区别）</li>
</ul>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="强制指定类型"><a href="#强制指定类型" class="headerlink" title="强制指定类型"></a>强制指定类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">inputNumber(event: MouseEvent | TouchEvent) &#123;</span><br><span class="line">  <span class="keyword">const</span> button = (event.target <span class="keyword">as</span> HTMLButtonElement); <span class="comment">// 因为有的元素的 textContent 可能为空（比如图片），所以我们需要强制指定为 Button 元素</span></span><br><span class="line">  <span class="built_in">console</span>.log(button.textContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以给返回值强制指定类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'records'</span>) || <span class="string">'[]'</span>) <span class="keyword">as</span> RecordItem[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配合-JS-使用"><a href="#配合-JS-使用" class="headerlink" title="配合 JS 使用"></a>配合 JS 使用</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx <span class="built_in">require</span>(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="全局声明-type"><a href="#全局声明-type" class="headerlink" title="全局声明 type"></a>全局声明 <code>type</code></h2><p>在 <code>src</code> 中创建 <code>custom.d.ts</code>（也可以叫 <code>xxx.d.ts</code>），在里面声明 <code>type</code></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Tip</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 基本语法</title>
    <url>/hais-notebook/2020/02/04/SQL/</url>
    <content><![CDATA[<p>涉及 SQL 的基本语法。</p>
<a id="more"></a>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载 MySQL</a><br><a href="https://dev.mysql.com/downloads/workbench" target="_blank" rel="noopener">下载 MySQL WorkBench</a></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- use [schemas name]</span></span><br><span class="line">usz lzblog;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert into [table name] ([colunm name]) values ([colunm value])</span></span><br><span class="line"><span class="comment">-- password 是关键字，所以要用 `` 引起来</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (username, <span class="string">`password`</span>, nickname) <span class="keyword">values</span> (<span class="string">'zs'</span>, <span class="string">'123'</span>, <span class="string">'zhangsan'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username =<span class="string">'zs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般采用软删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> state=<span class="string">'0'</span> <span class="keyword">where</span> username=<span class="string">'lz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> state &lt;&gt; <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> nickname=<span class="string">'lz2'</span> <span class="keyword">where</span> username=<span class="string">'lz'</span>;</span><br><span class="line"><span class="comment">-- update [table name] set [colunm name]=[value] where [condition]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,username <span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'lz'</span> <span class="keyword">and</span> <span class="string">`password`</span>=<span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'lz'</span> <span class="keyword">or</span> <span class="string">`password`</span>=<span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%z%'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%z%'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>全栈</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>慕课网</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>简单算法：字符串</title>
    <url>/hais-notebook/2020/02/04/CS-Algorithm-String/</url>
    <content><![CDATA[<p>一些字符串中涉及到的算法的题解。</p>
<a id="more"></a>
<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot; </span><br><span class="line"></span><br><span class="line">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> array = str.split(<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">const</span> result = array.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更优雅的写法</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .split(<span class="string">' '</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .split(<span class="regexp">/\s/g</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 match API</span></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">          .match(<span class="regexp">/[\w']+/g</span>)</span><br><span class="line">          .map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">          .join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a>计数二进制子串</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</span><br><span class="line"></span><br><span class="line">重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">示例 1 :</span><br><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">s.length 在1到50,000之间。</span><br><span class="line">s 只包含“0”或“1”字符。</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/count-binary-substrings" target="_blank" rel="noopener">LeetCode 原题链接</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 建立数据结构，堆栈、保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="comment">// 给定任意子输入都返回第一个符合条件的字符串</span></span><br><span class="line">  <span class="keyword">const</span> match = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> j = str.match(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).toString().repeat(j.length)</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 for 循环控制程序运行流程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sub = match(str.slice(i))</span><br><span class="line">    <span class="keyword">if</span>(sub)&#123;</span><br><span class="line">      result.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>慕课网</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小问题：数组去重</title>
    <url>/hais-notebook/2020/02/04/CS-Algorithm-QA-UniqueArray/</url>
    <content><![CDATA[<p>总结：恰当地利用对象和 Map key 的唯一性可以实现对 <code>&#39;1&#39;</code> 和 <code>1</code> 的区分、对象的去重，以及 <code>undefined</code> <code>null</code> <code>NaN</code> 的良好识别。</p>
<a id="more"></a>
<p>使用数组 <code>[ 1, 1, &#39;1&#39;, &#39;1&#39;, 0, 0, { a: 1 }, { a: 1 }, x, y, z, undefined, undefined, null, null, NaN, NaN ]</code> 输出进行实验，其中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> y = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> z = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">let</span> isRepeat</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    isRepeat = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArray.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>[i] === newArray[j])&#123;</span><br><span class="line">        isRepeat = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepeat) &#123;</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code></p>
<h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><code>indexOf</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="keyword">this</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (newArray.indexOf(current) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      newArray.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code></p>
<h1 id="相邻元素去重（先排序）"><a href="#相邻元素去重（先排序）" class="headerlink" title="相邻元素去重（先排序）"></a>相邻元素去重（先排序）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">this</span>.sort()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>[i] !== <span class="keyword">this</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code>，<code>undefined</code>（会丢失）</p>
<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newArray = <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象，<code>NaN</code>（会丢失）</p>
<h1 id="reduce（先排序）"><a href="#reduce（先排序）" class="headerlink" title="reduce（先排序）"></a><code>reduce</code>（先排序）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">result, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.length === <span class="number">0</span> || result[result.length - <span class="number">1</span>] !== current) &#123;</span><br><span class="line">      result.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象，<code>NaN</code></p>
<h1 id="includes"><a href="#includes" class="headerlink" title="includes"></a><code>includes</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>注意：原来的数组会被更改！</p>
<p>不能区分：对象</p>
<h1 id="对象键值对"><a href="#对象键值对" class="headerlink" title="对象键值对"></a>对象键值对</h1><p>利用对象中 key 的不可重复性去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能区分：对象（存进去的时候所有对象都变成了 <code>[object Object]</code>）、<code>&#39;1&#39;</code> 和 <code>1</code></p>
<h2 id="改进版本-1"><a href="#改进版本-1" class="headerlink" title="改进版本 1"></a>改进版本 1</h2><p>可以区分 <code>&#39;1&#39;</code> 和 <code>1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="keyword">this</span>[i]] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进版本-2"><a href="#改进版本-2" class="headerlink" title="改进版本 2"></a>改进版本 2</h2><p>可以区分对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i])]) &#123;</span><br><span class="line">      obj[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i])] = <span class="literal">true</span></span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>利用 Map 的 key 唯一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = []</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.get(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">      map.set(<span class="keyword">this</span>[i], <span class="literal">true</span>)</span><br><span class="line">      newArray.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> (!map.has(item) &amp;&amp; map.set(item, <span class="literal">true</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能去重：对象，可以像上面的对象键值对方法一样处理</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类似于数组，但成员的值都是唯一的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化为</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="keyword">this</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以简化为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, x, y, z, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span> ]</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">[ <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>
<p>不能去重：对象</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：原生 JavaScript</title>
    <url>/hais-notebook/2020/02/04/Others-QA-JS/</url>
    <content><![CDATA[<p>关于原生 JavaScript 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise-如何消灭回调地狱"><a href="#Promise-如何消灭回调地狱" class="headerlink" title="Promise 如何消灭回调地狱"></a>Promise 如何消灭回调地狱</h2><p>回调地狱：</p>
<ol>
<li>多层嵌套</li>
<li>无法方便地进行错误处理</li>
</ol>
<p>解决办法：</p>
<ol>
<li>回调函数延迟绑定，回调函数是通过后面的 then 方法传入的</li>
<li>返回值穿透，根据 then 中回调函数的传入值创建不同类型的 Promise，再把返回的 Promise 穿透到外层，以供后续使用。以上两点实现了链式调用，解决多层嵌套问题</li>
<li>错误冒泡，前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了</li>
</ol>
<h2 id="Promise-怎样实现链式调用的"><a href="#Promise-怎样实现链式调用的" class="headerlink" title="Promise 怎样实现链式调用的"></a>Promise 怎样实现链式调用的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存当前 Promise 实例</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.value = <span class="literal">null</span></span><br><span class="line">  self.error = <span class="literal">null</span></span><br><span class="line">  self.status = PENDING</span><br><span class="line">  <span class="comment">// 回调函数有可能是个数组</span></span><br><span class="line">  self.onFulfilledCallbacks = []</span><br><span class="line">  self.onRejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = FULFILLED</span><br><span class="line">      self.value = value</span><br><span class="line">      self.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.value))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = REJECTED</span><br><span class="line">      self.error = error</span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.error))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> bridgePromise</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">// 拆解这个 promise，直到返回值不为 promise 为止</span></span><br><span class="line">      <span class="keyword">if</span> (x.status === PENDING) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          resolvePromise(bridgePromise, y, resolve, reject)</span><br><span class="line">        &#125;, error =&gt; &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise =  <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      self.onFulfilledCallbacks.push(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 要拿到 then 中回调返回的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value)</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          reject(onRejected(error))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.error)</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><blockquote>
<p>路由就是根据不同的 URL 来展示不同的内容或页面</p>
</blockquote>
<p>用户每次提交表单就要重新刷新页面 -&gt; 催生了 AJAX；<br>用户在多页面之间跳转体验很差 -&gt; 催生了单页应用（SPA, Single-Page Application）<br>单页应用页面本身的 URL 没有变化，导致其无法记住用户的操作，对 SEO 也不友好 -&gt; 催生了前端路由</p>
<blockquote>
<p>前端路由就是在 <strong>保证只有一个 HTML 页面</strong>，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个 <strong>特殊的 URL</strong><br>在刷新、前进、后退和 SEO 时均通过这个特殊的 URL 来实现<br>并且改变 URL 时不向服务器发送请求</p>
</blockquote>
<h2 id="Hash-与-History"><a href="#Hash-与-History" class="headerlink" title="Hash 与 History"></a>Hash 与 History</h2><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 <code>hashchange</code> 事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。</p>
<h4 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.hash = <span class="string">'string'</span> <span class="comment">// 用于设置 hash 值</span></span><br><span class="line"><span class="keyword">let</span> hash = <span class="built_in">window</span>.location.hash <span class="comment">// 获取当前 hash 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 hash 变化，点击浏览器的前进后退会触发：</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newURL = event.newURL <span class="comment">// hash 改变后的新 URL</span></span><br><span class="line">  <span class="keyword">let</span> oldURL = event.oldURL <span class="comment">// hash 改变前的旧 URL</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以简写成</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="实现一个路由对象"><a href="#实现一个路由对象" class="headerlink" title="实现一个路由对象"></a>实现一个路由对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 存储不同的 hash 值对应的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.routers = &#123;&#125;</span><br><span class="line">    <span class="comment">// 通过 hashchange 来监听 hash 变化</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.load.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册每个视图（注册每个 hash 值对应的回调函数）</span></span><br><span class="line">  register(hash, callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[hash] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册首页的回调（没有 hash 值时默认为首页）</span></span><br><span class="line">  registerIndex(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'index'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理视图未找到的情况</span></span><br><span class="line">  registerNotFound(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'404'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理异常情况</span></span><br><span class="line">  registerError(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'error'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> handler</span><br><span class="line">      <span class="comment">// 没有 hash 默认首页</span></span><br><span class="line">    <span class="keyword">if</span> (!hash) &#123;</span><br><span class="line">      handler = <span class="keyword">this</span>.routers.index</span><br><span class="line">      <span class="comment">// 没找到对应的 hash 值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.routers.hasOwnProperty(hash)) &#123;</span><br><span class="line">      handler = <span class="keyword">this</span>.routers[<span class="string">'404'</span>] || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      <span class="comment">// 其他普通情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler = <span class="keyword">this</span>.routers[hash]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行注册的回调函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handler.call(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">      (<span class="keyword">this</span>.routers[<span class="string">'error'</span>] || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).call(<span class="keyword">this</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再这样使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page1"</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page2"</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page3"</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page4"</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page5"</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> HashRouter()</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册首页回调函数</span></span><br><span class="line">router.registerIndex(<span class="function"><span class="params">()</span> =&gt;</span> container.innerHTML = <span class="string">'我是首页'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册其他视图回调函数</span></span><br><span class="line">router.register(<span class="string">'/page1'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page1'</span>)</span><br><span class="line">router.register(<span class="string">'/page2'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page2'</span>)</span><br><span class="line">router.register(<span class="string">'/page3'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page3'</span>)</span><br><span class="line">router.register(<span class="string">'/page4'</span>, () =&gt; &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抛出一个异常'</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册未找到对应 hash 值时的回调</span></span><br><span class="line">router.regierNotFound(<span class="function"><span class="params">()</span> =&gt;</span> container.innerHTML = <span class="string">'页面未找到'</span>)</span><br><span class="line"><span class="comment">// 注册出现异常时的回调</span></span><br><span class="line">router.registerError(<span class="function">(<span class="params">e</span>) =&gt;</span> container.innerHTML = <span class="string">'页面异常，错误信息：&lt;br&gt;'</span> + e.message)</span><br><span class="line"><span class="comment">// 加载视图</span></span><br><span class="line">router.load()</span><br></pre></td></tr></table></figure>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>在 HTML5 之前，浏览器就已经有了 history 对象，但早期的只有 <code>go</code> <code>forward</code> <code>back</code> 这些方法，用于多页面之间的跳转，HTML 5 中新加入了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.pushState() <span class="comment">// 添加新的状态到历史状态栈</span></span><br><span class="line">history.replaceState() <span class="comment">// 用新的状态代替当前状态</span></span><br><span class="line">history.state <span class="comment">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure>
<p>与 hash 不同，history 的改变并不会触发任何事件，所以我们无法直接监听 history 的改变而做出相应的改变</p>
<p>而对于单页应用的 history 模式而言，URL 的改变只有可能是以下四种情况：</p>
<ol>
<li>点击浏览器的而前进或后退按钮</li>
<li>点击 a 标签</li>
<li>在 JS 代码中触发 <code>history.pushState</code> 函数</li>
<li>在 JS 代码中触发 <code>history.replaceState</code> 函数</li>
</ol>
<h4 id="实现一个路由对象-1"><a href="#实现一个路由对象-1" class="headerlink" title="实现一个路由对象"></a>实现一个路由对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistoryRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 存储不同 path 值对应的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.routers = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.listenPopState()</span><br><span class="line">    <span class="keyword">this</span>.listenLink()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听 popstate 事件，处理前进和后退时应该如何调用</span></span><br><span class="line">  listenPopState() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = e.state || &#123;&#125;</span><br><span class="line">      <span class="keyword">let</span> path = state.path || <span class="string">''</span></span><br><span class="line">      <span class="keyword">this</span>.dealPathHandler(path)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听 a 标签，阻止他的默认事件，并且调用 pushState 方法</span></span><br><span class="line">  listenLink() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = e.target</span><br><span class="line">      <span class="keyword">if</span> ((dom.tagName.toLowerCase === <span class="string">'a'</span>) &amp;&amp; dom.getAttribute(<span class="string">'href'</span>)) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">this</span>.assign(dom.getAttribute(<span class="string">'href'</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次进入页面时调用</span></span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="keyword">let</span> path = location.pathname</span><br><span class="line">    <span class="keyword">this</span>.dealPathHandler(path)</span><br><span class="line">  &#125;</span><br><span class="line">  register(path, callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  registerIndex(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'/'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  registerNotFound(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'404'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  registerError(callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routers[<span class="string">'error'</span>] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 pushState</span></span><br><span class="line">  assign(path) &#123;</span><br><span class="line">    history.pushState(&#123;path&#125;, <span class="literal">null</span>, path)</span><br><span class="line">    <span class="keyword">this</span>.dealPathHandler(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 replaceState</span></span><br><span class="line">  replace(path) &#123;</span><br><span class="line">    history.replaceState(&#123;path&#125;, <span class="literal">null</span>, path)</span><br><span class="line">    <span class="keyword">this</span>.dealPathHandler(path)</span><br><span class="line">  &#125;</span><br><span class="line">  dealPathHandler(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.routers.hasOwnProperty(path)) &#123;</span><br><span class="line">      handler = <span class="keyword">this</span>.routers[<span class="string">'404'</span>] || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler = <span class="keyword">this</span>.routers[path]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handler.call(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">      (<span class="keyword">this</span>.routers[<span class="string">'error'</span>] || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).call(<span class="keyword">this</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的使用方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page1"</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page2"</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page3"</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page4"</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/page5"</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> HashRouter()</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册首页回调函数</span></span><br><span class="line">router.registerIndex(<span class="function"><span class="params">()</span> =&gt;</span> container.innerHTML = <span class="string">'我是首页'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册其他视图回调函数</span></span><br><span class="line">router.register(<span class="string">'/page1'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page1'</span>)</span><br><span class="line">router.register(<span class="string">'/page2'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page2'</span>)</span><br><span class="line">router.register(<span class="string">'/page3'</span>, () =&gt; container.innerHTML = <span class="string">'我是 page3'</span>)</span><br><span class="line">router.register(<span class="string">'/page4'</span>, () =&gt; &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抛出一个异常'</span>)&#125;)</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="params">()</span> =&gt;</span> router.assign(<span class="string">'/page2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册未找到对应 path 值时的回调</span></span><br><span class="line">router.regierNotFound(<span class="function"><span class="params">()</span> =&gt;</span> container.innerHTML = <span class="string">'页面未找到'</span>)</span><br><span class="line"><span class="comment">// 注册出现异常时的回调</span></span><br><span class="line">router.registerError(<span class="function">(<span class="params">e</span>) =&gt;</span> container.innerHTML = <span class="string">'页面异常，错误信息：&lt;br&gt;'</span> + e.message)</span><br><span class="line"><span class="comment">// 加载视图</span></span><br><span class="line">router.load()</span><br></pre></td></tr></table></figure>
<h2 id="各自的优缺点及使用场景"><a href="#各自的优缺点及使用场景" class="headerlink" title="各自的优缺点及使用场景"></a>各自的优缺点及使用场景</h2><h3 id="为什么-hash-模式需要服务器端配合？"><a href="#为什么-hash-模式需要服务器端配合？" class="headerlink" title="为什么 hash 模式需要服务器端配合？"></a>为什么 hash 模式需要服务器端配合？</h3><p>我们通过 history 来修改 URL 后，页面不会刷新；如果我们手动刷新页面，或者通过 URL 直接进入应用时，服务端是无法识别这个 URL 的——因为我们其实只有一个 html 文件</p>
<p>因此，如果要使用 history 模式，就需要在服务端增加一个覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应返回单页应用的 html 文件</p>
<h3 id="各自的优缺点"><a href="#各自的优缺点" class="headerlink" title="各自的优缺点"></a>各自的优缺点</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>history</th>
</tr>
</thead>
<tbody>
<tr>
<td>观赏性</td>
<td>丑</td>
<td>美</td>
</tr>
<tr>
<td>兼容性</td>
<td>&gt;IE8</td>
<td>&gt;IE10</td>
</tr>
<tr>
<td>其他</td>
<td>锚点功能失效，相同 hash 值不触发动作</td>
<td>需要服务端配合，相同 path 值也可以通过 pushState 触发动作</td>
</tr>
</tbody>
</table>
</div>
<h1 id="函数防抖与函数节流"><a href="#函数防抖与函数节流" class="headerlink" title="函数防抖与函数节流"></a>函数防抖与函数节流</h1><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>等了一段时间，没有新的人上车了再发车：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay = <span class="number">300</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>冷却时间：指定时间间隔内只会执行一次任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval = <span class="number">300</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span></span><br><span class="line">    canRun = <span class="literal">false</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      canRun = <span class="literal">true</span></span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如何用正则实现-trim"><a href="#如何用正则实现-trim" class="headerlink" title="如何用正则实现 trim()"></a>如何用正则实现 <code>trim()</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> string.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对象和数组的深拷贝"><a href="#对象和数组的深拷贝" class="headerlink" title="对象和数组的深拷贝"></a>对象和数组的深拷贝</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">100</span>,</span><br><span class="line">  b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = obj1</span><br></pre></td></tr></table></figure>
<p>当改变 <code>obj1</code> 的时候，<code>obj2</code> 会跟着改变，这是直接赋值，不属于深/浅克隆</p>
<h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><blockquote>
<p>只克隆第一层</p>
</blockquote>
<h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj.hasOwnProperty(key)) <span class="keyword">continue</span> <span class="comment">// 这里也可以用 break，因为到这一步基本就已经到原型的属性了，可以直接跳出循环</span></span><br><span class="line">  obj2[key] = obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>他拷贝的是对象属性的引用，而不是对象本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj &#125;</span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat()</span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br></pre></td></tr></table></figure>
<h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><blockquote>
<p>每一层都克隆</p>
</blockquote>
<h3 id="简易版的深拷贝"><a href="#简易版的深拷贝" class="headerlink" title="简易版的深拷贝"></a>简易版的深拷贝</h3><p>最最最简单的深拷贝可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>
<p>但是在有些时候是会出现问题的：</p>
<ol>
<li>循环引用</li>
<li>无法处理 RegExp、Date、Set、Map、Function 等</li>
</ol>
<p>也可以用 <code>lodash</code> 之类的库，当然也可以手写一个简易版的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h3><p>思路：创建一个 Map，将已经拷贝过的对象记录下来，如果发现已经拷贝过，就直接返回他</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> weakMap(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isObject(target)) &#123;</span><br><span class="line">    map.set(target, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 Map，那么 map 的 key 将会与 map 形成强引用，如果强引用一直存在，那么对象将无法被回收；使用 WeakMap 可以构造一种弱引用（一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收），WeakMap 的 Key 必须是对象，而值可以是任意的。</p>
<h3 id="拷贝特殊对象"><a href="#拷贝特殊对象" class="headerlink" title="拷贝特殊对象"></a>拷贝特殊对象</h3><h4 id="可继续遍历"><a href="#可继续遍历" class="headerlink" title="可继续遍历"></a>可继续遍历</h4><p>比如 Map、Set、Array、Object、Arguments：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="built_in">Object</span>.prototype.toString.call</span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'[object Map]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Set]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Arguments]'</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) <span class="keyword">return</span> target</span><br><span class="line">  <span class="keyword">let</span> type = getType(target)</span><br><span class="line">  <span class="keyword">let</span> cloneTarget</span><br><span class="line">  <span class="keyword">if</span> (!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不可遍历对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> target.constructor()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (map.get(target)) <span class="keyword">return</span> target</span><br><span class="line">  map.set(target, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'[object Map]'</span>) &#123;</span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key), deepClone(item))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'[object Set]'</span>) &#123;</span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      target.add(deepClone(item))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 Object 和 Array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">      cloneTarget[prop] = deepClone(target[prop])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不可遍历"><a href="#不可遍历" class="headerlink" title="不可遍历"></a>不可遍历</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regExpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;source, flags&#125; = target</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要区分处理箭头函数和普通函数，因为普通函数是 Function 的实例，而箭头函数不是任何类的实例</span></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数返回自身</span></span><br><span class="line">  <span class="keyword">if</span> (!func.prototype) <span class="keyword">return</span> func</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)(?=&#125;)/m</span></span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s*&#123;)/</span></span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString()</span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString)</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString)</span><br><span class="line">  <span class="keyword">if</span> (!body) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].slice(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...param, body[<span class="number">0</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = target.<span class="keyword">constructor</span></span><br><span class="line">  switch (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="comment">// 因为用 new Boolean 创造出来的对象有问题</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> errorTag:</span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">constructor</span>(target)</span><br><span class="line">    case regExpTag:</span><br><span class="line">      return handleRegExp(target)</span><br><span class="line">    case funcTag:</span><br><span class="line">      return handleFunc(target)</span><br><span class="line">    default:</span><br><span class="line">      return new <span class="keyword">constructor</span>(target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">target</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(target).match(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].toLowerCase()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">target</span> =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'map'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'set'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'array'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'object'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'arguments'</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;source,flags&#125; = target</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!func.prototype) <span class="keyword">return</span> func</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)(?=&#125;)/m</span></span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span></span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString()</span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString)</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString)</span><br><span class="line">  <span class="keyword">if</span> (!body) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = target.<span class="keyword">constructor</span></span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'boolean'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'symbol'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'error'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'date'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">constructor</span>(target)</span><br><span class="line">    case 'regexp':</span><br><span class="line">      return handleRegExp(target)</span><br><span class="line">    case 'function':</span><br><span class="line">      return handleFunc(target)</span><br><span class="line">    default:</span><br><span class="line">      return new <span class="keyword">constructor</span>(target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const deepClone = (target, map = new WeakMap()) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> type = getType(target)</span><br><span class="line">  <span class="keyword">let</span> cloneTarget</span><br><span class="line">  <span class="keyword">if</span> (!canTraverse[type]) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> target.constructor()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.get(target)) <span class="keyword">return</span> target</span><br><span class="line">  map.set(target, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'map'</span>) &#123;</span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'set'</span>) &#123;</span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">      cloneTarget[prop] = deepClone(target[prop], map)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于堆栈内存和闭包"><a href="#关于堆栈内存和闭包" class="headerlink" title="关于堆栈内存和闭包"></a>关于堆栈内存和闭包</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="string">'0'</span>,</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">a[b]= <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Zhang'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = <span class="built_in">Symbol</span>(<span class="string">'1'</span>),</span><br><span class="line">    c = <span class="built_in">Symbol</span>(<span class="string">'1'</span>)</span><br><span class="line">a[b] = <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Harvey'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">    b = &#123; <span class="attr">n</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">    c = &#123; <span class="attr">m</span>: <span class="string">'2'</span> &#125;</span><br><span class="line">a[b] = <span class="string">'Harvey'</span></span><br><span class="line">a[c] = <span class="string">'Zhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// =&gt; 'Zhang'</span></span><br><span class="line"><span class="comment">// 所有的引用类型存的时候都会被转换成字符串，而 object 转换成字符串的结果都是 '[object Object]'</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>堆：存储引用类型值的空间；<br>栈：存储基本类型值和执行代码的环境；浏览器加载页面就会形成栈内存，当执行函数的时候，都会形成一个新的执行上下文（Execution Context Stack），压入栈中执行</p>
          </div>
<p>闭包的作用 1：保存——保存私有变量，不被销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i *= <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">2</span>) <span class="comment">// =&gt; var test = AAAFFF111</span></span><br><span class="line">test(<span class="number">5</span>) <span class="comment">// =&gt; '4'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：地址 AAAFFF111</span><br><span class="line">│ 作为函数，存储代码（字符串）</span><br><span class="line">│ 作为对象，存储键值对（prototype、length、name ...）</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 1，不销毁，因为 i 被占着</span><br><span class="line">│ i &#x3D; 2</span><br><span class="line">│ return AAAFFF111</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">    ↑</span><br><span class="line">    | 上级作用域</span><br><span class="line">    |</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：执行上下文 2，执行完之后销毁</span><br><span class="line">│ alert(i *&#x3D; 2)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<p>闭包的作用 2：保护——修改自己的私有变量，不会影响外面的东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>,</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123; <span class="comment">// 全局 A = AAAFFF000</span></span><br><span class="line">  A = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    alert(a + b++)</span><br><span class="line">  &#125;</span><br><span class="line">  alert(a++)</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>) <span class="comment">// =&gt; '1', a = 2</span></span><br><span class="line">A(<span class="number">2</span>) <span class="comment">// =&gt; '4', b = 3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ Global Object</span><br><span class="line">| a &#x3D; 0</span><br><span class="line">| b &#x3D; 0</span><br><span class="line">| A &#x3D; AAAFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">│ &#96;A &#x3D; function(b) &#123; alert(a + b++) &#125;; alert(a++)&#96;</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ &#96;alert(a + b++)&#96;</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(1) ECStack，因为 BBBFFF000 被全局 A 占用了，所以不销毁</span><br><span class="line">│ a &#x3D; 1</span><br><span class="line">| A &#x3D; BBBFFF000</span><br><span class="line">| alert(a++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 栈内存：A(2) ECStack，没有被占用的，所以销毁</span><br><span class="line">│ b &#x3D; 2</span><br><span class="line">| alert(a + b++)</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 存在变量提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName() <span class="comment">// 2</span></span><br><span class="line">getName() <span class="comment">// 4</span></span><br><span class="line">Foo().getName() <span class="comment">// Foo() 作为普通函数执行，改变了全局的 getName() 为 1，返回 this（为 window）</span></span><br><span class="line">getName() <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName() <span class="comment">// 前面是无参数 new（优先级18），后面是成员访问（优先级19），先执行成员访问，获取 Foo.getName()，为 2，再 new（相当于普通函数执行）</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName() <span class="comment">// 前面是有参数 new（优先级19），后面是成员访问（优先级19），先 new（创建实例），getName 是原型上的 getName，3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName() <span class="comment">// 先 new（创建实例 xxx），变为 new xxx.getName()，再算成员访问（原型上的方法），为 3，再 new</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：AAAFFF000</span><br><span class="line">| 代码字符串</span><br><span class="line">| getName: fun -&gt; 2</span><br><span class="line">| prototype: BBBFFF000</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 堆内存：BBBFFF000</span><br><span class="line">│ constructor: Foo</span><br><span class="line">| getName: func -&gt; 3</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 变量提升阶段</span><br><span class="line">| Foo &#x3D; AAAFFF000，声明并定义</span><br><span class="line">│ getName &#x3D; func -&gt; 5，var 声明，之后在 function 赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br><span class="line">┌─────────────────────────────────────────────────</span><br><span class="line">│ 代码执行阶段</span><br><span class="line">| getName &#x3D; func -&gt; 4，在 var 处赋值</span><br><span class="line">└─────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<h1 id="parseUrl-函数"><a href="#parseUrl-函数" class="headerlink" title="parseUrl 函数"></a>parseUrl 函数</h1><p>可以用 <code>new URL</code> API 或者创建一个 <code>&lt;a&gt;</code> 标签的，并获取他的属性：</p>
<p>new URL 在 IE 上兼容性不是很好，但是 Node 也支持这个 API。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parseUrl = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> URL(source)</span><br><span class="line">  <span class="keyword">const</span> query = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> params = url.search.replace(<span class="regexp">/^\?/</span>, <span class="string">''</span>).split(<span class="string">'&amp;'</span>)</span><br><span class="line">  params.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> param = item.split(<span class="string">'='</span>)</span><br><span class="line">    query[param[<span class="number">0</span>]] = param[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    protocol: url.protocol.replace(<span class="string">':'</span>, <span class="string">''</span>),</span><br><span class="line">    host: url.host,</span><br><span class="line">    path: url.pathname,</span><br><span class="line">    query: query,</span><br><span class="line">    hash: url.hash.replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseUrl(<span class="string">"http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parseUrl = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  a.href = source</span><br><span class="line">  <span class="comment">// 下面的内容是一样的</span></span><br><span class="line">  <span class="keyword">const</span> query = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> params = a.search.replace(<span class="regexp">/^\?/</span>,<span class="string">''</span>).split(<span class="string">'&amp;'</span>);</span><br><span class="line">  params.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> param = item.split(<span class="string">'='</span>)</span><br><span class="line">    query[param[<span class="number">0</span>]] = param[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    protocol: a.protocol.replace(<span class="string">':'</span>,<span class="string">''</span>),</span><br><span class="line">    host: a.host,</span><br><span class="line">    path: a.pathname,</span><br><span class="line">    query: query,</span><br><span class="line">    hash: a.hash.replace(<span class="string">'#'</span>,<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseUrl(<span class="string">"http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title"</span>))</span><br></pre></td></tr></table></figure>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><h2 id="浏览器中的-EventLoop"><a href="#浏览器中的-EventLoop" class="headerlink" title="浏览器中的 EventLoop"></a>浏览器中的 EventLoop</h2><p>浏览器中的 EventLoop 有 2 个阶段：<strong>宏任务</strong> 和 <strong>微任务</strong></p>
<ol>
<li>第一个 <strong>宏任务</strong>：整段脚本。执行过程中的 <strong>同步代码</strong> 直接执行，<strong>宏任务</strong> 进入宏任务队列，<strong>微任务</strong> 进入微任务队列</li>
<li>当前 <strong>宏任务</strong> 执行完出队，检查 <strong>微任务</strong> 队列，若有则依次执行，直至微任务队列为空</li>
<li>执行浏览器 <strong>UI 线程</strong> 的渲染工作</li>
<li>检查是否有 <strong>Web worker</strong> 任务，有则执行</li>
<li>执行队首新的 <strong>宏任务</strong>，回到 2 循环至宏任务队列为空</li>
</ol>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">await</span> async2() <span class="comment">// -&gt; 执行 async2 并等待返回结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>) <span class="comment">// 6 -&gt; 有的浏览器会先执行 then 的，而不是按入栈出栈的先后顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)  <span class="comment">// 1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>) <span class="comment">// 4</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>) <span class="comment">// 7</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="Node-js-中的-EventLoop"><a href="#Node-js-中的-EventLoop" class="headerlink" title="Node.js 中的 EventLoop"></a>Node.js 中的 EventLoop</h2><p><img src="https://user-gold-cdn.xitu.io/2019/11/23/16e96b8587ad911d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="三大关键阶段"><a href="#三大关键阶段" class="headerlink" title="三大关键阶段"></a>三大关键阶段</h3><ol>
<li><strong>timer</strong>：执行定时器回调阶段，检查定时器（<code>setTimeout</code> <code>setInterval</code>），如果到了时间就执行回调。</li>
<li><strong>poll</strong>：轮询阶段，当文件 I/O、网络 I/O 等一步操作执行完之后，通过 <code>data</code> <code>connect</code> 等事件来通知 JS 主线程，使得时间循环到达 poll 阶段：<ul>
<li>如果当前已经存在定时器，且定时器到时间了，拿出来执行，eventLoop 回到 timer 阶段</li>
<li>如果没有定时器，就去看回调函数队列<ul>
<li>如果队列不为空，拿出队列中的方法依次执行</li>
<li>如果队列为空，检查是否有 <code>setImmediate</code><ul>
<li>有则前往 check 阶段</li>
<li>没有则继续等待，等待 callback 加入队列，加入后会立即执行；一定时间后自动进入 check 阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>check</strong>：直接执行 <code>setImmediate</code></li>
</ol>
<ul>
<li><code>setTimeout</code> -&gt; timers</li>
<li><code>setImmediate</code> -&gt; check</li>
<li><code>nextTick</code> -&gt; 当前阶段的后面</li>
<li><code>promise.then</code> -&gt; 看他是通过什么实现的，如果是用 <code>nextTick</code> 实现的，就当 <code>nextTick</code> 看，当 <code>resolve</code> 的时候放在当前阶段的后面</li>
</ul>
<h3 id="一些例子-1"><a href="#一些例子-1" class="headerlink" title="一些例子"></a>一些例子</h3><p>注意：有可能先执行 JS 代码，也有可能先开启 EventLoop，因为进程开启都需要时间。</p>
<p>比如当执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(fn, <span class="number">100</span>)</span><br><span class="line">setImmediate(fn2)</span><br></pre></td></tr></table></figure>
<p><strong><code>fn</code> 放到一个 timers 的一个数组中</strong><br>V<br><strong>进入 poll 阶段进行等待，同时看时间</strong><br>V<br><strong>进入 check 阶段</strong><br>允许在 poll 阶段空闲的时候立即执行一些函数，主要是 <code>setImmediate()</code> 里面的，<br>比如如果有 <code>setImmediate(fn2)</code>，则在 poll 中就不等了，直接进入 check，在 check 中执行 <code>fn2</code><br>V<br><strong>进入 timers 阶段，执行 <code>fn</code></strong><br>如果因为之前有 <code>setImmediate()</code> 导致提前进入了下一个循环，而此时 <code>setTimeout</code> 的计时还没到，则此时不执行 <code>fn</code></p>
<p>而有种情况比较特殊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(fn, <span class="number">0</span>)</span><br><span class="line">setImmediate(fn2)</span><br></pre></td></tr></table></figure>
<p>注意：<br>如果 EventLoop 开启得很快，则此时 timers 中没有 <code>fn</code>；<br>如果 EventLoop 开启得慢，则此时 timers 中有 <code>fn</code>，而如果此时 timers 中有 <code>fn</code>，而且计时已经结束，就马上执行了 <code>fn</code> 再往下走</p>
<p>也就是说因为 EventLoop 有时候开启得快，有时候开启得慢，所以如果一开始就执行上面两句代码，他们的执行先后是不确定的！</p>
<h1 id="JS-垃圾回收"><a href="#JS-垃圾回收" class="headerlink" title="JS 垃圾回收"></a>JS 垃圾回收</h1><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>JS 环境中的内存声明周期由以下三部分组成：</p>
<ol>
<li>内存分配：当我们声明变量、函数、对象的时候，系统会自动分配内存</li>
<li>内存使用：使用变量、函数等</li>
<li>内存回收</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><ul>
<li>没有被引用的，所谓引用就是一个对象拥有访问另一个对象的权限（隐式或显式）</li>
<li>引用的几个对象互相组成环</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每次生成一个新东西，就将被引用的对象的计数 +1，每次删除一个东西，就将被引用的对象计数 -1<br>但是若出现循环引用，则无法回收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 div 引用了事件处理函数，事件处理函数也引用了 div，因为 div 可以在事件处理函数中被访问到。</p>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><ol>
<li>标记所有变量</li>
<li>从根部清除所有能触及的对象的标记</li>
<li>删除掉还有标记的变量</li>
</ol>
<p>解决除了循环引用的问题，因为循环引用的对象无法从全局对象出发再获取到他们的引用。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏</p>
<h3 id="常见的内存泄露"><a href="#常见的内存泄露" class="headerlink" title="常见的内存泄露"></a>常见的内存泄露</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar1 = <span class="string">'some text'</span> <span class="comment">// 实际上声明了全局变量 window.bar1</span></span><br><span class="line">  <span class="keyword">this</span>.bar2 = <span class="string">'some text'</span> <span class="comment">// 全局变量 window.bar2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="被遗忘的计时器和回调函数"><a href="#被遗忘的计时器和回调函数" class="headerlink" title="被遗忘的计时器和回调函数"></a>被遗忘的计时器和回调函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData()</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>)</span><br><span class="line">  <span class="keyword">if</span>(renderer) &#123;</span><br><span class="line">    renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>如果后续移除了 renderer，那么其实计时器已经没用了，但是没有回收计时器的话，计时器仍然后效，他依赖的 serverData 也依然有效</p>
<h4 id="DOM-引用"><a href="#DOM-引用" class="headerlink" title="DOM 引用"></a>DOM 引用</h4><p>前端除了 JS 进程以外，还有 DOM 进程：</p>
<ul>
<li>只使用 <code>div.remove</code> 只是将 <code>div</code> 从页面中删掉，但在内存中还在</li>
<li>只使用 <code>div = null</code>，而没有 <code>remove</code> 的话，<code>div</code> 还在 DOM 中，他就不会被回收</li>
</ul>
<p>此外还有一些特殊情况，比如如果我们引用了一个表格中的 td 元素，一旦在 DOM 中删除了整个表格，我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素。但是事实上，这个 td 元素是整个表格的一个子元素，并保留对于其父元素的引用。这就会导致对于整个表格，都无法进行内存回收。</p>
<h1 id="与后端进行数据交互的方法"><a href="#与后端进行数据交互的方法" class="headerlink" title="与后端进行数据交互的方法"></a>与后端进行数据交互的方法</h1><h2 id="Form-表单"><a href="#Form-表单" class="headerlink" title="Form 表单"></a>Form 表单</h2><ul>
<li>只支持 GET 和 POST 类型</li>
<li>有问无答</li>
<li>提交后页面会刷新，用户体验不佳</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li>支持多种请求方法</li>
<li>XMLHttpRequest</li>
<li>Fetch</li>
<li>POST 请求编码方式<ul>
<li>multipart/formData<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以用</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">formData.append(<span class="string">''</span>,<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 也可以直接将 Form 表单的 DOM 对象直接放进去</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData($form)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li>服务器可以主动发起请求</li>
</ul>
<h1 id="关于时间"><a href="#关于时间" class="headerlink" title="关于时间"></a>关于时间</h1><ul>
<li>ISO 8601</li>
<li>Moment.js</li>
<li>Day.js</li>
</ul>
<h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'x'</span>&#125;</span><br><span class="line">a.x = a = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码执行分为两步： 1. 确定 a 是什么；2. 执行（从右向左）</span></span><br><span class="line"><span class="comment">// 执行到 a.x 的时候，a 还是原来的地址，但是他右边的 a 已经是新的地址了</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs：HTML 与 CSS</title>
    <url>/hais-notebook/2020/02/04/Others-QA-HtmlCss/</url>
    <content><![CDATA[<p>关于 HTML 和 CSS 的一些问题与答案。</p>
<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML-语义化？"><a href="#HTML-语义化？" class="headerlink" title="HTML 语义化？"></a>HTML 语义化？</h2><h3 id="HTML-语义化的历史"><a href="#HTML-语义化的历史" class="headerlink" title="HTML 语义化的历史"></a>HTML 语义化的历史</h3><p>最开始是后台用写 HTML，主要使用 table 来布局，维护起来非常麻烦；后来进入 DIV+CSS 的时代，问题是不够语义化；现在才是比较专业的，使用正确的标签的正确的写法。</p>
<p>具体：平时写的代码中用到的语义化标签。</p>
<h2 id="meta-viewport？"><a href="#meta-viewport？" class="headerlink" title="meta viewport？"></a>meta viewport？</h2><h2 id="用过哪些-HTML-5-标签？"><a href="#用过哪些-HTML-5-标签？" class="headerlink" title="用过哪些 HTML 5 标签？"></a>用过哪些 HTML 5 标签？</h2><h2 id="H5-是什么？"><a href="#H5-是什么？" class="headerlink" title="H5 是什么？"></a>H5 是什么？</h2><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="回溯机制？"><a href="#回溯机制？" class="headerlink" title="回溯机制？"></a>回溯机制？</h2><h2 id="flex-的常见属性？"><a href="#flex-的常见属性？" class="headerlink" title="flex 的常见属性？"></a>flex 的常见属性？</h2><h2 id="页面导入样式时，link-和-import-有什么区别？"><a href="#页面导入样式时，link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，link 和 @import 有什么区别？"></a>页面导入样式时，<code>link</code> 和 <code>@import</code> 有什么区别？</h2><div class="table-container">
<table>
<thead>
<tr>
<th>link</th>
<th>@import</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTML 标签，除了 CSS 之外还可以定义 RSS 等</td>
<td>CSS 提供的</td>
</tr>
<tr>
<td>加载页面时同时加载</td>
<td>页面加载完之后再加载</td>
</tr>
<tr>
<td>没有兼容性问题</td>
<td>不兼容 IE 5 以下</td>
</tr>
<tr>
<td>可以通过 DOM 动态引入</td>
<td>不能动态引入</td>
</tr>
</tbody>
</table>
</div>
<h2 id="移动端响应式方案"><a href="#移动端响应式方案" class="headerlink" title="移动端响应式方案"></a>移动端响应式方案</h2><ol>
<li>@media</li>
<li>PC 固定布局，移动端 rem</li>
<li>flex</li>
<li>vh/vw</li>
</ol>
<h2 id="CSS-选择器优先级？"><a href="#CSS-选择器优先级？" class="headerlink" title="CSS 选择器优先级？"></a>CSS 选择器优先级？</h2><ol>
<li>越具体优先级越高</li>
<li>写在后面的覆盖写在前面的</li>
<li><code>important!</code> 最高，但是少用</li>
</ol>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2>]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>FAQ</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/hais-notebook/2020/02/04/React-Redux/</url>
    <content><![CDATA[<p>主要记录了 Redux 的相关东西。</p>
<p>可以看看 <a href="https://codesandbox.io/s/jovial-gates-wbs8e" target="_blank" rel="noopener">这个例子</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React Event</title>
    <url>/hais-notebook/2020/02/04/React-Event/</url>
    <content><![CDATA[<p>主要记录了 React 事件的相关东西。</p>
<a id="more"></a>
<h1 id="类组件的事件"><a href="#类组件的事件" class="headerlink" title="类组件的事件"></a>类组件的事件</h1><p>可以这样写事件</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 这样写的 addN 是挂在原型上的  </span></span><br><span class="line">  addN() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.addN()&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*   这样最安全最好懂，箭头函数的 <span class="keyword">this</span> 不会变   *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不能在 JSX 里面这样写：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&#123;/</span>*   这里面 addN 的 <span class="keyword">this</span> 会变成 <span class="built_in">window</span>   *<span class="regexp">/&#125;</span></span><br></pre></td></tr></table></figure>
<p>因为在点击的时候 React 实际上运行的是 <code>button.onClick.call(null,event)</code>，<code>this</code> 被 React 改了，当然我们可以通过 <code>bind</code> 来绑定 <code>this</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.addN.bind(<span class="keyword">this</span>)&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以给箭头函数取个名字再来调用：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; ... &#125;  </span><br><span class="line">  addN() &#123; ... &#125;</span><br><span class="line">  _addN() &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.addN()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>._addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以将 <code>addN</code> 写在 <code>constructor</code> 里面：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这样 addN 就是挂在每个实例对象上了  </span></span><br><span class="line">    <span class="keyword">this</span>.addN = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这种写法本质与上面的一样，只是 ES 6 的语法糖：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      n: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addN = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> n = state.n + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> &#123; n &#125;      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        n: &#123;<span class="keyword">this</span>.state.n&#125;            </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.addN&#125;&gt; n + <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/hais-notebook/2020/02/02/Tools-axios/</url>
    <content><![CDATA[<p>文档翻译<br>用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端。</p>
<a id="more"></a>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li>从浏览器发起 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li>
<li>从 node.js 发起 <a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>JSON 数据的自动转换</li>
<li>从客户端防范 XSRF 攻击</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<p>使用 bower：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure>
<p>使用 yarn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add axios</span><br></pre></td></tr></table></figure>
<p>使用 cdn：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="注意：这是在-CommonJS-中的使用方法"><a href="#注意：这是在-CommonJS-中的使用方法" class="headerlink" title="注意：这是在 CommonJS 中的使用方法"></a>注意：这是在 CommonJS 中的使用方法</h2><p>为了在使用 <code>require()</code> 进行导入的 CommonJS 中获得 TypeScript 输入时的智能补充和类型提示，需要使用这样的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>).default;</span><br><span class="line"><span class="comment">// 这样 axios.&lt;method&gt; 就可以提供自动补充和参数类型了</span></span><br></pre></td></tr></table></figure>
<p>执行一个 <code>GET</code> 请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已知 ID 的情况下请求 user</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理成功的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理失败的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 永远执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以这样写：</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理成功的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理失败的情形</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 永远执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要使用 async/await？那就在你外面的函数/方法上加上 `async` 关键字</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> aixos.get(<span class="string">'/user?ID=12345'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong><code>async/await</code> 是 ECMAScript 2017 的一部分，并且不支持 Internet Explorer 和一些更久的浏览器，所以使用的时候要注意。</p>
</blockquote>
<p>执行一个 <code>POST</code> 请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>执行多个并发请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permission'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermission()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct,perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求都完成了</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>
<h1 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h1><p>可以通过给 <code>axios</code> 传递相关的 config 来执行请求。</p>
<p>axios(config)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 GET 方法请求一个图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType: <span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>axios(url[, config])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求（默认方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h2><p>为了方便，所有支持的请求方法都提供了别名。</p>
<p>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config])<br>axios.options(url[, config])<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])</p>
<blockquote>
<p>注意<br>当使用别名时，不需要再在 config 中指定 <code>url</code> <code>method</code> 和 <code>data</code> 属性</p>
</blockquote>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>有一些帮助函数来处理并发请求。</p>
<p>axios.all(iterable)<br>axios.spread(callback)</p>
<h2 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h2><p>你可以使用自定义的 config 来创建一个 axios 实例。</p>
<p>axios.create([config])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>下面列举了可用的实例方法，指定的 config 会与实例的 config 合并。</p>
<p>axios#request(config)<br>axios#get(url[, config])<br>axios#delete(url[, config])<br>axios#head(url[, config])<br>axios#options(url[, config])<br>axios#post(url[, data[, config]])<br>axios#put(url[, data[, config]])<br>axios#patch(url[, data[, config]])<br>axios#getUri([config])</p>
<h1 id="请求的-config"><a href="#请求的-config" class="headerlink" title="请求的 config"></a>请求的 config</h1><p>在众多的 config 选项中，只有 <code>url</code> 是必须的。如果没有指定 <code>method</code>，则默认为 <code>GET</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url` 是被用于请求的服务器的 URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是发起请求时用的方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `baseURL` 将在 `url` 不是绝对路径的时候放在 `url` 的前面</span></span><br><span class="line">  <span class="comment">// 给 axios 实例设置一个 `baseURL` 就可以很方便地给实例的方法传递相对路径</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在请求发送给服务器之前变换数据</span></span><br><span class="line">  <span class="comment">// 这只适用于 'PUT' 'POST' 'PATCH' 和 'DELETE' 方法</span></span><br><span class="line">  <span class="comment">// 数组中最后的函数必须返回一个字符串</span></span><br><span class="line">  <span class="comment">// 或者 Buffer、ArrayBuffer、FormData 或 Stream 的实例</span></span><br><span class="line">  <span class="comment">// 你可以修改 headers 对象</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些什么来修改数据</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 允许对响应数据在传递给 then/catch 之前进行变换</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些什么来修改数据</span></span><br><span class="line">    <span class="keyword">return</span> data    </span><br><span class="line">  &#125;],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `headers` 是自定义的请求头</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `params` 是请求时的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须要是一个纯粹的对象或者 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个可选的函数，用来控制序列化的 `params`</span></span><br><span class="line">  <span class="comment">// （比如 https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/）</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是被当做请求体发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于 'PUT' 'POST' 和 'PATCH' 方法</span></span><br><span class="line">  <span class="comment">// 当没有设置 `transformRequest` 时，必须是以下几种类型之一：</span></span><br><span class="line">  <span class="comment">// - 字符串、纯粹的对象、ArrayBuffer、ArrayBufferView、URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 只有浏览器可用：FormData、文件、Blob</span></span><br><span class="line">  <span class="comment">// - 只有 Node 可用： Stream、Buffer</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送请求数据的另一种写法</span></span><br><span class="line">  <span class="comment">// post 方法</span></span><br><span class="line">  <span class="comment">// 只有 value 被发送，key 不会</span></span><br><span class="line">  data: <span class="string">'Country=Brasil&amp;City=Belo Horizonte'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定了请求超时的毫秒数</span></span><br><span class="line">  <span class="comment">// 如果请求超过了 `timeout`，则请求将会被放弃</span></span><br><span class="line">  timeout: <span class="number">1000</span>, <span class="comment">// 默认为 `0` （没有时限）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `withCredentials` 指定了访问跨站点的 Access-Control 请求</span></span><br><span class="line">  <span class="comment">// 是否使用证书</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `adapter` 允许自定义让测试变简单的请求控制器</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并且提供一个合法的响应</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 说明需要使用 HTTP 基本身份验证，并且提供合法的证书</span></span><br><span class="line">  <span class="comment">// 他将会 设置一个 `Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 并且会覆盖在 `headers` 中自定义的 `Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 请注意这里只能设置 HTTP 基本身份验证</span></span><br><span class="line">  <span class="comment">// 对于不记名令牌等，需要使用自定义的 `Authorization` 请求头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `responseType` 指定了服务器返回的数据类型</span></span><br><span class="line">  <span class="comment">// 包括 'arraybuffer' 'document' 'json' 'text' 'stream'</span></span><br><span class="line">  <span class="comment">// 只有浏览器可用：'blob'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 指定了解码响应数据的编码方式</span></span><br><span class="line">  <span class="comment">// 注意：在 'stream' 或客户端请求的 `responseType` 被忽略</span></span><br><span class="line">  responseEncoding: <span class="string">'utf-8'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用来做为 xsrf 令牌值的 cookie 的名字</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是保存 xsrf 令牌值的 HTTP 头的名字</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许控制上传的事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生事件做些什么</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许控制下载的事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生事件做些什么</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了以字节计量的 HTTP 响应允许的最大容量</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义根据 HTTP 响应的状态码</span></span><br><span class="line">  <span class="comment">// 是 resolve 还是 reject 这个 promise</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true`（或设为 `null` 或 `undefined`），</span></span><br><span class="line">  <span class="comment">// 将会 resolve 这个 promise</span></span><br><span class="line">  <span class="comment">// 反之则 reject 这个 promise</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在 node.js 中最大的重定向数</span></span><br><span class="line">  <span class="comment">// 如果设为 0，则不允许重定向</span></span><br><span class="line">  maxRedirect: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `socketPath` 定义了在 node.js 中使用的 UNIX Socket</span></span><br><span class="line">  <span class="comment">// 比如 '/var/run/docker.sock' 来发送请求到 docker daemon</span></span><br><span class="line">  <span class="comment">// `socketPath` 与 `proxy` 中只有一个生效</span></span><br><span class="line">  <span class="comment">// 如果都被设置了，则使用 `socketPath`</span></span><br><span class="line">  socketPath: <span class="literal">null</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别定义了一个执行 http 和 https 请求时</span></span><br><span class="line">  <span class="comment">// 在 node.js 中的代理</span></span><br><span class="line">  <span class="comment">// 这允许诸如 `keepAlive` 之类的默认情况下不允许的选项</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy' 定义了代理服务器的主机名和端口</span></span><br><span class="line">  <span class="comment">// 你也可以用常规的 `http_proxy` `https_proxy` 环境变量定义你的代理</span></span><br><span class="line">  <span class="comment">// 如果你正在使用环境变量来配置代理，你也可以定义 `no_proxy` 环境变量</span></span><br><span class="line">  <span class="comment">// 这是一个用逗号分隔的不应该被代理的主机列表</span></span><br><span class="line">  <span class="comment">// 用 `false` 来禁用代理，忽略环境变量</span></span><br><span class="line">  <span class="comment">// `auth` 表示在连接这个代理的时候应该使用 HTTP 基本身份验证，并提供证书</span></span><br><span class="line">  <span class="comment">// 这将会设置 `Proxy-Authorization` 请求头</span></span><br><span class="line">  <span class="comment">// 并且覆盖已经存在的在 `headers` 中自定义的 `Proxy-Authorization`</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定了一个可以被用来取消请求的取消令牌</span></span><br><span class="line">  <span class="comment">// （查看下面的取消部分来获取更多信息）</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="响应模式"><a href="#响应模式" class="headerlink" title="响应模式"></a>响应模式</h1><p>请求的响应包含了以下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 是服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `status` 是服务器返回的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 是服务器返回的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `headers` 是服务器返回的响应头</span></span><br><span class="line">  <span class="comment">// 所有的返回头都是小写</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是提供给 `axios` 做请求的 config</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `request` 是产生这个响应的请求</span></span><br><span class="line">  <span class="comment">// 这是 node.js 中（在重定向中）的最后一个 ClientRequest 实例</span></span><br><span class="line">  <span class="comment">// 和浏览器中的 XMLHttpRequest 实例</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用 <code>then</code> 的时候，你会收到这样的响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.header);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用 <code>catch</code> ，或者传递一个 rejection 回调作为 <code>then</code> 的第二个参数的时候，响应将在 <code>error</code> 对象中可用，就像在处理错误章节中说的一样。</p>
<h1 id="配置的默认值"><a href="#配置的默认值" class="headerlink" title="配置的默认值"></a>配置的默认值</h1><p>你可以指定一个默认配置应用于所有的请求。</p>
<h2 id="全局-axios-默认配置"><a href="#全局-axios-默认配置" class="headerlink" title="全局 axios 默认配置"></a>全局 axios 默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.helpers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="自定义实例默认配置"><a href="#自定义实例默认配置" class="headerlink" title="自定义实例默认配置"></a>自定义实例默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建实例的时候设置默认配置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在创建实例之后改变默认配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>
<h2 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h2><p>配置会根据优先顺序自动合并。首先是在 lib/defaults.js 里面的库默认配置，然后是实例中的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者的优先级比前者高。这里是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用库中提供的默认配置来创建一个实例</span></span><br><span class="line"><span class="comment">// 就这个例子来说，timeout 配置是 `0`，因为是库的默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖库中默认的 timeout 值</span></span><br><span class="line"><span class="comment">// 现在这个实例的所有请求会在超时之前等待 2.5 秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖这个请求的 timeout 值，因为我们知道他会花更长的时间</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>你可以在请求或者响应被 <code>then</code> 或 <code>catch</code> 处理之前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在请求发出之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在请求失败的时候做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有状态码在 2xx 范围的都会触发</span></span><br><span class="line">  <span class="comment">// 对返回的数据做些什么</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有状态码不在 2xx 范围的都会触发</span></span><br><span class="line">  <span class="comment">// 对返回的错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果你需要移除一个拦截器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.interseptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interseptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>
<p>你可以给一个 axios 实例增加拦截器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response) &#123;</span><br><span class="line">      <span class="comment">// 发出请求后收到一个状态码不在 2xx 范围的回复</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// 请求发出了但是没有收到回复</span></span><br><span class="line">      <span class="comment">// `error.request` 是浏览器中 XMLHttpRequest 的实例</span></span><br><span class="line">      <span class="comment">// 也是一个 node.js 中 http.ClientRequest 的实例</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在引发错误的请求的安装过程中发生了些状况</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>使用 <code>validateStatus</code> 配置选项，可以配置应该抛出错误的 HTTP 状态码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">// 只 reject 状态码大于等于 500 的响应</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 <code>toJSON</code> 可以获得关于 HTTP 错误的更多信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.toJSON());</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h1><p>你可以使用取消令牌来取消请求。</p>
<blockquote>
<p>axios 取消令牌 API 基于被弃用的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">cancelable promises proposal</a></p>
</blockquote>
<p>你可以用 <code>CancelToken.source</code> 工厂函数创建一个取消令牌：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken();</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by user.'</span>);</span><br></pre></td></tr></table></figure>
<p>你也可以通过传递一个执行函数给 <code>CancelToken</code> 构造器来创建一个取消令牌：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个执行函数接受取消函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：你可以用同一个取消令牌取消多个请求。</p>
</blockquote>
<h1 id="使用-application-x-www-form-urlencoded-表格"><a href="#使用-application-x-www-form-urlencoded-表格" class="headerlink" title="使用 application/x-www-form-urlencoded 表格"></a>使用 application/x-www-form-urlencoded 表格</h1><p>默认情况下，axios 会将 JavaScript 对象序列化为 <code>JSON</code>。如果需要以 <code>application/x-www-form-urlencoded</code> 的格式来发送数据，你可以下面的选项之一：</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>在浏览器中，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener"><code>URLSearchParams</code></a> API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意并不是所有的浏览器都支持 <code>URLSearchParams</code>，但是这里有一个可用的 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener">polyfill</a>（务必确认 polyfill 全局环境）</p>
</blockquote>
<p>你也可以用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库进行编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>或者用别的方法（ES 6）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123; <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>在 node.js 中，你可以使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener"><code>querystring</code></a> 模组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库。</p>
<blockquote>
<p>注意<br>如果你需要序列化嵌套对象，使用 <code>qs</code> 库是更合适的，因为 <code>querystring</code> 方法有些已知的问题（<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener">https://github.com/nodejs/node-v0.x-archive/issues/1665</a>）</p>
</blockquote>
<h1 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h1><p>axios <code>1.0</code> 版本之后，新的 minor 版本会发布一些重大的变化。比如 <code>0.5.1</code> 和 <code>0.5.4</code> 有着同样的 API，但是 <code>0.6.0</code> 版本会有一些重要的改变。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>axios 依赖于原生 ES6 的 Promise。如果你的环境不支持 ES6 Promises，你可以 <a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">polyfill</a>。</p>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>axios 包括一些 <a href="http://typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 Tips</title>
    <url>/hais-notebook/2020/02/02/Others-Tips/</url>
    <content><![CDATA[<p>收集一些 Tips。</p>
<a id="more"></a>
<h1 id="滚动条的宽度"><a href="#滚动条的宽度" class="headerlink" title="滚动条的宽度"></a>滚动条的宽度</h1><p>滚动条的宽度在 14 ~ 19px 之间，根据操作系统不同</p>
<h1 id="jQuery-制作-Tab"><a href="#jQuery-制作-Tab" class="headerlink" title="jQuery 制作 Tab"></a>jQuery 制作 Tab</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$tabBar.on(<span class="string">'click'</span>, <span class="string">'li'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> $li = $(e.currentTarget)</span><br><span class="line">  $li</span><br><span class="line">    .addClass(<span class="string">'selected'</span>)</span><br><span class="line">    .siblings()</span><br><span class="line">    .removeClass(<span class="string">'selected'</span>)</span><br><span class="line">  <span class="keyword">const</span> index = $li.index()</span><br><span class="line">  $tabContent</span><br><span class="line">    .children()</span><br><span class="line">    .eq(index)</span><br><span class="line">    .addClass(<span class="string">'active'</span>) <span class="comment">// 一定不要用.css 和.show，样式和行为分离</span></span><br><span class="line">    .siblings()</span><br><span class="line">    .removeClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$tabBar.children().eq(<span class="number">0</span>).trigger(<span class="string">'click'</span>)  <span class="comment">// 默认触发第一个</span></span><br></pre></td></tr></table></figure>
<h1 id="jQuery-如果有-class-就删掉，没有就加上"><a href="#jQuery-如果有-class-就删掉，没有就加上" class="headerlink" title="jQuery 如果有 class 就删掉，没有就加上"></a>jQuery 如果有 class 就删掉，没有就加上</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$square.on(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  $square.toggleClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="JS-的代码不能以括号开头"><a href="#JS-的代码不能以括号开头" class="headerlink" title="JS 的代码不能以括号开头"></a>JS 的代码不能以括号开头</h1><h1 id="方法-和-函数"><a href="#方法-和-函数" class="headerlink" title="*方法 和 函数"></a><strong>*方法</strong> 和 <strong>函数</strong></h1><ul>
<li>方法是面向对象概念，一定是依附于一个对象的</li>
<li>函数是数学概念</li>
<li>都是指的 function</li>
</ul>
<h1 id="常用的画草图的软件"><a href="#常用的画草图的软件" class="headerlink" title="常用的画草图的软件"></a>常用的画草图的软件</h1><ul>
<li>balsamiq</li>
<li>figma</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line">  .then( <span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'success1'</span>)&#125;, ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'error1'</span>)&#125; )</span><br><span class="line">  .then( <span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'success2'</span>)&#125;, ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'error2'</span>)&#125; )</span><br><span class="line"><span class="comment">// error1 -&gt; success2</span></span><br></pre></td></tr></table></figure>
<h1 id="新建一个项目要考虑哪些东西？"><a href="#新建一个项目要考虑哪些东西？" class="headerlink" title="新建一个项目要考虑哪些东西？"></a>新建一个项目要考虑哪些东西？</h1><ul>
<li>创建仓库</li>
<li>声明 LICENCE<br><img src="https://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png" alt=""></li>
<li>要用什么第三方的东西？ npm</li>
<li>在 webstorm 里面搜 VCS</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>BDD（Behavior-Driven Development）：行为驱动开发，用自然语言描述需求</li>
<li>TDD（Test-Driven Development）：测试驱动开发，目的是为了让测试通过</li>
<li>Assert：断言</li>
</ul>
<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><ul>
<li>持续测试</li>
<li>持续交付</li>
<li>持续部署</li>
</ul>
<h1 id="nodejs-Client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-MySQL-client"><a href="#nodejs-Client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-MySQL-client" class="headerlink" title="nodejs Client does not support authentication protocol requested by server; consider upgrading MySQL client"></a>nodejs Client does not support authentication protocol requested by server; consider upgrading MySQL client</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ul>
<li>web server 常用的缓存数据库，数据放在内存中</li>
<li>相比于 mysql，访问速度快；但是成本更高，数据量更小</li>
<li>解决：将 web server 和 redis 拆分成两个服务，不会占用 web server 的内存，可以跨进程访问</li>
<li>为何用 redis 来存 session？session 访问频繁，对性能要求高；不用考虑断电数据丢失的问题；session 数据量不会太大</li>
</ul>
<h1 id="Vue-的渲染过程"><a href="#Vue-的渲染过程" class="headerlink" title="Vue 的渲染过程"></a>Vue 的渲染过程</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的同步渲染过程</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">div.appendChild(child) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 1</span></span><br><span class="line">body.appendChild(div) <span class="comment">// -&gt; Vue.$mounted 调用，$mounted 是异步的，队列 2</span></span><br><span class="line"><span class="built_in">console</span>.log(div.outerHTML)</span><br></pre></td></tr></table></figure>
<h1 id="不能让-A-—更新—-gt-B-的同时-B-—更新—-gt-A"><a href="#不能让-A-—更新—-gt-B-的同时-B-—更新—-gt-A" class="headerlink" title="不能让  A —更新—&gt; B 的同时 B —更新—&gt; A"></a>不能让  A —更新—&gt; B 的同时 B —更新—&gt; A</h1><h1 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h1><ol>
<li>没有需求不要写代码，没有设计稿不要写代码</li>
<li>单元测试是重构的前提</li>
<li>设计模式<ol>
<li>发布订阅模式</li>
<li>单向数据流</li>
<li>正交（props）</li>
</ol>
</li>
</ol>
<h1 id="URL-和-URI？"><a href="#URL-和-URI？" class="headerlink" title="URL 和 URI？"></a>URL 和 URI？</h1><p>URL 实际上是 URI 的一个子集，除识别资源外还提供定位资源的方法。 </p>
<p>下面是一个 URI 的组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               path</span><br><span class="line">        ┌───────────────┴───────────────┐┌───┴────┐</span><br><span class="line">  abc:&#x2F;&#x2F;username:password@example.com:123&#x2F;path&#x2F;data?key&#x3D;value&amp;key2&#x3D;value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port                  query         fragment</span><br><span class="line"></span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure>
<p>举一个我们常见的 URL（URI） 的例子：</p>
<p><a href="https://zh.wikipedia.org/w/index.php?title=Special:随机页面#5" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=Special:随机页面#5</a></p>
<ol>
<li><code>https</code>：协议</li>
<li><code>zh.wikipedia.org</code>：域名</li>
<li><code>/w/index.php</code>：路径（不同的页面）</li>
<li><code>?title=Special:随机页面</code>：查询参数（相同页面，不同内容）</li>
<li><code>#5</code>：锚点（相同页面，相同内容，不同位置）</li>
<li>其中若不写端口号，则表示使用 https 对应的默认端口号 443</li>
</ol>
<h1 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h1><p>直接使用可以查询到域名的 A 记录。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nslookup hais-teatime.com</span><br></pre></td></tr></table></figure>
<h1 id="顶级域名？二级域名？"><a href="#顶级域名？二级域名？" class="headerlink" title="顶级域名？二级域名？"></a>顶级域名？二级域名？</h1><p>比如对于 www.baidu.com</p>
<ul>
<li>顶级域名：com</li>
<li>二级域名：baidu.com</li>
<li>三级域名：www.baidu.com</li>
</ul>
<p>三级域名跟二级域名可以没关系，有可能都不是属于一家公司，注意辨别。</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h1><p>看这个对象是不是处于原型链上的</p>
<h1 id="使用-表示-src-目录（import-alias）"><a href="#使用-表示-src-目录（import-alias）" class="headerlink" title="使用 @ 表示 src 目录（import alias）"></a>使用 <code>@</code> 表示 <code>src</code> 目录（import alias）</h1><h2 id="在-JS-或-TS-中使用"><a href="#在-JS-或-TS-中使用" class="headerlink" title="在 JS 或 TS 中使用 @"></a>在 JS 或 TS 中使用 <code>@</code></h2><p>可以直接使用</p>
<h2 id="在-CSS-或-SCSS-中使用"><a href="#在-CSS-或-SCSS-中使用" class="headerlink" title="在 CSS 或 SCSS 中使用 @"></a>在 CSS 或 SCSS 中使用 <code>@</code></h2><p>需要使用 <code>~@</code>，但是 webstorm 中会报错，需要点开 <code>settings</code>-<code>webpack</code>，在路径中找到 <code>node_modules\@vue\cli-service\webpack.config.js</code></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>Tip</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>React Props &amp; State</title>
    <url>/hais-notebook/2020/02/02/React-PropsState/</url>
    <content><![CDATA[<p>主要记录了 React 的 Props 和 State。</p>
<a id="more"></a>
<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><p>可以查看<a href="https://codesandbox.io/s/billowing-wind-d8kzw" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>可以查看<a href="https://codesandbox.io/s/silly-diffie-9yk38" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h2 id="setState-的注意事项"><a href="#setState-的注意事项" class="headerlink" title="setState 的注意事项"></a>setState 的注意事项</h2><ul>
<li><code>this.state.n += 1</code> 无效，UI 不会自动更新，需要用 <code>setState</code></li>
<li><code>setState</code> 不会马上改变 <code>state</code>，是异步更新的，推荐使用 <code>setState(函数)</code></li>
<li>不推荐 <code>this.setState(this.state)</code>，因为 React 不推荐我们修改旧的 <code>state</code>（不可变数据）</li>
</ul>
<h2 id="复杂-state"><a href="#复杂-state" class="headerlink" title="复杂 state"></a>复杂 state</h2><ul>
<li>类组件的 <code>setState</code> 会自动合并第一层，建议使用 <code>Object.assign</code> 或者 <code>...sate</code></li>
<li>函数组件不会自动合并，建议分开写</li>
</ul>
<h1 id="Vue-和-React-的区别"><a href="#Vue-和-React-的区别" class="headerlink" title="Vue 和 React 的区别"></a>Vue 和 React 的区别</h1><p>共同点：</p>
<ul>
<li>都是对视图的封装，React 是用类和函数表示一个组件，Vue 是用构造选项表示一个组件</li>
<li>都提供了 <code>creatElement</code> 的 XML 简写，React 是 JSX，Vue 是 template</li>
</ul>
<p>不同点：</p>
<ol>
<li>监听数据变化的实现原理不同<ul>
<li>Vue 通过 getter/setter 和代理等方式进行劫持，能够精确知道数据的变化，不需要特别的优化</li>
<li>React 默认是通过比较引用的方式来进行的，可能会造成不必要的 vDOM 重新渲染，需要用诸如 PureComponent/shouldComponentUpdate 等方式来进行优化</li>
</ul>
</li>
<li>数据流不同<ul>
<li>Vue 在 1.0 的时候 <strong>父子组件</strong> props 可以双向绑定，还有 v-model 可以实现 <strong>组件与 DOM</strong> 双向绑定</li>
<li>Vue 2 的时候 <strong>父子组件</strong> 不能双向绑定了（虽然仍然提供了 .sync 语法糖），并且还有 v-model</li>
<li>React 中是单向数据流，并且组件与 DOM 之间也需要使用 onChange/setState。</li>
</ul>
</li>
<li>HoC 和 mixins<ul>
<li>Vue 中使用不同功能的组合是通过 mixins 实现的</li>
<li>React 中则使用 HoC</li>
</ul>
</li>
<li>组件间的通信<ul>
<li>都有 props，也都可以跨层级通信，比如 Vue 的 provide/inject、React 的 context</li>
<li>React 本身不支持自定义事件，因此 Vue 里面一般使用事件，React 中一般使用父组件传来的回调函数</li>
</ul>
</li>
<li>更新视图<ul>
<li>Vue 中一个对象，对应一个虚拟 DOM，当对象的属性改变时，把属性相关的 DOM 节点全部更新</li>
<li>React 一个对象，对应一个虚拟 DOM，另一个对象对应另一个虚拟 DOM，对比两个更新，用 DOM Diff 算法找不同，然后局部更新 DOM</li>
</ul>
</li>
<li>写法不同<ul>
<li>Vue 是 JS in HTML</li>
<li>React 是 HTML in JS</li>
</ul>
</li>
<li>Vuex 和 Redux 的区别<ul>
<li>Vue 中的 $store 直接注入到了组件实例中，可以直接用 dispatch、commit、mapState、this.$store 等；React 中需要用 connect 把 props 和 dispatch、state 连接起来</li>
<li>Vue 中可以用 dispatch action、commit mutation；React 中只能使用 dispatch，不能直接操作 reduce</li>
<li>Redux 中的使用的是不可变数据，每次都要用新的 State 替换旧的，而 Vue 中是直接修改的</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React Advanced</title>
    <url>/hais-notebook/2020/02/02/React-Advanced/</url>
    <content><![CDATA[<p>主要抄了一下 React 文档。</p>
<a id="more"></a>
<h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><p>React 提供了类似于 Vue slot 的组合模式：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Wrapper</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'wrapper'</span>&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Wrapper&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt; Welcome &lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/Wrapper&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>同样的，也可以预留很多个洞：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"split-pane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="right"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;SplitPane</span></span><br><span class="line"><span class="regexp">      left=&#123;&lt;Left/</span>&gt;&#125;</span><br><span class="line">      right=&#123;&lt;Right/&gt;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>Context 类似于 Vue 的 provide / eject，使得数据可以跨层传递，而不必显式地通过组件树逐层传递 props。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(<span class="string">'defaultValue'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext value=<span class="string">"someValue"</span>&gt;</span><br><span class="line">        &lt;ButtonWrapper/&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function ButtonWrapper() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">class MyButton extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  static contextType = MyContext</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Button themeColor=&#123;this.context&#125;/</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 Context 之外还有一种避免中间组件显式传递底层组件的各种属性值的方法：直接将底层组件作为属性传递下去。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue)</span><br></pre></td></tr></table></figure>
<p>一旦有一个组件订阅了这个 Context 对象，这个组件会从组件树中寻找最近的匹配的 <code>Provider</code> 中读取 context 值；如果没有匹配到，则使用 <code>defaultValue</code>。需要注意的是，就算给 Provider 传递的是 <code>undefined</code>，<code>defaultValue</code> 也不会生效。</p>
<h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/* SomeValue */</span>&#125;&gt;</span><br><span class="line">  &lt;Child/&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br></pre></td></tr></table></figure>
<p>当 Provider 的 <code>value</code> 值发生变化时，内部所有的消费组件都会重新渲染，不受制于 <code>shouldComponentUpdate</code>，变化与否通过 <code>Object.is</code> 判定。</p>
<p>比如在下面这种情况时：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一旦 Provider 的父组件 App 进行重新渲染，每次 value 就会被赋值为新的对象，会引起所有下面的 consumer 组件的重新渲染。为了防止这么做，需要使用 state：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: &#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext</span><br></pre></td></tr></table></figure>
<p>通过挂载在 class 上的 <code>contextType</code> 属性获取一个 Context 对象，可以通过 <code>this.context</code> 来消费最近 Context 上的那个值，可以在包括 render 在内的任何生命周期中访问到他。</p>
<p>也可以通过 public class fields 语法中的 <code>static</code> 来初始化 <code>contextType</code>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>在函数式组件中，我们需要这样使用 context，中间的部分接受一个 context 值，返回一个 React 节点</p>
<h3 id="Context-displayName"><a href="#Context-displayName" class="headerlink" title="Context.displayName"></a>Context.displayName</h3><p>修改在 React DevTools 中显示的名字</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(<span class="comment">/* someValue */</span>)</span><br><span class="line">MyContext.displayName = <span class="string">'MyDisplayName'</span></span><br><span class="line"></span><br><span class="line">&lt;MyContext.Provider&gt; <span class="comment">// 在 DevTools 中显示 "MyDisplayName.Provider"</span></span><br><span class="line">&lt;MyContext.Consumer&gt; <span class="comment">// 在 DevTools 中显示 "MyDisplayName.Consumer"</span></span><br></pre></td></tr></table></figure>
<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><h2 id="如何使用-ref"><a href="#如何使用-ref" class="headerlink" title="如何使用 ref"></a>如何使用 ref</h2><h3 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef"></a>React.createRef</h3><p>可以这样创建一个属性 myRef，然后传递给 DOM 元素 <code>div</code>，后续就可以使用 <code>this.myRef.current</code> 访问到这个 <code>div</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.myRef&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Ref 用于普通 HTML 元素时，<code>this.myRef.current</code> 为 HTML 元素：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  focusEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.myRef&#125;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.textInput&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.focusEvent&#125;&gt;Focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Ref 用于自定义 class 组件时，<code>this.myRef.current</code> 为组件的实例：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 可以调用到 Child 组件里面的 focusTextInput 方法</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focusTextInput()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Child ref=&#123;<span class="keyword">this</span>.textInput&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不能在函数组件上使用 ref（函数组件没有实例，ref.current 没办法指向函数组件），但是可以在函数组件里面使用 ref。</p>
<h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><p>在这种方式中，传递的不是 <code>createRef()</code> 创建 <code>ref</code> 属性，而是一个函数。这个函数中接受 React 组件实例或者 HTML DOM 元素作为参数。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput = element</span><br><span class="line">  &#125;</span><br><span class="line">  focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用原生 DOM API 使得 textInput 获得焦点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.focusTextInput()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 给 ref 属性传一个一个回调函数，React 组件挂载式会调用回调函数并传入 element</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;&gt;Focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，你可以让 <code>textInpu</code> 指向一个 class 组件，但仍然不能让其指向一个函数组件（因为函数组件没有实例）；但是你可以给函数组件传递一个回调，并将其赋值给函数组件内部的 <code>ref</code> 属性，React 在挂载的时候将调用这个回调，并传入 <code>element</code> 作为参数：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span></span><br><span class="line">  &#125;  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child inputRef=&#123;el =&gt; <span class="keyword">this</span>.textInput = el&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Child() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="text" ref=&#123;props.inputRef&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>↑ 在 <code>forWardRef</code> 出现之前，函数组件需要借用回调函数达到 Ref 转发的目的</p>
<h2 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h2><p>为了解决上面这个问题，<code>forwardRef</code> 出现了，他允许组件接收 ref 并将其向下传递，最终可以使得 ref 指向最底层的 HTML DOM：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myRef = React.createRef()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Child ref=&#123;myRef&#125;&gt; I am a Button &lt;<span class="regexp">/Child&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const Child = React.forwardRef((props, ref) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;button ref=&#123;ref&#125; className="button-wrapper"&gt;</span></span><br><span class="line"><span class="regexp">    &#123;props.children&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>button&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>通过这样的方式，我们在 MyComp 中就可以通过 <code>myRef.current</code> 获取到原生的 button 了</p>
<h2 id="高阶组件的-Ref-转发"><a href="#高阶组件的-Ref-转发" class="headerlink" title="高阶组件的 Ref 转发"></a>高阶组件的 Ref 转发</h2><p>有时候我们会使用高阶组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'old props: '</span>, prevProps)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new props: '</span>, <span class="keyword">this</span>.props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">class Child extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  // ...</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default logProps(Child)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果对 HOC 添加 ref，该 ref 将会引用到其外层的容器组件，而不是被包裹的组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 按照以前的逻辑，这里的 ref 应该指向组件 Child</span></span><br><span class="line">      <span class="comment">// 但实际上，这里的 ref 指向的并不是 Child，而是他外面的 LogProps</span></span><br><span class="line">      &lt;Child ref=&#123;<span class="keyword">this</span>.textInput&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们需要使用 <code>React.forward</code> 来将 ref 透传下去（就像之前函数组件使用 <code>React.forward</code> 将 ref 透传，指向了最终的 HTML DOM 元素一样），使得 ref 指向原来被包裹的组件：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LongProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'old props: '</span>, prevProps)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new props: '</span>, <span class="keyword">this</span>.props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return React.fowardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;LongProps &#123;...props&#125; forwardedRef=&#123;ref&#125;/&gt;  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">export default logProps(Child)</span><br></pre></td></tr></table></figure>
<h1 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h1><p>类似于 <code>&lt;template&gt;</code>，使用 Fragments 可以创建类似的一个包裹器，而不会在 DOM 中添加额外的节点：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA/&gt;</span><br><span class="line">      &lt;ChildB/&gt;</span><br><span class="line">      &lt;ChildC/&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>还有一个简写版本，简写版不支持使用 key 或其他属性：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;ChildA/&gt;</span><br><span class="line">      &lt;ChildB/&gt;</span><br><span class="line">      &lt;ChildC/&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Higher-Order-Component"><a href="#Higher-Order-Component" class="headerlink" title="Higher-Order Component"></a>Higher-Order Component</h1><p>React 中经常会使用高阶组件（HOC, Higher-Order Component）来复用组件逻辑，它是一种设计模式。<br>具体来说，高阶组件是参数为组件，返回值为新组建的函数：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent)</span><br></pre></td></tr></table></figure>
<h2 id="HOC-的使用场景"><a href="#HOC-的使用场景" class="headerlink" title="HOC 的使用场景"></a>HOC 的使用场景</h2><h3 id="修改-props"><a href="#修改-props" class="headerlink" title="修改 props"></a>修改 props</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">let</span> props = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        <span class="comment">// 增加 message 这个 Prop</span></span><br><span class="line">        message: <span class="string">'Hello'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.props.data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="HOC-的例子"><a href="#HOC-的例子" class="headerlink" title="HOC 的例子"></a>HOC 的例子</h2><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React Redux"></a>React Redux</h3><p>通过 HOC 监听 redux store，然后把下级组件需要的 state、action creator 绑定到 WrappedComponent 的 props 上</p>
<h3 id="logger-和-debugger"><a href="#logger-和-debugger" class="headerlink" title="logger 和 debugger"></a>logger 和 debugger</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`WrappedComponent: <span class="subst">$&#123;WrappedComponent.displayName&#125;</span>, Current props: `</span>, <span class="keyword">this</span>.props)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`WrappedComponent: <span class="subst">$&#123;WrappedComponent.displayName&#125;</span>, Next props: `</span>, nextProps)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="页面权限管理"><a href="#页面权限管理" class="headerlink" title="页面权限管理"></a>页面权限管理</h3><p>通过 HOC 对组件进行包裹，当用户跳转到其他页面的时候，检查用户是否含有对应的权限，如果有的话，渲染页面，如果没有的话，跳转到其他页面</p>
<h1 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h1><p>Reconciliation 直译为协调，即 React 的渲染机制，他有以下几步：</p>
<ol>
<li>props 或 state 改变</li>
<li>render 函数返回不同的元素树（虚拟 DOM）</li>
<li>新旧 DOM 对比（vDOM Diff）</li>
<li>针对差异的地方进行更新</li>
<li>渲染为真实的 DOM 树</li>
</ol>
<h2 id="DOM-Diff-原理"><a href="#DOM-Diff-原理" class="headerlink" title="DOM Diff 原理"></a>DOM Diff 原理</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol>
<li>永远只比较同层的节点，不会跨层级比较</li>
<li>不同的两个节点产生不同的树（两个类型不同的节点直接用新的全部替代旧的，包括其后代）</li>
<li>通过 key 判断哪些元素是相同的（比如列表如果没有 key，从头部插入元素会导致列表全部更新），因此 key 需要在列表中保持唯一（不需要全局唯一）</li>
</ol>
<h3 id="比较流程"><a href="#比较流程" class="headerlink" title="比较流程"></a>比较流程</h3><ul>
<li>若元素类型不相同：直接用新的树替换掉原来的树</li>
<li>若元素类型相同：<ul>
<li>若都是 DOM 节点：更新 DOM 属性，比如 <code>style</code>、<code>title</code> 等，再向下递归找</li>
<li>若都是组件节点：组件实例保持不变，更新 Props</li>
</ul>
</li>
</ul>
<h2 id="如何减少-Diff-过程"><a href="#如何减少-Diff-过程" class="headerlink" title="如何减少 Diff 过程"></a>如何减少 Diff 过程</h2><blockquote>
<p>利用 <code>shouldComponentUpdate</code></p>
</blockquote>
<p>默认的 <code>shouldComponentUpdate</code> 会在 props 或 state 发生变化的时候返回 true，表示组件会重新渲染，然后调用 render 函数，进行 vDOM Diff；相对的，我们也可以通过控制它的返回值来控制是否发生 vDOM Diff</p>
<h2 id="浅比较与深比较"><a href="#浅比较与深比较" class="headerlink" title="浅比较与深比较"></a>浅比较与深比较</h2><p>如果不想使用 <code>shouldComponentUpdate</code> 来一个一个检查，可以使用 <code>pureComponent</code> 对所有 <code>props</code> 和 <code>state</code> 进行 <strong>浅比较</strong>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数组件，可以使用 <code>React.memo</code>：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Component)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>浅比较：</p><ol><li>首先会使用等价于 <code>Object.is</code> 的方法进行判断，因此若引用类型的地址相同则判定为没有发生变化；</li><li>然后对于地址不同的，会进行 <strong>一层</strong> key 和 value 的比较</li></ol>
          </div>
<p>因此，如果数据结构比较复杂，浅比较会损失掉很多信息，比如说通过 <code>push</code> 方法改变数组的值，浅比较将不能发现变化。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line"><span class="comment">// 这部分代码很糟，而且还有 bug</span></span><br><span class="line">  <span class="keyword">const</span> words = <span class="keyword">this</span>.state.words;</span><br><span class="line">  words.push(<span class="string">'marklar'</span>);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">words</span>: words&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候应该使用不可变数据，尽量避免修改正在用于 props 或 state 的值，而是创建一个新的值，去覆盖原来的值：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    words: state.words.concat([<span class="string">'marklar'</span>])</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 ES6 里的扩展运算符</span></span><br><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    words: [...state.words, <span class="string">'marklar'</span>]</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于对象，我们可以用 <code>Object.assign</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colorMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, colorMap, &#123;<span class="attr">right</span>: <span class="string">'blue'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用扩展运算符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colorMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;...colorMap, <span class="attr">right</span>: <span class="string">'blue'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，尽管扩展运算符和 <code>Object.assign</code> 创建了新的引用，但是他们仍然是 <strong>浅拷贝</strong>，这并不冲突</p>
<h2 id="immutable-数据结构"><a href="#immutable-数据结构" class="headerlink" title="immutable 数据结构"></a>immutable 数据结构</h2><p>immutable 的意义：浅比较缺点很明显，深比较有时候又比较浪费性能</p>
<p>简单来说：</p>
<ol>
<li><strong>节省性能</strong>：immutable 内部采用多叉树结构，如果它里面有节点被改变，那么则更新 <strong>这个节点</strong> 和他有关的所有 <strong>上级节点</strong></li>
<li><strong>返回一个新的引用</strong>，即使是浅比较也能感知到数据的变化</li>
</ol>
<h3 id="一些-immutable-API"><a href="#一些-immutable-API" class="headerlink" title="一些 immutable API"></a>一些 immutable API</h3><h4 id="fromJS"><a href="#fromJS" class="headerlink" title="fromJS"></a>fromJS</h4><p>将 JS 对象转换为 immutable 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"><span class="keyword">const</span> immutableState = fromJS (&#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h4><p>将 immutable 对象转换为 JS 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsObj = immutableState.toJS()</span><br></pre></td></tr></table></figure>
<h4 id="get-getIn"><a href="#get-getIn" class="headerlink" title="get/getIn"></a>get/getIn</h4><p>用来获取 immutable 对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = fromJS(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.get(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsObj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> res = jsObj.a.b</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutableObj = fromJS(jsObj)</span><br><span class="line"><span class="keyword">let</span> res = immutableObj.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">// 传入一个数组</span></span><br></pre></td></tr></table></figure>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>用来给 immutable 对象的属性赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = fromJS(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.set(<span class="string">'a'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>新旧数据对比，旧数据中不存在的属性直接添加，存在的属性用新数据覆盖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> immutableObj = fromJS(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line">immutableObj.merge(&#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h1><p>借助 Portal，可以将子节点渲染到存在于父组件以外的 DOM 节点。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br></pre></td></tr></table></figure>
<p>其中，<code>child</code> 是任何可以渲染的 React 子元素，比如组件、字符串、fragment，<code>container</code> 是一个 DOM 元素</p>
<p>通常我们这样写一个子组件，然后在父组件中调用它：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是有些时候如果父组件有 <code>overflow: hidden</code> <code>z-index</code> 等样式，如果子组件是对话框、悬浮卡或者提示框等时，我们需要让子组件跳脱出容器：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">    <span class="keyword">this</span>.props.children,</span><br><span class="line">    domNode</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>尽管 portal 可以被放在 DOM 树的任何位置，但他仍然在 React 树中，且与其在 DOM 树中的位置无关，因此像 context 之类的功能特性均不变。<br>事件冒泡也是这样，他会在 React 树中冒泡至 React 树的祖先，与 DOM 树无关。</p>
<h1 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h1><p><code>Profiler</code> 可以测量 React 多久渲染一次以及每次渲染的开销</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &#123;<span class="comment">/* Profiler 需要两个 Prop，一个是 id(string)，一个是当组件树中提交更新时被 React 调用的回调函数 onRender */</span>&#125;</span><br><span class="line">    &lt;Profiler id=<span class="string">"Navigation"</span> onRender=&#123;callback&#125;&gt;</span><br><span class="line">      &lt;Navigation &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Profiler&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Profiler id="Main" onRender=&#123;callback&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Main &#123;...props&#125;/</span>&gt;    </span><br><span class="line">    &lt;<span class="regexp">/Profiler&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>App&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRenderCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  id, <span class="regexp">//</span> 发生提交的 Profiler 树的 “id”</span></span></span><br><span class="line"><span class="function"><span class="params">  phase, <span class="regexp">//</span> <span class="string">"mount"</span> （如果组件树刚加载） 或者 <span class="string">"update"</span> （如果它重渲染了）之一</span></span></span><br><span class="line"><span class="function"><span class="params">  actualDuration, <span class="regexp">//</span> 本次更新 committed 花费的渲染时间</span></span></span><br><span class="line"><span class="function"><span class="params">  baseDuration, <span class="regexp">//</span> 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span></span></span><br><span class="line"><span class="function"><span class="params">  startTime, <span class="regexp">//</span> 本次更新中 React 开始渲染的时间</span></span></span><br><span class="line"><span class="function"><span class="params">  commitTime, <span class="regexp">//</span> 本次更新中 React committed 的时间</span></span></span><br><span class="line"><span class="function"><span class="params">  interactions <span class="regexp">//</span> 属于本次更新的 interactions 的集合</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合计或记录渲染时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h1><p>目的：封装组件，提高可复用性，可以这样使用：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="keyword">this</span>.props.mouse</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img src=<span class="string">"/cat.jpg"</span> style=&#123;&#123;<span class="attr">position</span>: <span class="string">'abosolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y&#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleMouseMove = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;<span class="attr">height</span>: <span class="string">'100%'</span>&#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">class MouseTracker extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;滑动鼠标&lt;/</span>h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125;/&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以创建一个 HOC：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMouse</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125;/&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      ) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的功能也可以通过在 <code>&lt;Mouse&gt;</code> 中使用 <code>props.children</code>，然后直接使用类似于这样的写法：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;Mouse&gt;</span><br><span class="line">  &#123;mouse =&gt; (</span><br><span class="line">    &lt;Cat mouse=&#123;mouse&#125;/&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;<span class="regexp">/Mouse&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 render prop 会导致 <code>React.PureComponent</code> 失效，因为外层组件更新的时候，render prop 的函数总是新的，除非你把它写成一个实例方法</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React Component</title>
    <url>/hais-notebook/2020/02/02/React-Component/</url>
    <content><![CDATA[<p>主要记录了 React 的组件的用法。</p>
<a id="more"></a>
<h1 id="元素（Element）与组件（Component）"><a href="#元素（Element）与组件（Component）" class="headerlink" title="元素（Element）与组件（Component）"></a>元素（Element）与组件（Component）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = React.createElement(<span class="string">'div'</span>,...) <span class="comment">// React 元素</span></span><br><span class="line"><span class="keyword">const</span> Div = <span class="function"><span class="params">()</span> =&gt;</span> React.createElement(<span class="string">'div'</span>,...) <span class="comment">// React 组件</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>目前而言，<br>React 中，一个返回 React 元素的<strong>函数</strong>就是组件<br>Vue 中，一个 <strong>构造选项</strong> 就可以表示一个组件</p>
          </div>
<h1 id="两种组件"><a href="#两种组件" class="headerlink" title="两种组件"></a>两种组件</h1><ul>
<li>函数组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">// 会自动变成 React.createElement(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类组件：</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者的使用方法都是：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;Welcome name=<span class="string">"frank"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>可以看看 <a href="https://codesandbox.io/s/tender-nightingale-eu1ne" target="_blank" rel="noopener">这个例子</a></p>
<h1 id="React-中的标签会被翻译成什么？"><a href="#React-中的标签会被翻译成什么？" class="headerlink" title="React 中的标签会被翻译成什么？"></a>React 中的标签会被翻译成什么？</h1><p><code>&lt;div/&gt;</code> 会被翻译成 <code>React.createElement(&#39;div&#39;)</code></p>
<p><code>&lt;Welcome/&gt;</code> 会被翻译成 <code>React.createElement(Welcome)</code></p>
<h2 id="React-creatElement"><a href="#React-creatElement" class="headerlink" title="React.creatElement"></a><code>React.creatElement</code></h2><ul>
<li>如果传入一个字符串 <code>&#39;div&#39;</code> ，则会创建一个 <code>div</code></li>
<li>如果传入一个函数，则会调用该函数，获取其返回值</li>
<li>如果传入一个类，则会在前面加类前面加 <code>new</code> （执行 constructor），获取一个组件的对象，然后调用对象的 render 方法，获取其返回值</li>
</ul>
<h1 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h1><h2 id="创建类组件"><a href="#创建类组件" class="headerlink" title="创建类组件"></a>创建类组件</h2><p>有两种方式创建类组件：</p>
<ul>
<li>ES 5 方式（过时）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;hi&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default A</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES 6 方式（使用 class）</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其实如果不在 constructor 里面加其他的东西，上面几行是可以省略掉的</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;hi&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default B</span></span><br></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">'harvey'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Child name=&#123;<span class="keyword">this</span>.state.name&#125;</span><br><span class="line">             onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;hi&lt;<span class="regexp">/Child&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 外部数据会被包装为一个对象：</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ &#123;name: 'harvey', onClick:..., children: 'hi'&#125; </span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props) /</span><span class="regexp">/ 这样会将 props 放到 this 上，这就是 props 的初始化</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 这样读取 props</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;this.props.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.name&#125;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>不允许修改 Props</p>
          </div>
<h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h3><p>会在 Props 变化的时候调用，目前已经不用了，并更名为 <code>UNSAFE_componentWillReceiveProps</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Props-的作用"><a href="#Props-的作用" class="headerlink" title="Props 的作用"></a>Props 的作用</h3><ul>
<li>接受外部的数据：只能读不能写</li>
<li>接受外部的函数：在恰当时机调用</li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 初始化 State</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改 State，注意 setState 不会立即修改 State，会在 set 成功之后调用 fn</span></span><br><span class="line">    <span class="comment">// 因此最后 this.state.x 不会 +2</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: <span class="keyword">this</span>.state.x + <span class="number">1</span></span><br><span class="line">    &#125;, fn)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: <span class="keyword">this</span>.state.x + <span class="number">1</span></span><br><span class="line">    &#125;, fn)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二种写法，这种情况下 this.state.x 会 +2</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      x: prevState.x + <span class="number">1</span></span><br><span class="line">    &#125;), fn)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      x: prevState.x + <span class="number">1</span></span><br><span class="line">    &#125;), fn)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 读取 State</span></span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;&#123;<span class="keyword">this</span>.state.x&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改 state 的时候会进行 <strong>Shallow Merge</strong>，新旧 state 进行一级合并</p>
<h2 id="React-Lifecycle"><a href="#React-Lifecycle" class="headerlink" title="React Lifecycle"></a>React Lifecycle</h2><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/React-LifeCycle.png" alt="React LifeCycle"></p>
<ul>
<li><strong><code>constructor(props)</code></strong>：用于初始化 state 和为事件处理函数绑定实例（<code>bind(this)</code>）</li>
<li><code>static getDerivedStateFromProps(props, state)</code>：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容</li>
<li><strong><code>shouldComponentUpdate()</code></strong>：判断 React 组件的输出是否受当前 state 或 props 更改的影响</li>
<li><strong><code>render()</code></strong>：当 state 或 props 发生变化时调用，可以通过 <code>shouldComponentUpdate</code> 调解调用时机</li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>：会在最近一次渲染输出之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）</li>
<li><strong><code>componentDidMount()</code></strong>：会在组件挂载后（插入 DOM 树中）立即调用</li>
<li><strong><code>componentDidUpdate(prevProps, prevState, snapshot)</code></strong>： 会在更新后会被立即调用。首次渲染不会执行此方法</li>
<li><strong><code>componentWillUnmount()</code></strong>：会在组件卸载及销毁之前直接调用</li>
<li><code>static getDerivedStateFromError(error)</code>：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</li>
<li><code>componentDidCatch(error, info)</code>：此生命周期在后代组件抛出错误后被调用</li>
</ul>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>初始化 props</li>
<li>初始化 state，但此时不能调用 <code>setState</code></li>
<li>用来写 <code>bind this</code><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>.onClick = <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用新语法代替</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul>
<li>返回 true 表示不阻止 UI 更新</li>
<li>返回 false 表示阻止 UI 更新</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>
<h4 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a><code>React.PureComponent</code></h4><p>会在 <code>render</code> 之前对新旧 state 和 props 进行浅对比（只比较一层），来控制是否 <code>render</code>，只要有任何一个 key 的值不同，就会 <code>render</code></p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a><code>render</code></h3><p>用于展示视图，可以用 <code>&lt;React.Fragment&gt;</code> 将多个标签括起来</p>
<p>可以在 <code>render</code> 中写</p>
<ul>
<li>if / else</li>
<li>map</li>
</ul>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h3><ul>
<li>在元素插入页面之后执行代码，这些代码通常依赖 DOM</li>
<li>同时官方推荐将加载数据的 AJAX 请求写在这里</li>
<li>首次渲染 <strong>会</strong> 执行这个钩子</li>
</ul>
<p>此外，推荐在使用 Ref 之前先赋值为一个 <code>undefined</code></p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><code>componentDidUpdate</code></h3><ul>
<li>在视图更新后执行代码</li>
<li>此处也可以发起 AJAX 请求，通常是用于更新数据</li>
<li>首次渲染 <strong>不会</strong> 执行这个钩子</li>
<li>在这里 <code>setState</code> 可能会引起无限循环，除非用 <code>if</code> 进行限制</li>
<li><code>shouldComponentUpdate</code> 返回 <code>false</code> 时不会调用</li>
</ul>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">compoentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><code>componentWillUnmount</code></h3><ul>
<li>组件将要被移除页面并销毁时，执行代码</li>
<li>Unmount 过的组件不会再次 Mount</li>
<li>通常需要在这里取消监听、计时器、AJAX 请求等</li>
</ul>
<h1 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h1><h2 id="创建函数组件"><a href="#创建函数组件" class="headerlink" title="创建函数组件"></a>创建函数组件</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> Hello1 = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数缩写</span></span><br><span class="line"><span class="keyword">const</span> Hello2 = <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello3</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数组件没有-state"><a href="#函数组件没有-state" class="headerlink" title="函数组件没有 state"></a>函数组件没有 state</h2><p>使用 <code>useState</code></p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [x, setX] = React.useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="函数组件没有生命周期"><a href="#函数组件没有生命周期" class="headerlink" title="函数组件没有生命周期"></a>函数组件没有生命周期</h2><p>使用 <code>useEffect</code></p>
<ul>
<li>模拟 <code>componentDidMount</code>（第一次渲染）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li>
<li>模拟 <code>componentDidUpdate</code>（更新时执行）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, [n])</span><br><span class="line"><span class="comment">// 这样的话第一次渲染也会执行，可以使用自定义 Hook 来解决</span></span><br><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">(<span class="params">fn, dep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [updateCount, setUpdateCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUpdateCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [dep])</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (updateCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [updateCount, fn])</span><br><span class="line">&#125;</span><br><span class="line">useUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, n)</span><br></pre></td></tr></table></figure></li>
<li>模拟 <code>componentWillUnmount</code>（将要销毁时执行）<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [n])</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React JSX</title>
    <url>/hais-notebook/2020/02/02/React-JSX/</url>
    <content><![CDATA[<p>JSX 介绍。</p>
<a id="more"></a>
<h1 id="引入-babel-loader"><a href="#引入-babel-loader" class="headerlink" title="引入 babel-loader"></a>引入 babel-loader</h1><h2 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h2><p>每次需要写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>使用 babel-loader</p>
<h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><h2 id="嵌入表达式"><a href="#嵌入表达式" class="headerlink" title="嵌入表达式"></a>嵌入表达式</h2><p>可以在大括号中使用任何合法的 JavaScript 表达式。</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'Josh Perez'</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>使用小括号将多行的 JSX 包裹起来，避免 JS 自动加分号的缺陷</p>
          </div>
<h2 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h2><p>可以返回在 <code>if</code> 语句和 <code>for</code> 循环中使用，可以传参给变量，可以作为参数接收，可以作为返回值</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定属性"><a href="#指定属性" class="headerlink" title="指定属性"></a>指定属性</h2><p>注意如果要使用大括号包裹 JS 表达式，别在大括号外面写引号</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>注意 <code>class</code> 变成了 <code>className</code>、<code>tabindex</code> 变成了 <code>tabIndex</code> 等</p>
          </div>
<h2 id="指定子元素"><a href="#指定子元素" class="headerlink" title="指定子元素"></a>指定子元素</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="JSX-阻止-XSS"><a href="#JSX-阻止-XSS" class="headerlink" title="JSX 阻止 XSS"></a>JSX 阻止 XSS</h2><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="JSX-代表了什么"><a href="#JSX-代表了什么" class="headerlink" title="JSX 代表了什么"></a>JSX 代表了什么</h2><p>下面两个表达方式是一样的：</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>React 开始</title>
    <url>/hais-notebook/2020/02/02/React-Start/</url>
    <content><![CDATA[<p>React 笔记的开始，主要记录了 React 的安装。</p>
<a id="more"></a>
<h1 id="引入-React"><a href="#引入-React" class="headerlink" title="引入 React"></a>引入 React</h1><h2 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/16.10.2/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>cjs 和 umd 的区别？</p>
<ul>
<li>cjs 全称是 CommonJS，是 Node.js 支持的模块规范</li>
<li>umd 是统一模块定义，兼容各种模块规范（包含浏览器）</li>
<li>理论上优先使用 umd，同时支持 Node.js 和浏览器</li>
<li>最新的模块规范是使用 <code>import</code> 和 <code>export</code> 关键字</li>
</ul>
<h2 id="通过-webpack-引入"><a href="#通过-webpack-引入" class="headerlink" title="通过 webpack 引入"></a>通过 webpack 引入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-create-react-app"><a href="#使用-create-react-app" class="headerlink" title="使用 create-react-app"></a>使用 create-react-app</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app</span><br></pre></td></tr></table></figure>
<h1 id="函数与普通代码的区别"><a href="#函数与普通代码的区别" class="headerlink" title="函数与普通代码的区别"></a>函数与普通代码的区别</h1><p>看 <a href="https://codesandbox.io/s/spring-waterfall-iyekc" target="_blank" rel="noopener">这个例子</a></p>
<ul>
<li>普通代码<strong>立即求值</strong>，读取当前值</li>
<li>函数会等调用的时候再求值（<strong>延迟求值</strong>），求值时才会读取 a 的最新值</li>
</ul>
<h1 id="对比-React-元素和函数组件的区别"><a href="#对比-React-元素和函数组件的区别" class="headerlink" title="对比 React 元素和函数组件的区别"></a>对比 React <strong>元素</strong>和<strong>函数组件</strong>的区别</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App1 = React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, n) <span class="comment">// App1 是一个 React 元素</span></span><br><span class="line"><span class="keyword">const</span> App2 = <span class="function"><span class="params">()</span> =&gt;</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, n) <span class="comment">// App2 是一个 React 函数组件</span></span><br><span class="line"><span class="comment">// App2 是延迟执行的代码，会在被调用的时候执行（会获取到 n 的最新值）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>React 元素<ul>
<li><code>createElement</code> 的返回值 <code>element</code> 可以代表一个 <code>div</code></li>
<li>但是 <code>element</code> 不是真正的 DOM 对象，而是一个 <strong>虚拟 DOM</strong> 对象</li>
</ul>
</li>
<li>() ⇒ React 元素<ul>
<li>返回 <code>element</code> 的函数，也可以代表一个 <code>div</code></li>
<li>函数可以多次执行，每次获取到最新的虚拟 <code>div</code></li>
<li>React 会对比两个虚拟 <code>div</code> ，找出不同，局部更新视图</li>
<li>找不同的算法叫做 <strong>DOM Diff 算法</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 入门尝试</title>
    <url>/hais-notebook/2020/02/02/Tools-Webpack-Basic/</url>
    <content><![CDATA[<p>webpack 的基础使用及问题。</p>
<a id="more"></a>
<div class="note warning">
            <p>webpack 安装的所有东西都是 —dev</p>
          </div>
<h1 id="Loader-与-Plugin"><a href="#Loader-与-Plugin" class="headerlink" title="Loader 与 Plugin"></a>Loader 与 Plugin</h1><ul>
<li>翻译</li>
<li>解释：加载文件；拓展功能</li>
<li>加载一个个 JS 文件，把 JS 文件转换成低版本浏览器可以支持的（JS Loader）；加载 CSS 文件，把 CSS 变成标签，或者进行其他处理 （CSS Loader、Style Loader）；加载图片，对图片进行优化；</li>
<li>HTML Webpack Plugin 生成 HTML 文件</li>
<li>Mini CSS Extract Plugin 抽取 CSS 文件</li>
</ul>
<h1 id="加载-JavaScript-文件"><a href="#加载-JavaScript-文件" class="headerlink" title="加载 JavaScript 文件"></a>加载 JavaScript 文件</h1><p>可以这样来调用本地安装的 webpack：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/webpack —version </span><br><span class="line"><span class="comment"># 或者用 npx，但 npx 不够稳定，比如如果 node 装到了有空格的目录，可能就有问题</span></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<p>webpack 自带了 JS Loader，我们需要自定义一下 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 默认为 './src/index.js'</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>HTTP Cache</strong><br>Response Header: Cache-Control</p>
</blockquote>
<p>可以设置 <code>package.json</code> 中的 <code>script</code>，让他每次自动删除之前的 <code>dist</code> 目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "rm -rf dist &amp;&amp; webpack"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后只要每次用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>
<h1 id="生成-HTML-文件"><a href="#生成-HTML-文件" class="headerlink" title="生成 HTML 文件"></a>生成 HTML 文件</h1><p>可以使用 <a href="https://webpack.js.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener">html-webpack-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>使用 html-webpack-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebPackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'my title'</span>,</span><br><span class="line">      template: <span class="string">'src/assets/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在 template 文件里面的 title 需要这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="加载-CSS-文件"><a href="#加载-CSS-文件" class="headerlink" title="加载 CSS 文件"></a>加载 CSS 文件</h1><p>可以使用 <a href="https://webpack.js.org/loaders/css-loader/" target="_blank" rel="noopener">css-loader</a> 和 <a href="https://webpack.js.org/loaders/style-loader/" target="_blank" rel="noopener">style-loader</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure>
<p>使用 css-loader 和 style-loader 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>CSSLoader 会把 .css 后缀的文件读到 JS 里面<br>StyleLoader 会把 style 标签放到 HTML 的 head 里面</p>
          </div>
<h1 id="预览与调试网页"><a href="#预览与调试网页" class="headerlink" title="预览与调试网页"></a>预览与调试网页</h1><p>可以使用 <a href="https://webpack.js.org/guides/development/" target="_blank" rel="noopener">webpack-dev-server</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>使用 webpack-dev-server 同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./dist'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在 <code>package.json</code> 里面加入 <code>script</code> 方便使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "webpack-dev-server --open",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h1><p>可以使用 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a></p>
<p>首先进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<p>使用 mini-css-extract-plugin 需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// all options are optional</span></span><br><span class="line">      filename: devMode ? <span class="string">'[name].css'</span> : <span class="string">'[name].[hash].css'</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">'[id].css'</span> : <span class="string">'[id].[hash].css'</span>,</span><br><span class="line">      ignoreOrder: <span class="literal">false</span>, <span class="comment">// Enable to remove warnings about conflicting order</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// you can specify a publicPath here</span></span><br><span class="line">              <span class="comment">// by default it uses publicPath in webpackOptions.output</span></span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">              hmr: process.env.NODE_ENV === <span class="string">'development'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="加载-Sass"><a href="#加载-Sass" class="headerlink" title="加载 Sass"></a>加载 Sass</h1><div class="note warning">
            <p>node sass 已经过时，应该使用 dart sass</p>
          </div>
<p>可以使用 <a href="https://webpack.js.org/loaders/sass-loader/" target="_blank" rel="noopener">sass-loader</a></p>
<p>同样需要修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options:&#123;<span class="attr">implementation</span>: <span class="built_in">require</span>(<span class="string">'dart-sass'</span>)&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h1 id="加载-Less"><a href="#加载-Less" class="headerlink" title="加载 Less"></a>加载 Less</h1><p>可以使用 <a href="https://webpack.js.org/loaders/less-loader/" target="_blank" rel="noopener">less-loader</a></p>
<h1 id="加载-Stylus"><a href="#加载-Stylus" class="headerlink" title="加载 Stylus"></a>加载 Stylus</h1><p>可以使用 <a href="https://github.com/shama/stylus-loader" target="_blank" rel="noopener">stylus-loader</a></p>
<h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>可以使用 file-loader，把文件变成文件路径</p>
<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>等到真正需要的时候再加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">import</span>(<span class="string">'./lazy.js'</span>)</span><br><span class="line"><span class="comment">// 将会得到一个 Promise 对象</span></span><br><span class="line">promise.then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">module</span>.default() <span class="comment">// 将会执行 export default 导出的函数</span></span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="在-GitHub-Pages-上部署"><a href="#在-GitHub-Pages-上部署" class="headerlink" title="在 GitHub Pages 上部署"></a>在 GitHub Pages 上部署</h1><p>第一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch gh-pages</span><br><span class="line">git checkout gh-pages</span><br><span class="line"><span class="comment"># 删除别的，只留下 dist、node_modules 和 .gitignore</span></span><br><span class="line">mv dist/* ./</span><br><span class="line">rm -rf dist</span><br></pre></td></tr></table></figure>
<p>以后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build: &amp;&amp;</span><br><span class="line">git checkout gh-pages &amp;&amp;</span><br><span class="line">rm -rf *.html *.js *.css *.png &amp;&amp;</span><br><span class="line">mv ./dist/* ./ &amp;&amp;</span><br><span class="line">rm -rf dist</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m <span class="string">'update'</span> &amp;&amp;</span><br><span class="line">git push &amp;&amp;</span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>踩坑</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>npm &amp; yarn</title>
    <url>/hais-notebook/2020/02/02/Tools-npm/</url>
    <content><![CDATA[<p>收集 npm 的包和问题。</p>
<a id="more"></a>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br><span class="line">nrm use taobao</span><br><span class="line"><span class="comment"># 所有的全局安装都在 C:\Users\Zhang\AppData\Roaming\npm\</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn global add yrm</span><br><span class="line">yrm use taobao</span><br><span class="line"><span class="comment"># 用 yrm ls 可以看所有源</span></span><br></pre></td></tr></table></figure>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="怎么知道包的最新版是多少？"><a href="#怎么知道包的最新版是多少？" class="headerlink" title="怎么知道包的最新版是多少？"></a>怎么知道包的最新版是多少？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm info [name] version</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>踩坑</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>一些话题</title>
    <url>/hais-notebook/2020/02/02/Others-Topics/</url>
    <content><![CDATA[<p>收集大佬的推荐。</p>
<a id="more"></a>
<h1 id="一些需要掌握的技术栈"><a href="#一些需要掌握的技术栈" class="headerlink" title="一些需要掌握的技术栈"></a>一些需要掌握的技术栈</h1><h2 id="最重要的"><a href="#最重要的" class="headerlink" title="最重要的"></a>最重要的</h2><ul>
<li>React Hooks</li>
<li>ES6</li>
<li>TypeScript</li>
<li>Flutter</li>
</ul>
<h2 id="值得一学的"><a href="#值得一学的" class="headerlink" title="值得一学的"></a>值得一学的</h2><ul>
<li>Graph QL</li>
<li>PWA</li>
<li>WebAssembly</li>
<li>WebGL 3D</li>
<li>《计算的本质》</li>
</ul>
<h2 id="需要了解的"><a href="#需要了解的" class="headerlink" title="需要了解的"></a>需要了解的</h2><h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h3><ul>
<li>语义化标签</li>
<li>音视频处理</li>
<li>canvas / webGL</li>
<li>history API</li>
<li>requestAnimationFrame</li>
<li>地理位置</li>
<li>web socket</li>
</ul>
<h3 id="CSS-3"><a href="#CSS-3" class="headerlink" title="CSS 3"></a>CSS 3</h3><ul>
<li>常规</li>
<li>动画</li>
<li>盒子模型</li>
<li>响应式布局</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>ES 3/5/6/7/8/9</li>
<li>DOM</li>
<li>BOM</li>
<li>设计模式</li>
<li>底层原理<ul>
<li>堆栈内存</li>
<li>闭包作用域 AO/VO/GO/EC/ESTACK</li>
<li>面向对象 OOP</li>
<li>This</li>
<li>EventLoop</li>
<li>浏览器渲染原理</li>
<li>回流重绘</li>
</ul>
</li>
</ul>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><ul>
<li>AJAX / Fetch / axios</li>
<li>HTTP 1.0/2.0</li>
<li>TCP</li>
<li>跨域处理方案</li>
<li>性能优化</li>
</ul>
<h3 id="Hybrid-APP-小程序"><a href="#Hybrid-APP-小程序" class="headerlink" title="Hybrid / APP / 小程序"></a>Hybrid / APP / 小程序</h3><ul>
<li>Hybrid</li>
<li>uni-app</li>
<li>RN</li>
<li>Flutter</li>
<li>MPVUE</li>
<li>Weex</li>
<li>PWA</li>
</ul>
<h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ul>
<li>webpack</li>
<li>git</li>
<li>linux / nginx</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/hais-notebook/2020/02/02/Tools-VSCode/</url>
    <content><![CDATA[<p>收集关于 VSCode 的用法及插件。</p>
<a id="more"></a>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>Vue<ul>
<li>Vetur</li>
<li>Vue VSCode Snippets</li>
</ul>
</li>
<li>TypeScript<ul>
<li>TypeScript Importer</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>收集</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 标签</title>
    <url>/hais-notebook/2020/02/02/HTML-Elements/</url>
    <content><![CDATA[<p>一些常见和重点的 HTML 标签。</p>
<a id="more"></a>
<h1 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h1><ul>
<li>表示书/文章的层级<ul>
<li>标题 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code></li>
<li>章节 <code>&lt;section&gt;</code></li>
<li>文章 <code>&lt;article&gt;</code></li>
<li>段落 <code>&lt;p&gt;</code></li>
<li>头部 <code>&lt;header&gt;</code></li>
<li>脚部 <code>&lt;footer&gt;</code></li>
<li>主要内容 <code>&lt;main&gt;</code></li>
<li>旁支内容 <code>&lt;aside&gt;</code></li>
<li>划分 <code>&lt;div&gt;</code></li>
</ul>
</li>
<li>内容标签<ul>
<li>有序列表 <code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code></li>
<li>无序列表 <code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code></li>
<li>描述 <code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code> + <code>&lt;dd&gt;</code>，其中 <code>&lt;dt&gt;</code> 表示描述词，<code>&lt;dd&gt;</code> 表示描述的内容（ <code>Emmet</code> 速写: <code>dl+</code>）</li>
<li>保留空格的段落 <code>&lt;pre&gt;</code></li>
<li>分割线 <code>&lt;hr&gt;</code></li>
<li>换行 <code>&lt;br&gt;</code></li>
<li>定位符、超链接 <code>&lt;a&gt;</code></li>
<li>语气的强调 <code>&lt;em&gt;</code></li>
<li>本质的强调 <code>&lt;strong&gt;</code></li>
<li>代码 <code>&lt;code&gt;</code>，默认是内联元素，可以用 <code>&lt;pre&gt;</code> 包住 <code>&lt;code&gt;</code></li>
<li>引用 <code>&lt;quote&gt;</code></li>
<li>块级引用 <code>&lt;blockquote&gt;</code></li>
</ul>
</li>
<li>全局属性<ul>
<li><code>class</code> 类</li>
<li><code>contenteditable</code> 用户可以直接编辑页面上的东西</li>
<li><code>hidden</code> 隐藏</li>
<li><code>id</code> 标记</li>
<li><code>style</code> 样式</li>
<li><code>tabindex</code> 控制 <code>Tab键</code> 激活元素的顺序，<code>tabindex=0</code> 是最后一个，<code>tabindex=-1</code> 代表永远不会访问</li>
<li><code>title</code> 鼠标悬浮显示的内容</li>
</ul>
</li>
</ul>
<div class="note warning">
            <p><strong>为什么会有默认样式？</strong><br>因为 HTML 被发明的时候，还没有CSS<br><strong>怎么看默认样式？</strong><br>开发者工具 -&gt; Elments -&gt; Styles -&gt; user agent stylesheet<br><strong>CSS Reset?</strong><br><a href="https://dev.to/hankchizljaw/a-modern-css-reset-6p3" target="_blank" rel="noopener">Andy Bell</a><br><a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">Meyerweb</a><br><a href="https://gist.github.com/FrankFang/df5e57a0799823ed89a960a642b3a1e2" target="_blank" rel="noopener">Frank Fang</a></p>
          </div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http-server . -c-1 <span class="comment"># -c-1 表示不要缓存</span></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">parcel index.html</span><br></pre></td></tr></table></figure>
<h1 id="lt-a-gt-标签"><a href="#lt-a-gt-标签" class="headerlink" title="&lt;a&gt; 标签"></a><code>&lt;a&gt;</code> 标签</h1><h2 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a><code>href</code> 属性</h2><ul>
<li>网址<ul>
<li><code>http://google.com</code></li>
<li><code>https://google.com</code></li>
<li><code>//google.com</code> 无协议网址</li>
</ul>
</li>
<li>路径<ul>
<li><code>/a/b/c</code> 绝对路径，但是是基于 <strong>HTTP 服务</strong> 开启的根目录，不是整个计算机的根目录</li>
<li><code>a/b/c</code> 相对路径，基于当前路径的目录</li>
<li><code>index.html</code> 当前目录的文件</li>
<li><code>./index.html</code> 当前目录的文件</li>
</ul>
</li>
<li><code>#id</code></li>
<li>伪协议<ul>
<li><code>javascript:alert(1);</code><ul>
<li><code>javasrcript:;</code> 可以写一个什么都不做的a标签</li>
</ul>
</li>
<li><code>mailto:xxx@xxx.com</code> 会呼出邮件客户端</li>
<li><code>tel:1300000000</code> 会呼出拨号界面</li>
</ul>
</li>
</ul>
<h2 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a><code>target</code> 属性</h2><ul>
<li>内置名字<ul>
<li><code>_blank</code> 新标签</li>
<li><code>_top</code> 在最顶层打开（比如 <code>iframe</code> 的最外层页面）</li>
<li><code>_parent</code> 在父级窗口打开，没有 <code>_top</code> 那么高层</li>
<li><code>_self</code> 在当前页面打开（比如 <code>iframe</code> 的当前层）</li>
</ul>
</li>
<li>其他自定义的新窗口的名字（<code>window.name</code>）或者 <code>iframe</code> 的名字</li>
</ul>
<p>使用 rel=noopener 不打开新标签</p>
<h2 id="download-属性"><a href="#download-属性" class="headerlink" title="download 属性"></a><code>download</code> 属性</h2><p>下载而不是查看网页，但是大部分不支持</p>
<h1 id="lt-iframe-gt-标签"><a href="#lt-iframe-gt-标签" class="headerlink" title="&lt;iframe&gt; 标签"></a><code>&lt;iframe&gt;</code> 标签</h1><p>内嵌窗口，现在大都不用了</p>
<h1 id="lt-table-gt-标签"><a href="#lt-table-gt-标签" class="headerlink" title="&lt;table&gt; 标签"></a><code>&lt;table&gt;</code> 标签</h1><div class="note warning">
            <p>里面必须写<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>，否则浏览器也会自己加上，并且显示的顺序与实际写的这三个顺序无关，浏览器一定是按照<code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfoot&gt;</code>的顺序显示</p>
          </div>
<p>相关的样式有：</p>
<ul>
<li><code>table-layout</code><ul>
<li><code>auto</code> 按照内容的多少来分配宽度权重</li>
<li><code>fixed</code> 等宽</li>
</ul>
</li>
<li><code>border-collapse: collapse</code> 表示两个单元格的边线合并</li>
<li><code>border-spacing</code> 两个单元格中间的空隙</li>
</ul>
<h1 id="lt-img-gt-标签"><a href="#lt-img-gt-标签" class="headerlink" title="&lt;img&gt; 标签"></a><code>&lt;img&gt;</code> 标签</h1><blockquote>
<p>发出一个GET请求，展示一张图片</p>
</blockquote>
<h2 id="src-属性"><a href="#src-属性" class="headerlink" title="src 属性"></a><code>src</code> 属性</h2><p>可以是相对路径，也可以是绝对路径</p>
<h2 id="alt-属性"><a href="#alt-属性" class="headerlink" title="alt 属性"></a><code>alt</code> 属性</h2><p>图片加载失败的时候显示的内容</p>
<h2 id="height-和-width-属性"><a href="#height-和-width-属性" class="headerlink" title="height 和 width 属性"></a><code>height</code> 和 <code>width</code> 属性</h2><p>若只写高度或宽度，图像比例保持不变</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><code>onload</code>图片加载成功</li>
<li><code>onerror</code> 图片加载失败</li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><code>max-width: 100%</code></p>
<h1 id="lt-form-gt-标签"><a href="#lt-form-gt-标签" class="headerlink" title="&lt;form&gt; 标签"></a><code>&lt;form&gt;</code> 标签</h1><blockquote>
<p>发出一个 GET 或 POST 请求，然后刷新页面</p>
</blockquote>
<h2 id="action-属性"><a href="#action-属性" class="headerlink" title="action 属性"></a><code>action</code> 属性</h2><p>请求到哪个页面</p>
<h2 id="method-属性"><a href="#method-属性" class="headerlink" title="method 属性"></a><code>method</code> 属性</h2><p>是用 GET 还是 POST</p>
<h2 id="autocomplete-属性"><a href="#autocomplete-属性" class="headerlink" title="autocomplete 属性"></a><code>autocomplete</code> 属性</h2><p>为 <code>on</code> 则打开自动填充，下面的 <code>text</code> 要写 <code>name</code></p>
<h2 id="target-属性-1"><a href="#target-属性-1" class="headerlink" title="target 属性"></a><code>target</code> 属性</h2><p>把哪个页面（ 值可以为 <code>_blank</code> 等等）变成要请求到的那个页面（也就是说哪个页面需要刷新）</p>
<div class="note warning">
            <ul><li>一般不监听 <code>input</code> 的 <code>click</code> 事件</li><li><code>form</code> 里面的 <code>input</code> 要有 <code>name</code></li><li>一个 form 必须要有一个 <code>type=&quot;submit&quot;</code>，如果 <code>button</code> 不写 <code>type</code>，默认 <code>submit</code></li></ul>
          </div>
<div class="note warning">
            <p><strong><code>&lt;input type=&quot;submit&quot;&gt;</code> 和 <code>&lt;button type=&quot;submit&quot;&gt;</code> 的区别？</strong><br><code>input</code> 里面不能再有标签（但是文字可以用 <code>value=&quot;&quot;</code> 进行更改）<br><code>button</code> 里面可以有任何东西（包括图片等其他标签）</p>
          </div>
<h1 id="lt-input-gt-标签"><a href="#lt-input-gt-标签" class="headerlink" title="&lt;input&gt; 标签"></a><code>&lt;input&gt;</code> 标签</h1><h2 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a><code>type</code> 属性</h2><ul>
<li><code>text</code></li>
<li><code>color</code></li>
<li><code>password</code></li>
<li><code>radio</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>checkbox</code> 所有的 <code>input</code> 要有同一个 <code>name</code></li>
<li><code>file</code> 加上 <code>multiple</code> 属性可以同时选多个文件</li>
<li><code>hidden</code></li>
<li><code>tel</code></li>
<li><code>email</code></li>
<li><code>search</code></li>
</ul>
<h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><ul>
<li><code>onchange</code></li>
<li><code>onfocus</code></li>
<li><code>onblur</code></li>
</ul>
<h1 id="lt-textarea-gt-标签"><a href="#lt-textarea-gt-标签" class="headerlink" title="&lt;textarea&gt; 标签"></a><code>&lt;textarea&gt;</code> 标签</h1><p><code>style=&quot;resize: none&quot;</code> 让右下角不能拖动</p>
<h1 id="lt-select-gt-标签"><a href="#lt-select-gt-标签" class="headerlink" title="&lt;select&gt; 标签"></a><code>&lt;select&gt;</code> 标签</h1><p><code>&lt;option value=&quot;1&quot;&gt;星期一&lt;/option&gt;</code></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 序章</title>
    <url>/hais-notebook/2020/02/02/HTML-Overview/</url>
    <content><![CDATA[<p>WWW 和 HTML 的历史。</p>
<a id="more"></a>
<h1 id="Word-Wide-Web"><a href="#Word-Wide-Web" class="headerlink" title="Word Wide Web"></a>Word Wide Web</h1><ul>
<li>互联网，基于IP之间通信，但是无法输入地址得到一个网页</li>
<li>WWW = URL + HTTP + HTML（李爵士发明的，基于互联网实现的，输入地址得到一个网页的网络）</li>
</ul>
<h1 id="HTML-历史"><a href="#HTML-历史" class="headerlink" title="HTML 历史"></a>HTML 历史</h1><p>诞生于李爵士的一篇文章，最开始只有 18 个元素，这些元素如今还有 11 个健在，现在最新版的HTML大概有 110 个标签</p>
<h2 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a>HTML 5</h2><ul>
<li>狭义HTML 5：最新版本 HTML 语言，多了 32 个新标签</li>
<li>广义HTML 5：包括 CSS3 等朋友们</li>
</ul>
<h3 id="HTML-5-技术集合"><a href="#HTML-5-技术集合" class="headerlink" title="HTML 5 技术集合"></a>HTML 5 技术集合</h3><ul>
<li>新标签、新属性</li>
<li>新的通信技术：WebSockets、WebRTC</li>
<li>离线存储技术：LocalStorage、断网检测</li>
<li>多媒体技术：视频、音频</li>
<li>图像技术：Canvas、SVG、WebGL</li>
<li>Web增强技术：History API、全屏</li>
<li>设备相关技术：摄像头、触摸屏</li>
<li>新的样式技术：CSS3新的 Flex、Grid 的布局方式</li>
</ul>
<h1 id="HTML-起手式"><a href="#HTML-起手式" class="headerlink" title="HTML 起手式"></a>HTML 起手式</h1><p>用 <code>Emmet</code> 所提供的速写法可以很快地写出你在写 <code>HTML</code> 所需要写的一个骨架。<br>你只需要在安装了插件的编辑器（某些编辑器默认具有此功能）中输入 <code>!</code> 再敲击 <code>Tab</code>，便可以很方便地输入以下内容。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 表示文档类型是 HTML 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> <span class="comment">&lt;!-- html 标签，可以在这里设置语言，比如 lang="zh-CN" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="comment">&lt;!-- 这里的东西不会显示到页面上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>  <span class="comment">&lt;!-- 文件的字符编码 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置视口大小为设备宽度（以兼容手机），并设置初始缩放为 1.0 并禁用缩放 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span> <span class="comment">&lt;!-- 让 IE 浏览器使用最新的内核 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 动画</title>
    <url>/hais-notebook/2020/02/02/CSS-Animation/</url>
    <content><![CDATA[<p>用 <code>transform</code> 的性能会比直接修改 <code>left</code> 属性好，因为浏览器不会 repaint 那么多次</p>
<a id="more"></a>
<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><p>根据 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">Google 团队的文章</a>分析，我们可以将网页的渲染过程大致分为以下几步：</p>
<ol>
<li>根据 HTML 构建 HTML 树（DOM）</li>
<li>根据 CSS 构建 CSS 树（CSSOM）</li>
<li>将两棵树合并为渲染树（Render Tree）</li>
<li>布局 <strong>Layout</strong>（文档流、盒模型、计算大小和位置）</li>
<li>绘制 <strong>Paint</strong>（边框颜色、文字颜色、阴影）</li>
<li>合成 <strong>Compose</strong>（根据层叠关系展示画面）</li>
</ol>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Browser-Render-Process.png" alt="浏览器渲染过程"></p>
<h1 id="更新样式"><a href="#更新样式" class="headerlink" title="更新样式"></a>更新样式</h1><div class="note warning">
            <p>一般用 JS 更新样式，比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style.background = <span class="string">'red'</span></span><br><span class="line">div.style.display = <span class="string">'none'</span></span><br><span class="line">div.classList.add(<span class="string">'red'</span>)</span><br><span class="line">div.remove()</span><br></pre></td></tr></table></figure>
          </div>
<h2 id="三种更新样式的路径"><a href="#三种更新样式的路径" class="headerlink" title="三种更新样式的路径"></a>三种更新样式的路径</h2><p>在 <a href="https://csstriggers.com/" target="_blank" rel="noopener">这里</a> 可以看到不同的属性在不同的浏览器中的更新路径</p>
<ul>
<li>JS/CSS &gt; Style &gt; Layout &gt; Paint &gt; Composite: remove</li>
<li>JS/CSS &gt; Style &gt; Paint &gt; Composite: background-color</li>
<li>JS/CSS &gt; Style &gt; Composite: transform</li>
</ul>
<h2 id="CSS-动画优化"><a href="#CSS-动画优化" class="headerlink" title="CSS 动画优化"></a>CSS 动画优化</h2><p>可以看看 <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">谷歌的这篇文档</a></p>
<ul>
<li>JS 优化：使用 <code>requestAnimationFrame</code> 代替 <code>setTimeout</code> 或者 <code>setInterval</code></li>
<li>CSS 优化：使用 <code>will-change</code> 或者 <code>transform</code></li>
</ul>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h1><blockquote>
<p>使用 <code>transform: none</code>，取消所有</p>
</blockquote>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: translateX(50px) | translateY(50%) | translateZ(50px) | translate(50px, 50px)</span><br></pre></td></tr></table></figure>
<p>视点的确定（在父元素上）： <code>perspective: 1000px</code> 表示父元素的中心为坐标原点，距离屏幕为 1000px</p>
<p>可以这样做绝对定位的居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">top</span>: 50%; <span class="selector-tag">left</span>: 50%; <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%)</span><br></pre></td></tr></table></figure>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>border 也会一起变</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: scaleX(&lt;number&gt;) | scaleY(&lt;number&gt;) | scale(&lt;number&gt;, &lt;number&gt;?)</span><br></pre></td></tr></table></figure>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>一般用来做 360 度旋转的 loading 或者按钮的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: rotate([&lt;angle&gt;|&lt;zero&gt;]) | rotateZ([&lt;angle&gt;|&lt;zero&gt;]) | rotateX([&lt;angle&gt;|&lt;zero&gt;])</span><br></pre></td></tr></table></figure>
<h2 id="扭曲"><a href="#扭曲" class="headerlink" title="扭曲"></a>扭曲</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: skewX(&lt;angle&gt;|&lt;zero&gt;) | skewY(&lt;angle&gt;|&lt;zero&gt;) | skew(&lt;angle&gt;|&lt;zero&gt;, &lt;angle&gt;|&lt;zero&gt;?)</span><br></pre></td></tr></table></figure>
<h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a><code>transition</code></h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">transition: 属性名(可以写all) 时长 过渡方式( linear | ease | ease-in | ease-in-out | cubic-bezier | step-start | step-end | steps ) 延迟</span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 3<span class="selector-tag">s</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>不是所有属性都有过渡<br><code>display: none =&gt; block</code>，一般改成 <code>visibility: hidden =&gt; visible</code></p>
          </div>
<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a><code>animation</code></h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> xxx &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  66<span class="selector-class">.66</span>% &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加动画 */</span></span><br><span class="line">animation: 时长 过渡方式 延迟 次数( infinite ) 方向( reverse | alternate | alternate-reverse ) 填充模式( none | forwards | backwards | both) 是否暂停( paused )  动画名</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 层叠上下文</title>
    <url>/hais-notebook/2020/02/02/CSS-StakingContext/</url>
    <content><![CDATA[<p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，<strong>层叠上下文</strong> 就是对这些 HTML 元素的一个 <strong>三维构想</strong>。众 HTML 元素基于其元素属性 <strong>按照优先级顺序</strong> 占据这个空间。</p>
<a id="more"></a>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Staking-Context.png" alt="CSS 层叠上下文"></p>
<p>默认的元素的三维层叠顺序如上图所示，可以看到定位元素会超出原来的高度范畴，换句话说，<strong>原来的 background、border、块级子元素、浮动元素、内联子元素均处在 z-index = -1 ~ 0 这个区间之内</strong>。</p>
<p>每一个层叠上下文就好像一个小世界，只有这里面的 <code>z-index</code> 才能进行比较，具有不同 <code>z-index</code> 的父元素之中的子元素根本无法同台竞技。</p>
<p>这些常见的属性（或元素）可以创建一个层叠上下文：</p>
<ul>
<li><code>HTML</code>（根元素）</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>relative | absolute</code> 元素</li>
<li><code>z-index</code> 值不为 <code>auto</code> 的 <code>flex</code> <code>grid</code> 子项</li>
<li><code>transform</code> 值不为 <code>none</code> 的元素</li>
<li><code>opacity</code> 值小于 <code>1</code> 的元素</li>
</ul>
<p>更多资料可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">MDN 文档</a> 。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 定位</title>
    <url>/hais-notebook/2020/02/02/CSS-Positioning/</url>
    <content><![CDATA[<p>定位和布局的区别：布局是平面上的，定位是垂直于屏幕的。</p>
<a id="more"></a>
<h1 id="一个-div-的分层"><a href="#一个-div-的分层" class="headerlink" title="一个 div 的分层"></a>一个 div 的分层</h1><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Position.png" alt="一个div的分层"></p>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a><code>position</code></h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>默认值，当前元素在文档流中</p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a><code>relative</code></h2><ul>
<li>距离自己原来的位置的偏离（<code>top</code> / <code>bottom</code>），还是占据原来的空间</li>
<li>做位移</li>
<li>做 <code>absolute</code> 元素的爸爸</li>
<li>配合 <code>z-index</code>，默认是 <code>auto</code>，<code>auto</code> 计算出来的值为 <code>0</code></li>
<li><strong>经验</strong>：不要写 <code>z-index: 9999</code>，要学会 <code>z-index</code> 的管理</li>
</ul>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a><code>absolute</code></h2><ul>
<li>脱离原来的位置，另起一层；会相对于<strong>祖先元素中最近的</strong>一个<strong>定位元素</strong>（即非 <code>static</code> 元素）</li>
<li>可以用于悬浮显示提示内容</li>
<li><code>white-space: nowrap</code> 文字内容不换行</li>
<li>经验：<ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>善用 <code>left: 100%</code>，善用 <code>left: 50%</code>加负 <code>margin</code></li>
</ul>
</li>
</ul>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a><code>fixed</code></h2><ul>
<li>相对于视口定位，但是如果放到具有 <code>transform</code>  属性的元素里面，会有问题</li>
<li>做广告</li>
<li>做回到顶部按钮</li>
<li><strong>经验</strong><ul>
<li>某些浏览器如果不写 <code>top / left</code> 会引起混乱</li>
<li>手机上尽量不要使用 <code>fixed</code></li>
</ul>
</li>
</ul>
<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a><code>sticky</code></h2><p>兼容性很差</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 布局</title>
    <url>/hais-notebook/2020/02/02/CSS-Layout/</url>
    <content><![CDATA[<p>如何选择布局。</p>
<a id="more"></a>
<h1 id="两种布局方式"><a href="#两种布局方式" class="headerlink" title="两种布局方式"></a>两种布局方式</h1><ul>
<li><strong>固定宽度布局</strong>：960、1000、1024</li>
<li><strong>不固定宽度布局</strong>：一般在手机上使用，主要靠文档流原理来布局</li>
<li><strong>响应式布局</strong>：PC上固定宽度，手机上不固定宽度，也就是一种<strong>混合布局</strong></li>
</ul>
<h1 id="两种布局思路"><a href="#两种布局思路" class="headerlink" title="两种布局思路"></a>两种布局思路</h1><ul>
<li>从大到小：先定下大局，然后再完善每个部分的小布局</li>
<li>从小到大：先完成小布局，然后再组合成大布局</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Layout.png" alt="两种布局思路"></p>
<h1 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h1><ol>
<li>在子元素上加 <code>float: left</code> 和 <code>width</code></li>
<li>在父元素加上 <code>class=&quot;clearfix&quot;</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验：</p>
<ul>
<li>有经验者会留一些空间或最后一个不设置 <code>width</code>（可以设置一个 <code>max-width</code>）</li>
<li>不需要考虑响应式，因为手机上没有 IE，这个布局是专门为 IE 准备的</li>
<li>在 IE 上有 BUG：最左边浮动元素的 <code>margin-left</code> 会变成双倍<ul>
<li>可以加一句兼容性写法：<code>_margin-left: ?px</code></li>
<li>也可以加上 <code>display: inline-block</code></li>
</ul>
</li>
<li>如果图片下面有空隙，加上 <code>vertical-align: middle | top</code> 就可以消除</li>
<li><strong><code>float</code> 元素外边距不合并</strong></li>
</ul>
<div class="note warning">
            <p>必要时可以采用负 margin</p>
          </div>
<p>比如说做平均布局，在所有的小块外面加一个 <code>div</code> ，然后再给这个 <code>div</code> 一个负 <code>margin</code></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Layout-Minus-Margin.png" alt="负Margin"></p>
<h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><p>这里是 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">CSS Tricks 上的 Flex 教程</a></p>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul>
<li>让一个元素变成 flex 容器：<code>display: flex | inline-flex</code></li>
<li>改变 items 的流动方向（主轴）：<code>flex-direction: row | row-reverse | column | column-reverse</code></li>
<li>改变折行：<code>flex-wrap: nowrap | wrap | wrap-revers</code></li>
<li>主轴的对齐方式：<code>justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly</code></li>
<li>次轴对齐：<code>align-items: flex-start | flex-end | center | stretch(默认)</code></li>
<li>多行对齐（基本不用）：<code>align-content: flex-start | flex-end | center | strech | space-between | space-around</code></li>
</ul>
<h2 id="Items"><a href="#Items" class="headerlink" title="Items"></a>Items</h2><ul>
<li><code>order</code>：改变显示顺序</li>
<li><code>flex-grow</code>：控制自己如何长胖（占多余所有空间的权重），默认是0（尽可能窄）</li>
<li>导航栏常用左边 logo 和右边用户头像都是 0，中间是 1</li>
<li><code>flex-shrink</code>：控制如何变瘦，（在空间不够用的时候，压缩的比例）默认是1（大家一起变小），可以写0（防止变小）</li>
<li><code>flex-basis</code>：控制基准宽度，一般用得比较少，默认是 auto（跟宽度一样）</li>
</ul>
<p>以上可以缩写为：<code>flex: grow shrink basis</code></p>
<ul>
<li><code>align-self: flex-start | flex-end</code></li>
</ul>
<p>经验：</p>
<ul>
<li>永远不要把 <code>width</code> 和 <code>height</code> 写死</li>
<li>尽量使用 <code>min-width</code> | <code>max-width</code> 等来写</li>
<li><code>margin-xxx: auto</code>，有奇效，类似于 <code>between</code></li>
</ul>
<h1 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h1><p>这里是 <a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">CSS Tricks 上的 Grid 教程</a></p>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CSS-Grid.png" alt="Grid布局"></p>
<h2 id="Container-1"><a href="#Container-1" class="headerlink" title="Container"></a>Container</h2><ul>
<li>让一个元素变成 grid 容器：<code>display: grid | inline-grid</code></li>
<li><p>行和列：</p>
<ul>
<li><code>grid-template-columns</code>: 每一列的宽度，可以写 <code>auto</code></li>
<li><p><code>grid-template-rows</code>: 每一行的高度，可以写 <code>auto</code><br>-</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">  "<span class="selector-tag">aside</span> <span class="selector-tag">main</span> <span class="selector-tag">ad</span>"</span><br><span class="line">  "<span class="selector-tag">footer</span> <span class="selector-tag">fotter</span> ."</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>grid-gap</code></p>
</li>
<li><code>grid-column-gap</code></li>
<li><code>grid-row-gap</code></li>
</ul>
</li>
</ul>
<h2 id="Items-1"><a href="#Items-1" class="headerlink" title="Items"></a>Items</h2><ul>
<li>grid-row-start</li>
<li>grid-row-end</li>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>fr：free space，类似于flex-grow</li>
<li><strong>grid-area: header;</strong></li>
<li><strong>grid-area: main;</strong></li>
<li><strong>….</strong></li>
</ul>
<h1 id="水平垂直居中的方案"><a href="#水平垂直居中的方案" class="headerlink" title="水平垂直居中的方案"></a>水平垂直居中的方案</h1><h2 id="定位：三种"><a href="#定位：三种" class="headerlink" title="定位：三种"></a>定位：三种</h2><ol>
<li><code>absolute</code> + <code>margin</code>：需要知道自己的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>absolute</code> + <code>margin</code>：不需要知道自己的宽高，但是得有宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>absolute</code> + <code>translate</code>： 不需要知道自己的宽高，不需要有具体的宽高</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a><code>flex</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-id">#box</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HTML = <span class="built_in">document</span>.documentElement,</span><br><span class="line">      winW = HTML.clientWidth,</span><br><span class="line">      winH = HTML.clientHeight,</span><br><span class="line">      boxW = box.offsetWidth, <span class="comment">// 带边框的宽，也可以用 getBoundingClientReact</span></span><br><span class="line">      boxH = box.offsetHeight <span class="comment">// 带边框的高</span></span><br><span class="line">box.style.position = <span class="string">'absolute'</span></span><br><span class="line">box.style.left = (winW - boxW) / <span class="number">2</span> + <span class="string">'px'</span></span><br><span class="line">box.style.top = (winH - boxH) / <span class="number">2</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure>
<h2 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a><code>table-cell</code></h2><p>要求父级有固定宽高，相当于给文本居中</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="左右固定、中间自适应布局"><a href="#左右固定、中间自适应布局" class="headerlink" title="左右固定、中间自适应布局"></a>左右固定、中间自适应布局</h1><h2 id="float-负-margin"><a href="#float-负-margin" class="headerlink" title="float + 负 margin"></a><code>float</code> + 负 <code>margin</code></h2><p>圣杯布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双飞翼布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.right</span>, <span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a><code>calc</code></h2><p>兼容到 IE 9，渲染会比较慢</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: calc(<span class="number">100%</span> - <span class="number">400px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a><code>flex</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基本概念</title>
    <url>/hais-notebook/2020/02/01/CSS-Concepts/</url>
    <content><![CDATA[<p>主要是包括文档流、脱离文档流、盒模型、margin 合并等问题</p>
<a id="more"></a>
<h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><blockquote>
<p>这里的文档流指的是 <strong>Normal Flow</strong>，也就是 <strong>正常布局流</strong><br>当我们没有使用过任何 CSS 规则来改变元素的展现方式的时候，他们会按照正常的布局流来组织——也就是默认情况下的元素布局——这也就是我们所说的 <strong>Noraml Flow</strong>，即 <strong>文档流</strong> </p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>display</code></th>
<th>流动方向</th>
<th>宽度</th>
<th>高度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inline</code></td>
<td>从左到右排列，<strong>行尾会截断成两行</strong></td>
<td>里面所有 inline 元素之和，不接受指定 <code>width</code></td>
<td><strong>实际高度</strong>由<strong>行高（<code>line-height</code>）间接</strong>（与字体有关，具体可以看 <a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729887779307520" target="_blank" rel="noopener">这个</a>）<strong>确定</strong>，<code>padding</code> 只能改变<strong>看得见</strong>的高度（而不是实际高度），如果没有内容，也有高度，为 <code>line-height</code></td>
</tr>
<tr>
<td><code>block</code></td>
<td>从上到下排列（每个占一行）</td>
<td>默认为 <code>auto</code>（不是100%），可以指定 <code>width</code>，但永远不要写 <code>width: 100%</code></td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code>，如果没有内容，高度为 <code>0</code></td>
</tr>
<tr>
<td><code>inline-block</code></td>
<td>从左到右排列，<strong>行尾不会分成两块</strong></td>
<td>默认为里面所有 <code>inline</code> 元素之和，但接受指定 <code>width</code></td>
<td>由里面<strong>所有</strong>的<strong>文档流</strong>元素决定，也可以设置 <code>height</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h1><blockquote>
<p>这里的溢出指的是 <strong>Overflow</strong></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>overflow</code></th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hidden</code></td>
<td>隐藏</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>滚动，就算没有溢出，依然有滚动条，<strong>如果有横向滚动条，inline 元素也只会在第一屏</strong></td>
</tr>
<tr>
<td><code>auto</code></td>
<td>没有溢出就没有滚动条，并且只显示必要的滚动条</td>
</tr>
</tbody>
</table>
</div>
<p>可以分开设置 <code>overflow-x</code> 和 <code>overflow-y</code></p>
<h1 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h1><blockquote>
<p>也就是 <strong>Out of flow</strong></p>
</blockquote>
<div class="note warning">
            <p>block 不计算其高度</p>
          </div>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">position: absolute | fixed;</span><br><span class="line"><span class="comment">/* OR */</span></span><br><span class="line">float: left | right;</span><br></pre></td></tr></table></figure>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>可以把网页中显示的 HTML 元素看成是一个个盒子，盒子具有四层：</p>
<ul>
<li>内容（content）</li>
<li>内边距（padding）</li>
<li>边框（border）</li>
<li>外边距（margin）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>box-sizing</code></th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>content-box</code></td>
<td>指定 <code>width</code> 或 <code>height</code> 时，说的是他的最里面的 <code>content</code> 的 宽或高</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>指定 <code>width</code> 或 <code>heihgt</code> 时，除了 <code>content</code> 的宽或高之外，还包括了 <code>padding</code> 和 <code>border</code> 的厚度</td>
</tr>
</tbody>
</table>
</div>
<p>通过 <code>box-sizing</code> 控制，一般使用 <code>border-box</code></p>
<h1 id="Margin-合并"><a href="#Margin-合并" class="headerlink" title="Margin 合并"></a>Margin 合并</h1><blockquote>
<p>跟 BFC 有关系</p>
</blockquote>
<p>是说我们上下两个元素若都有 <code>margin</code>，那么他们的 <code>margin</code> 将不会同时生效。有以下几个注意点：</p>
<ol>
<li>只有上下才会发生 <code>margin</code> 合并，左右不会发生</li>
<li>只有 <code>block</code> 会发生 <code>margin</code> 合并，<code>inline-block</code> 不会发生（生成了 BFC）</li>
<li><code>first-child</code> 和 <code>last-child</code> 也会和 <code>parent</code> 发生 <code>margin</code> 合并</li>
</ol>
<p>取消 margin 合并的方法，主要是靠生成 BFC：</p>
<ol>
<li>使用 <code>overflow:hidden</code> 之后就不会再合并</li>
<li>使用 <code>display:flex</code> 之后就不会再合并</li>
<li>通过给 <code>parent</code> 上面加东西（<code>padding</code> <code>border</code> <code>overflow</code> 等）之后就不会再合并</li>
</ol>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><blockquote>
<p>BFC （块级格式化上下文）就是一块小区域，一块独立的布局环境，在这个区域之内的任何布局和定位都不会影响到外面，外面也不能影响到里面。</p>
</blockquote>
<h2 id="BFC-的作用"><a href="#BFC-的作用" class="headerlink" title="BFC 的作用"></a>BFC 的作用</h2><ol>
<li>同一个 BFC 内会发生垂直方向的 Margin 合并，如果是不同 BFC 则不会</li>
<li>形成了 BFC 的区域不会与 float 元素重叠，可以与浮动元素形成左右自适应布局</li>
<li>清除浮动，因为浮动元素的高度也会被 BFC 纳入计算，因此可以解决高度塌陷的问题</li>
</ol>
<h2 id="如何形成-BFC"><a href="#如何形成-BFC" class="headerlink" title="如何形成 BFC"></a>如何形成 BFC</h2><ol>
<li><code>float: left</code></li>
<li><code>position: absolute</code></li>
<li><code>overflow: hidden</code>，经常使用</li>
<li><code>display: inline-block</code></li>
<li><code>display: table-cell</code></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 序章</title>
    <url>/hais-notebook/2020/02/01/CSS-Overview/</url>
    <content><![CDATA[<p>记录 CSS 的含义及基本语法。</p>
<a id="more"></a>
<h1 id="层叠的含义"><a href="#层叠的含义" class="headerlink" title="层叠的含义"></a>层叠的含义</h1><ul>
<li><strong>样式层叠</strong>：可以对同一个选择器进行样式声明</li>
<li><strong>选择器层叠</strong>：可以用不同的选择器对同一个元素进行样式声明</li>
<li><strong>文件层叠</strong>：可以用多个文件进行层叠</li>
</ul>
<h1 id="样式语法"><a href="#样式语法" class="headerlink" title="样式语法"></a>样式语法</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性名: 属性值;</span><br><span class="line">  <span class="comment">/* 注释 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="@ 语法"></a>@ 语法</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"UTF-8"</span>;   <span class="comment">/* 必须放在第一行 */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="number">2</span>.css); </span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">100px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">200px</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h1><ul>
<li>charset 是字符集的意思，但 UTF-8 不是字符集，而是字符编码(encoding)，这是历史遗留问题</li>
<li>ASCII 字符集的编码形式就是 ASCII，这个字符集只有英文</li>
<li>GB2312 字符集是中国人发明的简体中文字符集，他的编码形式也是 GB2312</li>
<li>GBK 是微软发明的中日韩（CJK）字符集，他的编码形式也是 GBK</li>
<li>unicode 是支持所有字符的字符集，他的编码形式有 UTF-8/UTF-16/UTF-32</li>
</ul>
<h1 id="找资料"><a href="#找资料" class="headerlink" title="找资料"></a>找资料</h1><ul>
<li>查资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN</a>、<a href="https://css-tricks.com/" target="_blank" rel="noopener">CSS Tricks</a>、<a href="https://www.zhangxinxu.com/wordpress/" target="_blank" rel="noopener">张鑫旭的博客</a></li>
<li>找素材（可以搜 PSD WEB）：<a href="https://www.freepik.com/" target="_blank" rel="noopener">Freepik</a>、<a href="http://dribbble.com/" target="_blank" rel="noopener">Dribbble</a>、<a href="https://cn.365psd.com/" target="_blank" rel="noopener">365 PSD</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/hais-notebook/2020/02/01/Vue-Vuex/</url>
    <content><![CDATA[<p>用了几次 Vuex 之后抄一下文档。</p>
<a id="more"></a>
<p>可以先看一下 <a href="https://codesandbox.io/s/quizzical-kalam-303z8" target="_blank" rel="noopener">这个例子</a></p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Vuex 的核心就是一个状态仓库，与普通的全局对象有所不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的，store 变化 -&gt; 组件响应式更新</li>
<li>不能直接修改 store 中的状态，只能通过提交 mutation 的方式来改变状态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 定义一个初始的状态</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 定义一些 mutation 来操作状态的变更</span></span><br><span class="line">  mutation: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以通过 store.state 获取对象，或者通过 store.commit 来触发变更</span></span><br><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>Vuex 使用单一状态树，每个应用仅仅包含一个 store 实例</p>
<h2 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h2><h3 id="方法一：通过计算属性"><a href="#方法一：通过计算属性" class="headerlink" title="方法一：通过计算属性"></a>方法一：通过计算属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每个需要使用 state 的组件中就都需要导入 store</p>
<h3 id="方法二：将状态从根组件注入每个子组件"><a href="#方法二：将状态从根组件注入每个子组件" class="headerlink" title="方法二：将状态从根组件注入每个子组件"></a>方法二：将状态从根组件注入每个子组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样子组件就可以通过 <code>this.$store</code> 访问到<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法三：mapState"><a href="#方法三：mapState" class="headerlink" title="方法三：mapState"></a>方法三：<code>mapState</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 可以使用箭头函数</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以使用普通函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若计算属性的名称与子节点名称相同，的也可以给 mapState 传一个数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h3 id="将-mapState-与局部计算属性混用"><a href="#将-mapState-与局部计算属性混用" class="headerlink" title="将 mapState 与局部计算属性混用"></a>将 mapState 与局部计算属性混用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h1><p>从 store 的 state 中派生出一些状态，类似于 store 的计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 可以传入 state 作为第一个参数</span></span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以传入其他 getter 作为第二个参数</span></span><br><span class="line">    doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以让 getter 返回一个函数来实现给 getter 传参</span></span><br><span class="line">    getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todo.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到时候通过 store.getters.getTodoById(2) 这样访问</span></span><br><span class="line">    <span class="comment">// 这样通过方法访问就不会有缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以像访问 State 访问这些 Getter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过 mapGetters</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">  ...mapGetters([</span><br><span class="line">  <span class="string">'doneTodosCount'</span>,</span><br><span class="line">  <span class="string">'anotherGetter'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 将 state 作为第一个参数</span></span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将 payload 作为第二个参数，大多数情况下 payload 应该传一个对象</span></span><br><span class="line">    decrement (state, payload) &#123;</span><br><span class="line">      state.count -= payload.amount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样提交<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line">store.commit(<span class="string">'decrement'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成含有 type 属性的对象</span></span><br><span class="line">sotre.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中提交</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapMutations</span></span><br><span class="line">  ...mapMutations([</span><br><span class="line">    <span class="string">'increment'</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note warning">
            <p>Mutation 必须是同步函数，因为异步会使得很难调试，无法区分谁先回调</p>
          </div>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态</li>
<li>Action 可以包含任意异步操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接受一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">  <span class="comment">// 这个 context 对象也有 context.state context.getters 这种方法</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以这样简化代码：</span></span><br><span class="line">  action: &#123;</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后这样触发，同 Mutation 一样，也支持 payload 和含有 type 的对象的形式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在组件中触发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 或者使用 mapActions</span></span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'incrementAsync'</span> <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('incrementAsync')`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'incrementAsync'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('incrementAsync')`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Router</title>
    <url>/hais-notebook/2020/02/01/Vue-Router/</url>
    <content><![CDATA[<p>用了几次 VueRouter 之后抄一下文档。</p>
<a id="more"></a>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><code>&lt;router-link/&gt;</code> 就像 <code>&lt;a&gt;</code> 标签，来链接到不同的路由</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;router-view/&gt;</code> 用来装路由匹配出来的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 引入 VueRouter</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入要被路由的组件</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'../Bar.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由，相当于定义 router 的配置选项</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo&#125;,      </span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar&#125;      </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建根实例，并使用 VueRouter</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h1><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td><code>{ username: &#39;evan&#39; }</code></td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td><code>{ username: &#39;evan&#39;, post_id: &#39;123&#39; }</code></td>
</tr>
</tbody>
</table>
</div>
<div class="note warning">
            <p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用，组件的生命周期钩子不会再被调用</p>
          </div>
<p>如果想要对路由参数的变化做出响应，需要 watch $route 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 beforeRouterUpdate：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don't forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>，此时要在 <code>VueRouter</code> 的参数中增加 <code>children</code> 的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">''</span>,</span><br><span class="line">          component: UserHome</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'profile'</span>,</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">'posts'</span>,</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>以 / 开头的嵌套路径会被当作根路径</p>
          </div>
<h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><h2 id="router-push-location-onComplete-onAbort"><a href="#router-push-location-onComplete-onAbort" class="headerlink" title="router.push(location, onComplete?, onAbort?)"></a><code>router.push(location, onComplete?, onAbort?)</code></h2><p>相当于 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>，两者的语法规则相同</p>
<div class="note warning">
            <p>在 Vue 实例里面，可以通过 $router 访问路由实例 <code>router</code>。因此可以调用 this.$router.push</p>
          </div>
<p>参数可以是字符串路径或者一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">'123'</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 提供了 path 之后 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>
<p><code>onComplete</code> 和 <code>onAbort</code> 参数可以传入两个回调：将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<div class="note warning">
            <p>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)</p>
          </div>
<h2 id="router-replace-location-onComplete-onAbort"><a href="#router-replace-location-onComplete-onAbort" class="headerlink" title="router.replace(location, onComplete?, onAbort?"></a><code>router.replace(location, onComplete?, onAbort?</code></h2><p>相当于 <code>router-link :to=&quot;...&quot; replace</code>，不会向 history 添加新的记录，而是替换掉当前的 history 目录</p>
<div class="note warning">
            <p>跟 <code>push</code> 的主要区别就是 <code>replace</code> 可以回去，<code>push</code> 则不能</p>
          </div>
<h2 id="router-go-n"><a href="#router-go-n" class="headerlink" title="router.go(n)"></a><code>router.go(n)</code></h2><p>类似 <code>window.history.go(n)</code> 意为在 history 记录中前进或后退多少步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h1 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><h2 id="全局前置导航守卫-router-beforeEach"><a href="#全局前置导航守卫-router-beforeEach" class="headerlink" title="全局前置导航守卫 router.beforeEach"></a>全局前置导航守卫 <code>router.beforeEach</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中<br>确保要调用 next 方法，否则钩子就不会被 resolved</p>
          </div>
<ul>
<li><p><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p>
</li>
<li><p><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</p>
</li>
<li><p><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code> 中的选项。</p>
</li>
<li><p><code>next(error)</code>: 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调。</p>
</li>
</ul>
<h2 id="全局解析守卫-router-beforeResolve"><a href="#全局解析守卫-router-beforeResolve" class="headerlink" title="全局解析守卫 router.beforeResolve"></a>全局解析守卫 <code>router.beforeResolve</code></h2><p>类似 <code>router.beforeEach</code>，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
<h2 id="全局后置钩子-router-afterEach"><a href="#全局后置钩子-router-afterEach" class="headerlink" title="全局后置钩子 router.afterEach"></a>全局后置钩子 <code>router.afterEach</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="路由独享的守卫-beforeEnter"><a href="#路由独享的守卫-beforeEnter" class="headerlink" title="路由独享的守卫 beforeEnter"></a>路由独享的守卫 <code>beforeEnter</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">    <span class="comment">// 但是可以通过传给 next 一个回调来访问组件实例          </span></span><br><span class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 通常用来禁止用户在还未保存修改前突然离开，通过 next(false) 来取消用户的导航    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导航的解析流程"><a href="#导航的解析流程" class="headerlink" title="导航的解析流程"></a>导航的解析流程</h2><ol>
<li>导航被触发</li>
<li>在失活的组件里调用离开守卫</li>
<li>调用全局的 <code>beforeEach</code> 守卫</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)</li>
<li>在路由配置里调用 <code>beforeEnter</code></li>
<li>解析异步路由组件</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code></li>
<li>调用全局的 <code>beforeResolve</code> 守卫</li>
<li>导航被确认</li>
<li>调用全局的 <code>afterEach</code> 钩子</li>
<li>触发 DOM 更新</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 选项</title>
    <url>/hais-notebook/2020/01/30/Vue-Options/</url>
    <content><![CDATA[<p>记录 Vue Options 中的内容。</p>
<a id="more"></a>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><ul>
<li>接收内部属性</li>
<li>有两种写法：对象和函数，函数 return 一个对象</li>
<li>优先使用函数，避免两个组件共用一个 data，此外在 vue 组件中的 data 不能使用对象</li>
<li>data 有 bug</li>
</ul>
<p>关于更多 data 与 响应式的内容，可以看看 <a href="https://hais-teatime.com/post/2019-12-25-vue-1/" target="_blank" rel="noopener">我的一篇博客</a></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li>接收外部属性，一个数组</li>
<li><code>message=&quot;n&quot;</code> 传入字符串</li>
<li><code>:message=&quot;n&quot;</code> 传入 this.n 数据</li>
<li><code>:fn=&quot;add&quot;</code> 传入 this.add 函数</li>
<li>如果外部有谁用了这个组件，可以在他的 <code>template</code> 里面把数据传给这个组件</li>
<li>如果传的时候在前面加上冒号，传的就是 JS 代码（变量），<strong>比如要传数字、布尔值、数组、对象等都需要加冒号</strong></li>
<li>子组件 <strong>不能</strong> 修改父组件传来的 prop，子组件如果想要进行修改或转换，最好是定义一个本地的 data，然后把 prop 作为初值赋给 data，或者使用 computed</li>
</ul>
<p>如果想要将一个对象的所有属性都作为 prop 传入，可以使用不带参数的 <code>v-bind</code> 这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以为 prop 指定类型（<code>String</code> <code>Number</code> <code>Boolean</code> <code>Array</code> <code>Object</code> <code>Function</code> <code>Date</code> <code>Symbol</code> 或者一个自定义的构造函数）或进行验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">const</span> User = &#123;</span><br><span class="line">     template: <span class="string">'...'</span>,</span><br><span class="line">     watch: &#123;</span><br><span class="line">       <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">         <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>props</code> 和 <code>data</code> 的区别：<br>如果需要传值，就放在 <code>props</code> 里面</p>
          </div>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>可以查看 <a href="https://codesandbox.io/s/beautiful-blackburn-5dn48" target="_blank" rel="noopener">在 CodeSandbox 上的这个例子</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      email: <span class="string">"harvey@example.com"</span>,</span><br><span class="line">      nickname: <span class="string">"hai"</span>,</span><br><span class="line">      phone: <span class="string">'1234567890'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123; <span class="comment">// 能够将计算而来的属性作为属性</span></span><br><span class="line">    displayName()&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">this</span>.user</span><br><span class="line">      <span class="keyword">return</span> user.nickname || user.email || user.phone</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 或者写成：</span></span><br><span class="line">    displayName: &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">this</span>.user</span><br><span class="line">        <span class="keyword">return</span> user.nickname || user.email || user.phone</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.user.nickname = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;displayName&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>computed 是有缓存的，如果 computed 依赖的属性没有变化，那么就不会重新计算<br>而普通的函数（方法），或者 getter / setter 默认是不会做缓存的，Vue 做了特殊处理</p>
          </div>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>简单来说就是当数据变化的时候执行一个函数，可以参考 <a href="https://codesandbox.io/s/dry-architecture-6cp4p" target="_blank" rel="noopener">这个简单的计算器的例子</a><br>watch 也可以用来实现 computed 的效果，可以参考 <a href="https://codesandbox.io/s/long-dust-7jb3q" target="_blank" rel="noopener">这个例子</a></p>
<div class="note warning">
            <p>什么叫数据变化？其实就是 <code>===</code> 的规则，简单类型比较值，引用类型比较地址<br><code>obj.a</code> 进行修改 → <code>obj</code> 没变<br><code>obj</code> 进行修改 → <code>obj</code> 变了</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    handler()&#123; <span class="built_in">console</span>.log(<span class="string">'changed'</span>) &#125;,</span><br><span class="line">    deep: <span class="literal">true</span> <span class="comment">// 这个可以使得监听到内部数据的变化，如果里面变了，那么就触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>不要使用箭头函数来定义 watcher，<code>this</code> 是 <code>window</code></p>
          </div>
<div class="note warning">
            <p><code>computed</code> 和 <code>watch</code> 的区别？</p><ul><li><code>computed</code> 是用来计算一个值的，调用的时候不需要加括号，会根据依赖缓存</li><li><code>watch</code> 有两个比较常用的选项：<code>immediate</code> 和 <code>deep</code>，通常是在需要进行异步或者开销比较大的操作的时候使用</li></ul>
          </div>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><ul>
<li>想要挂载到哪个节点，节点内容会被替换</li>
<li>在里面写了内容，基本上是不太可能被用户看见的，除非用户网速特别慢</li>
<li>可以用不用 el，替换为 $mount，效果一样：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(demo)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="三种写法"><a href="#三种写法" class="headerlink" title="三种写法"></a>三种写法</h3><ol>
<li>Vue 完整版，写在 HTML 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">  &#123;n&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#xxx"</span>,</span><br><span class="line">  data: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>Vue 完整版，写在 options 里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=xxx&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;button @click="add"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123; <span class="attr">n</span>: <span class="number">0</span> &#125;, <span class="comment">// data 可以改成函数</span></span><br><span class="line">  methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>) <span class="comment">// 注意这个时候 div#app 会被替代</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Vue 运行时版，写在 <code>.vue</code> 文件里面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template 不是 HTML，是 XML，有闭合标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">xxx</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    data()&#123; <span class="keyword">return</span> &#123; n:<span class="number">0</span> &#125; &#125;, <span class="comment">// data 必须为函数</span></span></span><br><span class="line"><span class="actionscript">    methods: &#123; add()&#123; <span class="keyword">this</span>.n += <span class="number">1</span> &#125; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* CSS-Code */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span> <span class="comment">// App 是一个 options 对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>HTML 与 XML 写法不同：<br><code>&lt;input name=&quot;username&quot;&gt;</code> - HTML<br><code>&lt;input name=&quot;username&quot;/&gt;</code> - XML<br><code>&lt;div&gt;&lt;/div&gt;</code> - HTML<br><code>&lt;div/&gt;</code> - XML</p>
          </div>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="展示内容"><a href="#展示内容" class="headerlink" title="展示内容"></a>展示内容</h4><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; object.a &#125;&#125; <span class="comment">&lt;!-- 表达式 --&gt;</span></span><br><span class="line">&#123;&#123; n + 1 &#125;&#125; <span class="comment">&lt;!-- 运算 --&gt;</span></span><br><span class="line">&#123;&#123; fn(n) &#125;&#125; <span class="comment">&lt;!-- 调用函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">"表达式"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>如果值为 undefined 或 null 就不显示</p>
          </div>
<h5 id="HTML-内容"><a href="#HTML-内容" class="headerlink" title="HTML 内容"></a>HTML 内容</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>span</code> 将会被 <code>rawHtml</code> 的内容所替换，并且 <code>rawHtml</code> 里面的数据绑定将会失效，因此我们不能用 <code>v-html</code> 来在 <code>template</code> 里面使用 <code>template</code>，这个时候需要用 <code>component</code> 来进行组件的组合。</p>
<h5 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-pre 不会对模板进行编译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h4><p>Mustache 语法（双大括号）并不能使用在 HTML 属性上，这时我们需要依靠 <code>v-bind</code> 来帮我们绑定属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"x"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可简写为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"x"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:style</span>=<span class="string">"&#123;border: '1px solid red', height: 100&#125;"</span>&gt;</span></span><br><span class="line">这里可以把 '100px' 写成 100</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="绑定-Class"><a href="#绑定-Class" class="headerlink" title="绑定 Class"></a>绑定 Class</h5><h6 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置 <code>isActive</code> 和 <code>hasError</code> 的值为 <code>true</code> 或者 <code>false</code> 来控制 <code>div</code> 是否有 <code>active</code> 和 <code>text-danger</code> 这两个 class</p>
<h6 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过给 <code>activeClass</code> 和 <code>errorClass</code> 赋值来控制 <code>div</code> 的 class</p>
<p>可以在数组语法中使用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样将始终添加 <code>errorClass</code> 里面的值，但是只有在 <code>isActive</code> 为真时才添加 <code>activeClass</code> 里面的值</p>
<p>也可以在数组语法中使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>给一个自定义组件加上 class 的话，会自动渲染到他的最外面的那个元素上面，并且最外面元素自身的 class 不会被覆盖，同样也支持对象语法等</p>
<h5 id="绑定-Style"><a href="#绑定-Style" class="headerlink" title="绑定 Style"></a>绑定 Style</h5><h6 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以为 <code>activeColor</code> 和 <code>fontSize</code> 赋值，来改变 Style</p>
<h6 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数组中可以装下多个样式对象</p>
<h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add()，自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add(1)"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 add(1)，不自动加括号 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"n+=1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击之后运行 n+=1 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以缩写 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>$event</code> 传递原始的 DOM 事件“</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>v- 开头的就是指令： <code>v-指令名:参数=值</code>，比如 <code>v-on:click=add</code></li>
<li>如果值里面没有特殊字符，可以不加引号</li>
<li>有的指令没有参数和值，比如 <code>v-pre</code></li>
<li>有的指令没有值，比如 <code>v-on:click.prevent</code>，阻止默认动作</li>
</ul>
<h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>有的指令支持修饰符，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@click.stop&#x3D;&quot;add&quot; 阻止冒泡</span><br><span class="line">@click.prevent&#x3D;&quot;add&quot; 阻止默认动作</span><br><span class="line">@click.stop.prevent&#x3D;&quot;add&quot;</span><br><span class="line">@keypress.13 当按下回车时执行，或者用 @keypress.enter，有很多都有别名</span><br></pre></td></tr></table></figure>
<h6 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h6><p>查看 <a href="https://codesandbox.io/s/kind-cookies-1o6rs" target="_blank" rel="noopener">这个在 CodeSandbox 上的例子</a>，或者 <a href="https://codesandbox.io/s/kind-cookies-1o6rs" target="_blank" rel="noopener">这个例子</a></p>
<ul>
<li>组件不能修改 <code>props</code> 外部数据</li>
<li><code>$emit</code> 可以触发一个事件，并传参（发布）， <code>v-on</code> 可以监听他（订阅）</li>
<li><code>$event</code> 可以获取 <code>$emit</code> 的参数</li>
<li>由于经常会出现让组件想要更新数据的情况，所以有了 <code>.sync</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:money.sync&#x3D;&quot;total&quot;</span><br><span class="line">等价于</span><br><span class="line">:money&#x3D;&quot;total&quot; v-on:update:money&#x3D;&quot;total &#x3D; $event&quot;</span><br><span class="line">update:money 是事件名</span><br></pre></td></tr></table></figure>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"x &gt; 0"</span>&gt;</span></span><br><span class="line">  x 大于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"x === 0"</span>&gt;</span></span><br><span class="line">  x 为 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  x 小于 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候我们需要加上 <code>key</code> 来管理元素的复用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为 label 没有 key，所以 label 复用了，仅仅是替换掉了文字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果没有 key，那么切换的时候 input 里面的内容将会保留，这就是元素的复用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"n % 2 === 0"</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 近似等于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123;display: n%2===0 ? 'block' : 'none'&#125;"</span>&gt;</span> n 是偶数 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 但是注意，不是所有看得见的元素 display 都是 block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table 是 table，li 是 list-item --&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>v-if</code> 与 <code>v-show</code></p><ul><li><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>，<code>v-if</code> 则都支持</li><li><code>v-if</code> 在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，<code>v-show</code> 则只是切换了 <code>display</code> 属性</li><li>若初始条件为假，<code>v-if</code> 不会渲染，<code>v-show</code> 则会渲染</li></ul>
          </div>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(user, index) in users"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    索引: &#123;&#123;index&#125;&#125; 值：&#123;&#123;user.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, name, index) in obj"</span> <span class="attr">:key</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    属性名: &#123;&#123;name&#125;&#125; 属性值：&#123;&#123;value&#125;&#125; 索引: &#123;&#123;index&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>:key=&quot;index&quot;</code> 有 Bug， <code>v-for</code> 一定要有 <code>:key</code>，尽量要是不重合的值</p>
          </div>
<p>当 <code>v-if</code> 和 <code>v-for</code> 同时使用的时候， <code>v-for</code> 的优先级会更高，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将只渲染未完成的 todo</p>
<p>在组件上使用 <code>v-for</code> 时需要手动将数据给传进去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p><code>v-model</code> 可以实现常用表单元素的双向绑定，包括文本、多行文本、复选框、单选按钮、选择框等</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相当于这样的简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"message"</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">input</span>=<span class="string">"message = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h1><h2 id="Vue-Lifecycle"><a href="#Vue-Lifecycle" class="headerlink" title="Vue Lifecycle"></a>Vue Lifecycle</h2><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p>
<p>在调用每个生命周期钩子的时候，已经完成了哪些事情：</p>
<ol>
<li><strong>beforeCreate</strong>：创建一个新的 Vue 实例，初始化事件与生命周期</li>
<li><strong>created</strong>：初始化数据，进行数据的观测（比如将使用 <code>Object.defineProperty</code> 改造 data，并将 vm 作为代理）</li>
<li><strong>beforeMount</strong>：将模板编译为 render 函数，将 v-if 变为 if、v-for 变为 map 等</li>
<li><strong>mounted</strong>：给 vm 添加 $el 成员，并且替换掉挂载的 DOM 元素</li>
<li><strong>updated</strong>：数据发生改变，触发组件更新，将会使用新的数据构造一份新的 DOM，替换掉原来的</li>
<li><strong>destroyed</strong>：vm 指示的所有东西都会解绑，所有的事件监听器被移除，所有的子实例被销毁</li>
</ol>
<p>对于父子组件：</p>
<ol>
<li>加载渲染过程<br>父 BeforeCreate -&gt; 父 Created -&gt; 父 BeforeMount -&gt; 子 BeforeCreate -&gt; 子 Created -&gt; 子 BeforeMount -&gt; 子 Mounted -&gt; 父 Mounted</li>
<li>子组件更新过程<br>父 BeforeUpdate -&gt; 子 BeforeUpdate -&gt; 子 Updated -&gt; 父 Updated</li>
<li>父组件更新过程<br>父 BeforeUpdate -&gt; 父 Updated</li>
<li>销毁过程<br>父 BeforeDestroy -&gt; 子 BeforeDestroy -&gt; 子 Destroyed -&gt; 父 Destroyed</li>
</ol>
<h1 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h1><h2 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h2><h3 id="指令声明"><a href="#指令声明" class="headerlink" title="指令声明"></a>指令声明</h3><p>可以查看 <a href="https://codesandbox.io/s/dank-cloud-99drb" target="_blank" rel="noopener">在 CodSandbox 上的这个例子</a></p>
<p>声明全局指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'x'</span>, directiveOptions)</span><br><span class="line"><span class="comment">// 然后就可以全局使用 v-x 了</span></span><br></pre></td></tr></table></figure>
<p>声明局部指令：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  x: &#123; derectiveOptions &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只能在当前组件用 v-x，其子组件也不能用</span></span><br></pre></td></tr></table></figure></p>
<h3 id="directiveOptions"><a href="#directiveOptions" class="headerlink" title="directiveOptions"></a>directiveOptions</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bind(el, info, vnode, oldVnode) <span class="comment">// 类似 created</span></span><br><span class="line">inserted(el, info, vnode, oldVnode) <span class="comment">// 类似 mounted</span></span><br><span class="line">update(el, info, vnode, oldVnode) <span class="comment">// 类似 updated</span></span><br><span class="line">componentUpdated(el, info, vnode, oldVnode)</span><br><span class="line">unbind(el, info, vnode, oldVnode) <span class="comment">// 类似 destroyed</span></span><br></pre></td></tr></table></figure>
<h3 id="指令的作用"><a href="#指令的作用" class="headerlink" title="指令的作用"></a>指令的作用</h3><ul>
<li><strong>用于 DOM 操作</strong><ul>
<li>Vue 的实例/组件主要用于数据绑定、事件监听、DOM 更新；Vue 指令主要目的是原生 DOM 操作</li>
</ul>
</li>
<li><strong>减少重复</strong><ul>
<li>如果某个 DOM 操作经常使用/很复杂，可以封装成指令</li>
</ul>
</li>
</ul>
<h2 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h2><p>尽量不用，用 methods</p>
<h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以引入一个 vue 文件，叫做 Demo，作为 frank 组件（局部注册）</span></span><br><span class="line"><span class="comment">// 优先使用这种，但是局部注册的组件在其子组件中不可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo.vue'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    frank: Demo, <span class="comment">// 如果是 Demo: Demo，就可以简化为 Demo</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以新建一个组件，后面接受的参数与 new Vue(options) 里面的 options 一样（除了没有 el），这叫全局组件</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'my-component-name'</span>, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写，options 也跟外面的一样（除了没有 el）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    frank: options,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件是一个抽象概念</li>
<li>文件名没有特殊规定，如果非常讲究，可以全用小写，因为比如 Windows 10 就不分大小写</li>
<li>组件名推荐首字母大写</li>
</ul>
<h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>目的：减少 data、methods、钩子的重复，可以查看在 <a href="https://codesandbox.io/s/lingering-microservice-6cw8h" target="_blank" rel="noopener">Codesandbox 上的这个例子</a><br>选项会智能合并：data、钩子等都会合并，在冲突的时候优先使用组件自己的</p>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVue = Vue.extend(options)</span><br><span class="line"><span class="comment">// 然后就可以用</span></span><br><span class="line"><span class="keyword">new</span> MyVue(options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> MyVue <span class="keyword">from</span> <span class="string">"../MyVue.js"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  extends: MyVue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看在 <a href="https://codesandbox.io/s/amazing-frog-f9xz5" target="_blank" rel="noopener">CodeSandbox 上的这个例子</a></p>
<h2 id="provide-amp-amp-inject"><a href="#provide-amp-amp-inject" class="headerlink" title="provide &amp;&amp; inject"></a>provide &amp;&amp; inject</h2><p>用于大范围的数据共用，简单数据类型不能直接更改，需要通过函数，传过去的函数的 this 会自动绑定到 Provider 上面，可以查看在 <a href="https://codesandbox.io/s/affectionate-jennings-v4y1t" target="_blank" rel="noopener">Codesandbox 上的这个例子</a></p>
<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 开始</title>
    <url>/hais-notebook/2020/01/30/Vue-Start/</url>
    <content><![CDATA[<p>Vue 笔记的开始，主要记录了 Vue 的安装与历史。</p>
<a id="more"></a>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><ul>
<li>2015 年，1.0 版，是 MVVM 框架</li>
<li>2016 年，2.0 版，没有完全遵循 MVVM 模型</li>
<li>2019 年，2.6 版</li>
<li>2020 年，3.0 版，完全不是 MVVM</li>
</ul>
<h1 id="创建一个-vue-项目"><a href="#创建一个-vue-项目" class="headerlink" title="创建一个 vue 项目"></a>创建一个 vue 项目</h1><ul>
<li>使用 @vue-cli</li>
<li>或者使用 webpack 或者 rollup 从零开始</li>
</ul>
<h1 id="完整版和运行时版本"><a href="#完整版和运行时版本" class="headerlink" title="完整版和运行时版本"></a>完整版和运行时版本</h1><ul>
<li><strong>完整版</strong>：同时包含编译器和运行时的版本，也就是 CDN 里面的 <code>vue.js</code>，可以直接在页面里面写 ，相当于把视图放在 html 里面写</li>
<li><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切，也就是 CDN 里面的 <code>vue.runtime.js</code>，不支持从 html 里面获取视图，也不支持在 template 里面写，没有编译器（compiler），代码体积小 30%</li>
<li>webpack 中的 vue-loader 可以在最后打包的时候将 template 里面的东西编译成 JS，因此我们不需要使用完整版</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>完整版</th>
<th>运行时版</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>特点 | 有 compiler | 没有 compiler | compiler 占 40% 的体积<br>视图 | 写在 HTML 里，或者写在 template 选项中 | 写在 render 函数里，用 h 来创建标签    h 是 Vue 写好传给 render 的<br>CDN 引入 | vue.js | vue.runtime.js | 文件名不同，生产环境后缀为 .min.js<br>webpack 引入 | 需要配置 alias | 默认使用此版 |      |<br>@vue/cli 引入 | 需要额外配置 | 默认使用此版     |   | </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie</title>
    <url>/hais-notebook/2020/01/30/Browser-Cookie/</url>
    <content><![CDATA[<p>Cookie 是浏览器下发给浏览器的一段字符串，浏览器必须保存这个 Cookie，之后发起的相同二级域名的请求，浏览器必须附上 Cookie。</p>
<a id="more"></a>
<h1 id="Cookie-防篡改"><a href="#Cookie-防篡改" class="headerlink" title="Cookie 防篡改"></a>Cookie 防篡改</h1><p>思路一：加密，但是有安全漏洞（加密后的内容可以无限期使用）</p>
<p>思路二：把用户信息隐藏在服务器，这样我就可以自由控制 Cookie 的失效时间</p>
<ul>
<li>把用户信息放在服务器的 <code>session</code> 里，再给信息一个随机 <code>id</code></li>
<li>把随机的 <code>id</code> 发送给浏览器</li>
<li>后端读取的时候，通过 <code>session[id]</code> 获取用户信息</li>
</ul>
<h1 id="Cookie、LocalStorage、SessionStorage-和-Session"><a href="#Cookie、LocalStorage、SessionStorage-和-Session" class="headerlink" title="Cookie、LocalStorage、SessionStorage 和 Session"></a>Cookie、LocalStorage、SessionStorage 和 Session</h1><h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><p>Cookie 是服务器发给浏览器的一段字符串，每次浏览器在访问对应域名的时候，都需要把这个字符串带上<br>Session 是会话，表示浏览器与服务器一段时间内的会话</p>
<ul>
<li>一般 Cookie 在浏览器上，Session 在服务器上</li>
<li>Session 一般是基于 Cookie 来实现的（把 SessionID 放到 Cookie 里面）</li>
</ul>
<h2 id="Cookie-和-LocalStorage-的区别"><a href="#Cookie-和-LocalStorage-的区别" class="headerlink" title="Cookie 和 LocalStorage 的区别"></a>Cookie 和 LocalStorage 的区别</h2><ul>
<li>Cookie 上限一般为 4K，LocalStorage 为 5M</li>
<li>Cookie 一般存储用户信息，LocalStorage 一般存储不重要的数据</li>
<li>Cookie 需要发送到服务器上，LocalStorage 不发送到服务器上</li>
</ul>
<h2 id="LocalStorage-和-SessionStorage-的区别"><a href="#LocalStorage-和-SessionStorage-的区别" class="headerlink" title="LocalStorage 和 SessionStorage 的区别"></a>LocalStorage 和 SessionStorage 的区别</h2><p>LocalStorage 一般不过期，SessionStorage 一般在 Session 结束的时候过期（比如关闭浏览器的时候）</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略与跨域</title>
    <url>/hais-notebook/2020/01/30/Browser-CrossDomain/</url>
    <content><![CDATA[<p>关于同源策略、CORS 和 JSONP 等的笔记。</p>
<a id="more"></a>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><ul>
<li>源：输入 <code>window.origin</code> 或者 <code>location.origin</code>，我们就可以看到 <strong>源</strong>，实际上他就是 <strong>协议 + 域名 + 端口号</strong>。</li>
<li>同源：当两个 url 的源（协议、域名、端口号）完全一致，则称之为 <strong>同源</strong>，比如 <code>https://baidu.com</code> 和 <code>https://www.baidu.com</code> 就不同源。</li>
<li>同源策略：<strong>浏览器</strong> 规定：如果 JS <strong>运行在</strong>源 A 里，那么就不能获取源 B 的数据，这就是 <strong>同源策略</strong> ——不允许不同源的资源 <strong>跨域访问</strong>。</li>
</ul>
<div class="note warning">
            <p>要注意的是，同源策略限制的是 <strong>数据的访问</strong>，引用 CSS、JS 和图片的时候，其实并不知道其内容，只是在 <strong>引用</strong>，因此不受同源策略限制。</p>
          </div>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><blockquote>
<p>Cross-Origin Resource Sharing</p>
</blockquote>
<p>只需要在响应头里面写 <code>Access-Control-Allow-Origin: http://foo.example</code> 就可以了，但是 IE 6、7、8、9 都不支持，得用 JSONP。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><blockquote>
<p>JSONP 和 JSON 没有多大关系</p>
</blockquote>
<p>让 <code>frank.com</code> 访问 <code>qq.com</code> 的方法：</p>
<ol>
<li><code>qq.com</code> 将 数据写到 <code>/friends.js</code></li>
<li><code>frank.com</code> 用 <code>script</code> 标签引用 <code>/friends.js</code></li>
<li><code>/friends.js</code> 执行，执行 <code>frank.com</code> 事先定义好的 <code>window.xxx</code> 函数（<code>window.xxx({friends:[...]})</code>）</li>
<li>然后 <code>frank.com</code> 通过 <code>window.xxx</code> 获取到了数据，这也是一个回调</li>
</ol>
<p>但是，JSONP 存在安全性问题：</p>
<ul>
<li>因为每个人都可以引用 js，需要进行 <code>referer</code> 检查</li>
<li>仍然存在安全问题，如果 <code>frank.com</code> 被攻陷，则 <code>qq.com</code> 也被攻陷</li>
</ul>
<p>如何自动生成 window.xxx（如何把 frank.com 定义好的函数传给后台）？</p>
<ul>
<li>通过查询参数</li>
</ul>
<blockquote>
<p>什么是 JSONP？<br>背景：当前浏览器或者由于某些因素导致不支持跨域<br>方法：请求一个 JS 文件，文件会执行一个回调，回调里面有我们的数据，回调的名字可以随机生成，我们把名字用 callback 参数传给后台，后台再返回给我们再执行<br>优点：兼容 IE、可以跨域<br>缺点：由于是 <code>script</code> 标签，所以读不到 AJAX 那么精确的状态（比如 Status、响应头等等），并且只能发 <code>GET</code> 请求，不支持 <code>POST</code></p>
</blockquote>
<p>一个代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">settings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = settings.data || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> key = settings.key || <span class="string">'callback'</span></span><br><span class="line">  <span class="keyword">const</span> callback = settings.callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  data[key] = <span class="string">'__onGetData__'</span></span><br><span class="line">  <span class="built_in">window</span>.__onGetData__ = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    callback(response)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> query = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    query.push(key + <span class="string">'='</span> + data.key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url + <span class="string">'?'</span> + <span class="built_in">encodeURIComponent</span>(query.join(<span class="string">'&amp;'</span>))</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script)</span><br><span class="line">  <span class="built_in">document</span>.head.removeChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 异步</title>
    <url>/hais-notebook/2020/01/30/JS-Async/</url>
    <content><![CDATA[<p>介绍 AJAX 与异步等。</p>
<a id="more"></a>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><blockquote>
<p>AJAX 即 Asynchronous JavaScript and XML（异步的 JavaScript 与 XML 技术），其实就是一套综合了多项技术的浏览器端网页开发技术。Google 在它多个著名的交互应用程序中使用了这套技术，如 Google 讨论组、Google 地图、Google 搜索建议、Gmail 等，这使得人们看到了前端领域新的可能性。</p>
<p>传统的 Web 应用允许用户端填写表单（form），当提交表单时就向网页服务器发送一个请求；服务器接收并处理传来的表单，然后送回一个<strong>新的网页</strong>。</p>
<p>但这个做法浪费了许多带宽，因为在前后两个页面中的大部分 HTML 码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>与此不同，AJAX 应用可以仅向服务器发送并取回必须的数据，并在客户端采用 JavaScript 处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p>
</blockquote>
<p>简单来讲：</p>
<ol>
<li>AJAX 是浏览器上的功能，浏览器可以使用 AJAX 发请求、收响应；</li>
<li>浏览器在 <code>window</code> 上面加了一个 <code>XMLHttpRequest</code>，方便开发者通过 JS 来发请求、收响应，这是一个构造函数</li>
</ol>
<h2 id="加载-CSS-JS-HTML-XML"><a href="#加载-CSS-JS-HTML-XML" class="headerlink" title="加载 CSS / JS / HTML / XML"></a>加载 CSS / JS / HTML / XML</h2><p>如果想要使用 <code>XMLHttpRequest</code> 让浏览器来帮我们加载 CSS / JS / HTML / XML，一共需要进行四步：</p>
<ol>
<li>创建 <code>XMLHttpResquest</code> 对象</li>
<li>调用他的 <code>open()</code> 方法</li>
<li>使用 <code>onreadystatechange</code> 监听他的成功和失败事件</li>
<li>调用他的 <code>send()</code> 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/&#123;url&#125;'</span>)</span><br><span class="line">request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      alert(<span class="string">'success'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">'error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure>
<p>HTTP 里面可以装 HTML / CSS / JS / XML 等，但得知道怎么解析他们：</p>
<ul>
<li>拿到 CSS 之后生成 <code>&lt;style&gt;</code> 标签</li>
<li>拿到 JS 之后生成 <code>&lt;script&gt;</code> 标签</li>
<li>拿到 HTML 之后使用 <code>innerHTML</code> 和 DOM API，可以新建一个 <code>div</code></li>
<li>拿到 XML 之后的 <code>request.responseXML</code> 实际上已经是一个 DOM 节点了</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<p>JavaScript Object Natation，JSON 不是对象，而是一种标记语言（就像 HTML、XML、Markdown），用来展示数据，<a href="http://json.org/json-zh.html" target="_blank" rel="noopener">JSON 中文官网</a></p>
</blockquote>
<h3 id="JSON-的数据类型"><a href="#JSON-的数据类型" class="headerlink" title="JSON 的数据类型"></a>JSON 的数据类型</h3><ul>
<li>string（但是只支持双引号）</li>
<li>number（支持科学计数法）</li>
<li>bool</li>
<li>null</li>
<li>object</li>
<li>array</li>
</ul>
<div class="note warning">
            <p>JSON 中，不支持函数和变量</p>
          </div>
<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><blockquote>
<p>反序列化</p>
</blockquote>
<ul>
<li>将符合 JSON 语法的字符串转换为 JS 对应类型的数据</li>
<li>JSON 字符串 ⇒ JS 数据</li>
<li>由于 JSON 只有六种类型，所以转换出的数据也只有六种</li>
<li>如果不符合 JSON 语法，则会抛出 Error，一般用 try catch 捕获错误，比如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	object = <span class="built_in">JSON</span>.parse(<span class="string">`&#123;'name':'harvey'&#125;`</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'出错了，错误详情是：'</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(error)</span><br><span class="line">	object = &#123;<span class="string">'name'</span>: <span class="string">'no name'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object)</span><br></pre></td></tr></table></figure>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><blockquote>
<p>序列化</p>
</blockquote>
<ul>
<li>是 JSON.parse 的逆运算</li>
<li>JS 数据 ⇒ JSON 字符串</li>
<li>由于 JS 的数据类型比 JSON 多，所以不一定能够成功</li>
<li>如果失败，则会抛出一个 Error 对象</li>
</ul>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><ul>
<li><strong>同步</strong>： <strong>能直接拿到结果，不拿到结果就不离开</strong>，就像医院挂号一样，可能需要花上几分钟，但是 <strong>拿到号之后才会离开窗口</strong></li>
<li><strong>异步</strong>： <strong>不能直接拿到结果</strong>，比如在餐厅门口等位，拿到号之后我们可以去逛街，那什么时候真正吃上饭呢？我们可以：<ul>
<li>每 10 分钟去餐厅问一下（<strong>轮询</strong>）</li>
<li>也可以扫码用微信接收通知（<strong>回调</strong>）</li>
</ul>
</li>
</ul>
<p>AJAX 举例：当 <code>request.send()</code> 之后，并不能直接得到 <code>response</code>，必须要等待 <code>readyState</code> 变成 <code>4</code> 之后，浏览器回头调用 <code>request.onreadystatechange</code> 函数</p>
<h2 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h2><ul>
<li>写给自己的函数，不是回调</li>
<li>写给别人用的函数，放在一个地方，让他来调用，就是回调</li>
<li><code>request.onreadystatechange</code>，是写给浏览器调用的，意思是让浏览器回头调一下这个函数</li>
</ul>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">f2(f1)</span><br><span class="line"><span class="comment">// 我调用了 f2，因此 f2 不是回调</span></span><br><span class="line"><span class="comment">// 我把 f1 传给了 f2</span></span><br><span class="line"><span class="comment">// 我没有调用，而是 f2 调用了 f1</span></span><br><span class="line"><span class="comment">// 所以 f1 是回调</span></span><br></pre></td></tr></table></figure>
<h2 id="异步与回调"><a href="#异步与回调" class="headerlink" title="异步与回调"></a>异步与回调</h2><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>异步任务需要在得到结果时通知 JS 来拿结果，怎么通知呢？</p>
<ol>
<li>可以让 JS 留一个函数地址（电话号码）给浏览器</li>
<li>异步任务完成之后，浏览器调用该函数的地址（拨打电话）</li>
<li>同时 <strong>把结果作为参数</strong> 传给该函数（电话里说可以来吃了）</li>
</ol>
<p>这个函数是我写给浏览器调用的，所以是回调函数</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>异步任务需要用回调函数来通知结果</p>
<ul>
<li>但异步也可以用 <strong>轮询</strong></li>
<li>回调也不一定用在异步里面，比如 <code>array.forEach( n ⇒ console.log(n) )</code>，这就是 <strong>同步回调</strong></li>
</ul>
<h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">MDN Async Function</a></p>
<p>如果一个函数的返回值处于以下这三个内部，即为异步函数：</p>
<ul>
<li><code>setTimeout</code></li>
<li>AJAX（即 <code>XMLHttpRequest</code>）</li>
<li><code>AddEventListener</code></li>
</ul>
<p>也可以设置同步的 AJAX，<code>request.open(&quot;get&quot;, &quot;/5.json&quot;, false)</code>，但是这样会使页面在请求期间卡住</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) + <span class="number">1</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是按上面这样写，将拿不到 1 ~ 6 的随机数，而是 undefined</span></span><br><span class="line"><span class="keyword">const</span> n = 摇骰子()</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调来拿到异步的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x) &#125;</span><br><span class="line">摇骰子(f1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化代码，因为 f1 只用了一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 摇骰子(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span>) +<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">摇骰子(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以再简化为</span></span><br><span class="line">摇骰子(<span class="built_in">console</span>.log) <span class="comment">// 但是如果参数个数不一致就不能这样简化</span></span><br></pre></td></tr></table></figure>
<p>可以再看一下下面这道题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(array) <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 正确的写法，i 和 arr 可以省略</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> paseInt(item)</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 最开始的写法相当于</span></span><br><span class="line">  <span class="keyword">const</span> array = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> paseInt(item, i, arr)</span><br><span class="line">    <span class="comment">// parseInt('1', 0, arr)，0 为无效参数，忽略</span></span><br><span class="line">    <span class="comment">// parseInt('2', 1, arr)，相当于把 '2' 作为 1 进制来进行解析 =&gt; NaN</span></span><br><span class="line">    <span class="comment">// parseInt('3', 2, arr)，相当于把 '3' 作为 2 进制来进行解析 =&gt; NaN</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>如果异步任务有两个结果：成功或失败，怎么做？</p>
</blockquote>
<p>方法一：回调接受两个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./1.txt'</span>, (error, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123; <span class="built_in">console</span>.log(<span class="string">'失败'</span>); <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>方法二：使用两个回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/1.json'</span>, data=&gt;&#123;&#125;, error=&gt;&#123;&#125;)</span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/1.json'</span>, &#123;</span><br><span class="line">  success: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;, <span class="attr">fail</span>: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是这两个方法都有问题：</p>
<ol>
<li>不规范，名称五花八门，有人用 <code>success + error</code>，有人用 <code>success + fail</code>，有人用 <code>done + fail</code></li>
<li>容易出现回调地狱，代码看不懂</li>
<li>很难进行错误处理</li>
</ol>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getUser( <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  getGroups( user, groups =&gt; &#123;</span><br><span class="line">    groups.forEach( <span class="function">(<span class="params">g</span>) =&gt;</span> &#123;</span><br><span class="line">      g.filter( <span class="function"><span class="params">x</span> =&gt;</span> x.owenerId === user.id)</span><br><span class="line">        .forEach( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;success, fail&#125; = options</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method, url)</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">       success.call(<span class="literal">null</span>, request.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">        fail.call(<span class="literal">null</span>, request, request.status)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/xxx'</span>, &#123;</span><br><span class="line">  success(response)&#123;&#125;, <span class="attr">fail</span>:<span class="function">(<span class="params">request, status</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;)  <span class="comment">// 左边是 function 的缩写，右边是箭头函数</span></span><br></pre></td></tr></table></figure>
<p>↑ 上面是普通的写法，↓ 下面是 Promise 的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="comment">// return new Promise((resolve, reject)=&gt;&#123;..&#125;)</span></span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(request.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">          resolve.call(<span class="literal">null</span>, request.response)  <span class="comment">// 成功调用 resolve(result)，他再回调用第一个函数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">          reject.call(<span class="literal">null</span>, request)  <span class="comment">// 失败调用 reject(error)，他再会调用第二个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'/xxx'</span>)</span><br><span class="line">  .then( <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;&#125;, (request) =&gt; &#123;&#125; )   <span class="comment">// Promise 的回调（成功/失败）只能接受一个参数</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-是如何解决回调地狱的"><a href="#Promise-是如何解决回调地狱的" class="headerlink" title="Promise 是如何解决回调地狱的"></a>Promise 是如何解决回调地狱的</h4><p>回调地狱：</p>
<ol>
<li>多层嵌套</li>
<li>无法方便地进行错误处理</li>
</ol>
<p>解决办法：</p>
<ol>
<li>回调函数延迟绑定，回调函数是通过后面的 then 方法传入的</li>
<li>返回值穿透，根据 then 中回调函数的传入值创建不同类型的 Promise，再把返回的 Promise 穿透到外层，以供后续使用。以上两点实现了链式调用，解决多层嵌套问题</li>
<li>错误冒泡，前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了</li>
</ol>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><ul>
<li>如果传入的参数是一个空的可迭代对象，比如空数组，则返回一个已完成（already resolved）状态的 Promise。</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。</li>
<li>其它情况下返回一个处理中（pending）的Promise。</li>
</ul>
<p>返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。（如果都成功，则成功；有一个失败，则失败）</p>
<p>返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 1337, "foo"] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>可以传入多个 promise，谁快，Promise.race() 就会跟谁一样，如果传的迭代是空的，则返回的 promise 将永远等待。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 入门</title>
    <url>/hais-notebook/2020/01/29/Tools-Git/</url>
    <content><![CDATA[<p>主要记录 Git 的基本用法及一些坑的解决。</p>
<a id="more"></a>
<h1 id="Git-本地仓库"><a href="#Git-本地仓库" class="headerlink" title="Git 本地仓库"></a>Git 本地仓库</h1><h2 id="六行配置"><a href="#六行配置" class="headerlink" title="六行配置"></a>六行配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name [username] </span><br><span class="line">git config --global user.email [useremail@example.com]</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">"code --wait"</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git init</code></td>
<td>创建 <code>.git</code> 目录，容纳代码快照</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>准备将文件提交进 git 目录（本地仓库），路径可以是绝对路径、相对路径、<code>.</code>（当前目录）和 <code>*</code></td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看目前的状态</td>
</tr>
<tr>
<td><code>git commit</code></td>
<td>提交（实际上是复制到了.git目录）</td>
</tr>
<tr>
<td><code>git commit -m &quot;version1&quot;</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>git commit -v（--verbose）</code></td>
<td>推荐，提交理由写得更详细</td>
</tr>
<tr>
<td><code>git reset --hard xxxxxx（提交号的前六位）</code></td>
<td>这个操作会使没有 commit 过的变动消失</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看历史记录</td>
</tr>
<tr>
<td><code>git reflog</code></td>
<td>查看包括 reset 的历史记录</td>
</tr>
<tr>
<td><code>git branch xxx</code></td>
<td>基于当前的commit创建一份新的分支</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看所有分支和当前分支</td>
</tr>
<tr>
<td><code>git branch -d xxx</code></td>
<td>删除分支</td>
</tr>
<tr>
<td><code>git checkout xxx</code></td>
<td>切换分支，当前未提交的文件如果与另一个分支不冲突，切换分支的操作就不会产生影响，如果冲突，可以用git stash或合并冲突</td>
</tr>
<tr>
<td><code>git merge xxx</code></td>
<td>合并分支，先到达想要保留的分支再使用</td>
</tr>
<tr>
<td><code>git rm --chached xxx</code></td>
<td>将已经被 add 的文件从缓存中删除</td>
</tr>
</tbody>
</table>
</div>
<p><code>.gitignore</code> 文件中可以输路径来忽略不想提交的文件，比如 <code>node_modules</code> <code>DS_Store</code> <code>.idea</code> <code>.vscode</code></p>
<h1 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个私钥和公钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C [useremail@example.com]</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传一个本地仓库</span></span><br><span class="line">git remote add origin [git@github.com:Hyuain/git-demo-1.git]</span><br><span class="line">git push -u origin master <span class="comment"># 一个新的分支需要写 -u 和后面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git：创建一个新目录，与 xxx 同名</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git yyy：创建一个新目录，命名为 yyy</span></span><br><span class="line"><span class="comment"># git clone git@?/xxx.git .：不会新建目录，使用当前目录容纳代码和 .git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="comment"># git stash：把文件藏起来</span></span><br><span class="line"><span class="comment"># git stash pop：再把文件取出来</span></span><br></pre></td></tr></table></figure>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias ga="git add"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gc="git commit -v"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gl="git pull"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gp="git push"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gco="git checkout"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'alias gst="git status -sb"'</span>&gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">code ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后加上</span></span><br><span class="line"><span class="built_in">alias</span> glog=<span class="string">"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit -- | less"</span></span><br></pre></td></tr></table></figure>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="git-log-中文乱码"><a href="#git-log-中文乱码" class="headerlink" title="git log 中文乱码"></a>git log 中文乱码</h2><p>输入以下命令即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
<h2 id="git-push-clone-报错"><a href="#git-push-clone-报错" class="headerlink" title="git push / clone 报错"></a>git push / clone 报错</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>防火墙添加 22 端口入站策略配置为允许，有时候不能解决问题。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ol>
<li>在 <code>~/.ssh</code> 存放密钥（<code>id_rsa</code> 和 <code>id_rsa.pub</code>）的文件夹，新建 <code>config</code>，内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User XXX@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
<ol>
<li>刷新 <code>config</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"XXX"</span></span><br><span class="line">git config --global user.email XXX@xx.com</span><br></pre></td></tr></table></figure>
<ol>
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>有时候还是不能解决问题</p>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><ol>
<li>修改 hosts 文件，也可以进入 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress</a> 查询这域名的 IP 地址。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<ol>
<li>刷新 DNS 缓存</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础</title>
    <url>/hais-notebook/2020/01/29/Tools-Command/</url>
    <content><![CDATA[<p>主要记录命令行的基本用法。</p>
<a id="more"></a>
<h1 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd ~</code></td>
<td>~ 表示用户目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>Print Work Directory，展示当前的绝对路径</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>List，查看当前目录文件内容（默认不显示以 <code>.</code> 开头的文件）</td>
</tr>
<tr>
<td><code>ls [file path]</code></td>
<td>查看文件路径内容</td>
</tr>
<tr>
<td><code>ls -l</code></td>
<td>查看更新时间</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>Concatenate，打印文件内容</td>
</tr>
<tr>
<td><code>head</code></td>
<td>展示前 10 行文件，或者 <code>-n [数字]</code></td>
</tr>
<tr>
<td><code>tail</code></td>
<td>展示后 10 行文件</td>
</tr>
<tr>
<td><code>less</code></td>
<td>进入一个可滚动的界面，按上、下（或 J、K ）滚动，按 Q 退出</td>
</tr>
</tbody>
</table>
</div>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>touch</code></td>
<td>创建空文件，可以同时创建多个文件；或者修改文件的更新时间</td>
</tr>
<tr>
<td><code>echo</code></td>
<td>返回你 <code>echo</code> 的东西</td>
</tr>
<tr>
<td><code>echo [content] &gt; 4.txt</code></td>
<td>创建有内容的文件，会覆盖之前的内容</td>
</tr>
<tr>
<td><code>echo [content] &gt;&gt; 4.txt</code></td>
<td>追加内容</td>
</tr>
<tr>
<td><code>echo -e &quot;[content]\n&quot; &gt;&gt; 4.txt</code></td>
<td>有换行的内容</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录，可以同时创建多个目录</td>
</tr>
<tr>
<td><code>mkdir -p a/b/c/d</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>cp [filename] [new filename]</code></td>
<td>复制文件</td>
</tr>
<tr>
<td><code>cp -r [dir] [new dir]</code></td>
<td>复制目录</td>
</tr>
</tbody>
</table>
</div>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rm</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>rm -r</code></td>
<td>删除目录</td>
</tr>
<tr>
<td><code>rm -rf</code></td>
<td>强制删除（不管里面有没有内容）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td>使用 VSCode 打开</td>
</tr>
<tr>
<td><code>start</code></td>
<td>使用默认程序打开</td>
</tr>
<tr>
<td><code>mv [filename] .</code></td>
<td>移动到当前目录</td>
</tr>
<tr>
<td><code>mv [filename] [new filename]</code></td>
<td>重命名文件</td>
</tr>
</tbody>
</table>
</div>
<h2 id="命令的组合"><a href="#命令的组合" class="headerlink" title="命令的组合"></a>命令的组合</h2><ul>
<li>成功返回 <code>0</code>，失败返回 <code>error</code> 和非 <code>0</code> 值，通过 <code>echo $?</code> 查看</li>
<li><code>&amp;&amp;</code>：第一条命令后才会执行后面的</li>
<li><code>;</code>：不管前面是否成功都会执行后面的</li>
</ul>
<h2 id="把命令变成文件"><a href="#把命令变成文件" class="headerlink" title="把命令变成文件"></a>把命令变成文件</h2><ul>
<li>MAC上需要执行：<code>chmod +x [filename]</code>，赋予执行权限</li>
<li>执行命令：<code>./[filename]</code> 或者 <code>sh [filename]</code></li>
<li>如果加入 <code>PATH</code>，就可以不用输入文件路径，也不用输入 <code>./</code>，输入文件名就能执行</li>
<li>命令行的本质就是可执行文件</li>
<li>windows 会优先去找 <code>.exe</code> 的文件</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM API</title>
    <url>/hais-notebook/2020/01/29/JS-DOM/</url>
    <content><![CDATA[<p>Document Object Model，即将网页抽象成对象，并用 JS 进行操作的方式。</p>
<a id="more"></a>
<h1 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.id <span class="comment">// 或者直接 id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'idxxx'</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'div&gt;span:nth-child(2)'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'.red'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取特定的元素"><a href="#获取特定的元素" class="headerlink" title="获取特定的元素"></a>获取特定的元素</h2><ul>
<li>获取 html： <code>document.documentElement</code></li>
<li>获取 head： <code>document.head</code></li>
<li>获取 body： <code>document.body</code></li>
<li>获取 window： <code>window</code></li>
<li>获取所有元素： <code>document.all</code>，第 6 个 <code>falsy</code> 值，别的浏览器为了不使用为了 IE 设计的代码（这个是 IE 发明的）</li>
</ul>
<h2 id="获取的元素的原型"><a href="#获取的元素的原型" class="headerlink" title="获取的元素的原型"></a>获取的元素的原型</h2><p>div 的原型链：</p>
<p><code>HTMLDivElement.prototype</code> → <code>HTMLElement.prototype</code> → <code>Elment.prototype</code> → <code>Node.prototype</code> → <code>EventTarget.prototype</code> → <code>Object.prototype</code></p>
<h2 id="节点（Node）和元素（Element）的区别"><a href="#节点（Node）和元素（Element）的区别" class="headerlink" title="节点（Node）和元素（Element）的区别"></a>节点（Node）和元素（Element）的区别</h2><p>使用 x.nodeType 可以得到一个数字：</p>
<ul>
<li>1 表示 Element（也叫 Tag ）</li>
<li>3 表示 Text</li>
<li>8 表示 Comment</li>
<li>9 表示 Document</li>
<li>11 表示 DocumentFragment</li>
</ul>
<h2 id="获取附近的元素"><a href="#获取附近的元素" class="headerlink" title="获取附近的元素"></a>获取附近的元素</h2><ul>
<li>查爸爸： <code>div.parentNode</code> 或者 <code>div.parentElement</code></li>
<li>查子代： <code>div.childNodes</code> 或者 <code>div.children</code>，推荐使用后者，因为前者包括了文本节点，比如空格，两者都会实时变化</li>
<li>查兄弟姐妹： <code>div.parentNode.childNodes</code> 或者 <code>div.parentNode.children</code>，然后再排除自己</li>
<li>查看老大： <code>div.firstChild</code></li>
<li>查看老幺： <code>div.lastChild</code></li>
<li>查看上一个哥哥： <code>div.previousSibling</code>（有可能查到文本节点，可以用 <code>div.previousElementSibling</code>）</li>
<li>查看下一个弟弟： <code>div.nextSibling</code>（有可能查到文本节点，可以用 <code>div.nextElementSibling</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历一个 div 里面所有的元素</span></span><br><span class="line">travel = <span class="function">(<span class="params">node, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  fn(node)</span><br><span class="line">    <span class="keyword">if</span>(node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">      travel(node.children[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">travel(div1, (node) =&gt; <span class="built_in">console</span>.log(node))</span><br></pre></td></tr></table></figure>
<h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><h2 id="创建一个标签"><a href="#创建一个标签" class="headerlink" title="创建一个标签"></a>创建一个标签</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建一个文本节点"><a href="#创建一个文本节点" class="headerlink" title="创建一个文本节点"></a>创建一个文本节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">text = <span class="built_in">document</span>.createTextNode(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="在标签里面插入文本"><a href="#在标签里面插入文本" class="headerlink" title="在标签里面插入文本"></a>在标签里面插入文本</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div1.appendChild(text1)</span><br><span class="line">div1.innerText = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">div1.textContent = <span class="string">'你好'</span></span><br><span class="line"><span class="comment">//但是不能用</span></span><br><span class="line">div.appendChild(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="插入到页面中"><a href="#插入到页面中" class="headerlink" title="插入到页面中"></a>插入到页面中</h2><ul>
<li><code>document.body.appendChild(div)</code> 或者 <code>已经在页面中的元素.appendChild(div)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有 div#test1 和 div#test2</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">test1.appendChild(div)</span><br><span class="line">test2.appendChild(div)</span><br><span class="line"><span class="comment">// div 最终只会出现在 test2 里面</span></span><br></pre></td></tr></table></figure>
<ul>
<li>让两个地方都有： <code>let div2 = div1.cloneNode(true)</code>，如果后面为 <code>true</code> 则使用深拷贝，所有的后代也会被拷贝</li>
</ul>
<h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.parentNode.removeChild(div)</span><br><span class="line">div.remove()</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>如果一个 Node 被移除了页面（DOM）树，它还可以再被放回去，它暂存在了内存里面，如果想删除，<code>div = null</code>，一会儿会自动回收</p>
          </div>
<h1 id="编辑节点"><a href="#编辑节点" class="headerlink" title="编辑节点"></a>编辑节点</h1><h2 id="编辑属性"><a href="#编辑属性" class="headerlink" title="编辑属性"></a>编辑属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.className = <span class="string">'red blue'</span><span class="comment">// 会覆盖掉之前的 class，要用 div.className += ' red'</span></span><br><span class="line"></span><br><span class="line">div.classList.add(<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line">div.style = <span class="string">'color: blue'</span></span><br><span class="line"><span class="comment">// 会覆盖掉之前的 style，一般就写 style 的一部分</span></span><br><span class="line"><span class="comment">// 比如 div.style.color = 'blue'，注意大小写问题：div.style.backgroundColor</span></span><br><span class="line"></span><br><span class="line">div.setAttribute(<span class="string">'data-x'</span>, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">div.getAtrribute(<span class="string">'data-x'</span>) <span class="comment">// 强加的，这样写也行</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>如果用 <code>a.href</code> 获取属性，然后是相对路径的话，他会把域名一起弄下来<br>如果用 <code>a.href.getAttribute(&#39;href&#39;)</code> 只获取属性里面写了的部分</p>
          </div>
<h2 id="编辑事件"><a href="#编辑事件" class="headerlink" title="编辑事件"></a>编辑事件</h2><ul>
<li><code>div.onclick</code> 默认为 <code>null</code>，如果改成 <code>fn</code>，那么在点击的时候就会调用 <code>fn.call(div, event)</code>，<code>event</code> 包含了点击事件的所有信息，比如坐标</li>
<li><code>div.addEventListener</code></li>
</ul>
<h2 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h2><h3 id="编辑文本内容"><a href="#编辑文本内容" class="headerlink" title="编辑文本内容"></a>编辑文本内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerText = <span class="string">'hi'</span></span><br><span class="line">test.textContent = <span class="string">'hi'</span></span><br></pre></td></tr></table></figure>
<h3 id="修改-HTML-内容"><a href="#修改-HTML-内容" class="headerlink" title="修改 HTML 内容"></a>修改 HTML 内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 里面的字符不能超过两万个</span></span><br></pre></td></tr></table></figure>
<h3 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.innerHTML = <span class="string">''</span> <span class="comment">// 先清空</span></span><br><span class="line">test.appendChild(div) <span class="comment">//再加内容</span></span><br></pre></td></tr></table></figure>
<h2 id="跨线程"><a href="#跨线程" class="headerlink" title="跨线程"></a>跨线程</h2><p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.start</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.end</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.classList.add(<span class="string">'start'</span>)</span><br><span class="line">test.clientWidth <span class="comment">// 如果没有这句话，上下两句话就会合并，这句话会触发重新渲染</span></span><br><span class="line">test.classList.add(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><ul>
<li>标准属性，会自动同步，比如 <code>id</code> <code>className</code> <code>title</code></li>
<li><code>data-*</code> 属性，也会自动同步</li>
<li>非标准属性，不会同步到页面里，只会停留在JS 线程中，而不会自动同步到页面上</li>
</ul>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Property-1.png" alt="JSProperty-1"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Property-2.png" alt="JSProperty-2"></p>
<div class="note warning">
            <p>自定义属性最好以 <code>data-</code> 为前缀</p>
          </div>
<h3 id="Property-和-Attribute"><a href="#Property-和-Attribute" class="headerlink" title="Property 和 Attribute"></a>Property 和 Attribute</h3><ul>
<li>Property 是 JS 线程中 div1 的所有属性</li>
<li>Attribute 是 渲染引擎中 div1 对应标签的属性</li>
<li>大部分时候，同名的 Property 和 Attribute 值相等</li>
<li>如果不是标准属性，那么他们俩只会在一开始的时候相等</li>
<li>但注意 Attribute 只支持字符串，而 Property 支持字符串、布尔等类型</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 世界</title>
    <url>/hais-notebook/2020/01/29/JS-World/</url>
    <content><![CDATA[<p>介绍 JavaScript 这个世界从诞生开始的故事。</p>
<a id="more"></a>
<h1 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h1><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><ul>
<li>固件是固定在主板上的存储设备，里面有开机程序</li>
<li>开机程序会将文件里的 OS 加载到内存里运行</li>
</ul>
<h2 id="操作系统（以-Linux-为例）"><a href="#操作系统（以-Linux-为例）" class="headerlink" title="操作系统（以 Linux 为例）"></a>操作系统（以 Linux 为例）</h2><ul>
<li>首先加载操作系统内核</li>
<li>然后启动初始化进程，编号为 1，每个进程都有 PID</li>
<li>启动系统服务：文件、安全、联网</li>
<li>等待用户登录：输入密码登录 / ssh 登录</li>
<li>登录后，运行 shell，用户就可以和操作系统对话了</li>
<li>bash 是一种 shell，图形化界面可认为是一种 shell</li>
</ul>
<h1 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h1><h2 id="chrome-exe"><a href="#chrome-exe" class="headerlink" title="chrome.exe"></a>chrome.exe</h2><ul>
<li>运行 chrome.exe 文件</li>
<li>开启 chrome 进程，作为主进程</li>
<li>主进程会开启一些辅助进程，如网络服务、GPU 加速</li>
<li>每新建一个标签，就有可能开启一个子进程</li>
</ul>
<h2 id="浏览器的功能"><a href="#浏览器的功能" class="headerlink" title="浏览器的功能"></a>浏览器的功能</h2><ul>
<li>发起请求、下载 HTML、解析 HTML、下载 CSS、解析 CSS、渲染界面、下载 JS、解析 JS、执行 JS</li>
<li>功能模块：用户界面、渲染引擎、JS 引擎、存储等，这些功能模块属于不同的线程<ul>
<li>JS 通过<strong>跨线程通信</strong>，使渲染引擎重新渲染</li>
<li>JS 是单线程的</li>
<li>DOM 操作慢：跨线程通信慢</li>
</ul>
</li>
</ul>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><ul>
<li>浏览器用的什么 JS 引擎？<ul>
<li>Chrome 用的是 V8 引擎，C++ 编写</li>
<li>网景用的是 SpiderMonkey，后被 Firefox 使用，C++</li>
<li>Safari 用的是 JavaScriptCore</li>
<li>IE 用的是 Chakra（JScript 9）</li>
<li>Edge 用的是 Chakra (JavaScript)</li>
<li>Node.js 用的是 V8 引擎</li>
</ul>
</li>
<li>主要功能<ul>
<li>编译：把 JS 代码翻译为机器能执行的字节码或机器码</li>
<li>优化：改写代码，使其更加高效</li>
<li>执行：执行上面的字节码或机器码</li>
<li>垃圾回收：把 JS 用完的内存回收，方便之后再次使用</li>
</ul>
</li>
</ul>
<h2 id="运行-JavaScript-代码"><a href="#运行-JavaScript-代码" class="headerlink" title="运行 JavaScript 代码"></a>运行 JavaScript 代码</h2><ul>
<li>准备工作<ul>
<li>提供 API： window、document、setTimeout（这些功能成为运行环境 runtime env）</li>
</ul>
</li>
<li>内存图<ul>
<li><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/RAM-Graph.png" alt="内存图"></li>
<li>红色区域（存放数据，但不会存变量名）<ul>
<li>Stack 栈：每个数据顺序存放，非对象都存在 Stack</li>
<li>Heap 堆：每个数据随机存放，对象都存在 Heap（数组、函数）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="堆内存与栈内存"><a href="#堆内存与栈内存" class="headerlink" title="堆内存与栈内存"></a>堆内存与栈内存</h2><p>JS 的内存空间分为</p>
<ul>
<li>栈（Stack）：存放简单类型，LIFO</li>
<li>堆（Heap）：存放引用类型，是一种经过排序的树形结构，每个节点都有一个值，通常说的堆是指二叉堆，存取随意</li>
<li>池（一般也被归类为栈中）：存放常量，故又称常量池</li>
</ul>
<h3 id="堆与栈的优缺点"><a href="#堆与栈的优缺点" class="headerlink" title="堆与栈的优缺点"></a>堆与栈的优缺点</h3><ul>
<li>栈内存系统效率高，因为堆内存需要分配空间和地址，还要把地址存在栈内存中，因此效率低</li>
<li>引用类型变量大小不确定，如果放到栈内存中就无法轻易改变自己的大小，同时也浪费空间</li>
</ul>
<p>闭包中的变量保存在堆内存中，而不是栈内存中，因此函数调用之后闭包仍然能够引用到函数内的变量</p>
<h3 id="闭包与堆内存"><a href="#闭包与堆内存" class="headerlink" title="闭包与堆内存"></a>闭包与堆内存</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = A()</span><br></pre></td></tr></table></figure>
<p>函数 A 弹出调用栈之后，函数 A 中的变量这个时候是存储在堆上的，现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上</p>
<h2 id="V8-执行一段代码的过程"><a href="#V8-执行一段代码的过程" class="headerlink" title="V8 执行一段代码的过程"></a>V8 执行一段代码的过程</h2><ol>
<li>首先通过词法分析和语法分析生成 <strong>AST</strong></li>
<li><strong>解释器</strong> 将 AST 转换为字节码</li>
<li>由 <strong>解释器</strong> 逐行执行字节码，遇到热点代码启动 <strong>编译器</strong> 进行编译，生成对应的机器码，优化执行效率</li>
</ol>
<h3 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>主要是把一行行代码分解成一个个 token：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'harvey'</span></span><br></pre></td></tr></table></figure>
<p>会把句子拆分成四个部分（四个 token）：关键字 let、变量名 name、赋值 =、字符串 ‘harvey’</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>将生成的这些 token 数据，根据一定的语法规则转化为 AST，之后会生成执行上下文。<br>babel 实际上就是将 ES6 代码解析生成  ES6 的 AST，然后再转换为 ES5 的 AST，然后再转换为 ES5 的代码。</p>
<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3><p>生成 AST 之后，直接通过 V8 解释器（Ignition） 生成字节码，但是字节码并不能让机器直接运行——之所以不直接转化为机器码，是因为机器码空间占用太大了。</p>
<p>字节码比机器码轻量很多，是介于 AST 和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。</p>
<h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p>热点代码：在执行字节码的过程中，如果有一段代码反复出现，则记为 <strong>热点代码</strong>（HotSpot），这段代码会被编译成机器码保存起来。在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码。</p>
<p>JS 实际上并不是一门完全的解释型语言，因为字节码不仅配合了 <strong>解释器</strong>，还要配合 <strong>编译器</strong>。编译器和解释器的根本区别在于前者会编译生成二进制文件而后者不会。</p>
<h1 id="JavaScript-世界"><a href="#JavaScript-世界" class="headerlink" title="JavaScript 世界"></a>JavaScript 世界</h1><blockquote class="blockquote-center"><p><strong>JS 公式：<code>对象.__proto__ === 其构造函数.prototype</code></strong><br><strong>根公理：<code>Object.prototype</code> 是所有对象的（直接或间接）原型</strong><br><strong>函数公理：所有函数都是由 <code>Function</code> 构造的</strong></p>
</blockquote>
<p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-1.png" alt="JSWorld-1"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-2.png" alt="JSWorld-2"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-3.png" alt="JSWorld-3"><br><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-World-4.png" alt="JSWorld-4"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Function</title>
    <url>/hais-notebook/2020/01/29/JS-Function/</url>
    <content><![CDATA[<p>正式介绍 JavaScript 中的函数。</p>
<a id="more"></a>
<h1 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h1><h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参</span>) </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>) </span>&#123; 函数体 &#125; <span class="comment">// 右边的部分也叫函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">形参</span>)</span>&#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 如果函数的声明是在 = 右边</span></span><br><span class="line"><span class="comment">// fn 的作用域只能在 = 右边</span></span><br><span class="line"><span class="comment">// 别的地方不能用 fn 这个名字</span></span><br></pre></td></tr></table></figure>
<h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入参数 =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; 输出参数</span><br><span class="line">( 输入参数<span class="number">1</span>, 输入参数<span class="number">2</span> )  =&gt; &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> 语句</span><br><span class="line">&#125;</span><br><span class="line">x =&gt; (&#123; <span class="attr">name</span>: <span class="string">'...'</span> &#125;) <span class="comment">// 如果要返回对象，就要加圆括号</span></span><br></pre></td></tr></table></figure>
<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数可以先使用再声明，因为 function 会跑到最前面<br>但是 <code>let fn = function(){}</code> 不是函数提升，他不能先使用再声明，因为这句话是赋值，右边的匿名函数不会提升</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li><strong>全局变量与局部变量</strong>：在 <strong>顶级作用域</strong> 声明的变量是全局变量（比如 window 上的变量是全局变量）；其他的都是局部变量</li>
<li><strong>就近原则</strong>：如果有多个作用域有同名变量 <code>a</code>，那么查找 <code>a</code> 的声明时，就向上取最近的作用域</li>
<li><strong>作用域的确定与函数的执行无关（JavaScript 的作用域为静态作用域），但变量的值在函数执行的时候才能确定</strong></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>函数用到了外部的变量，则函数+这个变量=闭包，作用域遵循就近原则</p>
</blockquote>
<p>闭包的作用：隐藏局部变量，暴露操作函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = createAdd()</span><br><span class="line">add() <span class="comment">// 1</span></span><br><span class="line">add() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>闭包的缺点：容易内存泄露。注意，虽然闭包并不会造成内存泄露，真实原因是 JS 引擎的实现有问题。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>复制内存图中 stack 里面的东西（简单类型复制值，对象复制地址）</p>
<h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>实际上就是变量声明： <code>var x = arguments[0]</code></p>
<div class="note warning">
            <p>形参可多可少</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>每个函数都有返回值，默认是 <code>undefined</code></li>
<li>只有函数才有返回值</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><ul>
<li>JS 在调用函数之前，需要把函数的环境 push 到一个数组（调用栈）里面，等函数执行完之后把环境 pop 出来，然后 return 到之前的环境中</li>
<li>递归很容易把栈压满：爆栈</li>
<li>调用栈最长有多少？Chrome 12578；Firefox 26773；Node 12536</li>
</ul>
<h1 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h1><blockquote>
<p>关于 this 更多的内容可以看看这篇文章—— <a href="https://hais-teatime.com/post/2019-12-24-this/" target="_blank" rel="noopener">再看 this</a>。</p>
</blockquote>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>调用函数即传入 arguments， arguments 是包含传入参数的伪数组</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><code>this</code> 的存在是为了解决函数获取一个对象的引用的问题</li>
<li>如果不给任何的条件， <code>this</code> 为 <code>window</code></li>
<li>如果想要指定 <code>this</code>，要用 <code>fn.call(xxx, 1, 2, 3)</code> 传入 <code>this</code> 和 <code>arguments</code>（如果传入的 <code>this</code> 不是对象，将会默认封装成对象，除非加上 <code>&#39;use strict&#39;</code>，JS的糟粕）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this: '</span> + <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">1</span>) <span class="comment">// 'this: 1'</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>) <span class="comment">// 'this: undefined'</span></span><br></pre></td></tr></table></figure>
<h3 id="两种调用函数的方法"><a href="#两种调用函数的方法" class="headerlink" title="两种调用函数的方法"></a>两种调用函数的方法</h3><h4 id="隐式传递"><a href="#隐式传递" class="headerlink" title="隐式传递"></a>隐式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi()</span><br><span class="line"><span class="comment">// 会自动地把 person 传到函数里，作为 this</span></span><br></pre></td></tr></table></figure>
<h4 id="显式传递"><a href="#显式传递" class="headerlink" title="显式传递"></a>显式传递</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHi.call(person)</span><br><span class="line"><span class="comment">// 手动把 person 传到函数里，作为 this</span></span><br><span class="line"><span class="comment">// apply 跟 call 的区别就是后面要加中括号（参数传的是数组）</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">p1, p2</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>, p1, p2) &#125;</span><br><span class="line"><span class="keyword">let</span> f3 = f1.bind( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125;, <span class="string">'hi'</span> )</span><br><span class="line">f3()  <span class="comment">// 等价于 f1.call( &#123;name:'hai'&#125;, 'hi' )</span></span><br><span class="line">      <span class="comment">// 相当于让 f3 的 this 和 arguments 永远等于这个</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>没有 <code>arguments</code> 和 <code>this</code>，里面的 <code>this</code> 就是外面的 <code>this</code>，就算加 <code>call</code> 也没有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">fn() <span class="comment">// window</span></span><br><span class="line">fn.call( &#123;<span class="attr">name</span>:<span class="string">'hai'</span>&#125; ) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>只想要一个局部变量，而不想要一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="regexp">/-/</span><span class="number">1</span>*<span class="regexp">/! function ()&#123; var a = 2; console.log(a) &#125; ()</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明了一个全局函数，立即调用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array</title>
    <url>/hais-notebook/2020/01/29/JS-Array/</url>
    <content><![CDATA[<p>JS 的数组不是典型的数组，而是一个对象；<strong>元素的数据类型可以不同，内存不一定连续，是通过字符串下标（而不是数字下标）获取元素</strong>。</p>
<a id="more"></a>
<h1 id="获得新数组"><a href="#获得新数组" class="headerlink" title="获得新数组"></a>获得新数组</h1><h2 id="将类数组转化为数组"><a href="#将类数组转化为数组" class="headerlink" title="将类数组转化为数组"></a>将类数组转化为数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">args = [...arguments]</span><br><span class="line">args = <span class="built_in">Array</span>.prototype.concat.apply([], <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>
<h2 id="新建数组"><a href="#新建数组" class="headerlink" title="新建数组"></a>新建数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的简便定义</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的标准写法</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者只传入一个参数，表示数组的长度</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以','分隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'1,2,3'</span>.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有间隔的字符串</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'123'</span>.split(<span class="string">''</span>)</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象转换</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转化为字符串</span></span><br><span class="line"><span class="keyword">let</span> str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">','</span>)</span><br></pre></td></tr></table></figure>
<p>数组对象除了 <code>__proto__</code> 之外，还包括 <strong>索引</strong> 和 <strong>长度（<code>length</code>）</strong> 这两个自身属性。</p>
<div class="note warning">
            <p><strong>伪数组</strong>：伪数组的原型链中没有数组的原型<br>比如 <code>let divList = document.querySelector(&#39;div&#39;)</code> 将得到一个伪数组；一个普通的对象只是加上 <code>length</code> 属性，也将得到一个伪数组。<br>通常我们需要把它转化为数组来使用<br><code>let divArray = Array.from(divList)</code></p>
          </div>
<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr1.concat(arr2) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h2 id="截取数组"><a href="#截取数组" class="headerlink" title="截取数组"></a>截取数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">2</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">0</span>) <span class="comment">// 生成新数组，原数组不变</span></span><br></pre></td></tr></table></figure>
<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];  <span class="keyword">delete</span> arr[<span class="string">'0'</span>]</span><br><span class="line"><span class="comment">// arr 为 [ empty, 'b', 'c']，如果3个都是 empty，称为稀疏数组，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改 length 也可以删除数组的元素，不推荐</span></span><br><span class="line"></span><br><span class="line">arr.shift()</span><br><span class="line"><span class="comment">// 删除最开始的元素，并返回他，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.pop()</span><br><span class="line"><span class="comment">// 删除最后一个元素，并返回他，arr 被修改</span></span><br><span class="line"> </span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，并返回删除的部分，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 从 2 开始，删除 3 个，增加 'x' 和 'y'</span></span><br><span class="line"><span class="comment">// 并返回删除的部分，arr 被修改</span></span><br></pre></td></tr></table></figure>
<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="built_in">Object</span>.values(arr) <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`$(index) : $(item)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两种基本没有区别</span></span><br><span class="line"><span class="comment">// 但 for 关键字有 continue 和 break，forEach 没有</span></span><br><span class="line"><span class="comment">// for 是块级作用域，forEach 是函数作用域</span></span><br></pre></td></tr></table></figure>
<h2 id="查找单个元素"><a href="#查找单个元素" class="headerlink" title="查找单个元素"></a>查找单个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexOf(item) <span class="comment">// 有就会返回 index，没有就会返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>) </span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 会返回第一个符合条件的元素对应的索引</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>索引越界</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[arr.length] === <span class="literal">undefined</span></span><br><span class="line">a[<span class="number">-1</span>] === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
          </div>
<h1 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push()</span><br><span class="line"><span class="comment">// 在尾部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.unshift()</span><br><span class="line"><span class="comment">// 在头部添加，返回数组长度，arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">8</span>, <span class="number">0</span>, <span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment">// 增加 'x' 和 'y'，并返回删除的部分（[]），arr 被修改</span></span><br></pre></td></tr></table></figure>
<h1 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reverse() <span class="comment">// arr 被修改</span></span><br><span class="line">arr.sort() <span class="comment">// arr 被修改</span></span><br><span class="line"></span><br><span class="line">arr.sort( <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a &gt; b ) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a === b ) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回 1，a 在 b 之后</span></span><br><span class="line"><span class="comment">// 返回 0，不变</span></span><br><span class="line"><span class="comment">// 返回 -1，b 在 a 之后</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.score - b.score) <span class="comment">// 按 score 从小到大排序</span></span><br></pre></td></tr></table></figure>
<h1 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h1><p>得到新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map： n 变 n</span></span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter：n 变少</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce：n 变 1</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item, <span class="number">0</span>)</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result.concat(item * item), [])</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span></span><br><span class="line">  result.concat(item % <span class="number">2</span> === <span class="number">1</span> ? [] : item), [])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Object</title>
    <url>/hais-notebook/2020/01/29/JS-Object/</url>
    <content><![CDATA[<p>简单来说，对象实际上就是无序的数据集合，或者说是 <strong>键/值对（Key/Value Paris）</strong>的集合.</p>
<a id="more"></a>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>对象有以下这样几种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的简便声明</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 对象的标准写法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对象也可以作为参数直接传入函数</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'harvey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这里我们需要注意以下几个细节：</p>
<ul>
<li>键名是字符串，不是标识符，可以是任意字符</li>
<li>引号可以省略，省略之后就只能写标识符或者以数字开头</li>
<li><strong>就算引号省略了，键名也还是字符串</strong>（不一定，键名也可能是函数、日期、正则等）</li>
<li>奇怪的属性名： <code>1e2</code> 会变成 <code>&#39;100&#39;</code>， <code>.234</code> 会变成 <code>&#39;0.234&#39;</code>， <code>0xFF</code> 会变成 <code>&#39;255&#39;</code></li>
<li>变量也可以作为属性名，比如：<code>let obj = { [p1]: &#39;harvey&#39; }</code>，这样就会用 <code>p1</code> 里面的值了，<strong>中括号里面的东西都会先求值</strong></li>
</ul>
<h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><h2 id="隐藏的属性"><a href="#隐藏的属性" class="headerlink" title="隐藏的属性"></a>隐藏的属性</h2><p><strong>每一个</strong> 对象都有一个隐藏属性 <code>__proto__</code>，这个属性存着 <strong>一个对象的地址</strong>，这个对象包含了这类对象（普通对象、数组、函数等）的 <strong>共有属性</strong></p>
<p><code>__proto__</code> 里面存的实际上就是 <strong>原型的地址</strong></p>
<p>因此，<strong>每一个对象都有原型</strong></p>
<p>比如 <code>obj = {}</code>，他的原型的地址就存储在 <code>obj.__proto__</code> 中，而<code>obj.__proto__</code> 也是一个对象，因此他也有原型，但我们规定，他的原型值为 <code>null</code></p>
<h2 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h2><p>有以下两种删除对象属性的方法：</p>
<ol>
<li><code>obj.name = undefined</code>，这样做只会删除属性的值，不会把属性完全删除</li>
<li><code>delete obj.name</code>，同时删除属性名和属性值，或者用 <code>delete obj[&#39;name&#39;]</code> 也是可以的</li>
</ol>
<p>删除完成后可以对删除的结果进行检查：</p>
<ol>
<li><code>&#39;name&#39; in obj</code>，检查 <code>&#39;name&#39;</code> 是不是 <code>obj</code> 的属性名，如果是用上面的第一种方法删除，检查的结果将是 <code>true</code>；如果是第二种方法删除，则会返回 <code>false</code>；注意属性名有引号（因为属性名实际上是字符串）</li>
<li><code>&#39;name&#39; in obj &amp;&amp; obj.name === undefined</code>，检查是否含有属性名且值为 <code>undefined</code>，如果是上面第一种方法删除，则会返回 <code>true</code></li>
</ol>
<h2 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h2><ul>
<li><code>Object.keys(obj)</code>，查看 <code>obj</code> 的 <strong>自身</strong> 属性名</li>
<li><code>Object.values(obj)</code>，查看 <code>obj</code> 的  <strong>自身</strong> 属性值</li>
<li><code>Object.entries(obj)</code>，返回结果包含两个数组，第一个数组是 <code>obj</code> 的 <strong>自身</strong> 属性名，第二个数组是 <code>obj</code> 的 <strong>自身</strong> 属性值</li>
<li><code>console.dir(obj)</code>，查看 <code>obj</code> 的 <strong>自身属性 + 共有属性</strong></li>
<li><code>in</code>，查看是不是 <strong>自身属性 + 共有属性</strong> （相当于所有属性）</li>
<li><code>obj.hasOwnProperty(&#39;toString&#39;)</code>，查看 <code>&#39;toString&#39;</code> 是不是 <code>&#39;obj&#39;</code> <strong>自身的</strong> 属性</li>
</ul>
<div class="note warning">
            <p><code>obj.name</code> 等价于 <code>obj[&#39;name&#39;]</code>，不等价于 <code>obj[name]</code></p>
          </div>
<h2 id="添加或修改属性"><a href="#添加或修改属性" class="headerlink" title="添加或修改属性"></a>添加或修改属性</h2><p>直接赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'name'</span>] = <span class="string">'harvey'</span></span><br><span class="line">obj[<span class="string">'na'</span>+<span class="string">'me'</span>] = <span class="string">'harvey'</span> <span class="comment">// 因为属性名本质是字符串，上面三句话实际上是一样的</span></span><br></pre></td></tr></table></figure>
<p>批量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj, &#123;<span class="attr">p1</span>:<span class="number">1</span>, <span class="attr">p2</span>:<span class="number">2</span>, <span class="attr">p3</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>但是，不能直接修改共有属性（原型上的属性）：比如，不能通过 <code>obj.toString</code> 来修改原型上的<code>&#39;toString&#39;</code>，这样只会为 <code>obj</code> 增添一个本身的<code>&#39;toString&#39;</code> 属性，而不会修改原型，除非这样写代码（但是这是不推荐的）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型的属性</span></span><br><span class="line">obj.__proto__.toString =</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString =</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(common)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">person.__proto__ = common <span class="comment">// 原型链增加一个环节</span></span><br></pre></td></tr></table></figure>
<h1 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h1><div class="note warning">
            <p>所有的函数自带 prototype（箭头函数没有 prototype）<br>prototype 中自带 constructor<br>constructor 里面的东西就是函数的内容</p>
          </div>
<h2 id="new-X"><a href="#new-X" class="headerlink" title="new X()"></a>new X()</h2><ol>
<li>自动创建空对象</li>
<li>自动为空对象关联原型，原型的地址为 <code>X.prototype</code></li>
<li>自动将空对象作为 <code>this</code> 关键字运行构造函数</li>
<li>自动 <code>return this</code>（也就是说可以接着写 <code>new X().getName()</code>）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现一个类似 new 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.b = b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> X(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NEW</span>(<span class="params">fun, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(fun.prototype)</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    <span class="comment">// let newObj = &#123;&#125;</span></span><br><span class="line">    <span class="comment">// newObj.__proto__ = fun.prototype</span></span><br><span class="line">    <span class="keyword">const</span> result = fun.apply(newObj, args)</span><br><span class="line">    <span class="comment">// 原版的 new 中，如果构造函数返回一个对象，则 new 也返回一个对象；如果构造函数返回一个简单类型，则 new 返回刚刚创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = NEW(X, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数-X"><a href="#构造函数-X" class="headerlink" title="构造函数 X"></a>构造函数 <code>X</code></h2><ul>
<li><code>X</code> 自身用于添加新对象的<strong>自身的属性</strong></li>
<li><code>X.prototype</code> 负责保存对象的<strong>共用属性</strong></li>
</ul>
<p>一般来讲有这样的代码规范：</p>
<ul>
<li>所有构造函数首字母大写，被构造出来的对象首字母小写</li>
<li><code>new</code> 后面的函数使用名词；其他的函数一般用动词开头</li>
</ul>
<h2 id="如何确定一个对象的原型？"><a href="#如何确定一个对象的原型？" class="headerlink" title="如何确定一个对象的原型？"></a>如何确定一个对象的原型？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.__proto__ === 其构造函数.prototype</span><br></pre></td></tr></table></figure>
<h2 id="数据类型与对象的分类"><a href="#数据类型与对象的分类" class="headerlink" title="数据类型与对象的分类"></a>数据类型与对象的分类</h2><blockquote>
<p> 数据类型是 JavaScript 数据的类型，一共有 7 种；<br> 对象的分类则有无数种，常见的有 Array、Function、Date、RegExp 等</p>
</blockquote>
<p>我们常见的有这几种类型的对象：</p>
<ul>
<li><p>数组对象</p>
<ul>
<li>自身属性：<code>&#39;0&#39;</code> <code>&#39;1&#39;</code> <code>&#39;2&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;push&#39;</code> <code>&#39;pop&#39;</code> <code>&#39;shift&#39;</code> <code>&#39;unshift&#39;</code> <code>&#39;join&#39;</code></li>
</ul>
</li>
<li><p>函数对象</p>
<ul>
<li>自身属性：<code>&#39;name&#39;</code> <code>&#39;length&#39;</code></li>
<li>共有属性：<code>&#39;call&#39;</code> <code>&#39;apply&#39;</code> <code>&#39;bind&#39;</code></li>
</ul>
</li>
</ul>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><blockquote>
<p><strong>Q: window 是谁构造出来的？</strong><br>A: 可以通过 constructor 属性看出构造者</p>
<p><strong>Q: window.Object 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的</p>
<p><strong>Q: window.Function 是谁构造的？</strong><br>A: window.Function，所有的函数都是 window.Function 构造的，浏览器构造了 Function，然后指定它的构造者是自己</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数据类型与运算符</title>
    <url>/hais-notebook/2020/01/29/JS-DataTypes-Operators/</url>
    <content><![CDATA[<p>JavaScript 有 7 种数据类型，3 种变量声明的方式，以及一些奇怪的运算符。</p>
<a id="more"></a>
<h1 id="字符存储"><a href="#字符存储" class="headerlink" title="字符存储"></a>字符存储</h1><ul>
<li>如何存数字？十进制转二进制，用十六进制（HEX）表示二进制</li>
<li>如何存字符？转换为数字，48 号表示 0，65 号表示 A，97 号表示 a</li>
<li>如何表示汉字（GB、GBK）？0000~FFFF，16 位，2 字节</li>
<li>Unicode 已收录 13 万字符（大于 16 位），全世界通用，以后还会继续扩充；缺点：两个字节不够用了，至少要三个字节</li>
<li>UTF-8：通过变长的存法，减小容量</li>
</ul>
<h1 id="7-种数据类型"><a href="#7-种数据类型" class="headerlink" title="7 种数据类型"></a>7 种数据类型</h1><blockquote>
<p>4 基 2 空 1 对象</p>
</blockquote>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote>
<p>64 位浮点数组成</p>
</blockquote>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p><code>0</code> <code>+0</code> <code>-0</code><br><code>Infinity</code> <code>+Infinity</code> (1/0) <code>-Infinity</code> (1/-0)<br><code>NaN</code>（0/0，但他还是一个数字，NaN不等于NaN）</p>
<h3 id="范围和精度"><a href="#范围和精度" class="headerlink" title="范围和精度"></a>范围和精度</h3><p><img src="https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JS-Number-Range.png" alt="JSNumber的存储"></p>
<p>范围：<code>Number.MAX_VALUE</code> 到 <code>Number.MIN_VALUE</code><br>精度：大概是 15 个十进制有效数字</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>每个字符两个字节（阉割版 UTF-8，两个字符定长）</p>
</blockquote>
<h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>单引号、双引号、反引号，引号不是字符串的一部分</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><code>\r</code> 表示回车， <code>\uFFFF</code> 表示对应的 Unicode 字符， <code>\xFF</code> 表示前256个 Unicode 字符</p>
<h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><p>字符串本来不应该有属性，只有对象才有属性，但是这个有渊源</p>
<ul>
<li>长度： <code>s.length</code></li>
<li>下标： <code>s[0]</code></li>
<li>base64 转码： <code>window.btoa</code> 编码， <code>window.atob</code> 反编码</li>
</ul>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><blockquote>
<p>否定运算、相等运算、比较运算可以得到 bool 值</p>
</blockquote>
<div class="note warning">
            <p><strong>5 个 falsy 值</strong><br><code>undefined</code> <code>null</code> <code>0</code> <code>NaN</code> <code>&#39;&#39;</code></p>
          </div>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><blockquote>
<p>每个 Symbol 都不一样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>如果声明了没有赋值，默认是 <code>undefined</code><br>如果函数没有写 <code>return</code>，默认是 <code>undefined</code></p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>习惯上把非对象空值写成 undefined，对象空值写成 null；<br>null 通常表示即该处不应该有值，undefined 通常表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><div class="note warning">
            <p>数组、函数、日期都是 Object，不是单独的数据类型，但是使用 <code>typeof</code> 的时候，可以分辨出 function</p>
          </div>
<h1 id="3-种变量声明的方式"><a href="#3-种变量声明的方式" class="headerlink" title="3 种变量声明的方式"></a>3 种变量声明的方式</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ul>
<li>过时的，不好的</li>
<li>函数作用域</li>
<li>可以重复声明</li>
<li>可以先使用再声明</li>
<li>全局声明的 <code>var</code> 变量会变成 <code>window</code> 的属性</li>
</ul>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul>
<li>新的，更合理的</li>
<li>遵循块作用域</li>
<li>不能重复声明</li>
<li>可以赋值，也可以不赋值</li>
<li>必须先声明再使用</li>
<li>全局声明的 <code>let</code> 变量不会再变成 <code>window</code> 的属性</li>
<li><code>let</code> 配合 <code>for</code> 循环有奇效</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>跟 <code>let</code> 几乎一样，但声明时必须赋值，且不能再更改</p>
<div class="note warning">
            <p>变量声明指定值的时候同时也指定了类型，但是 <strong>值和类型都可以随意变化</strong></p>
          </div>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a>Number</h3><ul>
<li>余数 <code>-x % 7</code> 为 <code>-(x % 7)</code></li>
<li>指数 <code>x ** 3</code></li>
<li>自增 <code>a++</code> 表达式的值是 <code>a</code> 加之前的值， <code>++a</code> 表达式的值是 <code>a</code> 加之后的值</li>
<li>求值运算符 <code>+</code>，附属运算符 <code>-</code></li>
</ul>
<h3 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h3><ul>
<li>连接运算 <code>+</code></li>
</ul>
<div class="note warning">
            <p><code>number + string</code>，变成字符串<br><code>string - number</code>，变成数字</p>
          </div>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><ul>
<li>模糊相等，发生自动类型转换，别用两个等于</li>
<li>JavaScript 三位一体</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title="==="></a>===</h3><p>全等，基本类型看值是否相等，对象看地址是否相等</p>
<ul>
<li><code>[] !== []</code></li>
<li><code>{} !== {}</code></li>
<li><code>NaN !== NaN</code></li>
</ul>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 防止 console.log 报错（防御性编程）</span></span><br><span class="line">a = a || <span class="number">100</span> <span class="comment">// 但是五个 falsy 值都会让 a 为假，因此有 bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用函数来赋初值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><h3 id="或与否"><a href="#或与否" class="headerlink" title="或与否"></a>或与否</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> | <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1111</span></span><br><span class="line">(<span class="number">0b1111</span> &amp; <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 1010</span></span><br><span class="line">(~<span class="number">0b1010</span>).toString <span class="comment">// 涉及到补码，留坑</span></span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b1111</span> ^ <span class="number">0b1010</span>).toString(<span class="number">2</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>按位取反可以用 <code>^1</code></p>
          </div>
<h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">(<span class="number">0b0010</span> &lt;&lt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h3 id="头部补零的右移运算符"><a href="#头部补零的右移运算符" class="headerlink" title="头部补零的右移运算符"></a>头部补零的右移运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0b0011</span> &gt;&gt;&gt; <span class="number">1</span>).toString(<span class="number">2</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="如何使用运算符判断奇偶？"><a href="#如何使用运算符判断奇偶？" class="headerlink" title="如何使用运算符判断奇偶？"></a>如何使用运算符判断奇偶？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">偶数 &amp; <span class="number">1</span> === <span class="number">0</span></span><br><span class="line">奇数 &amp; <span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-gt-gt-lt-lt-gt-gt-gt-来取整"><a href="#使用-gt-gt-lt-lt-gt-gt-gt-来取整" class="headerlink" title="使用 ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; | 来取整"></a>使用 <code>~</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> <code>|</code> 来取整</h3><blockquote>
<p>位运算不支持小数，会自动抹去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~ <span class="number">6.83</span> <span class="comment">// 6</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> | <span class="number">0</span></span><br><span class="line"><span class="number">6.83</span> &gt;&gt;&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-来交换-a-b-的值"><a href="#使用-来交换-a-b-的值" class="headerlink" title="使用 ^ 来交换 a b 的值"></a>使用 <code>^</code> 来交换 <code>a</code> <code>b</code> 的值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版语法</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符"></a>点运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 属性值</span><br></pre></td></tr></table></figure>
<p>如果不是对象，JS会创建一个对象，用完之后再自动删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.xxx = <span class="string">'harvey'</span> <span class="comment">// 'harvey'</span></span><br><span class="line">a.xxx <span class="comment">// undefiend</span></span><br></pre></td></tr></table></figure>
<h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h3><blockquote>
<p>求表达式的值或执行语句，然后 <code>void</code> 的值总为 <code>undefined</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 表达式或语句</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止假动作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"example.com"</span> <span class="attr">onclick</span>=<span class="string">"console.log(hi); return false;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(console.log('hi'))"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote>
<p>表示取后面的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// a 为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'hi'</span>); <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">x</span> =&gt;</span> (<span class="built_in">console</span>.log(<span class="string">'hi'</span>), x + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 跟上面是一样的，先执行 console.log，再让 return 为x + 1</span></span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>圆括号的优先级最高</p>
<h1 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h1><h2 id="typeof-instanceof-toString-的比较"><a href="#typeof-instanceof-toString-的比较" class="headerlink" title="typeof instanceof toString 的比较"></a><code>typeof</code> <code>instanceof</code> <code>toString</code> 的比较</h2><table>
  <tr>
    <td colspan="2">类型</td>
    <td>举例</td>
    <td colspan="2">typeof</td>
    <td colspan="2">instanceof</td>
    <td colspan="2">Object.prototype.toString.call()</td>
  </tr>
  <tr>
    <td rowspan="4">基本类型</td>
    <td>Number</td>
    <td>1</td>
    <td>number</td>
    <td>√</td>
    <td>false*</td>
    <td>○</td>
    <td>[object Number]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>String</td>
    <td>hello'</td>
    <td>string</td>
    <td>√</td>
    <td>false*</td>
    <td>○</td>
    <td>[object String]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Boolean</td>
    <td>true</td>
    <td>boolean</td>
    <td>√</td>
    <td>false*</td>
    <td>○</td>
    <td>[object Boolean]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Symbol / new Symbol()</td>
    <td>new Symbol()</td>
    <td>symbol</td>
    <td>√</td>
    <td>false*</td>
    <td>○</td>
    <td>[object Symbol]</td>
    <td>√</td>
  </tr>
  <tr>
    <td rowspan="3">new 基本类型</td>
    <td>new Number()</td>
    <td>new Number(1)</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object Number]**</td>
    <td>√</td>
  </tr>
  <tr>
    <td>new String()</td>
    <td>new String('hello')</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object String]**</td>
    <td>√</td>
  </tr>
  <tr>
    <td>new Boolean()</td>
    <td>new Boolean('false')</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object Boolean]**</td>
    <td>√</td>
  </tr>
  <tr>
    <td rowspan="2">空值</td>
    <td>null</td>
    <td>null</td>
    <td>object</td>
    <td>×</td>
    <td>false*</td>
    <td>○</td>
    <td>[object Null]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>undefined</td>
    <td>undefined</td>
    <td>undefined</td>
    <td>√</td>
    <td>false*</td>
    <td>○</td>
    <td>[object Undefined]</td>
    <td>√</td>
  </tr>
  <tr>
    <td rowspan="6">对象类型</td>
    <td>普通对象</td>
    <td>{a: '1', b: '2'}</td>
    <td>object</td>
    <td>√</td>
    <td>true</td>
    <td>√</td>
    <td>[object Object]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Array</td>
    <td>[1, 2, 3]</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object Array]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Function</td>
    <td>function() {}</td>
    <td>function</td>
    <td>√</td>
    <td>true</td>
    <td>√</td>
    <td>[object Function]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Error</td>
    <td>new Error()</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object Error]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>Date</td>
    <td>new Date()</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object Date]</td>
    <td>√</td>
  </tr>
  <tr>
    <td>RegExp</td>
    <td>new RegExp()</td>
    <td>object</td>
    <td>○</td>
    <td>true</td>
    <td>√</td>
    <td>[object RegExp]</td>
    <td>√</td>
  </tr>
</table>

<p>*尽管我们直接使用 <code>1 instanceof Number</code> 会出现错误，但是我们可以自定义 <code>instanceof</code> 方法，让他可以判断基本类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveNumber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> instance === <span class="string">'number'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> PrimitiveNumber <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>**基本类型与用 <code>new Constructor</code> 构造的用对象包裹的基本类型实际上是不一样的，特别是在 <code>Boolean</code> 上，这点需要注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boolean = <span class="literal">false</span></span><br><span class="line">!!boolean <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line">!!newBoolean <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="自己实现一个-instanceof"><a href="#自己实现一个-instanceof" class="headerlink" title="自己实现一个 instanceof"></a>自己实现一个 <code>instanceof</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left) <span class="comment">// 相当于 left.__proto__</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(proto === right.prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-is-和"><a href="#Object-is-和" class="headerlink" title="Object.is 和 ==="></a><code>Object.is</code> 和 <code>===</code></h2><p><code>Object.is</code> 修复了 <code>===</code> 的一些失误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// 修复 +0 和 -0 相等的问题</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 修复 NaN 和 NaN 不相等的问题</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 表达式与语句</title>
    <url>/hais-notebook/2020/01/29/JS-Expressions/</url>
    <content><![CDATA[<p>JavaScript 的表达式与语句，包括标识符、block 等概念。</p>
<a id="more"></a>
<h1 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h1><ul>
<li>表达式一般都有值，语句可能有也可能没有</li>
<li>语句一般会改变环境（声明、赋值），逗号表示语句没完</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>          <span class="comment">// 值为 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)      <span class="comment">// 值为函数的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log    <span class="comment">// 值为函数本身</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// 值为函数的返回值：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>retrun</code> 后面不能接回车，否则相当于返回 <code>undefined</code></p>
          </div>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 JavaScript 中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。（有时候也可以用其他的 Unicode 字符，比如中文，比如 Emoji）</p>
<h2 id="代码区块-block"><a href="#代码区块-block" class="headerlink" title="代码区块 block"></a>代码区块 block</h2><p>简单来说就是把代码用大括号包在一起</p>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>如果前面是 <strong>真的</strong>，就执行后面的（若前面是假的，表达式的值为前面；若前面是真的，表达式的值为后面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.f1 &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'f1 存在'</span>)</span><br><span class="line"><span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'hi'</span>) <span class="comment">// 因为 IE 没有 console.log，所以可以这样写防止出错</span></span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title="||"></a>||</h2><p>如果前面是 <strong>假的</strong>，就执行后面的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a || <span class="number">100</span> <span class="comment">// 可以用于设置保底值</span></span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 5 5 5 5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">a</span>:<span class="number">1</span> &#125; <span class="comment">// a 是一个 label，值是 1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 序章</title>
    <url>/hais-notebook/2020/01/29/JS-Overview/</url>
    <content><![CDATA[<p>JavaScript 的历史和评价的简单介绍。</p>
<a id="more"></a>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>1994 年，网景公司（当时叫 Mosaic Communications）发布了一款名为 <strong>Mosaic Netscape</strong> 的网页浏览器，在四个月内，这款浏览器就占据了四分之三的浏览器市场，并成为 1990 年代互联网的主要浏览器。</p>
<blockquote>
<p>因为世界最早流行的图形接口网页浏览器 <strong>NCSA Mosaic</strong> 是美国国家超级电脑应用中心（NCSA）与 1993 年发布的，网景公司为了避免版权纠纷，将浏览器改名为 <strong>Netscape Navigator</strong>，而公司则改名为 <strong>Netscape Communications</strong>。</p>
</blockquote>
<p>这款浏览器发布之后，网景意识到，<strong>光有静态的页面是不行的，需一种网页脚本语言，使得浏览器可以与网页互动。</strong></p>
<p>1995 年，昇阳（Sun）正式向市场推出 Java，网景公司看到 Java 的前景，决定与之结盟，并在浏览器中支持 Java，但如果直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂。</p>
<p>同年，网景招募了布兰登（Brendan Eich），授意其开发一款 <strong>“未来的脚本语言”</strong> ，这种语言需要：“看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手。”——这个决定就排除了 Perl、Python、Tcl 或 Scheme 这些选项，同时也促成了 JavaScript 的诞生。</p>
<p>由于对 Java 不感兴趣，布兰登只用了十天时间就设计出了这款语言的原型，并命名为 <strong>Mocha</strong>，后续又改名为 <strong>LiveScript</strong>，但在 1995 年 12 月，公司为了蹭 Java 的热度，改名为 <strong>JavaScript</strong>。而事实上，JavaScript 和 Java 关系并不大。</p>
<blockquote>
<p>总的来说，布兰登的设计思路是这样的：</p>
<ol>
<li>借鉴 C 的基本语法；</li>
<li>借鉴 Java 的数据类型和内存管理；</li>
<li>借鉴 Scheme，将函数提升到“第一等公民”（first class）的地位；</li>
<li>借鉴 Self，使用基于原型（prototype）的继承机制。</li>
</ol>
</blockquote>
<p>由于 JavaScript 在浏览器上的大获成功，微软（Microsoft）在后续推出的 IE 3 上也使用了 <strong>JScript</strong> ——这与 JavaScript 是类似、但不同标准的语言。于是当年市场上出现了两者对峙的情况，网页设计者通常会在主页放上“用 Netscape可达到最佳效果 ”或“用 IE 可达到最佳效果”的标志。</p>
<p>1996 年 11 月，网景正式向 <strong>欧洲计算机制造商协会（ECMA）</strong> 提交语言标准；1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。自然 JavaScript 也成为了 ECMAScript 最著名的实现之一。</p>
<p>由于只有短短十天的设计时间，而且世界上之前没有出现过结合了函数式编程和对象编程的语言，以及发展的迅速导致没有时间调整设计，JavaScript 成功成为了有着众多设计缺陷的语言，在这里不做细谈。</p>
<p>2001 年，微软发布 Windows XP，并捆绑了 IE 6。由于 Windows XP 迅速爆火以及长期的垄断，IE 6 也随之占据非常高的市场份额。前文已经说过，IE 6 对 JavaScript 支持并不好，同时 IE 6 对 CSS 标准的支持也不尽完善，导致前端技术的发展进入了漫长的蛰伏期。</p>
<p>2004 年，谷歌（Google）发布爆款应用 Gmail。这款应用在刚推出时，容量就比起其他受欢迎的电子邮箱服务如雅虎和微软的 Hotmail 多出过百倍，成为市场爆品，同时也让众多开发者看到了页面交互的巨大前景和可能性。</p>
<p>2005 年，Jesse 将谷歌用到的技术命名为 AJAX。</p>
<p>2006 年，至今为止最为长寿的 JavaScript 库—— jQuery，发布。</p>
<p>2008 年，谷歌发布 Chrome 浏览器；同年，Chrome 的使用率上升至 1%。其使用高性能 JavaScript 引擎 V8。</p>
<p>2009 年，Ryan 基于 V8 写了 Node.js。</p>
<p>2010 年，Isaac 基于 Node.js 写了 npm。</p>
<p>2010 年，TJ 受 Sinatra 启发，写了 Express.js。赶上了这几波顺风车的 JavaScript 迅速发展，并将触手伸向了后端。自此，JavaScript 也能胜任后端的一些工作了。</p>
<p>2012 年，Chrome 全球占有率达到 33%，超越 IE 跃居首位。</p>
<p>2015 年 12 月，Chrome 中国占有率达到 37%，超越 IE。</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><ul>
<li>JS 是历史的选择，最开始浏览器支持 Java、Flash、VBScript，只有 JS 活到了最后</li>
<li>JS 低开高走，一开始是一个玩具语言，但每次都走对了风口（ECMA 标准、Gmail、移动端、Node.js）</li>
<li>对于初学者，目前可以忽略与 IE 相关的知识</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>原生 JavaScript</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
</search>
