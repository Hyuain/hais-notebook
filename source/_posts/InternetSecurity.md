---
title: Internet Security
date: 2023-01-18 14:38:30
tags:
  - 计算机
categories:
  - [计算机]
---

Web 安全

# Web 安全概述

## Web 应用

- 由动态脚本、编译过的代码等组合而成
- 通常架设在 Web 服务器上，用户在 Web 浏览器上发送请求
- 这些请求使用 HTTP 协议，由 Web 应用和企业后台数据库及其他动态内容通信

## Web 应用三层架构

![Web 应用三层架构](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Web-Application.png)

## WASC 的定义

> WASC（Web Application Security Consortium）是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，负责为 WWW 指定广为接受的应用安全标准

WASC 将应用安全威胁分为六大类：

1. Authentication（验证）
2. Authorization（授权）
3. Client-Side Attacks（客户侧攻击）
4. Command Execution（命令执行）
5. Information Disclosure（信息暴露）
6. Logical Attacks（逻辑性攻击）

## OWASP 的定义

> OWASP（Open Web Application Security Project）致力于发现和解决不安全 Web 应用的根本原因

1. Injection（注入）
2. Broken Authentication（失效的身份认证）
3. Sensitive Data Exposure（敏感信息泄露）
4. XXE, XML External Entities（XML 外部实体）
5. Broken Access Control（失效的访问控制）
6. Security Misconfiguration（安全配置错误）
7. XSS, Cross-Site Scripting（跨站脚本）
8. Insecure Deserialization（不安全的反序列化）
9. Using Components with Known Vulnerabilities（使用含有已知漏洞的组件）
10. Insufficient Logging & Monitoring（不足的日志记录和监控）

# 验证机制安全

## 什么是验证机制

- 验证机制是 Web 应用中最简单的一种安全机制。一般来说，应用程序 **必须用户提交的用户名和密码，判断是否允许登录**
- 验证机制是应用程序防御恶意攻击的 **核心机制**，处于安全防御的最前沿，如果缺乏安全有效的验证机制，其他核心安全机制（会话管理和访问控制）都无法实施

![典型的用户登陆流程](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/Login-Process.webp)

有这样几种常用的验证技术：

- 基于 HTML 表单的验证
- 多元机制
- 客户端 SSL 证书

## 验证机制存在的安全隐患

### 弱密码

许多 Web 应用程序没有或很少对用户密码强度进行控制：

- 非常短或空白密码
- 以常用字典词汇为密码
- 密码与用户名完全相同
- 长时间使用默认密码

### 暴力破解

登陆功能的公开性会诱使攻击者视图猜测用户名和密码，有诸如 Burp Suite 等工具提供了一些常用的字典

为了防止暴力破解，可以使用验证码，而验证码也需要注意几个问题：

- 验证码是否真实有效
- 验证码的复杂度
- 应对当前诸如 OCR、打码等技术

也可以设置 Cookie 和会话检测，增加失败计数器，当然 Cookie 在客户端可以随意修改

此外现在常用双因子认证（你知道的 + 你拥有的）

### 忘记密码

包括问题的答案、邮箱、手机验证码用明文或简单的 MD5 加密等

### 多阶登录机制

多次验证检查可能会提高登录机制的安全性，但在这个过程中可能也存在更多的执行缺陷：

- 可能会认为到达第三阶段的用户已经通过了第一二阶段
- 可能认为每个阶段用户的身份不会变化
- 有些问题的细节或答案没有保存在服务器上，而是放在隐藏的 HTML 字段中

# 会话管理

## 什么是会话管理

- 会话管理在用户通过请求提交他们的证书后，**持续** 向应用程序保证用户身份的真实性
- 由于会话管理机制发挥关键作用，且比较难以发现其漏洞，因此成为针对应用程序的恶意攻击的主要目标，攻击者若能破坏应用程序的会话管理，就能轻易避开验证机制

## 会话管理的安全隐患

### 会话令牌生成漏洞

通过简单的用户名、电子邮件经过简单的编码、加密生成的，不安全

#### 令牌可预测

令牌有一定的模式和规则、时间依赖

#### 随机数强度不足

计算机中的数据极少完全随机，一般通过软件使用各种技巧生成伪随机数

### 会话传输漏洞

尽可能缩短一个会话的寿命可以降低攻击者截获、猜测或滥用有效会话的风险

#### 会话终止攻击

有一些应用程序没有有效的会话终止功能，他的有效期非常长

有些时候，退出功能并不能帮助服务器终止会话，比如只是简单地删除客户端的 Cookie，我们需要让服务端的会话失效

#### 会话劫持攻击

攻击者通过网络嗅探、XSS 攻击等方式截获令牌

## 会话管理漏洞的防御

- **令牌传输过程**：令牌只能通过 HTTPS 传送，让浏览器不能通过 HTTP 传送令牌
- **增加软硬会话过期**
  - 软会话过期：一定时间没有交互之后，Session 失效
  - 应会话过期：经过一定时间之后，不管用户做什么，会话都会过期
- **提供完善的注销功能**

# SQL 注入攻击

Web 程序经常会建立用户提交数据的 SQL 语句，但如果建立 SQL 语句的方法不安全，则容易造成 SQL 注入漏洞

## SQL 注入危害

- **探知数据库的具体结构**，为进一步攻击做准备
- **泄露数据**，尤其是机密信息、账户信息等
- **获得更高权限**，来修改数据甚至是内部结构

## SQL 注入防御

- **参数化查询**：最根本性的防御
  - 指定查询结构，用户输入预留占位符
  - 指定占位符的内容

# XSS 跨站脚本攻击

攻击者通常通过注入 HTML 或 JS 脚本发动攻击，攻击成功后，攻击者可以得到私密网页内容和 Cookie 等

## XSS 攻击危害

- **盗号**
- **控制数据**，读取、篡改、添加、删除敏感数据
- **非法转账**
- **网站挂马**
- **控制肉鸡**

## XSS 攻击分类

### 反射式 XSS 攻击

又称非永久性 XSS，是目前最流行的 XSS 攻击

出现在服务器直接使用客户端提交的数据，比如 URL 数据、HTML 表单等，并且没有对数据进行无害化处理，这些数据中藏着一些可执行脚本，最常见的方式就是恶意连接，其中包含了 XSS 攻击脚本

### 存储式 XSS 攻击

又称永久性 XSS，危害更大

攻击者将脚本上传到 Web 服务器上，使得所有访问该页面的用户都面临信息泄露的可能

多发生在个人信息字段、文档或上传的文件及其他数据的名称、提交给应用程序管理员的反馈或问题、向其他用户传送的信息、在用户之间共享的上传文件内容

### 基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击仅仅通过 JavaScript 执行，常发生在应用程序每次返回相同的静态 HTML，而客户端 JavaScript 动态生成信息，并不会跟服务端交互获取的时候

## XSS 攻击载荷

- **会话令牌**：XSS 攻击最普遍的方式，截取受害者的会话令牌，劫持他的会话
- **虚拟置换**：向 Web 应用程序页面注入恶意数据（修改页面），没有修改保存在服务器上保存的内容，而是通过程序处理来显示置换
- **注入木马**：比如突然弹出一个对话框（木马登录表单），诱导你输入用户密码

## XSS 防御措施

- **输入验证**
  - 数据不是太长
  - 数据仅包含合法字符
  - 数据与正则表达式匹配
  - 对不同的数据类型（比如账号、邮箱等）设置不同的规则
- **输出编码**
  - 对数据进行 HTML 编码，使用 HTML 实体代替字面量字符，净化可能的恶意字符

# CSRF 跨站请求伪造

典型的流程如下：

1. 受害者登录 `a.com`，并且保留了登录凭证（Cookie）
2. 攻击者诱使受害者访问 `hack.com`
3. `hack.com` 向 `a.com` 发送请求：`a.com/act=xx` 浏览器默认会携带上 `a.com` 的 `Cookie`
4. `a.com` 收到请求后，确认是受害者的凭证，误认为是受害者自己发送的请求
5. `a.com` 以受害者的名义执行了 `act=x`

## 几种常见的攻击类型

### GET 类型的 CSRF

这个类型非常简单，一般只需要一个 HTTP 请求：

```html
<img src="http://bank.example/withraw?amount=10000&for=hacker">
```

在受害者访问有这个 img 的页面之后，浏览器会自动向 `http://bank.example/withraw?amount=10000&for=hacker` 发送请求

### POST 类型的 CSRF

这类攻击通常是使用一个自动提交的表单：

```html
<form action="http://bank.example/withdraw" method="POST">
  <input type="hidden" name="account" value="xiaoming">
  <input type="hidden" name="amount" value="10000">
  <input type="hidden" name="for" value="hacker">
</form>
<script>
  document.forms[0].submit()
</script>
```

### 链接类型的 CSRF

需要用户点击链接才会触发：

```html
<a href="http://bank.example/withraw?amount=10000&for=hacker" target="_blank">
重磅消息！！
</a>
```

## CSRF 的特点

- 攻击一般发起在 **第三方网站**，而不是被攻击的网站（通常是 **跨域** 的），因此被攻击的网站无法防止攻击的发生
- 攻击者利用受害者的登陆凭证，而不是直接盗取数据
- 攻击者仅仅是 **利用** 受害者的登录凭证，而 **不能获取** 到这个凭证
- 跨站请求可以用各种方式：图片、超链接、CORS、Form 表单等，部分请求可以直接嵌入第三方论坛、文章中，难以进行追踪
- 通常是跨域的，但有时候也可以在 **本域** 进行，比如在论坛和评论区可以发图和连接，这种攻击更加危险

## CSRF 防御措施

针对 CSRF 通常是跨域请求，并且攻击者只是冒用、而无法真正获得 Cookie 的特点，可以采取以下策略：

- **阻止不明外域的访问**
  - 同源检测
  - Samesite Cookie
- **提交时要求附加本域才能获得的信息**
  - CSRF Token
  - 双重 Cookie 验证

### 同源检测

可以通过 **Origin Header** 和 **Referer Header** 来判断请求是否来自外域

对于 Origin 有两个问题：

- IE 11 不会在 CORS 请求上添加 Origin 标头
- 302 重定向之后，Origin 不再包含在重定向之后的请求中

对于 Referer 也有问题：

- 每个浏览器对于 Referer 的实现可能有差别，不能保证浏览器自身没有安全漏洞
- 攻击请求可能隐藏 Referer

当 Origin 和 Referer 都不存在的时候，建议直接阻止访问

，同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这有时候也有问题，比如搜索引擎来的请求也会被当做疑似 CSRF 攻击，并且安全性并不是很高

### CSRF Token

1. **将 CSRF Token 输出到页面中**，用户打开页面时，需要给用户生成一个 Token，可以将这个 Token 保存在 Session 中，同时给页面上所有的 a 标签 和 form 标签后面加入这个 Token
2. **页面提交的请求携带这个 Token**
3. **服务器验证 Token 是否正确**

### 分布式校验

使用一种计算出来的结果而不是随机生成的字符串作为 Token，这样在校验的时候就无需读取存储的 Token，只需要再计算一次即可

### 双重 Cookie 验证

因为攻击者实际上无法知道 Cookie 里面的内容，所以只需要让 AJAX 和表单请求中携带一个 Cookie 中的值，后端接口验证 Cookie 中的字段与请求参数中的字段是否相同，这样可以减小后端服务器 Session 存储的压力

但是也有一些问题：

1. 如果用户访问 `www.a.com`，后端域名为 `api.a.com`，那么在 `www.a.com` 下就拿不到 `api.a.com` 的 Cookie
2. 于是这个认证必须种在 `a.com` 下
3. 于是任意子域名都可以修改 `a.com` 下的 Cookie
4. 如果某个子域名存在漏洞被 XSS 攻击，那么攻击者就可以修改 `a.com` 下的 Cookie
5. 攻击者就可以使用自己配置的 Cookie，对用户在 `www.a.com` 下发起 CSRF 攻击

### Samesite Cookie

Google 起草了一份草案来改进 HTTP 协议，就是为 `Set-Cookie` 响应头增加 `Samesite` 属性，表明这个 Cookie 是个 **同站 Cookie**