---
title: Operating System
date: 2023-01-18 21:37:30
categories:
  - [计算机]
---

.

<!-- more -->

# Introduction

# Process & Thread

## Process

> **进程（Process）** 是 **程序**（比如 exe）的执行实例。**程序** 在CPU上执行的活动叫做 **进程**。

一个进程可以创建另一个进程（父进程与子进程）。

### Pseudoparallelism

**伪并行（Pseudoparallelism）**：单核 CPU 在一个时刻，只能做一件事情，为了让用户在同一时刻可以做多件事，就需要在不同进程中快速切换。这样多个程序在宏观上并行，微观上串行。多个进程之间会出现抢资源（比如打印机就很明显）的现象。

### Process Model

在进程模型中，所有计算机上运行的软件（包括操作系统）被组织为 **顺序进程（Sequential Processes）**，也简称为 **进程（Process）**。

一个进程就是一个执行程序的实例，此外进程还包括程序计数器、寄存器和变量的当前值。

多个进程独立运行，有各自的逻辑程序计数器，和共用的一个物理程序计数器。当程序需要运行的时候，他的逻辑程序计数器就会装载到物理程序计数器上。

### Creation of Process

#### System Initialization

启动操作系统时会创建一些进程，包括 **前台进程（Numerous Processes）** 和 **守护进程（Daemons）**。在 UNIX 中，使用 `ps` 可以看到真该运行的进程。

#### System Call

正在运行的程序会发出 **系统调用（System Calls）**来创建一个或多个新进程来辅助完成工作。

#### User Request

用户可以通过命令、鼠标或其他交互方式创建新进程并与之进行交互。

#### Batch Processing

用户在大型机的批处理系统中提交批处理作业，当操作系统确定他有资源来运行另一个任务时，他将创建一个新进程运行下一个作业。

### End of Process

#### Exit

进程完成工作后正常终止，编译器会执行一个系统调用来告诉操作系统他完成了工作。比如 UNIX 中的 `exit` 和 Windows 中的 `ExitProcess`。

很多程序会提供一个按钮供用户点击，从而通知进程删除他打开的所有临时文件，然后退出。

#### Exception

发生了意料之内的错误，比如执行了命令 `cc foo.c`，但文件 foo.c 并不存在，此时应用程序通常会给出错误信息，并询问是重试还是退出。

#### Error

进程引起的错误，通常是程序错误导致的，比如执行了非法指令、引用不存在的内存、除以零等。有时候在这类错误中，进程会收到中断信号，并不会直接终止进程。

#### Killed

某个进程执行系统调用，让操作系统杀掉其他进程，比如 UNIX 中的 `kill`。

### Hierarchy of Process

在有的操作系统中，进程可以通过创建其他进程来形成父子层次结构关系。

#### UNIX

UNIX 中进程和他的所有子孙进程组成一个进程组。比如当用户键盘发出信号后，该信号会被发送给当前与键盘相关的进程组中的每一个成员，他们可以根据需求做出不同的响应。

比如：

- UNIX 在启动的时候会有一个初始化进程 init。

- 当他开始运行时，他会读取一个文件，文件会告诉他有多少个终端，然后为每个终端创建一个新进程。
- 用户成功登录某个终端后，该登录进程就会执行一个 shell 来等待用户输入指令，这些指令可能会启动更多的进程。

#### Windows

Windows 中没有进程层次的概念，里面的所有进程都是平等的。不过父进程在创建子进程的时候会得到一个令牌（句柄），可以用来控制子进程，该句柄是可以传递给别的进程的。

### Process Status

- **运行态**：实际占用 CPU 时间片。
- **就绪态**：可运行的状态，等待其他进程运行完成后获取 CPU 资源。就绪态和运行态之间的切换是有操作系统的进程调度程序来进行的，他会决定哪个进程优先被运行、运行多久。
- **阻塞态**：除非某种外部事件发生，比如有的进程在等待 I/O 完成（比如文件读取），如果这时候即使把 CPU 分配给他，他也不会使用 CPU，而是继续等 I/O。如果 I/O 完成事件发生，则会转变为运行态或就绪态。

### Process Table

操作系统会维护一张进程表（Process Table）来进行进程间的切换。

每个进程都在其中占据一个进程表项，该表项会记录程序计数器、堆栈指针、内存分配情况、打开文件状态、账号和调度信息等。

## Thread

早期的面向进程设计的操作系统中，进程是程序的基本执行实体。现在的面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。

- 多线程之间共用同一块地址空间和数据，多进程之间则不行；
- 线程比进程更加轻量级，创建一个线程比创建一个进程块 10 ~ 100 倍。

### Classical Thread Model

**进程存放程序正文、数据、打开的文件、子进程、定时器、信号处理程序、账号信息等资源，是资源分配的基本实体。**

**线程有程序计数器、寄存器、堆栈，作为 CPU 上调度执行的基本实体。**

同一个进程中的所有线程都会有完全一样的地址空间，同样的全局变量，他甚至可以读取、写入和擦除另一个线程的堆栈。

进程通常会从当前的某个单线程开始，调用某个库函数，比如 `thread_create` 来创建新进程。

线程工作完成后可以调用 `thread_exit` 之类的库函数来退出。

某些线程可以在运行过程中调用 `thread_join` 来等待另一个线程退出。

线程与进程不同，他不能利用时钟中断强制让出 CPU，但可以调用 `thread_yield` 来自动放弃 CPU 来让其他线程运行。

### POSIX

POSIX 线程通常也被称为 pthreads，是一种通用的线程标准，一种独立于语言的执行模型，以及并行执行模型。每个工作流程被称为一个线程，可以通过 POSIX Threads API 来实现对这些流程的创建和控制，比如上面提到的 `thread_create` `thread_exit` 等。

###

### 概念

- CPU 调度和执行的最小单元
- 一个进程中可以有一个或多个线程
- 一个进程中的线程共享该进程的所有资源
- 进程的第一个线程叫做初始化线程
- 线程的调度可以由操作系统负责，也可以由用户自己负责

# Deadlock

死锁是指两个或从多个进程在执行的过程中，因为争抢资源而造成的一种僵局。

想象这样一个场景：一个进程正在持有某些资源而不释放他们，并且正在等待释放其他资源，而这些其他资源也在被其他进程持有并且不释放。这就导致了一个僵局，其中进程相互等待彼此持有的资源，而没有谁能够继续执行。

可以想象两个人坐在餐桌上，每个人都有一个叉子，但需要两个叉子才能吃饭。他们都不愿意放下自己的叉子去拿另一个叉子，因为他们担心另一个人会拿走它。所以，他们只是坐在那里，互相等待，没有人吃饭，这就是死锁的情况。

## Resouce

我们把需要排他性使用的对象称为 **资源（Resource）**，同一时刻一个资源只能由一个进程使用，就像打印机，同一时间打印机只能打印一份东西。

资源可以进一步分为：

- **可抢占资源（Preemtable Resource）**，可以从拥有它的进程中抢占过来而不会造成其他影响，比如内存。
- **不可抢占资源（Nonpreemptable Resource）**，进程无法抢占指定资源，否则会引起错误或异常，比如光盘。

死锁通常与不可抢占资源有关，因为可抢占资源造成的死锁可以通过强行抢占资源来简单化解。

