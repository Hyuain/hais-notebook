---
title: 读书笔记：《计算机科学精粹》
date: 2021-05-09 19:48:23
tags:
  - 读书笔记
categories:
  - [读书笔记, 计算机]
mathjax: true
---

有幸得贵人赠书《计算机科学精粹》，将纸质版读书笔记提炼誊抄至此。

<!-- more -->

# 第一章：预备知识

## 逻辑

### 运算符

> 我们称 `->` 为条件运算符，可读作「若……，则……」

一个示例：

```text
A: 泳池暖和
B: 我去游泳
A -> B: 如果泳池暖和，我就去游泳
```

#### 换质位法

指的是这两句话含义相同（即逆否命题与原命题含义相同）：

```text
A -> B: 如果泳池暖和，我就去游泳
!B -> !A: 如果我不去游泳，那么泳池就不暖和
```

{% note warning %}
`A -> B` 和 `B -> A` 含义并不相同！
{% endnote %}

#### 双条件

若要使 `A -> B` 和 `B -> A` 都成立，则需要使用双条件：

```text
A <-> B: 当且仅当泳池暖和，我才去游泳
```

### 布尔代数

#### 结合律

```text
A and ( B and C ) = ( A and B ) and C
A or ( B or C ) = ( A or B ) or C
```

#### 分配律

```text
A and ( B or C ) = ( A and B ) or ( A and C )
A or ( B and C ) = ( A or B ) and ( A or C )
```

#### 德摩根定律

```text
!( A and B ) = !A or !B
!( A or B ) = !A and !B 
```

## 计数

### 乘法

两个不相关事件的可能性用乘法计算：

$$
{m}\cdot{n}
$$

### 排列

n 个项的排列方式种数：

$$
n!
$$

n 个元素中选 m 个排成一列：

$$
A_{n}^{m} = \frac{n!}{(n-m)!}
$$

n 个元素中，r 个相同排成一列：

$$
\frac{n!}{r!}
$$

### 组合

n 个不同元素，选 m 个并成一组（与顺序无关）：

$$
\tbinom{n}{m} = C_{n}^{m} = \frac{n!}{m!(n-m)!}
$$

### 概率

- 独立事件：两个事件的结果不会相互影响，概率相乘
- 互斥事件：两个事件结果不能同时发生，概率相加
- 对立事件：两个互斥事件概率涵盖所有可能的结果，概率之和为 1

# 第二章：复杂度

## 时间复杂度的计算

例：选择排序

```javascript
function selectionSort(list) {
  // 外层循环执行 n-1 次，每次执行赋值、交换两项操作，共 2n-2 次
  for (current = 1 ... list.length - 1) {
    smallest = current
    // 内层循环执行 n-1（外层第一次）、n-2（外层第二次）、n-3 次，共计 (n*n-n)/2 次赋值与交换操作，也就是 n*n-n 次操作 
    for (i = current + 1 ... list.length) {
      if (list[i] < list[current]) {
        smallest = i
      }
    }
    list.swap_items(current, smallest)
  }
}
```

因此上述选择排序算法总计进行了 $T(n) = n^2 + n - 2$ 次操作

## 大 O 符号

表示最坏情况下算法成本函数的主项，比如选择排序的时间复杂度可记为 $O(n^2)$

## 空间复杂度的计算

比如对于选择排序，只需要一组固定的变量作为存储空间，因此空间复杂度可以记为 $O(1)$

# 第三章：策略

本章主要讲解这几种策略：

- 通过 **迭代** 处理 *重复性* 任务
- 通过 **递归** 进行优雅地 *迭代*
- 资源允许时使用 **蛮力法**
- 测试不可行的选择并 **回溯**
- 采用 **启发法** 合理缩短求解的时间
- 采用 **分治法** 求解难题
- **动态地** 识别重复问题，避免浪费资源
- 对问题 **定界** 缩小求解范围

## 迭代

```text
     ┌──────┐循环(每一步操作就被称为迭代)
     │      │                           满足条件 
  求解过程 ────────────────────────────────────────────> 目标
     ↑      │
     └──────┘
```

例：合并两个排好序的数组

比如将 `[1, 3, 5, 7]` 与 `[2, 4, 6, 8]` 合并为 `[1, 2, 3, 4, 5, 6, 7, 8]`

```javascript
function merge(list1, list2) {
  result = []
  while (list1.has_item || list2.has_item) {
    if (list1.top_item > list2.top_item) {
      temp = list1.remove_top_item
    } else {
      temp = list2.remove_top_item
    }
    result.push(fish)
  }
  return result
}
```

例：嵌套循环与幂集

> 对于给定对象 S 的集合，其幂集是 S 的全部子集构成的集合

比如有几种花，花可以调配香水，我们需要求出能调配的所有可能的香水。

使用迭代的思维：

- 若没有花，一种无味的香水，记做0
- 若有一种花：0、A
- 若有两种花：0、A、0+B、A+B
- 若有三种花：0、A、0+B、A+B、0+C、A+C、0+B+C、A+B+C

不难发现，多加一种花，就是把之前的复制一遍，再给复制之后的每种香水加上新的花。

```javascript
function powerSet(flowers) {
  fragrances = Set.new
  fragrances.add(Set.new)
  for (flower in flowers) {
    // 复制已有的香水
    new_fragrances = copy(fragrances)
    for (fragrance in new_fragrances) {
      // 给复制之后的香水加上新的花
      fragrance.add(flower)
    }
    fragrances = fragrances + new_fragrances
  }
  return fragrances
}
```

这种构建幂集的方式时间复杂度为 $O(n^2)$，每增加一次循环，时间将会增加一倍。这种方法也可以用于构建真值表，每种花是否加入用布尔值进行表示。

## 递归

> 函数自己调用自己

例：判断回文字符串

```javascript
function isPalindrome(word) {
  if (word.length <= 1) return true
  if (word.first_char != word.last_char) return false
  w = word.remove_first_and_last_char
  return isPalindrome(w)
}
```

递归与迭代：递归算法通常更短，但由于其执行时大量调用自身，从而引入计算开销。

```text
迭代：
START => 1 => 2 => 3 => END

递归：
START => 1 => 2 => 3
                   ↓
  END <= 1 <= 2 <= 3
```

## 蛮力法（穷举法）

有时候，蛮力法的时间复杂度很高（$O(n^2)$），比如最佳交易日问题；有时候他的时间复杂度也并不会是最差的，比如对于 NP 完全问题（背包问题，对其求幂集，然后进行逐行检查）。

> 对于 NP 完全问题，只有指数算法才能解决这个问题。

## 回溯法

例：八皇后问题。在棋盘上放置八个后，如何才能让他们不相互攻击？

核心：仅搜索 **可行的** 位置，比如：第一个可随意摆放，第二个不能与第一个相互攻击，……这种情况下可能摆不满八个就不能继续摆了，这时就需要 **回溯**。

```javascript
function queens() {
  if (board.has_8_queens) return board
  for (position in board.unattacked_positions) {
    board.place_queen(position)
    solution = queens(board)
    if (solution) return solution
    board.remove_queen(position)
  }
  return false
}
```

## 启发法

> 依靠直觉找出一种够好的方法

### 贪心法

一种常用的启发法。他：

1. 永远不会回退到之前的选择
2. 尝试在每一步都做出最佳选择
3. 无后效性

例：邪恶背包问题。小偷不会计算出最佳的装背包方法。他会不断地将最值钱的东西放入背包，直到背包塞满。

```javascript
function greedy_knapsack(items, max_weight) {
  bag_weight = 0
  bag_items = List.new
  for (item in sort_by_value(items)) {
    if (max_weight >= bag_weight + item.weight) {
      bag_weight += item.weight
      bag_items.append(item)
    }
  }
  return bag_items
}
```

### 利用贪心法解决电网问题

贪心法有时也能获得最优解：

例：如何使用最短的输电线将所有的定居点接入电网？

1. 从尚未连入电网的定居点中，选择与已有电力供应的定居点最近的，连接他们
2. 重复，直到左右的定居点都连入电网

## 分治法

> 将问题分解为若干个小问题

### 归并排序

```javascript
function merge_sort(list) {
  if (list.length == 1) return list
  left = list.left_half
  right = list.right_half
  return merge(merge_sort(left), merge_sort(right))
}
```

### 最佳交易日问题

例：给出一段时间内的每日金价，找出一个买入日期、一个卖出日期，达到利润最大化。

思路：将时间一分为二，分别找出前半段和后半段的最佳交易。整个时间段的最佳交易日则可能是：

1. 前半段买入并卖出
2. 后半段买入并卖出
3. 前半段买入后半段卖出

前两个情况就是两个子问题，第三种情况则是在前半段的最低价买入，后半段的最高价卖出。
递归的终点就是当天买入当天卖出，收益为0。

```javascript
function trade(prices) {
  if (prices.length == 1) return 0
  former = prices.first_half
  later = prices.last_half
  case3 = max(later) - min(former)
  return max(trade(former), trade(later), case3)
}
```

### 背包问题

我们将第 $i$ 件物品的重量记为 $w_i$，价值记为 $v_i$。将选择的物品数量记为 $n$，背包容量记为 $c$，背包的总价值记为 $K(n,c)$。

当考察到第 $n$ 件物品的时候（$K(n,c)$），有两种情况：

1. $K(n-1,c)$：不拿第 $n$ 件物品，留给之前 $n-1$ 次选择的容量仍然为 $c$
2. $K(n-1,c-w_n)+v_n$：拿第 $n$ 件物品，留给之前 $n-1$ 次选择的容量就要减去第 $n$ 次的重量

因此我们得到这样的递归公式：

$$
K(n,c)=max(K(n-1,c),K(n-1,c-w_n)+v_n)
$$

## 动态规划

> 找出重复的子问题，对每个重复的子问题只计算一次

### 利用记忆化求解斐波那契数

这是一个普通的斐波那契数计算函数，可以看出他对很多数进行了重复计算：

```javascript
function fib(n) {
  if (n <= 2) return n
  return fib(n - 1) + fib(n - 2)
}
```

我们可以将每次计算的结果存起来，这种 **记忆化** 的技巧可以提高 fib 算法的性能：

```javascript
M = { 1: 1, 2: 2 }
function dfib(n) {
  if (n not in M) {
    M[n] = dfib(n - 1) + dfib(n - 2)
  }
  return M[n]
}
```

### 利用记忆化求解背包问题

不难发现，在用分治法求解背包问题的时候，也会有很多重复的计算，可以用类似的方法将计算结果记下来，提升性能。

### 利用自底向上法求解最佳交易问题

用分治法求最佳交易日的递归中，不存在重复调用，**但存在重复计算**——算法不断地在将数据一分为二后求最大值和最小值（比如我们需要找出房间里最高的人、最高的男人和最高的女人，我们不需要先测量所有人的身高找出最高的人，再测量所有的男人以找到最高的男人，再测量所有的女人以找到最高的女人）。

我们之前使用的都是 **自顶向下** 法来解决问题，这种方法中，输入不断减小，直到到达基线条件。我们也可以采用 **自底向上** 法：首先计算基线条件，然后不断组合，直到得到通解（感觉有点像数学归纳法）。

假设第 $n$ 天的金价为 $P(n)$，且在第 $n$ 天卖出是的买入最佳交易日为 $B(n)$。

- $B(1)$：在第一天卖出只能在第一天买入，因此 $B(1) = 1$
- $B(2)$：如果在第二天卖出，可以在第一天买入，也可以在第一天卖出
  - 若 $P(2) < P(1)$，则在第二天买入，$B(2) = 2$
  - 若 $P(2) \ge P(1)$，则在第一天买入，$B(2) = 1$
- $B(3)$：如果在第三天卖出，可以在第三天买入，也可以在前两天的最佳交易日买入
  - 若 $P(3) < P(B(2))$，则在第三天买入，$B(3) = 3$
  - 若 $P(3) \ge P(B(2))$，则在前两天的最佳交易日买入，$B(3) = B(2)$
- ……

由此可以得到：

$$
B(n) =
\begin{cases}
n, & P(n) < P(B(n-1)) \\
B(n-1), & P(n) \ge P(B(n-1))
\end{cases}
$$

然后我们就可以求得所有的 $B$，从而求得对应的利润：

```javascript
function trade_dp(P) {
  B[1] = 1
  sell_day = 1
  best_profit = 0
  for (n = 2; n <= P.length; i++) {
    B[n] = P[n] < P[B[n - 1]] ? n : B[n - 1]
    profit = P[n] - P[B[n]]
    if (profit > best_profit) {
      sell_day = n
      best_profit = profit
    }
  }
  return { sell_day, buy_day: B[sell_day], best_profit }
}
```

`trade_dp` 算法对输入列表的每个元素执行一组固定的简单操作，因此时间复杂度为 $O(n)$，比之前讨论的 $O(n \cdot log n)$ 算法有很大的提升。但由于辅助向量 $B$ 的元素数量与输入一样多，因此它的空间复杂度是 $O(n)$。

## 分支定界法

> 有助于预测最佳差的路径，避免在这些路径上浪费时间

### 上界与下界

比如在之前讨论的邪恶背包问题中，`greedy_knapsack` 算法给出了最优利润的下界，这个下界可能接近（也可能不接近）最优利润。

现在来看另一种形式的背包问题，所有的物品均为粉末，我们可以将物品的一部分放入背包。我们同样可以用贪心法求解，始终将最优性价比的物品放入背包：

```javascript
function powdered_knapsack(items, max_weight) {
  bag_weight = 0
  bag_items = List.new
  items = sort_by_value_weight_ratio(items)
  for (item in items) {
    // 有可能这件物品总重量比剩下的容量大
    weight = min(max_weight - bag_weight, item.weight)
    bag_weight = bag_weight + weight
    value = weight * item.value_weight_ratio
    bagged_value = bagged_value + value
    bag_items.append(item, weight)
  }
  return bag_items, bag_value
}
```

`powdered_knapsack` 算法实际上给出了不可分割物品版本最优利润的上界。

### 背包问题的上界与下界

> 看书 P56 的图解比较舒服

如果要求出解背包问题最优解，时间复杂度为 $O(2^n)$。但我们利用 `greedy_knapsack` 和 `powdered_knapsack` 可以很快速地求出背包问题最优利润的下界和上界。

假设我们有 ABCDE 五件物品，容量为 10 的背包。我们求出他的上界和下界。 然后用类似于分治法的思维往下分解，考虑放入 E 和不放入 E 的两种场景。最终我们发现上界和下界收束了。

1. 将问题分解为若干子问题
2. 找出子问题的上界和下界
3. 比较所有分支的界限
4. 对最可行的子问题重复第 1 步

# 第四章：数据

- **过程抽象**：将复杂的过程隐藏在调用的后面，使得算法更加简单
- **数据抽象**：隐藏数据处理过程的细节
- **抽象数据模型**：可以用抽象数据模型来讨论问题，在代码中也应该使用抽象数据模型封装好的接口，这样当底层的数据结构发生改变的时候也不用改变程序中的其他代码
  - 常见的抽象数据模型：栈、队列、优先队列、列表、排序列表、映射、集合
- **数据结构**：抽象数据模型的底层具体实现

| 数据结构 | 优点 | 缺点 | 适用的抽象数据模型 |
| --- | --- | --- | --- |
| 数组 | 易于编写，可以立即访问到任何元素 | 内存中需要大量分配连续空间，删除或添加中间元素比较麻烦 | 栈、列表、队列 |
| 链表 | 每个单元可以保存在内存的任何位置，可以很容易地增删元素 | 无法立即检索到某个元素，没有其他信息的情况下无法获取到前一个单元的地址 | 栈、列表、队列 |
| 双向链表 | 在链表的基础上可以向两个方向移动 | 无法立即检索到某个元素，两个指针增加代码复杂性，需要更多内存 | 栈、列表、队列 |
| 树 | 与链表类似 |  | 文件目录结构等有层次关系的数据 |
| 二叉查找树 | 查找速度很快 | | 映射、集合 |
| 二叉堆 | 可以立即检索到最大（或最小）的元素 | | 优先队列 |
| 图 | 非常灵活 | | 几乎可以表示任何类型的数据、人际关系 |
| 散列表 | 查找元素的时间复杂度为 $O(1)$，且比树插入删除更快 | 需要预先分配大量连续内存，空间不足时散列冲突会显著影响性能 |  映射、集合 |


## 抽象数据类型

**抽象数据类型（ADT）** 是一组有意义的操作规范，ADT 定义的接口用于处理保存给定类型数据的变量。

## 常见抽象

### 基本数据类型

编程语言内置的数据类型，无需调用外部模块即可使用。总是包括整数、浮点数，以及对他们的简单操作等。

### 栈

> 后进先出（LIFO）。用于处理一堆元素，并且只对栈顶的元素进行操作。

- `push(e)`：将元素 `e` 添加到栈顶
- `pop()`：检索并删除栈顶元素

比如文本编辑器为了实现撤销功能，可以用栈。

### 队列

> 先进先出（FIFO）。检索到的元素总是最先加入的元素。

- `enqueue(e)`：将元素 `e` 添加到队列后端
- `dequeue()`：删除并返回队列最前端的元素

### 优先队列

> 队列的基础上，增加了 **优先级**，比如排队就诊的队列中，重病急诊患者优先级最高。

- `enqueue(e, p)`：根据优先级 `p` 将元素 `e` 添加到队列
- `dequeue()`：删除并返回队列最前端的元素

### 列表

> 不受限制地将元素重新排序，或者对任意位置的元素进行访问、插入、删除。

- `insert(n, e)`：将元素 `e` 插入到位置 `n`
- `remove(n)`：删除位置 `n` 的元素
- `get(n)`：获取位置 `n` 的元素
- `sort()`：将列表中的元素排序
- `slice(start, end)`：返回从位置 `start` 到 `end` 的字列表
- `reverse()`：反转列表的顺序

### 排序列表

> 一个始终保持排序状态的列表。

- `insert(e)`：将元素 `e` 插入到正确的位置
- `remove(n)`：删除位置 `n` 的元素
- `get(n)` 获取位置 `n` 的元素

### 映射

> 即字典。用来存储 **键** 和 **值** 之间的映射关系。可以通过键来查询映射，并获取到对应的值。

- `set(key, value)`：添加键值映射
- `delete(key)`：删除 `key` 及其关联的值
- `get(key)`：获取 `key` 关联的值

### 集合

> 若干 **唯一** 元素的 **无序** 集合。

- `add(e)`：添加元素
- `list()`：列出集合中的元素
- `delete(e)`：删除集合中的元素 `e`

## 数据结构

- 描述了数据在计算机内存中的组织与访问方式
- 提供了在数据处理模块中实现 ADT 的方法

### 数组

> 计算机在内存中分配连续的存储空间，然后按顺序将元素写入该空间，并用特殊的 `NULL` 令牌标记序列的结束

假设数组从地址 $s$ 开始存储，每个元素的长度为 $b$ 字节，那么如果需要访问第 $n$ 个元素，则只需要从地址 $s+(b·n)$ 开始取出 $b$ 字节即可

因此我们可以 **立即** 访问到任何元素

数组可以用来实现栈、列表、队列，易于编写且可以即时访问，但也存在缺点：

- 内存中大量分配连续空间不太现实，如果要对数组进行扩展，内存中可能没有足够的连续可用空间
- 删除中间元素需要将之后所有的元素前移，添加中间元素需要将之后的所有元素后移

### 链表

> 每个单元包含一个指针，指向下一个单元的地址，包含空指针的单元标记了链的结束

列表可以很容易地增删元素，并且每个单元可以保存在内存的任何位置

可以利用链表实现栈、列表、队列

列表的不足之处：

- 无法立即检索到第 $n$ 个元素
- 在没有其他信息的情况下，无法获取到链中前一个单元的地址，于是没办法删除这个单元

### 双向链表

> 每个单元包含两个指针，分别指向签一个单元和后一个单元

即便只给出一个单元的地址，也可以删除这个单元，但仍然无法立即访问第 $n$ 个元素

### 树

> 每个单元中包含着指向其他单元的指针，但这些单元及其指针并不是像链表一样线性排列，而是呈树状结构

特别适合保存文件目录结构、军队的命令链等具有层次关系的数据

- **结点**：每个单元称为一个结点
- **边**：从一个单元指向另一个单元的指针
- **根节点**：位于树顶端的结点，他是唯一没有 **父结点** 的结点。除了根结点外，每个结点都 **有且仅有** 一个父结点
- **兄弟节点**：具有相同父结点的两个结点
- **叶结点**：没有任何子结点的结点
- **路径**：两个结点之间的路径是从一个结点到另一个结点的 **一组结点与边**
- **层次**：结点的层次是该结点与根节点的路径长度
- **高度**：树中最深结点的高度
- **森林**：树的集合

### 二叉查找树

> 一种能实现高效搜索的特殊树结构

树中的结点最多可以有两个子结点，根据结点的键值对确定其位置。父结点左侧的子结点必须小于父结点，右侧的子结点必须大于父结点。

我们可以很容易在这种特殊的树上搜索具有给定键值对的某个结点：

```javascript
function find_node(binary_tree, value) {
  node = binary_tree.root_node
  while (node) {
    if (node.value == value) { return node }
    node = value > node.value ? node.right : node.left
  }
  return "NOT FOUND"
}
```

插入元素时，我们需要在树中搜索这个值。采用搜索中探索的最后一个节点，并使其的左指针或右指针指向新节点：

```javascript
function insert_node(binary_tree, new_node) {
  node = binary_tree.root_node
  while (node) {
    last_node = node
    node = new_node.value > node.value ? node.right : node.left
  }
  if (new_node.value > last_node.value) {
    last_node.right = new_node
  } else {
    last_node.left = new_node
  }
}
```

#### 树的平衡

有时候二叉树会变得很高（比如我们一直插入大于前一个结点的键值对时，我们可能会得到类似链表的结构），这是就需要通过 **树的平衡** 来得到尽可能矮的树。

因为树的大部分操作都涉及跟踪结点之间的链接，当树特别高的时候，结点之间的平均路径就会变长，需要访问内存的次数就会变多。

我们可以这样构建一棵完美平衡的二叉查找树：

```javascript
function build_balanced(nodes) {
  if (nodes.is_empty) { return null }
  middle = nodes.length / 2
  left = nodes.slice(0, middle - 1)
  right = nodes.slice(middle + 1, nodes.length)
  balanced = BinaryTree.new({ root: nodes[middle] })
  balanced.left = build_balanced(left)
  balanced.right = build_balanced(right)
  return balanced 
}
```

树的平衡成本很高，因此需要权衡平衡的时机。

- 一个由 $n$ 个结点构成的二叉查找树，他的最大高度是 $n$（类似一个链表），完美平衡时的最小高度为 $log_2 n$
- 搜索一个元素的复杂度与树的高度成正比，最坏情况下需要搜索到最低的叶节点
- 搜索 $n$ 个元素的平衡二叉树，时间复杂度为 $O(log n)$
- 因此我们经常选择这种结构来实现集合、映射

为了有效处理变化很大的二叉树，人们发明了 **自平衡二叉树**，他会在插入或删除的时候保持平衡的状态，比如红黑树、AVL树、B树等。

### 二叉堆

> 二叉堆是一种特殊的二叉查找树，可以立即检索到最大（或最小）的元素，在实现优先队列中非常有用

父结点的左侧的子结点小于右侧的子结点，且父结点必须大于（或小于）他的两个子结点。

由于最大（或最小）元素始终是树的根节点，查找最大（或最小）元素时的时间复杂度为 $O(1)$；搜索或插入节点的时间复杂度依然为 $O(log n)$

### 图

> 图与树类似，但图没有子结点、父结点、根节点，任何节点可以有多个入边或出边

图是最灵活的数据结构，几乎可以表示任何类型的数据

### 散列表

> 散列表查找元素的时间复杂度为 $O(1)$

散列表与数组类似，需要预先分配大块连续存储空间，但散列表中的元素并非存储在有序序列中，而是由 **散列函数** 确定位置。

- **散列函数**：输入一个需要存储的元素，输出一个随机生成的数字，作为存储元素的位置（地址）。通过该地址就可以实现对元素的即时检索
- **散列冲突**：对于两个不同的输入，散列函数有时候会返回相同的存储地址，冲突发生时，两个元素必须保存在相同的地址（比如使用从这个地址开始的链表）。为了减少散列冲突，应确保散列表中至少存在50%的可用空间，否则可能由于过于频繁的冲突降低散列表的性能

散列表常用于实现映射和集合。他比树有更高的插入、删除速度，但需要大量连续的内存才能正常工作

# 第五章：算法

## 排序

### 选择排序

> 在 i ... list.length 的中找到最小的，放到 i 的位置

选择排序的时间复杂度为 $O(n^2)$，人们常用这种算法来排序扑克牌

### 插入排序

> 将第 i 项插入之前已经排好序的列表中

插入排序也是一种具有二次成本的算法，但他在排序几乎已经排序的数组时非常有效

```javascript
function insertion_sort(list) {
  for (i = 1 ... list.length) {
    j = i
    while (j.notNull && list[j - 1] > list) {
      list.swap_items(j, j - 1)
      j = j - 1
    }
  }
}
```

### 归并排序

> 将数据分成两份，对其分别进行排序，再合并，时间复杂度为 $O(n log n)$

### 快速排序

> 随机选一个基准；将大于他的放在右边，小于他的放在左边；然后对左右分别继续操作；再合并左、基准、右

```javascript
function quickSort(list) {
  if (list.length < 2) { return list }
  if (list.lenght == 2) { return list[0] > list[1] ? list.swap(0, 1) : list }
  pivotIndex = list.length / 2
  left = list.slice(0, pivotIndex)
  right = list.slice(pivotIndex, list.length)
  return merge(quickSort(left), list[pivotIndex], quickSort(right))
}
```

## 搜索

选择好的数据结构，比如二分查找树、散列表等，可以大幅提高查找效率

### 顺序搜索

> 最简单的搜索，从头开始找，时间复杂度为 $O(n)$

### 二分查找

> 元素位于排序数组中可以用二分查找，时间复杂度为 $O(n)$

```javascript
function binarySearch(items, key) {
  if (items.isNull) { return null }
  i = items.length / 2
  if (key == items[i]) { return i }
  sliced = key > items[i]
    ? items.slice(i + 1, items.length)
    : items.slice(0, i)
  return binarySearch(sliced, key)
}
```

## 图

### 图的搜索

#### 深度优先搜索（DFS）

> 沿着图的边逐渐深入，达到某个与任何新结点都没有边相连的结点时，就返回前一个结点继续这个过程

- 借助栈来跟踪搜索路径：将探索的结点压入栈中，需要返回时弹出来
- 回溯策略就是利用这种方式搜索

```javascript
function DFS(startNode, key) {
  nextNodes = Stack.new()
  // 由于是图，没有父子关系，我们需要记住访问过哪些了
  seenNodes = Set.new()
  
  nextNodes.push(startNode)
  seenNodes.add(startNode)
  
  while (nextNodes.notEmpty) {
    node = nextNodes.pop()
    if (node.key == key) { return node }
    for (n in node.connectedNodes) {
      if (!seenNodes.has(n)) {
        nextNodes.push(n)
        seenNodes.add(n)
      }
    }
  }
  
  return null
}
```

#### 广度优先搜索（BFS）

> 逐层对图进行探索

- 用队列跟踪访问的结点：完成探索后，我们将它的子结点插入队列，然后取出下一个结点进行探索

```javascript
function BFS(startNode, key) {
  nextNodes = Queue.new()
  // 由于是图，没有父子关系，我们需要记住访问过哪些了
  seenNodes = Set.new()
  
  nextNodes.enqueue(startNode)
  seenNodes.add(startNode)
  
  while (!nextNodes.isEmpty(nextNodes)) {
    node = nextNodes.dequeue()
    if (node.key == key) { return node }
    for (n in node.connectedNodes) {
      if (!seenNodes.has(node)) {
        nextNodes.enqueue(n)
        seenNodes.add(n)
      }
    }
  }
  
  return null
}
```

#### 如何选择

{% note warning %}
DFS 和 BFS 其实只在跟踪结点的存储方式上有所不同：DFS 使用栈，而 BFS 使用队列。
{% endnote %}

- DFS 只需要存储“从哪个节点来”，BFS 则需要存储整个搜索的边界，当数据量十分庞大的时候，BFS 会消耗过多的内存
- 如果正在搜索的结点距离起始点不太远，选择成本较高的 BFS 就比较划算，因为能更快地找到指定节点
- 如果需要探索图的全部节点，最好使用 DFS，因为易于实现且内存占用更少

### 图着色

抽象模型：给固定数量的“颜色”，必须为图中的每个结点分配一种颜色，且通过边相连的结点不能共享同一种颜色。

例：给一张基站及其小区的地图，位于相邻小区的基站必须工作在不同频率以避免干扰，且有四种频率可供选择，那么应该为每个基站分配哪种频率？

> 书中没有给出解，感觉可以尝试使用回溯法解决，跟八皇后问题有点像

### 寻路

可以使用 BFS 或 DFS 策略找出较短的路径，但不如用 **戴克斯特拉算法**。

- 使用优先队列跟踪探索过程：完成新结点的探索之后，将结点之间的连接添加进优先队列，结点的优先级是连接该节点与起始节点的边的权重
- 负权重的路径可能会导致负循环——这会使得算法陷入无限循环
- 如果搜索的图过于庞大，可以考虑使用 **双向搜索**，即：两个搜索进程从起始点和目标点同时进行，如果一个搜索区域中的任意节点出现在了另一个搜索区域中，就说明找到了符合条件的路径。

### PageRank

分析网页并呈现最相关的给用户。可以将万维网建模为一张图，其中的结点表示网页，边表示网页之间的链接。

- 如果一个网页包括许多来自其他重要页面的链接，那么这个网页也很重要
- 初始阶段，图中的网页具有相同的“分值”
- 每轮计算完成后，每个页面将各自的分值分发给与之链接的页面
- 重复进行，直到分值达到稳定分布，每个页面的稳定分值叫做 PageRank，使用 PageRank 来确定网页的重要性

## 运筹学

> 做出最佳决策，更好地管理人力与资源，涉及 **最大化** 或 **最小化** 目标

- 航空公司用运筹学优化航班时刻表
- 炼油厂找出原料的最佳配比
- 用运筹学调度劳动力和设备

### 线性最优化问题

> 能用线性方程对问题的目标与约束条件进行建模的问题

例：文件柜采购。

- 文件柜 X 的价格为 10 元，占地 6 平米，能存放 8 立方米的文件；
- 文件柜 Y 的价格为 20 元，占地 8 平米，能存放 12 立方米的文件；
- 预算为 140 元，可用面积为 72 平米，如何采购才能放最多的文件？

设 $x$ 和 $y$ 分别表示两种文件柜的数量，$z$ 为总容量，有：

$$
z = 8x + 12y
$$

现在我们要让 $z$ 最大，同时有这些约束条件：

- 预算约束：$10x + 20y \leq 140$
- 面积约束：$6x + 8y \leq 72$
- 其他约束：$x \geq 0$，$y \geq 0$

可以在坐标轴中将约束方程画出来，得到约束区域，然后从中找出 $z$ 最大的点即可。

这被称为 **单纯形法**，可以用单纯形法求解器得到解。

### 网络流问题

例：补给网络。连接各个城市的铁路构成了铁路网，每条铁路有最大运力，求从一个给定的生产城市每天可以运送多少物资到一个给定的消费城市。

- 每条铁路用一个变量来表示，表示通过这条铁路运送的物资量
- 所有铁路不能超过其运力
- 除了生产和消费城市以外，所有城市的流入量与流出量相等

# 第六章：数据库

**数据库管理系统（DBMS）** 是用于管理数据库的一种特殊软件，他负责数据的组织和与存储。

## 关系型数据库

关系型数据库可以很容易地避免信息重复与数据不一致的问题，是目前使用最广泛的数据库系统。

- 在关系模型中，数据被划分为不同的 **表**
- **行** 代表数据条目
- **列** 是数据条目具有的不同属性
- 通常会为列指定可以容纳的数据类型，也可以指定其他条件，比如必须、唯一
- 通常将列称为 **字段**，比如仅能存储整数的列称为 **整数字段**
- 字段与限制的组合称为表的 **模式**
- 违反表的模式的行将无法进入数据库系统，这是关系型数据库的优点，也是他的局限性所在

### 关系

> 通过将不同的表中数据关联起来，避免一个表中的数据重复

为了支持关系的使用，每张表都有一个特殊的标识字段（ID），用于引用表中特定的行，每行的 ID 都是唯一的。

- 主键：表的 ID 字段
- 外键：记录其他航 ID 的引用的字段

- 规范化的：一个数据库以完全不存在重复信息的方式进行组织
- 规范化：将包含重复数据的数据库转换为不包含重复数据的过程

### 模式迁移

> 模式迁移脚本可以帮助我们升级模式并转换现有数据，这些脚本通常还具备撤销更改的功能

### SQL

> 一种语句，描述了需要检索的数据

```sql
SELECT DISTINCT customers.name, customers.phone
FROM customers
JOIN orders ON orders.customer = customers.id
WHERE orders.amount > 100.00
```

### 索引

> 为了能通过给定 ID 快速检索到数据条目，DBMS 构建了一个辅助**索引**，用来将 ID 映射到在内存中的地址

索引实际上是一种自平衡二叉查找树，表中每一行对应着树中的每一个结点。结点的键是索引字段中的值（比如 ID）。

通常 DBMS 为数据库的每一个主键都建立一个索引。如果经常需要通过搜索其他字段来查找寄存器（比如通过姓名搜索客户），可以指示 DBMS 为这些字段建立额外的索引。

- **唯一性约束**。具有唯一性约束的字段通常会自动建立索引。因为在插入新的行的时候，我们需要快速检查这个字段是否重复，因此需要为其建立索引。
- **排序**。在建立索引的字段中，索引有助于以排序顺序获取行。比如如果以“姓名”字段作为索引，那么无需额外的计算就能够按姓名对行进行排序。当需要对两个字段进行排序时，可以使用 **联合索引** 对多个字段进行索引。
- **性能**。由于在表中插入或删除一个寄存器时，必须更新表的全部索引，如果表的索引很多，更新、插入、删除的计算开销就会变大（树的平衡）。此外，索引会占用磁盘空间。

### 事务

> 以**原子方式**执行数据库操作的列表。即在一步之内执行完毕，不会出现只执行一半的情况。

```sql
START TRANSACTION;
UPDATE value SET balance = balance + 50 WHERE id=2;
UPDATE value SET balance = balance - 50 WHERE id=1;
COMMIT;
```

## 非关系数据库

关系数据库的局限性：

- 随着程序越来越复杂，会有越来越多的表
- 查询会变得越来越大，越来越难理解
- `JOIN` 操作会逐渐增多，增加计算成本

> **非关系模型** 抛弃了表格关系，几乎不需要合并来自多个数据条目的信息，使用不同于 SQL 的查询语言，也被成为 **NoSQL 数据库**

### 文档存储

> 数据条目完全按应用程序所需要的方式保存

文档存储中不存在“表”和“行”，数据条目称为 **文档**，相关文档被分组在 **集合** 中。

文档包括一个主键，但一般不会使用 `JOIN` 操作来跟踪跨文档的关系。如果多个文档需要共享相关数据，那么应该将数据复制到文档中。

### 键值对存储

> 在有组织且持久的数据存储方式中，**简直对存储** 是最简单的形式，主要在缓存中使用（特别是需要频繁访问缓存时）

### 图数据库

> 将数据条目存储为结点，关系存储为边

图数据库是最灵活的数据库类型，没有表和集合，以最直观的方式存储网络化数据。如果数据结构类似某种网络、存在大量重要的关系时，可以使用图数据库。

图数据库还可以实现不同类型的面向图的查询，比如将公交数据存在图中，就能直接查询两个给定公交车站之间的最佳直达路线。

### SQL 与 NoSQL 的比较

- 关系数据库：能最大限度利用数据结构并消除重复
- 非关系数据库：以应用程序为中心，便于根据用户的需求进行访问和使用。能快速有效存储大量易失性的非结构化数据，不必担心固定模式与模式迁移；但用户需要负责更新跨文档与集合的重复信息，并采取措施保证数据的一致性

## 分布式数据库

比如在这些场景中，DBMS 运行在多台协同工作的计算机中，构成一个分布式数据库系统：

- 超级大容量的数据
- 并发数超级高的数据
- 任务关键型数据

### 单主机复制

- 以一台计算机作为主机
- 主机与多台从机相连，每台都有一份数据库的副本
- 主机响应外界的读写查询，并转发给从机，使各个从机保持同步

因此，可以处理更多的读查询、可靠性也提高了

### 多主机复制

- 集群中的所有计算机都成为主机
- 负载均衡设备将传入的读写查询分给集群中的计算机
- 每台计算机都有一份完整的数据库副本

因此，可以处理更多的并发写查询

### 分片

- 如果数据库收到大量写查询，很难让所有主机中的数据库保持同步，因为某些计算机可能空间不够
- 于是将数据库切分到各个计算机中
- 查询路由器将读写查询分发到对应分片的计算机
- 可以将分片与复制结合起来使用，降低单点故障的风险

### 数据一致性

- 可以使用一些数据库提供的工具来缓解数据不一致的问题，但这会降低数据库系统的性能
- 需要在一致性与性能之间作出权衡
- 如果数据库查询并非严格执行一致性，则可以认为他们追求**最终一致性**，即保证数据在一段时间后能**最终** 达到一致性

## 地理数据库

许多通用的 DBMS 都支持 GIS（地理信息系统）扩展，应当使用提供 GIS支持的数据库引擎来处理地理数据

## 序列化格式

- **SQL（结构化查询语言）**
  - 序列化关系数据库时最常见的格式
  - 通过编写 SQL 命令来复制数据库及其细节
  - 大部分关系型数据库系统提供“转储”和“恢复”命令，前者用于创建数据库的 SQL 序列化文件，后者用于将这类“转储”文件加载回数据库系统
- **XML（可扩展标记语言）**
  - 另一种表示结构化数据的方式 
  - 但不依赖于关系模型或某种数据库的实现
- **JSON（JavaScript 对象表示法）**
  - 大部分人认可的序列化格式
  - JSON 还有其他衍生格式：BSON（二进制 JSON）可以大幅提高 JSON 的数据处理效率；JSON-LD（关联数据的 JSON）则将 XML 结构的强大功能引入 JSON
- **CSV（逗号分隔值）**
  - 数据交换的最简单形式
  - 数据以文本形式存储，每行包含一个元素，元素属性通过逗号隔开
  - 有助于实现简单的数据转储，但不适合表示复杂的数据