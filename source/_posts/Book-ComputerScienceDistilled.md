---                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
title: 读书笔记：《计算机科学精粹》
date: 2021-05-09 19:48:23
tags:
  - 读书笔记
categories:
  - [读书笔记, 计算机]
mathjax: true
---          

有幸得贵人赠书《计算机科学精粹》，将纸质版读书笔记提炼誊抄至此。

<!-- more -->

# 第一章：预备知识

## 逻辑

### 运算符

> 我们称 `->` 为条件运算符，可读作「若……，则……」

一个示例：

```text
A: 泳池暖和
B: 我去游泳
A -> B: 如果泳池暖和，我就去游泳
```

#### 换质位法

指的是这两句话含义相同（即逆否命题与原命题含义相同）：

```text
A -> B: 如果泳池暖和，我就去游泳
!B -> !A: 如果我不去游泳，那么泳池就不暖和
```

{% note warning %}
`A -> B` 和 `B -> A` 含义并不相同！
{% endnote %}

#### 双条件

若要使 `A -> B` 和 `B -> A` 都成立，则需要使用双条件：

```text
A <-> B: 当且仅当泳池暖和，我才去游泳
```

### 布尔代数

#### 结合律

```text
A and ( B and C ) = ( A and B ) and C
A or ( B or C ) = ( A or B ) or C
```

#### 分配律

```text
A and ( B or C ) = ( A and B ) or ( A and C )
A or ( B and C ) = ( A or B ) and ( A or C )
```

#### 德摩根定律

```text
!( A and B ) = !A or !B
!( A or B ) = !A and !B 
```

## 计数

### 乘法

两个不相关事件的可能性用乘法计算：

$$
{m}\cdot{n}
$$

### 排列

n 个项的排列方式种数：

$$
n!
$$

n 个元素中选 m 个排成一列：

$$
A_{n}^{m} = \frac{n!}{(n-m)!}
$$

n 个元素中，r 个相同排成一列：

$$
\frac{n!}{r!}
$$

### 组合

n 个不同元素，选 m 个并成一组（与顺序无关）：

$$
\tbinom{n}{m} = C_{n}^{m} = \frac{n!}{m!(n-m)!}
$$

### 概率

- 独立事件：两个事件的结果不会相互影响，概率相乘
- 互斥事件：两个事件结果不能同时发生，概率相加
- 对立事件：两个互斥事件概率涵盖所有可能的结果，概率之和为 1

# 第二章：复杂度

## 时间复杂度的计算

例：选择排序

```javascript
function selectionSort(list) {
  // 外层循环执行 n-1 次，每次执行赋值、交换两项操作，共 2n-2 次
  for (current = 1 ... list.length - 1) {
    smallest = current
    // 内层循环执行 n-1（外层第一次）、n-2（外层第二次）、n-3 次，共计 (n*n-n)/2 次赋值与交换操作，也就是 n*n-n 次操作 
    for (i = current + 1 ... list.length) {
      if (list[i] < list[current]) {
        smallest = i
      }
    }
    list.swap_items(current, smallest)
  }
}
```

因此上述选择排序算法总计进行了 $T(n) = n^2 + n - 2$ 次操作

## 大 O 符号

表示最坏情况下算法成本函数的主项，比如选择排序的时间复杂度可记为 $O(n^2)$

## 空间复杂度的计算

比如对于选择排序，只需要一组固定的变量作为存储空间，因此空间复杂度可以记为 $O(1)$

# 第三章：策略

本章主要讲解这几种策略：

- 通过 **迭代** 处理 *重复性* 任务
- 通过 **递归** 进行优雅地 *迭代*
- 资源允许时使用 **蛮力法**
- 测试不可行的选择并 **回溯**
- 采用 **启发法** 合理缩短求解的时间
- 采用 **分治法** 求解难题
- **动态地** 识别重复问题，避免浪费资源
- 对问题 **定界** 缩小求解范围

## 迭代

```text
     ┌──────┐循环(每一步操作就被称为迭代)
     │      │                           满足条件 
  求解过程 ────────────────────────────────────────────> 目标
     ↑      │
     └──────┘
```

例：合并两个排好序的数组

比如将 `[1, 3, 5, 7]` 与 `[2, 4, 6, 8]` 合并为 `[1, 2, 3, 4, 5, 6, 7, 8]`

```javascript
function merge(list1, list2) {
  result = []
  while (list1.has_item || list2.has_item) {
    if (list1.top_item > list2.top_item) {
      temp = list1.remove_top_item
    } else {
      temp = list2.remove_top_item
    }
    result.push(fish)
  }
  return result
}
```

例：嵌套循环与幂集

> 对于给定对象 S 的集合，其幂集是 S 的全部子集构成的集合

比如有几种花，花可以调配香水，我们需要求出能调配的所有可能的香水。

使用迭代的思维：

- 若没有花，一种无味的香水，记做0
- 若有一种花：0、A
- 若有两种花：0、A、0+B、A+B
- 若有三种花：0、A、0+B、A+B、0+C、A+C、0+B+C、A+B+C

不难发现，多加一种花，就是把之前的复制一遍，再给复制之后的每种香水加上新的花。

```javascript
function powerSet(flowers) {
  fragrances = Set.new
  fragrances.add(Set.new)
  for (flower in flowers) {
    // 复制已有的香水
    new_fragrances = copy(fragrances)
    for (fragrance in new_fragrances) {
      // 给复制之后的香水加上新的花
      fragrance.add(flower)
    }
    fragrances = fragrances + new_fragrances
  }
  return fragrances
}
```

这种构建幂集的方式时间复杂度为 $O(n^2)$，每增加一次循环，时间将会增加一倍。这种方法也可以用于构建真值表，每种花是否加入用布尔值进行表示。

## 递归

> 函数自己调用自己

例：判断回文字符串

```javascript
function isPalindrome(word) {
  if (word.length <= 1) return true
  if (word.first_char != word.last_char) return false
  w = word.remove_first_and_last_char
  return isPalindrome(w)
}
```

递归与迭代：递归算法通常更短，但由于其执行时大量调用自身，从而引入计算开销。

```text
迭代：
START => 1 => 2 => 3 => END

递归：
START => 1 => 2 => 3
                   ↓
  END <= 1 <= 2 <= 3
```

## 蛮力法（穷举法）

有时候，蛮力法的时间复杂度很高（$O(n^2)$），比如最佳交易日问题；有时候他的时间复杂度也并不会是最差的，比如对于 NP 完全问题（背包问题，对其求幂集，然后进行逐行检查）。

> 对于 NP 完全问题，只有指数算法才能解决这个问题。

## 回溯法

例：八皇后问题。在棋盘上放置八个后，如何才能让他们不相互攻击？

核心：仅搜索 **可行的** 位置，比如：第一个可随意摆放，第二个不能与第一个相互攻击，……这种情况下可能摆不满八个就不能继续摆了，这时就需要 **回溯**。

```javascript
function queens() {
  if (board.has_8_queens) return board
  for (position in board.unattacked_positions) {
    board.place_queen(position)
    solution = queens(board)
    if (solution) return solution
    board.remove_queen(position)
  }
  return false
}
```

## 启发法

> 依靠直觉找出一种够好的方法

### 贪心法

一种常用的启发法。他：

1. 永远不会回退到之前的选择
2. 尝试在每一步都做出最佳选择
3. 无后效性

例：邪恶背包问题。小偷不会计算出最佳的装背包方法。他会不断地将最值钱的东西放入背包，直到背包塞满。

```javascript
function greedy_knapsack(items, max_weight) {
  bag_weight = 0
  bag_items = List.new
  for (item in sort_by_value(items)) {
    if (max_weight >= bag_weight + item.weight) {
      bag_weight += item.weight
      bag_items.append(item)
    }
  }
  return bag_items
}
```

### 利用贪心法解决电网问题

贪心法有时也能获得最优解：

例：如何使用最短的输电线将所有的定居点接入电网？

1. 从尚未连入电网的定居点中，选择与已有电力供应的定居点最近的，连接他们
2. 重复，直到左右的定居点都连入电网

## 分治法

> 将问题分解为若干个小问题

### 归并排序

```javascript
function merge_sort(list) {
  if (list.length == 1) return list
  left = list.left_half
  right = list.right_half
  return merge(merge_sort(left), merge_sort(right))
}
```

### 最佳交易日问题

例：给出一段时间内的每日金价，找出一个买入日期、一个卖出日期，达到利润最大化。

思路：将时间一分为二，分别找出前半段和后半段的最佳交易。整个时间段的最佳交易日则可能是：

1. 前半段买入并卖出
2. 后半段买入并卖出
3. 前半段买入后半段卖出

前两个情况就是两个子问题，第三种情况则是在前半段的最低价买入，后半段的最高价卖出。
递归的终点就是当天买入当天卖出，收益为0。

```javascript
function trade(prices) {
  if (prices.length == 1) return 0
  former = prices.first_half
  later = prices.last_half
  case3 = max(later) - min(former)
  return max(trade(former), trade(later), case3)
}
```

### 背包问题

我们将第 $i$ 件物品的重量记为 $w_i$，价值记为 $v_i$。将选择的物品数量记为 $n$，背包容量记为 $c$，背包的总价值记为 $K(n,c)$。

当考察到第 $n$ 件物品的时候（$K(n,c)$），有两种情况：

1. $K(n-1,c)$：不拿第 $n$ 件物品，留给之前 $n-1$ 次选择的容量仍然为 $c$
2. $K(n-1,c-w_n)+v_n$：拿第 $n$ 件物品，留给之前 $n-1$ 次选择的容量就要减去第 $n$ 次的重量

因此我们得到这样的递归公式：

$$
K(n,c)=max(K(n-1,c),K(n-1,c-w_n)+v_n)
$$

## 动态规划

> 找出重复的子问题，对每个重复的子问题只计算一次

### 利用记忆化求解斐波那契数

这是一个普通的斐波那契数计算函数，可以看出他对很多数进行了重复计算：

```javascript
function fib(n) {
  if (n <= 2) return n
  return fib(n - 1) + fib(n - 2)
}
```

我们可以将每次计算的结果存起来，这种 **记忆化** 的技巧可以提高 fib 算法的性能：

```javascript
M = { 1: 1, 2: 2 }
function dfib(n) {
  if (n not in M) {
    M[n] = dfib(n - 1) + dfib(n - 2)
  }
  return M[n]
}
```

### 利用记忆化求解背包问题

不难发现，在用分治法求解背包问题的时候，也会有很多重复的计算，可以用类似的方法将计算结果记下来，提升性能。

### 利用自底向上法求解最佳交易问题

用分治法求最佳交易日的递归中，不存在重复调用，**但存在重复计算**——算法不断地在将数据一分为二后求最大值和最小值（比如我们需要找出房间里最高的人、最高的男人和最高的女人，我们不需要先测量所有人的身高找出最高的人，再测量所有的男人以找到最高的男人，再测量所有的女人以找到最高的女人）。

我们之前使用的都是 **自顶向下** 法来解决问题，这种方法中，输入不断减小，直到到达基线条件。我们也可以采用 **自底向上** 法：首先计算基线条件，然后不断组合，直到得到通解（感觉有点像数学归纳法）。

假设第 $n$ 天的金价为 $P(n)$，且在第 $n$ 天卖出是的买入最佳交易日为 $B(n)$。

- $B(1)$：在第一天卖出只能在第一天买入，因此 $B(1) = 1$
- $B(2)$：如果在第二天卖出，可以在第一天买入，也可以在第一天卖出
  - 若 $P(2) < P(1)$，则在第二天买入，$B(2) = 2$
  - 若 $P(2) \ge P(1)$，则在第一天买入，$B(2) = 1$
- $B(3)$：如果在第三天卖出，可以在第三天买入，也可以在前两天的最佳交易日买入
  - 若 $P(3) < P(B(2))$，则在第三天买入，$B(3) = 3$
  - 若 $P(3) \ge P(B(2))$，则在前两天的最佳交易日买入，$B(3) = B(2)$
- ……

由此可以得到：

$$
B(n) =
\begin{cases}
n, & P(n) < P(B(n-1)) \\
B(n-1), & P(n) \ge P(B(n-1))
\end{cases}
$$

然后我们就可以求得所有的 $B$，从而求得对应的利润：

```javascript
function trade_dp(P) {
  B[1] = 1
  sell_day = 1
  best_profit = 0
  for (n = 2; n <= P.length; i++) {
    B[n] = P[n] < P[B[n - 1]] ? n : B[n - 1]
    profit = P[n] - P[B[n]]
    if (profit > best_profit) {
      sell_day = n
      best_profit = profit
    }
  }
  return { sell_day, buy_day: B[sell_day], best_profit }
}
```

`trade_dp` 算法对输入列表的每个元素执行一组固定的简单操作，因此时间复杂度为 $O(n)$，比之前讨论的 $O(n \cdot log n)$ 算法有很大的提升。但由于辅助向量 $B$ 的元素数量与输入一样多，因此它的空间复杂度是 $O(n)$。

## 分支定界法

> 有助于预测最佳差的路径，避免在这些路径上浪费时间

### 上界与下界

比如在之前讨论的邪恶背包问题中，`greedy_knapsack` 算法给出了最优利润的下界，这个下界可能接近（也可能不接近）最优利润。

现在来看另一种形式的背包问题，所有的物品均为粉末，我们可以将物品的一部分放入背包。我们同样可以用贪心法求解，始终将最优性价比的物品放入背包：

```javascript
function powdered_knapsack(items, max_weight) {
  bag_weight = 0
  bag_items = List.new
  items = sort_by_value_weight_ratio(items)
  for (item in items) {
    // 有可能这件物品总重量比剩下的容量大
    weight = min(max_weight - bag_weight, item.weight)
    bag_weight = bag_weight + weight
    value = weight * item.value_weight_ratio
    bagged_value = bagged_value + value
    bag_items.append(item, weight)
  }
  return bag_items, bag_value
}
```

`powdered_knapsack` 算法实际上给出了不可分割物品版本最优利润的上界。

### 背包问题的上界与下界

> 看书 P56 的图解比较舒服

如果要求出解背包问题最优解，时间复杂度为 $O(2^n)$。但我们利用 `greedy_knapsack` 和 `powdered_knapsack` 可以很快速地求出背包问题最优利润的下界和上界。

假设我们有 ABCDE 五件物品，容量为 10 的背包。我们求出他的上界和下界。 然后用类似于分治法的思维往下分解，考虑放入 E 和不放入 E 的两种场景。最终我们发现上界和下界收束了。

1. 将问题分解为若干子问题
2. 找出子问题的上界和下界
3. 比较所有分支的界限
4. 对最可行的子问题重复第 1 步

# 第四章：数据

- **过程抽象**：将复杂的过程隐藏在调用的后面，使得算法更加简单
- **数据抽象**：隐藏数据处理过程的细节
- **抽象数据模型**：可以用抽象数据模型来讨论问题，在代码中也应该使用抽象数据模型封装好的接口，这样当底层的数据结构发生改变的时候也不用改变程序中的其他代码
  - 常见的抽象数据模型：栈、队列、优先队列、列表、排序列表、映射、集合
- **数据结构**：抽象数据模型的底层具体实现

| 数据结构 | 优点 | 缺点 | 适用的抽象数据模型 |
| --- | --- | --- | --- |
| 数组 | 易于编写，可以立即访问到任何元素 | 内存中需要大量分配连续空间，删除或添加中间元素比较麻烦 | 栈、列表、队列 |
| 链表 | 每个单元可以保存在内存的任何位置，可以很容易地增删元素 | 无法立即检索到某个元素，没有其他信息的情况下无法获取到前一个单元的地址 | 栈、列表、队列 |
| 双向链表 | 在链表的基础上可以向两个方向移动 | 无法立即检索到某个元素，两个指针增加代码复杂性，需要更多内存 | 栈、列表、队列 |
| 树 | 与链表类似 |  | 文件目录结构等有层次关系的数据 |
| 二叉查找树 | 查找速度很快 | | 映射、集合 |
| 二叉堆 | 可以立即检索到最大（或最小）的元素 | | 优先队列 |
| 图 | 非常灵活 | | 几乎可以表示任何类型的数据、人际关系 |
| 散列表 | 查找元素的时间复杂度为 $O(1)$，且比树插入删除更快 | 需要预先分配大量连续内存，空间不足时散列冲突会显著影响性能 |  映射、集合 |


## 抽象数据类型

**抽象数据类型（ADT）** 是一组有意义的操作规范，ADT 定义的接口用于处理保存给定类型数据的变量。

## 常见抽象

### 基本数据类型

编程语言内置的数据类型，无需调用外部模块即可使用。总是包括整数、浮点数，以及对他们的简单操作等。

### 栈

> 后进先出（LIFO）。用于处理一堆元素，并且只对栈顶的元素进行操作。

- `push(e)`：将元素 `e` 添加到栈顶
- `pop()`：检索并删除栈顶元素

比如文本编辑器为了实现撤销功能，可以用栈。

### 队列

> 先进先出（FIFO）。检索到的元素总是最先加入的元素。

- `enqueue(e)`：将元素 `e` 添加到队列后端
- `dequeue()`：删除并返回队列最前端的元素

### 优先队列

> 队列的基础上，增加了 **优先级**，比如排队就诊的队列中，重病急诊患者优先级最高。

- `enqueue(e, p)`：根据优先级 `p` 将元素 `e` 添加到队列
- `dequeue()`：删除并返回队列最前端的元素

### 列表

> 不受限制地将元素重新排序，或者对任意位置的元素进行访问、插入、删除。

- `insert(n, e)`：将元素 `e` 插入到位置 `n`
- `remove(n)`：删除位置 `n` 的元素
- `get(n)`：获取位置 `n` 的元素
- `sort()`：将列表中的元素排序
- `slice(start, end)`：返回从位置 `start` 到 `end` 的字列表
- `reverse()`：反转列表的顺序

### 排序列表

> 一个始终保持排序状态的列表。

- `insert(e)`：将元素 `e` 插入到正确的位置
- `remove(n)`：删除位置 `n` 的元素
- `get(n)` 获取位置 `n` 的元素

### 映射

> 即字典。用来存储 **键** 和 **值** 之间的映射关系。可以通过键来查询映射，并获取到对应的值。

- `set(key, value)`：添加键值映射
- `delete(key)`：删除 `key` 及其关联的值
- `get(key)`：获取 `key` 关联的值

### 集合

> 若干 **唯一** 元素的 **无序** 集合。

- `add(e)`：添加元素
- `list()`：列出集合中的元素
- `delete(e)`：删除集合中的元素 `e`

## 数据结构

- 描述了数据在计算机内存中的组织与访问方式
- 提供了在数据处理模块中实现 ADT 的方法

### 数组

> 计算机在内存中分配连续的存储空间，然后按顺序将元素写入该空间，并用特殊的 `NULL` 令牌标记序列的结束

假设数组从地址 $s$ 开始存储，每个元素的长度为 $b$ 字节，那么如果需要访问第 $n$ 个元素，则只需要从地址 $s+(b·n)$ 开始取出 $b$ 字节即可

因此我们可以 **立即** 访问到任何元素

数组可以用来实现栈、列表、队列，易于编写且可以即时访问，但也存在缺点：

- 内存中大量分配连续空间不太现实，如果要对数组进行扩展，内存中可能没有足够的连续可用空间
- 删除中间元素需要将之后所有的元素前移，添加中间元素需要将之后的所有元素后移

### 链表

> 每个单元包含一个指针，指向下一个单元的地址，包含空指针的单元标记了链的结束

列表可以很容易地增删元素，并且每个单元可以保存在内存的任何位置

可以利用链表实现栈、列表、队列

列表的不足之处：

- 无法立即检索到第 $n$ 个元素
- 在没有其他信息的情况下，无法获取到链中前一个单元的地址，于是没办法删除这个单元

### 双向链表

> 每个单元包含两个指针，分别指向签一个单元和后一个单元

即便只给出一个单元的地址，也可以删除这个单元，但仍然无法立即访问第 $n$ 个元素

### 树

> 每个单元中包含着指向其他单元的指针，但这些单元及其指针并不是像链表一样线性排列，而是呈树状结构

特别适合保存文件目录结构、军队的命令链等具有层次关系的数据

- **结点**：每个单元称为一个结点
- **边**：从一个单元指向另一个单元的指针
- **根节点**：位于树顶端的结点，他是唯一没有 **父结点** 的结点。除了根结点外，每个结点都 **有且仅有** 一个父结点
- **兄弟节点**：具有相同父结点的两个结点
- **叶结点**：没有任何子结点的结点
- **路径**：两个结点之间的路径是从一个结点到另一个结点的 **一组结点与边**
- **层次**：结点的层次是该结点与根节点的路径长度
- **高度**：树中最深结点的高度
- **森林**：树的集合

### 二叉查找树

> 一种能实现高效搜索的特殊树结构

树中的结点最多可以有两个子结点，根据结点的键值对确定其位置。父结点左侧的子结点必须小于父结点，右侧的子结点必须大于父结点。

我们可以很容易在这种特殊的树上搜索具有给定键值对的某个结点：

```javascript
function find_node(binary_tree, value) {
  node = binary_tree.root_node
  while (node) {
    if (node.value == value) { return node }
    node = value > node.value ? node.right : node.left
  }
  return "NOT FOUND"
}
```

插入元素时，我们需要在树中搜索这个值。采用搜索中探索的最后一个节点，并使其的左指针或右指针指向新节点：

```javascript
function insert_node(binary_tree, new_node) {
  node = binary_tree.root_node
  while (node) {
    last_node = node
    node = new_node.value > node.value ? node.right : node.left
  }
  if (new_node.value > last_node.value) {
    last_node.right = new_node
  } else {
    last_node.left = new_node
  }
}
```

#### 树的平衡

有时候二叉树会变得很高（比如我们一直插入大于前一个结点的键值对时，我们可能会得到类似链表的结构），这是就需要通过 **树的平衡** 来得到尽可能矮的树。

因为树的大部分操作都涉及跟踪结点之间的链接，当树特别高的时候，结点之间的平均路径就会变长，需要访问内存的次数就会变多。

我们可以这样构建一棵完美平衡的二叉查找树：

```javascript
function build_balanced(nodes) {
  if (nodes.is_empty) { return null }
  middle = nodes.length / 2
  left = nodes.slice(0, middle - 1)
  right = nodes.slice(middle + 1, nodes.length)
  balanced = BinaryTree.new({ root: nodes[middle] })
  balanced.left = build_balanced(left)
  balanced.right = build_balanced(right)
  return balanced 
}
```

树的平衡成本很高，因此需要权衡平衡的时机。

- 一个由 $n$ 个结点构成的二叉查找树，他的最大高度是 $n$（类似一个链表），完美平衡时的最小高度为 $log_2 n$
- 搜索一个元素的复杂度与树的高度成正比，最坏情况下需要搜索到最低的叶节点
- 搜索 $n$ 个元素的平衡二叉树，时间复杂度为 $O(log n)$
- 因此我们经常选择这种结构来实现集合、映射

为了有效处理变化很大的二叉树，人们发明了 **自平衡二叉树**，他会在插入或删除的时候保持平衡的状态，比如红黑树、AVL树、B树等。

### 二叉堆

> 二叉堆是一种特殊的二叉查找树，可以立即检索到最大（或最小）的元素，在实现优先队列中非常有用

父结点的左侧的子结点小于右侧的子结点，且父结点必须大于（或小于）他的两个子结点。

由于最大（或最小）元素始终是树的根节点，查找最大（或最小）元素时的时间复杂度为 $O(1)$；搜索或插入节点的时间复杂度依然为 $O(log n)$

### 图

> 图与树类似，但图没有子结点、父结点、根节点，任何节点可以有多个入边或出边

图是最灵活的数据结构，几乎可以表示任何类型的数据

### 散列表

> 散列表查找元素的时间复杂度为 $O(1)$

散列表与数组类似，需要预先分配大块连续存储空间，但散列表中的元素并非存储在有序序列中，而是由 **散列函数** 确定位置。

- **散列函数**：输入一个需要存储的元素，输出一个随机生成的数字，作为存储元素的位置（地址）。通过该地址就可以实现对元素的即时检索
- **散列冲突**：对于两个不同的输入，散列函数有时候会返回相同的存储地址，冲突发生时，两个元素必须保存在相同的地址（比如使用从这个地址开始的链表）。为了减少散列冲突，应确保散列表中至少存在50%的可用空间，否则可能由于过于频繁的冲突降低散列表的性能

散列表常用于实现映射和集合。他比树有更高的插入、删除速度，但需要大量连续的内存才能正常工作

# 第五章：算法

## 排序

### 选择排序

> 在 i ... list.length 的中找到最小的，放到 i 的位置

选择排序的时间复杂度为 $O(n^2)$，人们常用这种算法来排序扑克牌

### 插入排序

> 将第 i 项插入之前已经排好序的列表中

插入排序也是一种具有二次成本的算法，但他在排序几乎已经排序的数组时非常有效

```javascript
function insertion_sort(list) {
  for (i = 1 ... list.length) {
    j = i
    while (j.notNull && list[j - 1] > list) {
      list.swap_items(j, j - 1)
      j = j - 1
    }
  }
}
```

### 归并排序

> 将数据分成两份，对其分别进行排序，再合并，时间复杂度为 $O(n log n)$

### 快速排序

> 随机选一个基准；将大于他的放在右边，小于他的放在左边；然后对左右分别继续操作；再合并左、基准、右

```javascript
function quickSort(list) {
  if (list.length < 2) { return list }
  if (list.lenght == 2) { return list[0] > list[1] ? list.swap(0, 1) : list }
  pivotIndex = list.length / 2
  left = list.slice(0, pivotIndex)
  right = list.slice(pivotIndex, list.length)
  return merge(quickSort(left), list[pivotIndex], quickSort(right))
}
```

## 搜索

选择好的数据结构，比如二分查找树、散列表等，可以大幅提高查找效率

### 顺序搜索

> 最简单的搜索，从头开始找，时间复杂度为 $O(n)$

### 二分查找

> 元素位于排序数组中可以用二分查找，时间复杂度为 $O(n)$

```javascript
function binarySearch(items, key) {
  if (items.isNull) { return null }
  i = items.length / 2
  if (key == items[i]) { return i }
  sliced = key > items[i]
    ? items.slice(i + 1, items.length)
    : items.slice(0, i)
  return binarySearch(sliced, key)
}
```

## 图

### 图的搜索

#### 深度优先搜索（DFS）

> 沿着图的边逐渐深入，达到某个与任何新结点都没有边相连的结点时，就返回前一个结点继续这个过程

- 借助栈来跟踪搜索路径：将探索的结点压入栈中，需要返回时弹出来
- 回溯策略就是利用这种方式搜索

```javascript
function DFS(startNode, key) {
  nextNodes = Stack.new()
  // 由于是图，没有父子关系，我们需要记住访问过哪些了
  seenNodes = Set.new()
  
  nextNodes.push(startNode)
  seenNodes.add(startNode)
  
  while (nextNodes.notEmpty) {
    node = nextNodes.pop()
    if (node.key == key) { return node }
    for (n in node.connectedNodes) {
      if (!seenNodes.has(n)) {
        nextNodes.push(n)
        seenNodes.add(n)
      }
    }
  }
  
  return null
}
```

#### 广度优先搜索（BFS）

> 逐层对图进行探索

- 用队列跟踪访问的结点：完成探索后，我们将它的子结点插入队列，然后取出下一个结点进行探索

```javascript
function BFS(startNode, key) {
  nextNodes = Queue.new()
  // 由于是图，没有父子关系，我们需要记住访问过哪些了
  seenNodes = Set.new()
  
  nextNodes.enqueue(startNode)
  seenNodes.add(startNode)
  
  while (!nextNodes.isEmpty(nextNodes)) {
    node = nextNodes.dequeue()
    if (node.key == key) { return node }
    for (n in node.connectedNodes) {
      if (!seenNodes.has(node)) {
        nextNodes.enqueue(n)
        seenNodes.add(n)
      }
    }
  }
  
  return null
}
```

#### 如何选择

{% note warning %}
DFS 和 BFS 其实只在跟踪结点的存储方式上有所不同：DFS 使用栈，而 BFS 使用队列。
{% endnote %}

- DFS 只需要存储“从哪个节点来”，BFS 则需要存储整个搜索的边界，当数据量十分庞大的时候，BFS 会消耗过多的内存
- 如果正在搜索的结点距离起始点不太远，选择成本较高的 BFS 就比较划算，因为能更快地找到指定节点
- 如果需要探索图的全部节点，最好使用 DFS，因为易于实现且内存占用更少

### 图着色

抽象模型：给固定数量的“颜色”，必须为图中的每个结点分配一种颜色，且通过边相连的结点不能共享同一种颜色。

例：给一张基站及其小区的地图，位于相邻小区的基站必须工作在不同频率以避免干扰，且有四种频率可供选择，那么应该为每个基站分配哪种频率？

> 书中没有给出解，感觉可以尝试使用回溯法解决，跟八皇后问题有点像

### 寻路

可以使用 BFS 或 DFS 策略找出较短的路径，但不如用 **戴克斯特拉算法**。

- 使用优先队列跟踪探索过程：完成新结点的探索之后，将结点之间的连接添加进优先队列，结点的优先级是连接该节点与起始节点的边的权重
- 负权重的路径可能会导致负循环——这会使得算法陷入无限循环
- 如果搜索的图过于庞大，可以考虑使用 **双向搜索**，即：两个搜索进程从起始点和目标点同时进行，如果一个搜索区域中的任意节点出现在了另一个搜索区域中，就说明找到了符合条件的路径。

### PageRank

分析网页并呈现最相关的给用户。可以将万维网建模为一张图，其中的结点表示网页，边表示网页之间的链接。

- 如果一个网页包括许多来自其他重要页面的链接，那么这个网页也很重要
- 初始阶段，图中的网页具有相同的“分值”
- 每轮计算完成后，每个页面将各自的分值分发给与之链接的页面
- 重复进行，直到分值达到稳定分布，每个页面的稳定分值叫做 PageRank，使用 PageRank 来确定网页的重要性

## 运筹学

> 做出最佳决策，更好地管理人力与资源，涉及 **最大化** 或 **最小化** 目标

- 航空公司用运筹学优化航班时刻表
- 炼油厂找出原料的最佳配比
- 用运筹学调度劳动力和设备

### 线性最优化问题

> 能用线性方程对问题的目标与约束条件进行建模的问题

例：文件柜采购。

- 文件柜 X 的价格为 10 元，占地 6 平米，能存放 8 立方米的文件；
- 文件柜 Y 的价格为 20 元，占地 8 平米，能存放 12 立方米的文件；
- 预算为 140 元，可用面积为 72 平米，如何采购才能放最多的文件？

设 $x$ 和 $y$ 分别表示两种文件柜的数量，$z$ 为总容量，有：

$$
z = 8x + 12y
$$

现在我们要让 $z$ 最大，同时有这些约束条件：

- 预算约束：$10x + 20y \leq 140$
- 面积约束：$6x + 8y \leq 72$
- 其他约束：$x \geq 0$，$y \geq 0$

可以在坐标轴中将约束方程画出来，得到约束区域，然后从中找出 $z$ 最大的点即可。

这被称为 **单纯形法**，可以用单纯形法求解器得到解。

### 网络流问题

例：补给网络。连接各个城市的铁路构成了铁路网，每条铁路有最大运力，求从一个给定的生产城市每天可以运送多少物资到一个给定的消费城市。

- 每条铁路用一个变量来表示，表示通过这条铁路运送的物资量
- 所有铁路不能超过其运力
- 除了生产和消费城市以外，所有城市的流入量与流出量相等

# 第六章：数据库

**数据库管理系统（DBMS）** 是用于管理数据库的一种特殊软件，他负责数据的组织和与存储。

## 关系型数据库

关系型数据库可以很容易地避免信息重复与数据不一致的问题，是目前使用最广泛的数据库系统。

- 在关系模型中，数据被划分为不同的 **表**
- **行** 代表数据条目
- **列** 是数据条目具有的不同属性
- 通常会为列指定可以容纳的数据类型，也可以指定其他条件，比如必须、唯一
- 通常将列称为 **字段**，比如仅能存储整数的列称为 **整数字段**
- 字段与限制的组合称为表的 **模式**
- 违反表的模式的行将无法进入数据库系统，这是关系型数据库的优点，也是他的局限性所在

### 关系

> 通过将不同的表中数据关联起来，避免一个表中的数据重复

为了支持关系的使用，每张表都有一个特殊的标识字段（ID），用于引用表中特定的行，每行的 ID 都是唯一的。

- 主键：表的 ID 字段
- 外键：记录其他航 ID 的引用的字段

- 规范化的：一个数据库以完全不存在重复信息的方式进行组织
- 规范化：将包含重复数据的数据库转换为不包含重复数据的过程

### 模式迁移

> 模式迁移脚本可以帮助我们升级模式并转换现有数据，这些脚本通常还具备撤销更改的功能

### SQL

> 一种语句，描述了需要检索的数据

```sql
SELECT DISTINCT customers.name, customers.phone
FROM customers
JOIN orders ON orders.customer = customers.id
WHERE orders.amount > 100.00
```

### 索引

> 为了能通过给定 ID 快速检索到数据条目，DBMS 构建了一个辅助**索引**，用来将 ID 映射到在内存中的地址

索引实际上是一种自平衡二叉查找树，表中每一行对应着树中的每一个结点。结点的键是索引字段中的值（比如 ID）。

通常 DBMS 为数据库的每一个主键都建立一个索引。如果经常需要通过搜索其他字段来查找寄存器（比如通过姓名搜索客户），可以指示 DBMS 为这些字段建立额外的索引。

- **唯一性约束**。具有唯一性约束的字段通常会自动建立索引。因为在插入新的行的时候，我们需要快速检查这个字段是否重复，因此需要为其建立索引。
- **排序**。在建立索引的字段中，索引有助于以排序顺序获取行。比如如果以“姓名”字段作为索引，那么无需额外的计算就能够按姓名对行进行排序。当需要对两个字段进行排序时，可以使用 **联合索引** 对多个字段进行索引。
- **性能**。由于在表中插入或删除一个寄存器时，必须更新表的全部索引，如果表的索引很多，更新、插入、删除的计算开销就会变大（树的平衡）。此外，索引会占用磁盘空间。

### 事务

> 以**原子方式**执行数据库操作的列表。即在一步之内执行完毕，不会出现只执行一半的情况。

```sql
START TRANSACTION;
UPDATE value SET balance = balance + 50 WHERE id=2;
UPDATE value SET balance = balance - 50 WHERE id=1;
COMMIT;
```

## 非关系数据库

关系数据库的局限性：

- 随着程序越来越复杂，会有越来越多的表
- 查询会变得越来越大，越来越难理解
- `JOIN` 操作会逐渐增多，增加计算成本

> **非关系模型** 抛弃了表格关系，几乎不需要合并来自多个数据条目的信息，使用不同于 SQL 的查询语言，也被成为 **NoSQL 数据库**

### 文档存储

> 数据条目完全按应用程序所需要的方式保存

文档存储中不存在“表”和“行”，数据条目称为 **文档**，相关文档被分组在 **集合** 中。

文档包括一个主键，但一般不会使用 `JOIN` 操作来跟踪跨文档的关系。如果多个文档需要共享相关数据，那么应该将数据复制到文档中。

### 键值对存储

> 在有组织且持久的数据存储方式中，**简直对存储** 是最简单的形式，主要在缓存中使用（特别是需要频繁访问缓存时）

### 图数据库

> 将数据条目存储为结点，关系存储为边

图数据库是最灵活的数据库类型，没有表和集合，以最直观的方式存储网络化数据。如果数据结构类似某种网络、存在大量重要的关系时，可以使用图数据库。

图数据库还可以实现不同类型的面向图的查询，比如将公交数据存在图中，就能直接查询两个给定公交车站之间的最佳直达路线。

### SQL 与 NoSQL 的比较

- 关系数据库：能最大限度利用数据结构并消除重复
- 非关系数据库：以应用程序为中心，便于根据用户的需求进行访问和使用。能快速有效存储大量易失性的非结构化数据，不必担心固定模式与模式迁移；但用户需要负责更新跨文档与集合的重复信息，并采取措施保证数据的一致性

## 分布式数据库

比如在这些场景中，DBMS 运行在多台协同工作的计算机中，构成一个分布式数据库系统：

- 超级大容量的数据
- 并发数超级高的数据
- 任务关键型数据

### 单主机复制

- 以一台计算机作为主机
- 主机与多台从机相连，每台都有一份数据库的副本
- 主机响应外界的读写查询，并转发给从机，使各个从机保持同步

因此，可以处理更多的读查询、可靠性也提高了

### 多主机复制

- 集群中的所有计算机都成为主机
- 负载均衡设备将传入的读写查询分给集群中的计算机
- 每台计算机都有一份完整的数据库副本

因此，可以处理更多的并发写查询

### 分片

- 如果数据库收到大量写查询，很难让所有主机中的数据库保持同步，因为某些计算机可能空间不够
- 于是将数据库切分到各个计算机中
- 查询路由器将读写查询分发到对应分片的计算机
- 可以将分片与复制结合起来使用，降低单点故障的风险

### 数据一致性

- 可以使用一些数据库提供的工具来缓解数据不一致的问题，但这会降低数据库系统的性能
- 需要在一致性与性能之间作出权衡
- 如果数据库查询并非严格执行一致性，则可以认为他们追求**最终一致性**，即保证数据在一段时间后能**最终** 达到一致性

## 地理数据库

许多通用的 DBMS 都支持 GIS（地理信息系统）扩展，应当使用提供 GIS支持的数据库引擎来处理地理数据

## 序列化格式

- **SQL（结构化查询语言）**
  - 序列化关系数据库时最常见的格式
  - 通过编写 SQL 命令来复制数据库及其细节
  - 大部分关系型数据库系统提供“转储”和“恢复”命令，前者用于创建数据库的 SQL 序列化文件，后者用于将这类“转储”文件加载回数据库系统
- **XML（可扩展标记语言）**
  - 另一种表示结构化数据的方式 
  - 但不依赖于关系模型或某种数据库的实现
- **JSON（JavaScript 对象表示法）**
  - 大部分人认可的序列化格式
  - JSON 还有其他衍生格式：BSON（二进制 JSON）可以大幅提高 JSON 的数据处理效率；JSON-LD（关联数据的 JSON）则将 XML 结构的强大功能引入 JSON
- **CSV（逗号分隔值）**
  - 数据交换的最简单形式
  - 数据以文本形式存储，每行包含一个元素，元素属性通过逗号隔开
  - 有助于实现简单的数据转储，但不适合表示复杂的数据

# 第七章：计算机

## 体系结构

### 存储器

- 总线：传输相同数据的一组信号线
- 地址总线：传输地址的 8 条信号线
- 数据总线：传输数据的 8 条信号线

### CPU

- 指令集：CPU 可以执行的所有操作的集合
- CPU 的工作流程：
  1. 从程序计数器 Program Counter 指定的存储地址获取指令
  2. PC 自增
  3. 执行命令
  4. 返回步骤 1
- PC 会在 CPU 上电时复位为默认值，这时就是计算机中第一条待执行指令的地址，通常是一个不可变的内置程序（在个人计算机中，这种程序通常称为基本输入输出系统 BIOS
- CPU 时钟：CPU 每秒可执行的基本操作数
- CPU 体系结构：x86、ARM 等，不同的 CPU 体系结构意味着 CPU 指令集、以及将指令编码为数字的方式的不同
- 32位与64位体系结构：CPU 在一条机器指令中最多可以对多少位二进制数执行求和、比较与移动操作
- 大端序与小端序：按从左至右的顺序在 RAM 和 CPU 中存储数字，称为小端序；反之称为大端序。目前大部分 CPU 采用小端序，在解析来自网络交换机的数据时要尤其注意字节序不匹配的问题
- 模拟器：模拟目标机器，假定与其拥有形同的硬件，将指令进行解码并执行

## 编译器

- 图灵完备：机器能遵循包含指令的程序，以便:
  - 对存储器中的数据进行读写
  - 执行条件分支：如果存储地址具有给定的值，则跳转到程序的另一个点
- 无论计算的复杂性或难度如何，都可以采用简单的读取、写入、分支指令来表达
- 一种称为 `MOV`（数据传送）的 CPU 指令是图灵完备的，通过 `MOV` 指令可以严格地表达任何类型的代码
- 编译器可以将代码从复杂的语言转换为简单的语言

### 操作系统

- 程序可以借助操作系统使用不同的硬件
- 程序创建特殊的 **系统调用**，请求操作系统执行所需的输入、输出操作
- 编译器负责将输入、输出命令转换为合适的系统调用
- 因此，不同的操作系统需要不同的编译后代码

### 编译优化

- 编译器会尝试修改部分代码来提高执行效率
- 比如通常不使用递归性能会更佳，但编译器会自动重写简单的递归函数，因此我们在写代码的时候应更注重易读性，减少在不必要的微操作下浪费时间

### 脚本语言

- JavaScript、Python、Ruby 等语言在执行时并不会被编译为机器码，他们被称为 **脚本语言**
- 脚本语言的代码由 **解释器** 而非 CPU 执行
- 解释器实时转译并执行代码，因此通常运行速度会比编译之后的代码 **慢很多**，但也省去了编译的时间

### 反汇编与逆向工程

- 反汇编：可以对二进制程序进行解码，将用于编码 CPU 指令的数字转换为人类可读的指令序列
- 逆向工程：查看这些 CPU 指令，并尝试分析他们的用途

## 存储器层次结构

### 时间局部性和空间局部性

- 时间局部性：访问某个存储地址时，可能很快会再次访问该地址
- 空间局部性：访问某个存储地址时，可能会很快访问与之相邻的地址
- 将这些存储地址保存在 CPU 寄存器中，有助于避免大部分对 RAM 的昂贵操作
- 一级缓存：10KB 左右，一种集成在 CPU 内部并且速度极快的辅助存储器，读取速度仅比寄存器稍慢（约 10 个 CPU 周期）。可以将可能访问的 RAM 中的数据复制进去
- 二级缓存：200KB 左右，读取速度约 100 个 CPU 周期

### 第一级存储器和第二级存储器

- 第一级存储器：通常指 RAM，速度约 1000 个 CPU 周期
- 第二级存储器：存储应用和数据的磁盘，速度约 100 万个 CPU 周期

### 外部存储器和第三级存储器

- 并非总是在线和可用的，比如磁带、CD 等

# 第八章：程序设计

## 语言学

编程语言依靠三种基本的构建模块来操作信息：**值** 表示信息，**表达式** 产生值，**语句** 使用值向计算机发出指令。

### 值

值又被称为变成语言的“头等功名”，编程语言会支持与值有关的各种操作。

### 表达式

可以通过编写 **字面量** 或调用 **函数** 两种方式创建值：

```javascript
// 这是一个字面量表达式，我们创建了一个值 3
3
// 这是一个函数的调用，创建了一个与洛杉矶当前时间相等的值
getPacificTime()
// 我们通过运算符将简单表达式连接起来，就构成了复杂表达式
3 + getPacificTime()
```

### 语句

语句用于指示计算机 **执行** 某种操作，比如 `console.log("Hello World")`。

- 定义：某些编程语言提供称为**定义**的特殊语句，他通过添加不存在的实体（如新的值或函数）来改变程序状态
- 名称绑定：为了引用所定义的实体，需要将名称与实体关联起来

## 变量

变量是最重要的名称绑定，变量将名称与保存值的存储地址关联在一起，作为“别名”使用

### 变量类型

大部分编程语言中，需要为变量指定一种类型，以便程序了解如何解释在变量内存块中读取的1和0，也有助于在处理变量时发现错误

### 变量作用域

- 作用域定义了变量的有效位置和可供使用的范围
- 上下文（或称环境）表示在程序的某个给定点，所有可用名称绑定的集合
- 命名空间构成了所有全局可用名称的集合

## 范式

范式是定义科学领域的概念与实践的特定集合，比如牛顿学派和相对论学派就是物理学两种不同的范式。目前存在三种主要的编程范式：**命令式编程**、**声明式编程**、**逻辑式编程**

### 命令式编程

通过特定的命令指示计算机在每一步必须执行的操作，每条命令都会改变计算机的状态，构成程序的命令序列将依次执行

#### 机器码编程

- 早期程序员需要用 1 和 0 将代码输入计算机
- 后来人们使用助记符编写 CPU 指令序列，比如 `CP` `MOV` `CMP`
- 接着人们编写了一种程序，可以将助记符转换为等效的二进制数，这就是 **汇编语言**
- 现在汇编语言多用于对微波炉、早期车载计算机等系统进行编程，或者用于追求极致性能的地方

#### 结构化编程

- 程序最初是通过 `GOTO` 来控制执行流，可以在代码中跳转执行
- 面条式代码：不同的执行流与 `GOTO` 和 `JUMP` 命令交织在一起，很难阅读
- 戴克斯特拉于 1968 年发表了“GOTO有害论”
- 此后程序员开始使用控制结构（`if` `else` `while` `for`）等编写程序

#### 过程式编程

- 将代码组织到过程中，在避免代码重复的同事也提高了代码的可重用性
- 比如我们可以创建一个函数，然后在不同的地方调用这个函数
- 利用过程更容易对相关代码分组，将他们划分为不同的逻辑部分

### 声明式编程

**声明式编程**旨在声明所需要的结果，关心的是要实现**哪些**目标，而不是**如何**实现目标

#### 函数式编程

- 在函数式编程范式中，函数不仅仅是过程，他们声明两个或多个元素之间的关系，类似于数学函数
- 函数是头等公民，与其他基本数据类型的处理并无二致
- 高阶函数：函数可以将其他的函数作为输入参数，也可以返回其他函数作为输出，这被称为 **高阶函数**

```javascript
// 比如 sort 函数传入两个函数，coordinates 包含一个地理位置列表，closer_to_home 接受两个参数，并返回离家近的那个
sort(coordinates, closer_to_home)

// 同理，比如 filter 函数和 map 函数
odd_numbers = filter(numbsers, number_is_odd)
squard_numbers = map(numbers, square)

// 再同理，我们可以编写一个 reduce 函数
function reduce(list, inital_val, func)  {
  accumulator = inital_val
  for (item in list) {
    accumulator = func(accumulator, item)
  }
  return accumulator
}
```

##### 闭包

高阶函数将对值的引用 **包含** 到所生成的函数中。支持 **闭包** 的函数能“记住”内容，并访问到所包含值的环境

##### 柯里化

闭包的应用之一，对于传入多个函数的参数，可以利用闭包将函数的执行分解为多个步骤

```javascript
sum = function (a, b) { return a + b }
// sum 理应传入两个参数。假设只用一个参数就可以调用它，并且 sum(3) 返回的不是数字，而是一个经过 **经过柯里化** 的新函数
sum_three = sum(3) // 这句话调用 sum 函数并使用 3 作为第一个参数，并返回一个新函数，对 3 的引用包含在这个新函数中

sum_three(1) // 4

special_sum = sum(get_number()) // 创建 special_sum 函数不会调用 get_number 函数，对 get_number 的引用包含在 special_sum 中，仅当需要对 special_sum 求值时才会调用 get_number 函数，这就是 **惰性求值**
```

###### 模板函数

闭包也可以用来生成一组遵循模板的相关函数，使用函数模板可以提高代码的可读性并避免重复：

```javascript
function power_generator (base) {
  function power (x) {
    return Math.pow(x, base)
  }
  return power
}

// 可以用 power_generator 生成计算幂的不同函数
square = power_generator(2)
square(2) // 4
cube = power_generator(3)
cube(2) // 8
```

###### 管理函数内部状态

创建一个有记忆功能的累加器，我们可以使用闭包而不借助全局变量：

```javascript
function make_adder () {
  n = 0
  function adder (x) {
    n += x
    return n
  }
  return adder
}

my_adder = make_adder()
my_adder(5) // 5
my_adder(2) // 7
```
