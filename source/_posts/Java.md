---
title: Java
date: 2023-02-09 17:14:22
categories:
  - [全栈]
---

Object Oriented Design, Java, Maven, Spring Boot.

<!-- more -->

# Building Blocks

## The Environment

### JDK & JRE & JVM

#### Java Development Kit (JDK)

包含了 **Java 运行时环境（Java Runtime Environment, JRE）**、编译器和各种工具（比如 JavaDoc、Java Debugger 等）。

![jdk](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/jdk.jpg)

**Key Commands Provided By JDK**

- `javac`: converts `.java` source files into `.class` bytecode

- `java`: excutes a program
- `jar`: java archive (packing files together)
- `javadoc`: for documentation

#### Java Runtime Environment (JRE)

JRE 是 JDK 的一部分。JRE 包括 JVM、浏览器插件和小程序支持。

#### Java Virtual Machine (JVM)

The phases of program excution:

1. **Writing code**: Java Programmer.
2. **Compilation**: Javac compiler (the primary java compiler, included in java development kit, or **JDK**). Input java program, output bytecode.
3. **Run**: JVM executes the bytecode generated by compiler.

Each operating system has different JVM, however the output they produce after execution of bytecode is same across all operating systems.

![JVM](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/JVM.jpg)

![jvm_architecture](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/jvm_architecture.jpg)

**Class Loader**: Reads the `.class` file, and save the bytecode in the **method area**.

**Method Area**: There is **only one method area in a JVM**. Holds the class level information of each `.class` file.

**Heap**: A part of JVM memory where objects are allocated.

**Stack**: Stack is a  also part of JVM memory but unlike Heap, it is used for storing temporary variables.

**PC Registers**: This keeps the track of which instruction has been executed and which one is going to be executed. Since instructions are executed by threads, **each thread has separate PC register**.

**Native Method stack**: A native method can access the runtime data areas of the virtual machine.

**Native Method interface**: Enables java code to call or be called by native applications. Native applications are programs that are specific to the hardware and OS of a system.

### Bytecode

Javac compiler compiles the java source code into bytecode.

The byte code is saved in a `.class` file.

## The main() method

Java program starts by excuting the `main()` method.

```java
public static void main(String[] args) {}
public static void main(String args[]) {}
public static void main(String... args) {}
public final static void main(final String[] args) {}
static public void main(String[] args) {}
```

For example:

```java
// in Names.java
public class Names {
  public static void main(String[] args) {
    System.out.println("First name: " + args[0]);
    System.out.println("Last name: " + args[1]);
  }
}
```

Then run:

```bash
javac Names.java
java Names Harvey Z
  First name: Harvey
  Last name: Z
```



# Java & JavaScript

**主函数**

JavaScript：没有主函数，文件会从头执行到尾。

Java：需要一个主函数，作为程序执行的入口点，主函数的格式是固定的：

```java
class Test {
    public static void main(String[] args) {
        // 程序的代码
    }
}
```

一个打包的 Java 程序中（`*.jar`），可能有很多个类似的函数，但是当程序运行的时候只有一个函数会被运行，该函数被定义在 `Mainifest` 文件中。

**注释**

与 JavaScript 相同

**基本数据类型**

| JavaScript  | Java                                                      |
| ----------- | --------------------------------------------------------- |
| `boolean`   | `boolean`                                                 |
|             | `byte`                                                    |
|             | `char`                                                    |
| `string`    | `String`                                                  |
| `number`    | `double`<br />`float`<br />`int`<br />`long`<br />`short` |
| `bigint`    | `BigInteger`                                              |
| `symbol`    |                                                           |
| `null`      | `null`                                                    |
| `undefined` |                                                           |

**强制类型转换**

Java 中两个操作数如果是不同的类型，会自动进行无信息丢失的转换（比如 `int` `float` 转换为 `double` 就是无信息丢失的）。如果我们需要进行可能损失信息的类型转换（比如 `int` 转换为 `float`），需要显式地进行强制类型转换：

```java
double x = 9.997;
int nx = (int) x;   // 9，会直接截掉小数部分
```

**复杂数据类型**

| JavaScript    | Java                                                         |
| ------------- | ------------------------------------------------------------ |
| `new Array()` | `int[] ary = new int[10]`<br />`int[] ary = { 2, 3, 5 };`<br />`ary = new int[] { 2, 3, 5 };` |

**包装数据类型**

JavaScript 和 Java 都有在基本数据类型上面进行包装，使得基本数据类型可以更好地在面向对象编程中使用。

JavaScript 会自动对基本数据类型进行包装，并且不鼓励我们调用构造函数显式进行包装，就像 `new Number(123)`。

Java 5 才引入了自动装箱拆箱机制，在此之前都需要进行显式装箱：

```java
int value1 = 1;
Integer integer = Integer.valueOf(value1);
int value2 = integer.intValue();
```

注意 Java 中包装后的对象有一些特殊的性质，比如：

- `Integer` 默认值是 `null`，而 `int` 的默认值是 `0`；
- `Integer` 最好不要使用 `==` 来判断相同，需要使用 `equals()` 等。

**字符串**

Java 中的 `String` 与 JavaScript 中的高度类似，字符串内容本身也是不可变的，拼接、取子串等均会产生一个新的字符串。注意：

- Java 中没有 `slice`，只有 `substring`；

- 字符串之间不能用 `==` 判断是否相等，需要使用 `equals()`；

- Java 中可以使用 `str.length() === 0` 或 `str.equals("")` 来判断字符串是空串，但注意还有可能为 `null`，因此一般可以用这种条件：
  ```java
  if (str != null && str.length() != 0)
  ```

- Java 中如果需要由较短的字符或字符串拼接一个大的字符串可以使用 `StringBuilder`，通过 `builder.append(str)` 方法来向其中添加字符，然后使用 `builder.toString()` 方法来得到最终的字符串。不过该类只能在单线程中使用，在多线程中可以使用 `StringBuffer`，他的效率稍微低一些。

**运算符**

Java 中除了没有 `===` 以外，与 JavaScript 一致，布尔运算符也有短路逻辑。

**数学函数**

Java 中也有 `Math` 类提供一些数学函数，包括 `pow` `sqrt` `round` `abs` `max` `ceil` 等，与 JavaScript 高度类似。

**变量与函数声明**

Java 与 TypeScript 类似，都需要声明类型，不过 TypeScript 是放在冒号后面，而 Java 中则是写在前面，就像这样：

```java
int a = 12;
String str = "Hello!";
// final 关键字表示不可更改
final double PI = 3.14;
```

Java 中不允许嵌套作用域声明同名变量。

**模块系统**

Java 中 `Class` 会放在 `package` 里面，一个 `package` 里面不允许有同名的 `Class`，在 `Class` 的第一行通常需要说明该类属于哪个包：

```java
package org.group.me;
```

通过 `import` 关键字引入别的包的类：

```java
import java.util.Scanner;
```

**控制语句**

Java 与 JavaScript 的控制语句相同，`if-else` `switch-case`  `while` `do-while` 均一致，除了 `for` 有些许区别。

他们都有普通的 `for` 循环用法：

```java
for (int i; i < 10; i++) {
}
```

但有一些特殊的用法不同，JavaScript 中有比较早的 `for-in` 用来遍历对象中的所有可枚举字符串属性、`for-of` 用来遍历可迭代对象。Java 中则有这种写法来遍历数组或集合：

```java
for (int el: arr) {
}
```

**继承**

Java 的 Class 和 Interface 与 TypeScript 的基本一致，不过 TypeSccript 中未指定可见性时默认为 `public`，而 Java 中默认为 `default`，只有同一个包里的类可以访问。

**多态**

与 TypeScript 一致，Java 中一个变量可以保存其所声明的类型或该类型的任何子类型。

**泛型**

与 TypeScript 一致。

**Lambda 表达式**

Lambda 表达式与 JavaScript 的箭头函数写法基本一样，不过 `=>` 变成了 `->`。

Java 有函数式接口，该接口只有一个抽象方法，lambda 表达式可以自动填进该方法，比如：

```java
import java.io.PrintWriter;

public class Main {
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        String[] plants = {"Mercury", "venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
        Test test = s -> {  // lambda 表达式作为函数式接口的实例
            if (s.length() % 2 == 0) {
                return true;
            }
            return false;
        };
        for (String word : plants) {
            if (test.check(word)) {
                out.print(word + " ");
            }
        }
        out.close();
    }
}

interface Test {
    public boolean check(String s);
}
```

再比如：

```java
import java.io.PrintWriter;

public class Main {
    static PrintWriter out = new PrintWriter(System.out);

    public static double calc(double a, double b, Calculator util) {
        return util.operation(a, b);
    }

    public static void main(String[] args) {
        Calculator util[] = new Calculator[4];  // 定义函数式接口数组
        util[0] = (a, b) -> a + b;
        util[1] = (a, b) -> a - b;
        util[2] = (a, b) -> a * b;
        util[3] = (a, b) -> a / b;
        double a = 20, b = 15;
        for (Calculator c : util) {
            System.out.println(calc(a, b, c));
        }
        out.close();
    }
}

interface Calculator {
    public double operation(double a, double b);
}
```

**Collection**

`Collection` 是 Java 中的一个 Interface，他有很多子 Interface，比如 `List` `Map` `Set`，而子 Interface 又进一步被诸如 `ArrayList` 等 `Class` 实现。

| Interface | Class        | Usage                                     |
| --------- | ------------ | ----------------------------------------- |
| `List`    | `ArrayList`  | 动态长度的数组，默认长度为 10             |
| `List`    | `LinkedList` | 双链表，时间复杂度与 `ArrayList` 有所不同 |
|           |              |                                           |



# Concepts

## Object Oriented

- **Encapsulation**: 封装，一个 Class 包含了他的数据和行为，并隐藏他不想要外界访问的内容。
- **Abstraction**：抽象，将实现细节抽象，隔离代码改变带来的影响。
- **Inheritance**: 继承，这一定程度上破坏了封装。继承是一种方法，可以用来创建“子类使用父类方法和属性”这一体系结构。
- **Polymorphism**: 多态，不同类的对象被当作一个共同的超类的对象来对待。多态主要聚焦于灵活地使用继承的方法，允许一个 Interface 表达不同的对象。意味着可以调用不同 Classes 的同样的方法。
- **Coupling and Cohesion**: *Loose coupled, highly cohesive*，高内聚、低耦合。
  - **Coupling** (dependency): 一个 Class 对另一个 Class 了解多深。
  - **Cohesion**: 一个 Class 有独立、高度聚焦的目标的程度。

- **Interface/Implementation Paradigm**
  - 一个对象应该 **只暴露给其他对象交互用的接口**。
  - Class 的客户不应该受到 Class 内部具体实现改变的影响。

## UML Class Diagrams

[UML Class Diagram Tutorial Video](https://www.youtube.com/watch?v=UI6lqHOVHic)

[UML Class Diagram Tutorial](https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/;WWWSESSIONID=011FBA1C6F02E5074E7D3E435507A547.www1)

### Attributes

类的实例的数据，也称为 fields, variables, properties。

### Methods

规定了 Class 的行为，也称为 operations 或 functions.

### Visibility

```text
- private
+ public
# protected
~ package/default
```

### Relationship

![Class Relationship](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/ClassRelationship.jpg)

![Inheritance](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDInheritance.jpg)

![Association](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDAssociation.jpg)

![Aggregation](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDAggregation.jpg)

![Composition](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDComposition.jpg)

### Example

![Class Diagram Example](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CDExample1.jpg)

## SOLID Principle

- **SRP**: Single Responsibility Principle
- **OCP**: Open/Close Principle
- **LSP**: Liskov Substitution Principle
- **IPS**: Interface Segregation Principle
- **DIP**: Dependency Inversion Principle

### SRP: Single Responsibility Principle

```text
Animal
- perfiomWalk()
- performSwim()
- performSleep()
```

### OCP: Open/Close Principle

- 软件实体（模组、类、函数等）应该：
  - Open for extension
  - Close for modification
- 可以在不修改他的基础上拓展某个类的行为。

### LSP: Liskov Substitution Principle

用子类替换掉某个超类，程序将不会被中断。**如果超类可以一件事，那么子类一定也可以做这件事。**

### IPS: Interface Segregation Principle

代码不应该强制依赖于一个他根本没有使用的方法。需要将大的 Interfaces 切分成更小的、更精确的 Interfaces：

```java
// Large interface
public interface Zookeeper {
  void washAnimal();
  void feedAnimal();
  void petAnimal();
}

// Split into ...
public interface AnimalCleaner {
  void washAnimal();
}
public interface AnimalFeeder {
  void feedAnimal();
}
public interface AnimalPetter {
  void petAnimal();
}

class AnimalCarer implements AnimalCleaner, AnimalFeeder {
  //...
}
class AnimalLover implements AnimalPetter {
  //...
}
```

### DIP: Dependency Inversion Principle

依赖于抽象，而不是依赖于某个具体的类。

具体的实现细节应该依赖于他的抽象。

## Convention-Over-Configuration Principle

The convention represents the most-used way to configure the app for a specific purpose.

Only need to change those places where your app needs more particular configuration.

Write less code for configuration.



## Data Transfer Object (DTO)

DTO 是一种设计模式，在软件工程（尤其是分布式系统）中被广泛运用，用来在不同的 Layer、Component 之间交换数据。

Java 中的 DTO 就是一些简单的类，有一些属性、Getters 和 Setters，作为数据的轻量容器来使用。

在 Spring 中，DTOs 一般用来表达 RESTful APIs 的请求和响应数据，他们可以很轻松地使用 Bean Validation API 来进行校验（比如 @NotNull、@Size、@Email 等）。

**DTO 主要用于：**

- 在客户端与服务端之间交换数据。
- 在不同的应用之间交换数据。

**DTO 的好处：**

- 封装，当数据结构发生改变的时候，只有相关的 DTO 需要改变。
- 关注点分离，将数据表达和数据处理分开。
- 提升性能，在分布式系统中，DTO 可以减少不同组件之间的数据传输。

**DTO 的命名：**

一般 DTO 需要反映他的用途，比如 UserCreateDTO、UserUpdateDTO、UserDetailsDTO。

# Startup

## Extension Pack for Java for VSCode

1. Install the `Extension Pack for Java`
2. Refresh VSCode: Press `Ctrl+Shift+P` and input `Reload Window`
3. Clean the Java workspace when there are problems: Press `Ctrl+Shift+P` and input `Java: Clean Java Language Server Workspace`

## Creating and Running Java programs

Create Java source file `TestCircle.java`:

```java
// TestCircle.java
public class TestCircle {
  public static void main(String args[]) {
    System.out.println("Hello");
  }
}
```

Compile the Java source file into bytecode:

```bash
javac TestCircle.java
```

Execute the Java program:

```java
java TestCircle
```

To generate Setter and Getter methods in VSCode, in a Java source file, right-click and select `Source Action...`. And then select `Generate Getters and Setters`. The way to generate constructors is similar.

# OO Design in Java

## Encapsulation

- **Access Modifier**
  - `private` 关键字表示该方法或变量只能在声明该变量的对象内部访问。
  - 所有/大多数属性都应该用声明为私有的。
- **Getters and Setters**

## Inheritance

- **Is-a Relationship**: 子类（subclass）可以做所有其父类（superclass）可以做的事情。
  - **Generalization**: 子类是父类的类型，比如 Dog **is-a** Mammal。

### Method Overriding

```java
public class Animal {
  public void sound() {
    //...
  }
}

public class Horse extends Animal {
  // Not mandatory but considered as best practice for coding
  // Because it will let comiler to check wether Animal has sound or not
  @Override
  public void sound() {}
}
```

### Interface and Abstract Class

- **Interface 不能提供实现细节。**
  - 一个 Class 只能继承自一个父类，但是可以实现（Implement）多个 Interfaces。
- **Abstract Class 可以提供部分实现细节。** 

```java
interface Nameable {
  String getName();
  void setName(String aName);
}

abstract class Mammal {
  public void generateHeat() {
    //...
  }
  public abstract void makeNoise();
}
  
class Dog extends Mammal implements Nameable {
  String name;
  
  public void makeNoise() {
    //...
  }
  public void setName (String aName) {
    name = aName;
  }
  public String getName() {
    return name;
  }
}

Dog D = new Dog();
Mammal M = D;
Nameable N = D;
```

## Composition

- **Has-a Relationship**: A dog **has a** head.

```java
class Mammal {
  public void eat() {
    //...
  }
}

public Walkable {
  public void walk() {
    //...
  }
}

class Dog {
  Mammal m = new Mammal();
  Walkable w = new Walkable();
  
  public void performWalk() {
    w.walk();
  }
  public void performEat() {
    m.eat();
  }
}
```

## Inverting of Control (IoC)

根据依赖反转原则（DIP）

- 高级的模组不应该依赖于低级的模组，而是应该依赖于抽象
- 低级的模组的实现也应该依赖于抽象

![High-level module depends on low level module](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/java-before-ioc.jpg)

![Inverting of Control](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/java-ioc.jpg)

创建两个 Interfaces 来获取并导出数据：

- 所有低级模组必须实现他们的 Interfaces。
- 高级模组（Balance Sheet Module）需要依赖于这些 Interfaces。

```java
public interface IFetchData {
  List<Object[]> fetchData();
}
public interface IExportData {
  File exportData(List<Object[]> listData);
}
```

```java
public class BalanceSheet {
  private IExportData exportDataObj = null;
  private IFetchData fetchDataObj = null;
  
  public Object generateBalanceSheet() {
    List<Object[]> dataList = fetchDataObj.fetchData();
    return exportDataObj.exportData(dataList);
  }
}
```

### Dependency Injection (DI)

依赖注入（DI） 是一种实现控制反转（IoC）的方式。

将类的构造和他依赖的构造解耦：
- 将对象的创建过程改交给别的代码或实例负责；
- 然后从外部注入创建好的对象。

#### Constructor Injection

```java
public class BalanceSheet {
  private IExportData exportDataObj;
  private IFetchData fetchDataObj;
  
  BalanceSheet(IFetchData fetchData, IExportData exportData) {
    this.fetchDataObj = fetchData;
    this.exportDataObj = exportData;
  }
}
```

#### Setter Injection

```java
public class BalanceSheet {
  private IExportData exportDataObj;
  private IFetchData fetchDataObj;
  
  public void setExportDataObj(IExportData exportDataObj) {
    this.exportDataObj = exportDataObj;
  }
}
```

### IoC Containers

- IoC 容器负责对象的创建、配置和管理；
- 只需要做一些配置，容器会自己负责对象的初始化和依赖管理；
- Java IoC Containers: Spring, Google Guice and Dagger.

### Factory Pattern

```java
public class BalanceSheet {
  private IFetchData fetchDataObj;
  
  public void configureFetchData(String type) {
    this.fetchDataObj = FetchDataFactory.getFetchData(type);
  }
}

public class FetchDataFactory {
  public static IFetchData getFetchData(String type) {
    IFetchData fetchData = null;
    if ("FROM_DB".equalsIgnoreCase(type)) {
      fetchData = new FetchDatabase();
    }
    else if ("FROM_WS".equalsIgnoreCase(type)) {
      fetchData = new FetchWebService();
    }
    else {
      return null;
    }
    return fetchData;
  }
}
```

# Maven

Maven 是 Java 项目的构建与管理工具。

```text
|-- pom.xml
`-- src
  |--main
  |  `-- java
  |    `-- com
  |      `-- example
  |        `-- App.java
  `-- test
    `-- java
      `-- com
        `-- example
          `-- AppTest.java
```

- **src/main/java**: 源代码。
- **src/main/resources**: 资源，比如 configuration files 和 property files。
- **src/test/resources**: 测试需要的资源，比如 configuration files 和 property files。
- **pom.xml:** **Project Object Model**. 项目信息和依赖。
  - **groupId**: 区分依赖所属的 group 或 organization。
  - **artifactId**: 该工具在 group 内的 id。
  - **version**: 项目所需的依赖版本。
  - **scope**: 依赖的范围（比如是编译、测试、运行时所需）。
- **target**: 编译后的代码和其它构建过程中产生的文件。

## Create a Maven Project

### Use VSCode Extension

Step 1:

In VSCode, press `Ctrl+Shift+P`. Search for Java, Select `Java: Create Java Project`.

Alternatively, you may click `+` under the **Java Project Panel**.

Step 2: Choose `Maven`.

Step 3: Select `maven-archetype-quickstart`

### Use Command

```bash
mvn archetype:generate -DgroupId=com.example \
-DartifactId=Demo2 \
-DarchetkypeArtifactId=maven-archetype-quickstart \
-DinteractiveMode=false
```

## Maven Lifecycle

三个内置的生命周期：

- **Default**: 用于项目部署。
- **Clean**: 用于项目清理。
- **Site**: 用于创建项目网站。

Default 生命周期的一些 Phases：

- **validate**
- **compile**
- **test**: 单元测试
- **package**
- **verify**: 集成测试
- **install**: 将包安装到本地仓库
- **deploy**

## Goals

- Goal 是一个特定的任务（比 Phase 更小），用来构建和管理项目。
- 每个 Goal 都与一个或多个 Phases 绑定。
  - 与一个需要执行的特定的行为相关；
  - 比如编译代码、运行测试、打包代码等。
- 有一个或多个 Plugin 与 Goal 绑定。

## Plugins

- 执行特定 Goal(s) 中的任务。
  - 比如自动化一些通用的构建任务，像编译代码、运行测试、打包代码等。
- 可以与一个或多个 Goal 绑定。

## Commands

![Maven Phases, goals and Plugins](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/maven-phase-goal-plugin.jpg)

Maven 命令有两种形式：

```bash
mvn [phase]
mvn [plugin]:[goal]
```

比如：

```bash
mvn compile            # 执行 Default 生命周期直到 compile 为止的所有 Phase
mvn compiler:compile   # 只使用 compiler 插件来进行 compile

mvn test
mvn surefire:test      # 只使用 surefire 插件来进行 test

mvn exec:java
```

## JAR (Java Archive) File

一种包文件格式，将一些 Java 的类文件、相关元数据和资源打包成一个文件方便分发。

# Spring Boot

## Simple Demo With Rest API

### Spring Initializr

- [Spring Initializr](https://start.spring.io/) helps you initialize spring boot project.

- Choose Spring Web, Spring Data JPA and PostgreSQL Driver.
- Use IntelliJ to open the project. 

- Since we have not installed database, comment out `spring-boot-starter-data-jpa` in `pom.xml`, and then run the project.

- Open browser and go to localhost:8080

### Simple API

In `DemoApplication.java`

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@SpringBootApplication
@RestController
public class DemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

  @GetMapping("/xx")
  public List<String> hello() {
    return List.of("Hello World", "123");
  }

}
```

### Student Class

- Right click `com.example.demo` folder, click new package to create a `com.example.demo.student` package.

- Create a `Student` class inside the package.

```java
package com.example.demo.student;

import java.time.LocalDate;

public class Student {
    private Long id;
    private String name;
    private String email;
    private LocalDate dob;
    private Integer age;

    // Use Ctrl+Insert to generate construtors, getters, setters, toString quickly
    public Student() {
    }

    public Student(Long id, String name, String email, LocalDate dob, Integer age) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.dob = dob;
        this.age = age;
    }

    public Student(String name, String email, LocalDate dob, Integer age) {
        this.name = name;
        this.email = email;
        this.dob = dob;
        this.age = age;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public LocalDate getDob() {
        return dob;
    }

    public void setDob(LocalDate dob) {
        this.dob = dob;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", dob=" + dob +
                ", age=" + age +
                '}';
    }
}
```

And then go to `DemoApplication`

```java
  @GetMapping("/xx")
  public List<Student> hello() {
    return List.of(
        new Student(
            1L,
            "Mariam",
            "Mariam.jamal@gmail.com",
            LocalDate.of(2000, Month.JANUARY, 5),
            21
        )
    );
  }
```

### API Layer

Create `StudentController` class inside student package, and remove relative code from `DemoApplication`

```java
package com.example.demo.student;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;
import java.time.Month;
import java.util.List;

@RestController
@RequestMapping(path = "api/v1/student")
public class StudentController {
    @GetMapping
    public List<Student> getStudents() {
        return List.of(
                new Student(
                        1L,
                        "Mariam",
                        "Mariam.jamal@gmail.com",
                        LocalDate.of(2000, Month.JANUARY, 5),
                        21
                )
        );
    }
}

```

### Business Layer and Dependency Injection

Create a `StudentService` class inside student package, and modify `StudentController` like below:

```java
// StudentService.java
package com.example.demo.student;

import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.Month;
import java.util.List;

// @Component or @Service tells the class should be instantiated (It is a bean)
@Service
public class StudentService {
    public List<Student> getStudents() {
        return List.of(
                new Student(
                        1L,
                        "Mariam",
                        "Mariam.jamal@gmail.com",
                        LocalDate.of(2000, Month.JANUARY, 5),
                        21
                )
        );
    }
}
```

```java
// StudentController.java
package com.example.demo.student;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping(path = "api/v1/student")
public class StudentController {

    private final StudentService studentService;

    // @Autowired annotation tells inject StudentService automatically
    @Autowired
    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping
    public List<Student> getStudents() {
        return studentService.getStudents();
    }
}
```

Use dependency injection to inject `StudentService` into `StudentController`.

### Create Database and Properties File

Modify the `application.properties` file (Sometimes `username` and `password` are also needed.):

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/student
spring.datasource.username=
spring.datasource.password=
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
```

Install PostgreSQL. (Sometimes you need to turn on postgresql service in windows task manager.)

Enter psql using `psql` command or SQL Shell (psql). Use `\l` to see existed databases.

Then, create student database:

```sql
CREATE DATABASE student;
```

Use `\du` to see list of roles.

Then, grant privileges:

```sql
GRANT ALL PRIVILEGES ON "student" TO [username];
```

Then, connect to student database:

```bash
\c student
```

Use `\d` to see tables in student database.

Uncomment `spring-boot-starter-data-jpa` in `pom.xml`

### JPA

Modify `Student` class:

```java
@Entity
@Table
public class Student {
    @Id
    @SequenceGenerator(
            name = "student_sequence",
            sequenceName = "student_sequence",
            allocationSize = 1
    )
    @GeneratedValue(
            strategy = GenerationType.SEQUENCE,
            generator = "student_sequence"
    )
    private Long id;
    //...
}
```

### JPA Repository

Create a `StudentRepository` interface inside student package:

```java
package com.example.demo.student;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// JpaRepository<Type, ID Type>
@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {

}
```

Inject into `StudentService` class:

```java
@Service
public class StudentService {

    private final StudentRepository studentRepository;

    @Autowired
    public StudentService(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }
    public List<Student> getStudents() {
        return studentRepository.findAll();
    }
}
```

### Saving Student

Create a `StudentConfig` class inside student package:

```java
package com.example.demo.student;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDate;
import java.time.Month;
import java.util.List;

@Configuration
public class StudentConfig {

    @Bean
    CommandLineRunner commandLineRunner(StudentRepository repository) {
        return args -> {
            Student mariam = new Student(
                    1L,
                    "Mariam",
                    "Mariam.jamal@gmail.com",
                    LocalDate.of(2000, Month.JANUARY, 5),
                    21
            );
            Student alex = new Student(
                    2L,
                    "Alex",
                    "Alex@gmail.com",
                    LocalDate.of(2004, Month.JANUARY, 5),
                    21
            );
            repository.saveAll(
                    List.of(mariam, alex)
            );
        };
    }
}

```

Restart the server, and 2 students above will be saved in student database, and can be seen using `\d`.

### Transient

Add `@Transient` notation to `age`, since age can be calculated.

```java
@Entity
@Table
public class Student {
    @Transient
    private Integer age;
    //...
    public Integer getAge() {
        return Period.between(this.dob, LocalDate.now()).getYears();
    }

}
```

 Restart the server, and age will no longer be a column in the table.

### Add Student

Use `@PostMapping` in `StudentController`.

`@RequestBody` can map request body to class.

```java
@PostMapping
public void registerNewStudent(@RequestBody Student student) {
    studentService.addNewStudent(student);
}
```

Click the network icon to generate http-client for testing:

```http
###
POST http://localhost:8080/api/v1/student
Content-Type: application/json

{
  "name": "Bilal",
  "email": "bilal.ahmed@gmail.com",
  "dob": "1995-12-17"
}
```

Complete `addNewStudent` method in `StudentService`:

```java
  public void addNewStudent(Student student) {
      Optional<Student> studentOptional = studentRepository.findStudentByEmail(student.getEmail());
      if (studentOptional.isPresent()) {
          throw new IllegalStateException("email taken");
      }
      studentRepository.save(student);
      System.out.println(student);
  }
```

And `findStudentByEmail` method in `StudentRepository`:

```java
// @Query can be omitted
@Query("SELECT s FROM Student s WHERE s.email = ?1")
Optional<Student> findStudentByEmail(String email);
```

Modify `application.properties` to send error message to front end:

```properties
server.error.include-message=always
```

### Delete Student

Use `@DeleteMapping` in `StudentController`:

```java
@DeleteMapping(path = "{studentId}")
public void deleteStudent(@PathVariable("studentId") Long studentId) {
    studentService.deleteStudent(studentId);
}
```

Complete `StudentService`:

```java
public void deleteStudent(Long studentId) {
    boolean exists = studentRepository.existsById(studentId);
    if (!exists) {
        throw new IllegalStateException("student with id " + studentId + "does not exists");
    }
    studentRepository.deleteById(studentId);
}
```

### Update Student

Use `@PutMapping` in `StudentController`:

```java
@PutMapping(path = "{studentId}")
public void updateStudent(
        @PathVariable("studentId") Long studentId,
        @RequestParam(required = false) String name,
        @RequestParam(required = false) String email
) {
    studentService.updateStudent(studentId, name, email);
}
```

Complete `updateStudent` in `StudentService`:

```java
@Transactional
public void updateStudent(Long studentId, String name, String email) {
    Student student = studentRepository.findById(studentId)
            .orElseThrow(() -> new IllegalStateException(
                    "student with id " + studentId + " dose not exist"
            ));
    if (name != null && name.length() > 0 && !Objects.equals(student.getName(), name)) {
        student.setName(name);
    }
    if (email != null && email.length() > 0 && !Objects.equals(student.getEmail(), email)) {
        Optional<Student> studentOptional = studentRepository.findStudentByEmail(email);
        if (studentOptional.isPresent()) {
            throw new IllegalStateException("email taken");
        }
        student.setEmail(name);
    }
}
```

### Packaging

Stop the servers, open Maven panel, and run `clean`. It will delete the `target` folder.

Then run `install`, get the `target folder`. There is a `demo-0.0.1-SNAPSHOT.jar` file in this folder.

Open the terminal:

```bash
cd target
java -jar demo-0.0.1-SNAPSHOT.jar
```

Now the application is running.

And we can change the port by adding `--server.port=8081` at the end.

## Generate a Spring Boot Project

[Spring Initializr](https://start.spring.io/) 为我们的 Maven 项目做了基本配置

- The Spring app main class
- The Spring Boot POM parent
- The dependencies
- The Spring Boot Maven plugin
- The properties file

## Dependency Starter

Dependency Starter 是我们添加的配置应用的一组依赖。

![Dependency Starter](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/dependency-starter.jpg)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

## The Spring Ecosystem

- Spring Core
- Spring Model-View-Controller (MVC): Web application development.
- Spring Data Access: Connect to SQL databases.
- Spring Testing

## @SpringBootApplication

@SpringBootApplication 启用了：

- **@EnableAutoConfiguration**: 根据添加的依赖自动配置 Spring 应用，比如根据特定的依赖配置数据库连接。
- **@ComponentScan**: 启用扫描 **@Component**.
- **@Configuration**: 允许在 Context 中注册额外的 Beans，或导入额外的 Configuration Classes。

## Spring Context

The place in the app's memory where we add the object instances we want Spring to manage.

### @Bean

A bean is an object that is instantiated, assembled, and managed by a Spring IoC container.

![Spring Context](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SpringContext.jpg)

### @Configuration

Configuration class is a special class to instruct Spring to do specific actions.

```java
@Configuration
public class ProjectConfig {
  @Bean
  Parrot parrot() {
    var p = new Parrot();
    p.setName("Koko");
    return p;
  }

}
```

### @Component

Mark it as a component. Spring creates an instance of the class and adds that instance to its context.

### @ControllerAdvice

@ControllerAdivce 是 @Component 的一个特殊化（Specialization），用 @ControllerAdvice进行注解的类也会在应用启动时 Spring 扫描 Components 的时候被检测到并注册。

ControllerAdivce 类提供了集中处理多个 Controllers 错误和其他问题的场所，在该类中可以：

- 处理全局错误：使用 @ExceptionHandler 定义全局处理错误方法。
- 绑定 Model Attribute：使用 @ModelAttribute 绑定在多个 Controller 中通用的属性，可以用来存储用户信息、应用设置等。
- 配置数据绑定：使用 @InitBinder 配置多个 Controller 之间通用的数据绑定设置，比如自定义编辑器、格式化器、校验器等。

### @Autowired

Defines the object that needs the dependency.

If there is a SMSService which implements MessageService:

```java
@Component
public class SMSService implements MessageService {
}
```

#### Field-Based Injection

```java
@Component
public class Client {
  @Autowired
  private MessageService messageService;
}
```

#### Constructor-Based Injection

```java
@Component
public class Client {
  private final MessageService messageService;
  
  @Autowired
  public Client(MessageService messageService) {
    this.messageService = messageService;
  }
}
```

#### Setter-Based Injection

```java
@Component
public class Client {
  private MessageService messageService;
  
  @Autowired(required = false)
  public void setMessageService(MessageService messageService) {
    this.messageService = messageService;
  }
}
```

### @Qualifier

If there are multiple beans, we need use @Qualifier to tell Spring which one is correct.

```java
@Component
@Qualifier("SMSService")
public class SMSService implements MessageService {
}

@Component
@Qualifier("EmailService")
public class EmailService implements MessageService {
}
```

#### Field-Base Injection

```java
@Component
public class Client {
  @Autowired
  @Qualifier("SMSService")
  private MessageService messageService;
}
```

#### Constructor-Based Injection

```java
@Component
public class Client {
  private final MessageService messageService;
  
  @Autowired
  public Client(@Qualifier("SMSService") MessageService messageService) {
    this.messageService = messageService;
  }
}
```

#### Setter-Based Injection

```java
@Component
public class Client {
  private MessageService messageService;
  
  @Autowired(required = false)
  @Qualifier("SMSService")
  public void setMessageService(MessageService messageService) {
    this.messageService = messageService;
  }
}
```

### @Primary

We can also use @Primary to indicate the default one.

## Web Server

REST Endpoints in Spring:

1. The **client** makes an *HTTP request*.
2. **Tomcat** accepts the request, and delivers it to the **Spring app**. **Dispatcher servlet** gets the HTTP request and manages the flow.
3. The **dispatcher servlet** finds out what **method** of the **controller** to call depending on the *path* and *HTTP method* of the request. (It uses the **handler mapping**).
4. The **dispatcher servlet** calls the **method**. After execution, the **controller method** returns the value to be sent to the client in the *HTTP response body*.
5. Through **Tomcat**, the *HTTP response* is returned to the **client**.
6. The **client** gets the *HTTP response data*.

### @Controller

**@ResponseBody** tells the dispatcher servlet that the controller's action **doesn't return a view** but the **data sent directly in the HTTP response**.

```java
@Controller
public class HelloController {
  
  @GetMapping("/hello")
  @ResponseBody
  public String hello() {
    return "Hello!"
  }
}
```

### @RestController

- Instruct Spring that all the controller's actions are REST endpoints.

- Avoid  repeating the **@ResponseBody** annotation.

```java
public class Country {
  private String name;
  private int population;
  //...
}
```

```java
@RestController
public class HelloController {
  
  private static Logger logger = Logger.getLogger(HelloController.class.getName());
  
  @GetMapping("/hello")
  public String hello() {
    return "Hello!"
  }
  
  // Spring will create a string representation of the object
  // and formats it as JSON objects
  @GetMapping("/france") {
    Contry c = Country.of("France", 67);
    return c;
    // { "name": "France", "population": 67 }
  }
  
  // ResponseEntity allows you to specify the response body, status, and headers on the HTTP response.
  @GetMapping("/france")
  public ResponseEntity<Country> france() {
    Country c = country.of("France", 67);
    return ResponseEntity
      .status(HttpStatus.OK)
      .body(c)
  }
  
  @PostMapping("/payment")
  public ResponseEntity<PaymentDetails> makePayment(
    // @RequestBody will try to decode the JSON string into an instance of  your parameter type
    @RequestBody PaymentDetails paymentDetails
  ) {
    logger.info("Received payment " + paymentDetails.getAmount());
    return ResponseEntity
      .status(HttpStatus.ACCEPTED)
      .body(paymentDetails)
  }
}
```

### Spring Data

- A high-level layer over various way to implement the persistence.
  - Provides a common set of interfaces (contracts) you extend to define the app's persistence capabilities.
- Spring Data gives your app the possibility to implement only the operations it needs.
  - Interface segregation principle.

![Spring Data Layer](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SpringData-2.jpg)

![Spring Data Interfaces](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/SpringData-1.jpg)

#### Interfaces Architecture

##### CrudRepository

CRUD: Creating, Retrieving, Updating and Deleting.

![CrudRepository](https://hais-note-pics-1301462215.cos.ap-chengdu.myqcloud.com/CrudRepository.jpg)

##### PagingAndSortingRepostiroy

Extends **CrudRepository** and adds operations related to sorting and paging.

##### JpaRepository

- **JPA (Java Persistence API)**: Provides a specification for persisting, reading, and managing data from your Java object to relational tables in database.
- **JpaRepository**: Adds operations related to JPA. (E.g. Hibernate ORM framework implements JpaRepository interface)
- **Hibernate**
  - An **Object-relational mapping (ORM)** solution for Java environments.
  - Map application domain model objects to the relational database tables.

```text
Java Class  <-------->  Hibernate (an ORM framework)  <-------->  Database Table
```

#### Using Spring Data

Add dependencies in **pom.xml**:

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
```

Define a entity class to model data:

```java
@Entity
public class Account {
  @Id
  private long id;
  private String name;
  private BigDecimal amount;
  
  //...
}
```

Implement the Spring Data repository by defining an interface that extends one of the Repository interfaces:

```java
public interface AccountRepository
  extends JpaRepository<Account, Long> {
  
  // Spring creates the SQL query automatically
  // You can also use the @Query annotion to specify the SQL query
  @Query("SELECT * FROM account WHERE name = :name")
  List<Account> findAccountsByName(String name);
}
```

Inject the repository in your service class:

```java
@Service
public class TransferService {
  
  @Autowired
  private final AccountRepository accountRepository;
}
```

#### Hibernate

##### Mapping a collection

```java
@Enity
public class Item {
  @Id
  @GeneratedValue(generator = Constants.ID_GENERATOR)
  protected Long id;
  
  @ElementCollection
  @CollectionTable(name = "IMAGE")
  @Column(name = "FILENAME")
  protected List<String> images = new ArrayList<String>();
  
  //...
}
```

##### Table Per Hierarchy

- **Discriminator Column**: An extra column is created in the table to identitfy the class.

```java
@Entity
@Table(name = "employee")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "type", discriminatiorType = DiscriminatorType.STRING)
@DiscriminatorValue(value = "employee")
public class Employee {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  @Column(name = "id")
  private int id;
  
  @Column(name = "name")
  private String name;
  
  //...
}
```

```java
@Entity
@DiscriminatorValue("regularemployee")
public class RegularEmployee extends Employee {
  @Column(name = "salary")
  private float salary;
  
  @Column(name = "bonus")
  private int bonus;
  
  //...
}
```

```java
@Entity
@DiscriminatorValue("contracteemployee")
public class ContractEmployee extends Employee {
  @Column(name = "pay_per_hour")
  private float payPerHour;
  
  @Column(name = "contract_duration")
  private String contract_duration;
  
  //...
}
```

##### Many to many relationship

```java
@Entity
@Table(name = "Employee")
public class Employee {
  //...
  @ManyToMany(cascade = { CascadeType.ALL })
  @JoinTable(
    name = "EmployProject",
    joinColumns = { @JoinColumn(name = "employee_id") },
    inverseJoinColumns = { @JoinColumn(name = "project_id") }
  )
  Set<Project> projects = new HashSet<>();
  
  //...
}
```

```java
@Entity
@Table(name = "Project")
public class Project {
  //...
  @ManyToMany(mappedBy = "projects")
  private Set<Employee> employees = new HashSet<>();
  
  //...
}
```

# Parameter Validation

## Tools

- `javax.validation` 和 `jakarta.validation` 是两个 Bean Validation 规范，他们都定义了一些标准的 Annotaions 和 API，后者可以看做前者的延续。他们并没有提供校验功能的具体实现，只提供了标准接口。
- Hibernate Validator 提供了校验功能的具体实现。
- 当我们使用 SpringBoot 的时候，可以引入 `spring-boot-starter-validation`，他会自动帮我们引入恰当的 Hibernate Validaotr。
- 当使用 Spring Boot 2.5.x 及以下版本时，Starter 会自动引入 Hibernate Validator 6.x（使用 `javax.validation`）；当使用 Spring Boot 2.6.x 及以上版本时，Starter 会自动引入 Hibernate Validator 7.x（使用 `jakarta.validation`）

## Usage

**1. 在 `pom.xml` 中添加 `spring-boot-starter-validation`**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

 **2. 在 [UserCreateDTO](#data-transfer-object-dto) 中添加 Annotaions**

```java
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class UserCreateDTO {

    @NotBlank
    @Size(min = 1, max = 50)
    private String name;

    @NotBlank
    @Email
    @Size(min = 5, max = 50)
    private String email;

    // Getters and setters
}
```

**3. 在 UserController 中添加 @Valid**

```java
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<?> createUser(@Valid @RequestBody UserCreateDTO userCreateDTO) {
        // Perform the actual user creation logic here
        // For example, you can call a service method to save the user to the database

        return ResponseEntity.status(HttpStatus.CREATED).body("User created successfully");
    }
}
```

**4. 使用 [ControllerAdvice Class](#controlleradvice) 处理校验错误**

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<?> handleMethodArgumentNotValid(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
}
```
